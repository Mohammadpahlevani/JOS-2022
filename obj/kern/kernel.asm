
obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000000100000 <_head64>:
.globl _head64
_head64:

# Save multiboot_info addr passed by bootloader
	
    movl $multiboot_info, %eax
  100000:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  100005:	89 18                	mov    %ebx,(%rax)

    movw $0x1234,0x472			# warm boot	
  100007:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472(%rip)        # 100482 <verify_cpu_no_longmode+0x36f>
  10000e:	34 12 
	
# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  100010:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100015:	e8 cc 00 00 00       	callq  1000e6 <verify_cpu>
    movl $CR4_PAE,%eax	
  10001a:	b8 20 00 00 00       	mov    $0x20,%eax
    movl %eax,%cr4
  10001f:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100022:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100027:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100029:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002e:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  100030:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100035:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  10003a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  100040:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100042:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100047:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10004a:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004d:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  100050:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100055:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  10005a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100060:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100062:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100067:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006c:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006f:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100072:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100074:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100079:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007e:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100083:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100089:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008e:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  100090:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100092:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100095:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100098:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009d:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  1000a0:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a3:	75 e9                	jne    10008e <_head64+0x8e>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a5:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000aa:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ad:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b2:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b4:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b8:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000ba:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bd:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000c0:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c5:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000ca:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000cf:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d2:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d5:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000da:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dd:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000df:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e4:	50                   	push   %rax

00000000001000e5 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e5:	cb                   	lret   

00000000001000e6 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e6:	9c                   	pushfq 
    popl %eax
  1000e7:	58                   	pop    %rax
    movl %eax,%ecx
  1000e8:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000ea:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ef:	50                   	push   %rax
    popfl
  1000f0:	9d                   	popfq  
    pushfl
  1000f1:	9c                   	pushfq 
    popl %eax
  1000f2:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f3:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f5:	74 1c                	je     100113 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f7:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fc:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fe:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100101:	72 10                	jb     100113 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100103:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100108:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  10010a:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  100110:	74 01                	je     100113 <verify_cpu_no_longmode>

    ret
  100112:	c3                   	retq   

0000000000100113 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100113:	eb fe                	jmp    100113 <verify_cpu_no_longmode>
  100115:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10011c:	00 00 00 
  10011f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100126:	00 00 00 
  100129:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100130:	00 00 00 
  100133:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10013a:	00 00 00 
  10013d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100144:	00 00 00 
  100147:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10014e:	00 00 00 
  100151:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100158:	00 00 00 
  10015b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100162:	00 00 00 
  100165:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10016c:	00 00 00 
  10016f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100176:	00 00 00 
  100179:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100180:	00 00 00 
  100183:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10018a:	00 00 00 
  10018d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100194:	00 00 00 
  100197:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10019e:	00 00 00 
  1001a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001a8:	00 00 00 
  1001ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001b2:	00 00 00 
  1001b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001bc:	00 00 00 
  1001bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001c6:	00 00 00 
  1001c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001d0:	00 00 00 
  1001d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001da:	00 00 00 
  1001dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001e4:	00 00 00 
  1001e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001ee:	00 00 00 
  1001f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001f8:	00 00 00 
  1001fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100202:	00 00 00 
  100205:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10020c:	00 00 00 
  10020f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100216:	00 00 00 
  100219:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100220:	00 00 00 
  100223:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10022a:	00 00 00 
  10022d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100234:	00 00 00 
  100237:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10023e:	00 00 00 
  100241:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100248:	00 00 00 
  10024b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100252:	00 00 00 
  100255:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10025c:	00 00 00 
  10025f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100266:	00 00 00 
  100269:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100270:	00 00 00 
  100273:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10027a:	00 00 00 
  10027d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100284:	00 00 00 
  100287:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10028e:	00 00 00 
  100291:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100298:	00 00 00 
  10029b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002a2:	00 00 00 
  1002a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ac:	00 00 00 
  1002af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002b6:	00 00 00 
  1002b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002c0:	00 00 00 
  1002c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ca:	00 00 00 
  1002cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002d4:	00 00 00 
  1002d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002de:	00 00 00 
  1002e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002e8:	00 00 00 
  1002eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002f2:	00 00 00 
  1002f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002fc:	00 00 00 
  1002ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100306:	00 00 00 
  100309:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100310:	00 00 00 
  100313:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10031a:	00 00 00 
  10031d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100324:	00 00 00 
  100327:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10032e:	00 00 00 
  100331:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100338:	00 00 00 
  10033b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100342:	00 00 00 
  100345:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10034c:	00 00 00 
  10034f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100356:	00 00 00 
  100359:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100360:	00 00 00 
  100363:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10036a:	00 00 00 
  10036d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100374:	00 00 00 
  100377:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10037e:	00 00 00 
  100381:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100388:	00 00 00 
  10038b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100392:	00 00 00 
  100395:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10039c:	00 00 00 
  10039f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003a6:	00 00 00 
  1003a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003b0:	00 00 00 
  1003b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ba:	00 00 00 
  1003bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003c4:	00 00 00 
  1003c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ce:	00 00 00 
  1003d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003d8:	00 00 00 
  1003db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003e2:	00 00 00 
  1003e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ec:	00 00 00 
  1003ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003f6:	00 00 00 
  1003f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100400:	00 00 00 
  100403:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10040a:	00 00 00 
  10040d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100414:	00 00 00 
  100417:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10041e:	00 00 00 
  100421:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100428:	00 00 00 
  10042b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100432:	00 00 00 
  100435:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10043c:	00 00 00 
  10043f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100446:	00 00 00 
  100449:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100450:	00 00 00 
  100453:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10045a:	00 00 00 
  10045d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100464:	00 00 00 
  100467:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10046e:	00 00 00 
  100471:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100478:	00 00 00 
  10047b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100482:	00 00 00 
  100485:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10048c:	00 00 00 
  10048f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100496:	00 00 00 
  100499:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004a0:	00 00 00 
  1004a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004aa:	00 00 00 
  1004ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004b4:	00 00 00 
  1004b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004be:	00 00 00 
  1004c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004c8:	00 00 00 
  1004cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004d2:	00 00 00 
  1004d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004dc:	00 00 00 
  1004df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004e6:	00 00 00 
  1004e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004f0:	00 00 00 
  1004f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004fa:	00 00 00 
  1004fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100504:	00 00 00 
  100507:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10050e:	00 00 00 
  100511:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100518:	00 00 00 
  10051b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100522:	00 00 00 
  100525:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10052c:	00 00 00 
  10052f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100536:	00 00 00 
  100539:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100540:	00 00 00 
  100543:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10054a:	00 00 00 
  10054d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100554:	00 00 00 
  100557:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10055e:	00 00 00 
  100561:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100568:	00 00 00 
  10056b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100572:	00 00 00 
  100575:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10057c:	00 00 00 
  10057f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100586:	00 00 00 
  100589:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100590:	00 00 00 
  100593:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10059a:	00 00 00 
  10059d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005a4:	00 00 00 
  1005a7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ae:	00 00 00 
  1005b1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005b8:	00 00 00 
  1005bb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005c2:	00 00 00 
  1005c5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005cc:	00 00 00 
  1005cf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005d6:	00 00 00 
  1005d9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005e0:	00 00 00 
  1005e3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ea:	00 00 00 
  1005ed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005f4:	00 00 00 
  1005f7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005fe:	00 00 00 
  100601:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100608:	00 00 00 
  10060b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100612:	00 00 00 
  100615:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10061c:	00 00 00 
  10061f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100626:	00 00 00 
  100629:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100630:	00 00 00 
  100633:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10063a:	00 00 00 
  10063d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100644:	00 00 00 
  100647:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10064e:	00 00 00 
  100651:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100658:	00 00 00 
  10065b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100662:	00 00 00 
  100665:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10066c:	00 00 00 
  10066f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100676:	00 00 00 
  100679:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100680:	00 00 00 
  100683:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10068a:	00 00 00 
  10068d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100694:	00 00 00 
  100697:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10069e:	00 00 00 
  1006a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006a8:	00 00 00 
  1006ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006b2:	00 00 00 
  1006b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006bc:	00 00 00 
  1006bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006c6:	00 00 00 
  1006c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006d0:	00 00 00 
  1006d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006da:	00 00 00 
  1006dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006e4:	00 00 00 
  1006e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006ee:	00 00 00 
  1006f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006f8:	00 00 00 
  1006fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100702:	00 00 00 
  100705:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10070c:	00 00 00 
  10070f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100716:	00 00 00 
  100719:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100720:	00 00 00 
  100723:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10072a:	00 00 00 
  10072d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100734:	00 00 00 
  100737:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10073e:	00 00 00 
  100741:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100748:	00 00 00 
  10074b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100752:	00 00 00 
  100755:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10075c:	00 00 00 
  10075f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100766:	00 00 00 
  100769:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100770:	00 00 00 
  100773:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10077a:	00 00 00 
  10077d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100784:	00 00 00 
  100787:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10078e:	00 00 00 
  100791:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100798:	00 00 00 
  10079b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007a2:	00 00 00 
  1007a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ac:	00 00 00 
  1007af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007b6:	00 00 00 
  1007b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007c0:	00 00 00 
  1007c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ca:	00 00 00 
  1007cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007d4:	00 00 00 
  1007d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007de:	00 00 00 
  1007e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007e8:	00 00 00 
  1007eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007f2:	00 00 00 
  1007f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007fc:	00 00 00 
  1007ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100806:	00 00 00 
  100809:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100810:	00 00 00 
  100813:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10081a:	00 00 00 
  10081d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100824:	00 00 00 
  100827:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10082e:	00 00 00 
  100831:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100838:	00 00 00 
  10083b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100842:	00 00 00 
  100845:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10084c:	00 00 00 
  10084f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100856:	00 00 00 
  100859:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100860:	00 00 00 
  100863:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10086a:	00 00 00 
  10086d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100874:	00 00 00 
  100877:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10087e:	00 00 00 
  100881:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100888:	00 00 00 
  10088b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100892:	00 00 00 
  100895:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10089c:	00 00 00 
  10089f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008a6:	00 00 00 
  1008a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008b0:	00 00 00 
  1008b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ba:	00 00 00 
  1008bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008c4:	00 00 00 
  1008c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ce:	00 00 00 
  1008d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008d8:	00 00 00 
  1008db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008e2:	00 00 00 
  1008e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ec:	00 00 00 
  1008ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008f6:	00 00 00 
  1008f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100900:	00 00 00 
  100903:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10090a:	00 00 00 
  10090d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100914:	00 00 00 
  100917:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10091e:	00 00 00 
  100921:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100928:	00 00 00 
  10092b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100932:	00 00 00 
  100935:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10093c:	00 00 00 
  10093f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100946:	00 00 00 
  100949:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100950:	00 00 00 
  100953:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10095a:	00 00 00 
  10095d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100964:	00 00 00 
  100967:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10096e:	00 00 00 
  100971:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100978:	00 00 00 
  10097b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100982:	00 00 00 
  100985:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10098c:	00 00 00 
  10098f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100996:	00 00 00 
  100999:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009a0:	00 00 00 
  1009a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009aa:	00 00 00 
  1009ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009b4:	00 00 00 
  1009b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009be:	00 00 00 
  1009c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009c8:	00 00 00 
  1009cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009d2:	00 00 00 
  1009d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009dc:	00 00 00 
  1009df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009e6:	00 00 00 
  1009e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009f0:	00 00 00 
  1009f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009fa:	00 00 00 
  1009fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a04:	00 00 00 
  100a07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a0e:	00 00 00 
  100a11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a18:	00 00 00 
  100a1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a22:	00 00 00 
  100a25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a2c:	00 00 00 
  100a2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a36:	00 00 00 
  100a39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a40:	00 00 00 
  100a43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a4a:	00 00 00 
  100a4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a54:	00 00 00 
  100a57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a5e:	00 00 00 
  100a61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a68:	00 00 00 
  100a6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a72:	00 00 00 
  100a75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a7c:	00 00 00 
  100a7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a86:	00 00 00 
  100a89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a90:	00 00 00 
  100a93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a9a:	00 00 00 
  100a9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aa4:	00 00 00 
  100aa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aae:	00 00 00 
  100ab1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ab8:	00 00 00 
  100abb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ac2:	00 00 00 
  100ac5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100acc:	00 00 00 
  100acf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ad6:	00 00 00 
  100ad9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ae0:	00 00 00 
  100ae3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aea:	00 00 00 
  100aed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100af4:	00 00 00 
  100af7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100afe:	00 00 00 
  100b01:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b08:	00 00 00 
  100b0b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b12:	00 00 00 
  100b15:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b1c:	00 00 00 
  100b1f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b26:	00 00 00 
  100b29:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b30:	00 00 00 
  100b33:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b3a:	00 00 00 
  100b3d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b44:	00 00 00 
  100b47:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b4e:	00 00 00 
  100b51:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b58:	00 00 00 
  100b5b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b62:	00 00 00 
  100b65:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b6c:	00 00 00 
  100b6f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b76:	00 00 00 
  100b79:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b80:	00 00 00 
  100b83:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b8a:	00 00 00 
  100b8d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b94:	00 00 00 
  100b97:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b9e:	00 00 00 
  100ba1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ba8:	00 00 00 
  100bab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bb2:	00 00 00 
  100bb5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bbc:	00 00 00 
  100bbf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bc6:	00 00 00 
  100bc9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bd0:	00 00 00 
  100bd3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bda:	00 00 00 
  100bdd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100be4:	00 00 00 
  100be7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bee:	00 00 00 
  100bf1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bf8:	00 00 00 
  100bfb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c02:	00 00 00 
  100c05:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c0c:	00 00 00 
  100c0f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c16:	00 00 00 
  100c19:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c20:	00 00 00 
  100c23:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c2a:	00 00 00 
  100c2d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c34:	00 00 00 
  100c37:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c3e:	00 00 00 
  100c41:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c48:	00 00 00 
  100c4b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c52:	00 00 00 
  100c55:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c5c:	00 00 00 
  100c5f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c66:	00 00 00 
  100c69:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c70:	00 00 00 
  100c73:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c7a:	00 00 00 
  100c7d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c84:	00 00 00 
  100c87:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c8e:	00 00 00 
  100c91:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c98:	00 00 00 
  100c9b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ca2:	00 00 00 
  100ca5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cac:	00 00 00 
  100caf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cb6:	00 00 00 
  100cb9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cc0:	00 00 00 
  100cc3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cca:	00 00 00 
  100ccd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cd4:	00 00 00 
  100cd7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cde:	00 00 00 
  100ce1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ce8:	00 00 00 
  100ceb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cf2:	00 00 00 
  100cf5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cfc:	00 00 00 
  100cff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d06:	00 00 00 
  100d09:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d10:	00 00 00 
  100d13:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d1a:	00 00 00 
  100d1d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d24:	00 00 00 
  100d27:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d2e:	00 00 00 
  100d31:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d38:	00 00 00 
  100d3b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d42:	00 00 00 
  100d45:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d4c:	00 00 00 
  100d4f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d56:	00 00 00 
  100d59:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d60:	00 00 00 
  100d63:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d6a:	00 00 00 
  100d6d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d74:	00 00 00 
  100d77:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d7e:	00 00 00 
  100d81:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d88:	00 00 00 
  100d8b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d92:	00 00 00 
  100d95:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d9c:	00 00 00 
  100d9f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100da6:	00 00 00 
  100da9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100db0:	00 00 00 
  100db3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dba:	00 00 00 
  100dbd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dc4:	00 00 00 
  100dc7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dce:	00 00 00 
  100dd1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dd8:	00 00 00 
  100ddb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100de2:	00 00 00 
  100de5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dec:	00 00 00 
  100def:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100df6:	00 00 00 
  100df9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e00:	00 00 00 
  100e03:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e0a:	00 00 00 
  100e0d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e14:	00 00 00 
  100e17:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e1e:	00 00 00 
  100e21:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e28:	00 00 00 
  100e2b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e32:	00 00 00 
  100e35:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e3c:	00 00 00 
  100e3f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e46:	00 00 00 
  100e49:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e50:	00 00 00 
  100e53:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e5a:	00 00 00 
  100e5d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e64:	00 00 00 
  100e67:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e6e:	00 00 00 
  100e71:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e78:	00 00 00 
  100e7b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e82:	00 00 00 
  100e85:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e8c:	00 00 00 
  100e8f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e96:	00 00 00 
  100e99:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ea0:	00 00 00 
  100ea3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eaa:	00 00 00 
  100ead:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eb4:	00 00 00 
  100eb7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ebe:	00 00 00 
  100ec1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ec8:	00 00 00 
  100ecb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ed2:	00 00 00 
  100ed5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100edc:	00 00 00 
  100edf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ee6:	00 00 00 
  100ee9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ef0:	00 00 00 
  100ef3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100efa:	00 00 00 
  100efd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f04:	00 00 00 
  100f07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f0e:	00 00 00 
  100f11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f18:	00 00 00 
  100f1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f22:	00 00 00 
  100f25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f2c:	00 00 00 
  100f2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f36:	00 00 00 
  100f39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f40:	00 00 00 
  100f43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f4a:	00 00 00 
  100f4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f54:	00 00 00 
  100f57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f5e:	00 00 00 
  100f61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f68:	00 00 00 
  100f6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f72:	00 00 00 
  100f75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f7c:	00 00 00 
  100f7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f86:	00 00 00 
  100f89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f90:	00 00 00 
  100f93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f9a:	00 00 00 
  100f9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fa4:	00 00 00 
  100fa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fae:	00 00 00 
  100fb1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fb8:	00 00 00 
  100fbb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fc2:	00 00 00 
  100fc5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fcc:	00 00 00 
  100fcf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fd6:	00 00 00 
  100fd9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fe0:	00 00 00 
  100fe3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fea:	00 00 00 
  100fed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ff4:	00 00 00 
  100ff7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  100ffe:	00 00 

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4phys>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Disassembly of section .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4 48                	in     $0x48,%al

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 60 22 04 80 	movabs $0x8004226038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 60 22 04 80 	movabs $0x8004226000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <i386_init>:



void
i386_init(void)
{
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  800420005c:	48 ba e0 eb 2b 04 80 	movabs $0x80042bebe0,%rdx
  8004200063:	00 00 00 
  8004200066:	48 b8 29 c4 2b 04 80 	movabs $0x80042bc429,%rax
  800420006d:	00 00 00 
  8004200070:	48 29 c2             	sub    %rax,%rdx
  8004200073:	48 89 d0             	mov    %rdx,%rax
  8004200076:	48 89 c2             	mov    %rax,%rdx
  8004200079:	be 00 00 00 00       	mov    $0x0,%esi
  800420007e:	48 bf 29 c4 2b 04 80 	movabs $0x80042bc429,%rdi
  8004200085:	00 00 00 
  8004200088:	48 b8 96 ba 20 04 80 	movabs $0x800420ba96,%rax
  800420008f:	00 00 00 
  8004200092:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  8004200094:	48 b8 b2 0d 20 04 80 	movabs $0x8004200db2,%rax
  800420009b:	00 00 00 
  800420009e:	ff d0                	callq  *%rax

	cprintf("6828 decimal is %o octal!\n", 6828);
  80042000a0:	be ac 1a 00 00       	mov    $0x1aac,%esi
  80042000a5:	48 bf 80 1e 21 04 80 	movabs $0x8004211e80,%rdi
  80042000ac:	00 00 00 
  80042000af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042000b4:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  80042000bb:	00 00 00 
  80042000be:	ff d2                	callq  *%rdx

	extern char end[];
	end_debug = read_section_headers((0x10000+KERNBASE), (uintptr_t)end);
  80042000c0:	48 b8 e0 eb 2b 04 80 	movabs $0x80042bebe0,%rax
  80042000c7:	00 00 00 
  80042000ca:	48 89 c6             	mov    %rax,%rsi
  80042000cd:	48 bf 00 00 01 04 80 	movabs $0x8004010000,%rdi
  80042000d4:	00 00 00 
  80042000d7:	48 b8 b6 14 21 04 80 	movabs $0x80042114b6,%rax
  80042000de:	00 00 00 
  80042000e1:	ff d0                	callq  *%rax
  80042000e3:	48 ba c8 db 2b 04 80 	movabs $0x80042bdbc8,%rdx
  80042000ea:	00 00 00 
  80042000ed:	48 89 02             	mov    %rax,(%rdx)

	// Lab 2 memory management initialization functions
	x64_vm_init();
  80042000f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042000f5:	48 ba 6e 1e 20 04 80 	movabs $0x8004201e6e,%rdx
  80042000fc:	00 00 00 
  80042000ff:	ff d2                	callq  *%rdx

	// Lab 3 user environment initialization functions
	env_init();
  8004200101:	48 b8 94 69 20 04 80 	movabs $0x8004206994,%rax
  8004200108:	00 00 00 
  800420010b:	ff d0                	callq  *%rax
	trap_init();
  800420010d:	48 b8 65 7c 20 04 80 	movabs $0x8004207c65,%rax
  8004200114:	00 00 00 
  8004200117:	ff d0                	callq  *%rax



#if defined(TEST)
	// Don't touch -- used by grading script!
	ENV_CREATE(TEST, ENV_TYPE_USER);
  8004200119:	be 00 00 00 00       	mov    $0x0,%esi
  800420011e:	48 bf 01 94 24 04 80 	movabs $0x8004249401,%rdi
  8004200125:	00 00 00 
  8004200128:	48 b8 96 72 20 04 80 	movabs $0x8004207296,%rax
  800420012f:	00 00 00 
  8004200132:	ff d0                	callq  *%rax
	// ENV_CREATE(user_evilhello, ENV_TYPE_USER);
	ENV_CREATE(user_buggyhello, ENV_TYPE_USER);
#endif // TEST*

	// We only have one user environment for now, so just run it.
	env_run(&envs[0]);
  8004200134:	48 b8 90 c6 2b 04 80 	movabs $0x80042bc690,%rax
  800420013b:	00 00 00 
  800420013e:	48 8b 00             	mov    (%rax),%rax
  8004200141:	48 89 c7             	mov    %rax,%rdi
  8004200144:	48 b8 e4 78 20 04 80 	movabs $0x80042078e4,%rax
  800420014b:	00 00 00 
  800420014e:	ff d0                	callq  *%rax

0000008004200150 <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  8004200150:	55                   	push   %rbp
  8004200151:	48 89 e5             	mov    %rsp,%rbp
  8004200154:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420015b:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  8004200162:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  8004200168:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420016f:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004200176:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420017d:	84 c0                	test   %al,%al
  800420017f:	74 20                	je     80042001a1 <_panic+0x51>
  8004200181:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004200185:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004200189:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420018d:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004200191:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004200195:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004200199:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420019d:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  80042001a1:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	if (panicstr)
  80042001a8:	48 b8 d0 db 2b 04 80 	movabs $0x80042bdbd0,%rax
  80042001af:	00 00 00 
  80042001b2:	48 8b 00             	mov    (%rax),%rax
  80042001b5:	48 85 c0             	test   %rax,%rax
  80042001b8:	74 05                	je     80042001bf <_panic+0x6f>
		goto dead;
  80042001ba:	e9 a9 00 00 00       	jmpq   8004200268 <_panic+0x118>
	panicstr = fmt;
  80042001bf:	48 b8 d0 db 2b 04 80 	movabs $0x80042bdbd0,%rax
  80042001c6:	00 00 00 
  80042001c9:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  80042001d0:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  80042001d3:	fa                   	cli    
  80042001d4:	fc                   	cld    

	va_start(ap, fmt);
  80042001d5:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  80042001dc:	00 00 00 
  80042001df:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  80042001e6:	00 00 00 
  80042001e9:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042001ed:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042001f4:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042001fb:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel panic at %s:%d: ", file, line);
  8004200202:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004200208:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420020f:	48 89 c6             	mov    %rax,%rsi
  8004200212:	48 bf 9b 1e 21 04 80 	movabs $0x8004211e9b,%rdi
  8004200219:	00 00 00 
  800420021c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200221:	48 b9 46 7b 20 04 80 	movabs $0x8004207b46,%rcx
  8004200228:	00 00 00 
  800420022b:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  800420022d:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  8004200234:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800420023b:	48 89 d6             	mov    %rdx,%rsi
  800420023e:	48 89 c7             	mov    %rax,%rdi
  8004200241:	48 b8 e7 7a 20 04 80 	movabs $0x8004207ae7,%rax
  8004200248:	00 00 00 
  800420024b:	ff d0                	callq  *%rax
	cprintf("\n");
  800420024d:	48 bf b3 1e 21 04 80 	movabs $0x8004211eb3,%rdi
  8004200254:	00 00 00 
  8004200257:	b8 00 00 00 00       	mov    $0x0,%eax
  800420025c:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004200263:	00 00 00 
  8004200266:	ff d2                	callq  *%rdx
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  8004200268:	bf 00 00 00 00       	mov    $0x0,%edi
  800420026d:	48 b8 ad 12 20 04 80 	movabs $0x80042012ad,%rax
  8004200274:	00 00 00 
  8004200277:	ff d0                	callq  *%rax
  8004200279:	eb ed                	jmp    8004200268 <_panic+0x118>

000000800420027b <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  800420027b:	55                   	push   %rbp
  800420027c:	48 89 e5             	mov    %rsp,%rbp
  800420027f:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  8004200286:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420028d:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  8004200293:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420029a:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  80042002a1:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  80042002a8:	84 c0                	test   %al,%al
  80042002aa:	74 20                	je     80042002cc <_warn+0x51>
  80042002ac:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80042002b0:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80042002b4:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  80042002b8:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80042002bc:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80042002c0:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80042002c4:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  80042002c8:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  80042002cc:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  80042002d3:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  80042002da:	00 00 00 
  80042002dd:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  80042002e4:	00 00 00 
  80042002e7:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042002eb:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042002f2:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042002f9:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  8004200300:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004200306:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420030d:	48 89 c6             	mov    %rax,%rsi
  8004200310:	48 bf b5 1e 21 04 80 	movabs $0x8004211eb5,%rdi
  8004200317:	00 00 00 
  800420031a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420031f:	48 b9 46 7b 20 04 80 	movabs $0x8004207b46,%rcx
  8004200326:	00 00 00 
  8004200329:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  800420032b:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  8004200332:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004200339:	48 89 d6             	mov    %rdx,%rsi
  800420033c:	48 89 c7             	mov    %rax,%rdi
  800420033f:	48 b8 e7 7a 20 04 80 	movabs $0x8004207ae7,%rax
  8004200346:	00 00 00 
  8004200349:	ff d0                	callq  *%rax
	cprintf("\n");
  800420034b:	48 bf b3 1e 21 04 80 	movabs $0x8004211eb3,%rdi
  8004200352:	00 00 00 
  8004200355:	b8 00 00 00 00       	mov    $0x0,%eax
  800420035a:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004200361:	00 00 00 
  8004200364:	ff d2                	callq  *%rdx
	va_end(ap);
}
  8004200366:	c9                   	leaveq 
  8004200367:	c3                   	retq   

0000008004200368 <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  8004200368:	55                   	push   %rbp
  8004200369:	48 89 e5             	mov    %rsp,%rbp
  800420036c:	48 83 ec 20          	sub    $0x20,%rsp
  8004200370:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200377:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420037a:	89 c2                	mov    %eax,%edx
  800420037c:	ec                   	in     (%dx),%al
  800420037d:	88 45 fb             	mov    %al,-0x5(%rbp)
  8004200380:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)
  8004200387:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420038a:	89 c2                	mov    %eax,%edx
  800420038c:	ec                   	in     (%dx),%al
  800420038d:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004200390:	c7 45 ec 84 00 00 00 	movl   $0x84,-0x14(%rbp)
  8004200397:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420039a:	89 c2                	mov    %eax,%edx
  800420039c:	ec                   	in     (%dx),%al
  800420039d:	88 45 eb             	mov    %al,-0x15(%rbp)
  80042003a0:	c7 45 e4 84 00 00 00 	movl   $0x84,-0x1c(%rbp)
  80042003a7:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042003aa:	89 c2                	mov    %eax,%edx
  80042003ac:	ec                   	in     (%dx),%al
  80042003ad:	88 45 e3             	mov    %al,-0x1d(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  80042003b0:	c9                   	leaveq 
  80042003b1:	c3                   	retq   

00000080042003b2 <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  80042003b2:	55                   	push   %rbp
  80042003b3:	48 89 e5             	mov    %rsp,%rbp
  80042003b6:	48 83 ec 10          	sub    $0x10,%rsp
  80042003ba:	c7 45 fc fd 03 00 00 	movl   $0x3fd,-0x4(%rbp)
  80042003c1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042003c4:	89 c2                	mov    %eax,%edx
  80042003c6:	ec                   	in     (%dx),%al
  80042003c7:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  80042003ca:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  80042003ce:	0f b6 c0             	movzbl %al,%eax
  80042003d1:	83 e0 01             	and    $0x1,%eax
  80042003d4:	85 c0                	test   %eax,%eax
  80042003d6:	75 07                	jne    80042003df <serial_proc_data+0x2d>
		return -1;
  80042003d8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042003dd:	eb 17                	jmp    80042003f6 <serial_proc_data+0x44>
  80042003df:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042003e6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042003e9:	89 c2                	mov    %eax,%edx
  80042003eb:	ec                   	in     (%dx),%al
  80042003ec:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  80042003ef:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(COM1+COM_RX);
  80042003f3:	0f b6 c0             	movzbl %al,%eax
}
  80042003f6:	c9                   	leaveq 
  80042003f7:	c3                   	retq   

00000080042003f8 <serial_intr>:

void
serial_intr(void)
{
  80042003f8:	55                   	push   %rbp
  80042003f9:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  80042003fc:	48 b8 40 c4 2b 04 80 	movabs $0x80042bc440,%rax
  8004200403:	00 00 00 
  8004200406:	0f b6 00             	movzbl (%rax),%eax
  8004200409:	84 c0                	test   %al,%al
  800420040b:	74 16                	je     8004200423 <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  800420040d:	48 bf b2 03 20 04 80 	movabs $0x80042003b2,%rdi
  8004200414:	00 00 00 
  8004200417:	48 b8 35 0c 20 04 80 	movabs $0x8004200c35,%rax
  800420041e:	00 00 00 
  8004200421:	ff d0                	callq  *%rax
}
  8004200423:	5d                   	pop    %rbp
  8004200424:	c3                   	retq   

0000008004200425 <serial_putc>:

static void
serial_putc(int c)
{
  8004200425:	55                   	push   %rbp
  8004200426:	48 89 e5             	mov    %rsp,%rbp
  8004200429:	48 83 ec 28          	sub    $0x28,%rsp
  800420042d:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int i;

	for (i = 0;
  8004200430:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004200437:	eb 10                	jmp    8004200449 <serial_putc+0x24>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  8004200439:	48 b8 68 03 20 04 80 	movabs $0x8004200368,%rax
  8004200440:	00 00 00 
  8004200443:	ff d0                	callq  *%rax
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
  8004200445:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200449:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200450:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004200453:	89 c2                	mov    %eax,%edx
  8004200455:	ec                   	in     (%dx),%al
  8004200456:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  8004200459:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
serial_putc(int c)
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  800420045d:	0f b6 c0             	movzbl %al,%eax
  8004200460:	83 e0 20             	and    $0x20,%eax
static void
serial_putc(int c)
{
	int i;

	for (i = 0;
  8004200463:	85 c0                	test   %eax,%eax
  8004200465:	75 09                	jne    8004200470 <serial_putc+0x4b>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  8004200467:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  800420046e:	7e c9                	jle    8004200439 <serial_putc+0x14>
	     i++)
		delay();

	outb(COM1 + COM_TX, c);
  8004200470:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200473:	0f b6 c0             	movzbl %al,%eax
  8004200476:	c7 45 f0 f8 03 00 00 	movl   $0x3f8,-0x10(%rbp)
  800420047d:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200480:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200484:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200487:	ee                   	out    %al,(%dx)
}
  8004200488:	c9                   	leaveq 
  8004200489:	c3                   	retq   

000000800420048a <serial_init>:

static void
serial_init(void)
{
  800420048a:	55                   	push   %rbp
  800420048b:	48 89 e5             	mov    %rsp,%rbp
  800420048e:	48 83 ec 50          	sub    $0x50,%rsp
  8004200492:	c7 45 fc fa 03 00 00 	movl   $0x3fa,-0x4(%rbp)
  8004200499:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  800420049d:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042004a1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042004a4:	ee                   	out    %al,(%dx)
  80042004a5:	c7 45 f4 fb 03 00 00 	movl   $0x3fb,-0xc(%rbp)
  80042004ac:	c6 45 f3 80          	movb   $0x80,-0xd(%rbp)
  80042004b0:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  80042004b4:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042004b7:	ee                   	out    %al,(%dx)
  80042004b8:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%rbp)
  80042004bf:	c6 45 eb 0c          	movb   $0xc,-0x15(%rbp)
  80042004c3:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  80042004c7:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042004ca:	ee                   	out    %al,(%dx)
  80042004cb:	c7 45 e4 f9 03 00 00 	movl   $0x3f9,-0x1c(%rbp)
  80042004d2:	c6 45 e3 00          	movb   $0x0,-0x1d(%rbp)
  80042004d6:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  80042004da:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042004dd:	ee                   	out    %al,(%dx)
  80042004de:	c7 45 dc fb 03 00 00 	movl   $0x3fb,-0x24(%rbp)
  80042004e5:	c6 45 db 03          	movb   $0x3,-0x25(%rbp)
  80042004e9:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  80042004ed:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042004f0:	ee                   	out    %al,(%dx)
  80042004f1:	c7 45 d4 fc 03 00 00 	movl   $0x3fc,-0x2c(%rbp)
  80042004f8:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  80042004fc:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200500:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004200503:	ee                   	out    %al,(%dx)
  8004200504:	c7 45 cc f9 03 00 00 	movl   $0x3f9,-0x34(%rbp)
  800420050b:	c6 45 cb 01          	movb   $0x1,-0x35(%rbp)
  800420050f:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004200513:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004200516:	ee                   	out    %al,(%dx)
  8004200517:	c7 45 c4 fd 03 00 00 	movl   $0x3fd,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420051e:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004200521:	89 c2                	mov    %eax,%edx
  8004200523:	ec                   	in     (%dx),%al
  8004200524:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  8004200527:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  800420052b:	3c ff                	cmp    $0xff,%al
  800420052d:	0f 95 c2             	setne  %dl
  8004200530:	48 b8 40 c4 2b 04 80 	movabs $0x80042bc440,%rax
  8004200537:	00 00 00 
  800420053a:	88 10                	mov    %dl,(%rax)
  800420053c:	c7 45 bc fa 03 00 00 	movl   $0x3fa,-0x44(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200543:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004200546:	89 c2                	mov    %eax,%edx
  8004200548:	ec                   	in     (%dx),%al
  8004200549:	88 45 bb             	mov    %al,-0x45(%rbp)
  800420054c:	c7 45 b4 f8 03 00 00 	movl   $0x3f8,-0x4c(%rbp)
  8004200553:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004200556:	89 c2                	mov    %eax,%edx
  8004200558:	ec                   	in     (%dx),%al
  8004200559:	88 45 b3             	mov    %al,-0x4d(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

}
  800420055c:	c9                   	leaveq 
  800420055d:	c3                   	retq   

000000800420055e <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  800420055e:	55                   	push   %rbp
  800420055f:	48 89 e5             	mov    %rsp,%rbp
  8004200562:	48 83 ec 38          	sub    $0x38,%rsp
  8004200566:	89 7d cc             	mov    %edi,-0x34(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200569:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004200570:	eb 10                	jmp    8004200582 <lpt_putc+0x24>
		delay();
  8004200572:	48 b8 68 03 20 04 80 	movabs $0x8004200368,%rax
  8004200579:	00 00 00 
  800420057c:	ff d0                	callq  *%rax
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  800420057e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200582:	c7 45 f8 79 03 00 00 	movl   $0x379,-0x8(%rbp)
  8004200589:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420058c:	89 c2                	mov    %eax,%edx
  800420058e:	ec                   	in     (%dx),%al
  800420058f:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  8004200592:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200596:	84 c0                	test   %al,%al
  8004200598:	78 09                	js     80042005a3 <lpt_putc+0x45>
  800420059a:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  80042005a1:	7e cf                	jle    8004200572 <lpt_putc+0x14>
		delay();
	outb(0x378+0, c);
  80042005a3:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80042005a6:	0f b6 c0             	movzbl %al,%eax
  80042005a9:	c7 45 f0 78 03 00 00 	movl   $0x378,-0x10(%rbp)
  80042005b0:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042005b3:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042005b7:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042005ba:	ee                   	out    %al,(%dx)
  80042005bb:	c7 45 e8 7a 03 00 00 	movl   $0x37a,-0x18(%rbp)
  80042005c2:	c6 45 e7 0d          	movb   $0xd,-0x19(%rbp)
  80042005c6:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042005ca:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042005cd:	ee                   	out    %al,(%dx)
  80042005ce:	c7 45 e0 7a 03 00 00 	movl   $0x37a,-0x20(%rbp)
  80042005d5:	c6 45 df 08          	movb   $0x8,-0x21(%rbp)
  80042005d9:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80042005dd:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80042005e0:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  80042005e1:	c9                   	leaveq 
  80042005e2:	c3                   	retq   

00000080042005e3 <cga_init>:
static uint16_t *crt_buf;
static uint16_t crt_pos;

static void
cga_init(void)
{
  80042005e3:	55                   	push   %rbp
  80042005e4:	48 89 e5             	mov    %rsp,%rbp
  80042005e7:	48 83 ec 30          	sub    $0x30,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  80042005eb:	48 b8 00 80 0b 04 80 	movabs $0x80040b8000,%rax
  80042005f2:	00 00 00 
  80042005f5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	was = *cp;
  80042005f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042005fd:	0f b7 00             	movzwl (%rax),%eax
  8004200600:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	*cp = (uint16_t) 0xA55A;
  8004200604:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200608:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  800420060d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200611:	0f b7 00             	movzwl (%rax),%eax
  8004200614:	66 3d 5a a5          	cmp    $0xa55a,%ax
  8004200618:	74 20                	je     800420063a <cga_init+0x57>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  800420061a:	48 b8 00 00 0b 04 80 	movabs $0x80040b0000,%rax
  8004200621:	00 00 00 
  8004200624:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		addr_6845 = MONO_BASE;
  8004200628:	48 b8 44 c4 2b 04 80 	movabs $0x80042bc444,%rax
  800420062f:	00 00 00 
  8004200632:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  8004200638:	eb 1b                	jmp    8004200655 <cga_init+0x72>
	} else {
		*cp = was;
  800420063a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420063e:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004200642:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  8004200645:	48 b8 44 c4 2b 04 80 	movabs $0x80042bc444,%rax
  800420064c:	00 00 00 
  800420064f:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  8004200655:	48 b8 44 c4 2b 04 80 	movabs $0x80042bc444,%rax
  800420065c:	00 00 00 
  800420065f:	8b 00                	mov    (%rax),%eax
  8004200661:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004200664:	c6 45 eb 0e          	movb   $0xe,-0x15(%rbp)
  8004200668:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  800420066c:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420066f:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  8004200670:	48 b8 44 c4 2b 04 80 	movabs $0x80042bc444,%rax
  8004200677:	00 00 00 
  800420067a:	8b 00                	mov    (%rax),%eax
  800420067c:	83 c0 01             	add    $0x1,%eax
  800420067f:	89 45 e4             	mov    %eax,-0x1c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200682:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200685:	89 c2                	mov    %eax,%edx
  8004200687:	ec                   	in     (%dx),%al
  8004200688:	88 45 e3             	mov    %al,-0x1d(%rbp)
	return data;
  800420068b:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  800420068f:	0f b6 c0             	movzbl %al,%eax
  8004200692:	c1 e0 08             	shl    $0x8,%eax
  8004200695:	89 45 f0             	mov    %eax,-0x10(%rbp)
	outb(addr_6845, 15);
  8004200698:	48 b8 44 c4 2b 04 80 	movabs $0x80042bc444,%rax
  800420069f:	00 00 00 
  80042006a2:	8b 00                	mov    (%rax),%eax
  80042006a4:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042006a7:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042006ab:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  80042006af:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042006b2:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  80042006b3:	48 b8 44 c4 2b 04 80 	movabs $0x80042bc444,%rax
  80042006ba:	00 00 00 
  80042006bd:	8b 00                	mov    (%rax),%eax
  80042006bf:	83 c0 01             	add    $0x1,%eax
  80042006c2:	89 45 d4             	mov    %eax,-0x2c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042006c5:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80042006c8:	89 c2                	mov    %eax,%edx
  80042006ca:	ec                   	in     (%dx),%al
  80042006cb:	88 45 d3             	mov    %al,-0x2d(%rbp)
	return data;
  80042006ce:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  80042006d2:	0f b6 c0             	movzbl %al,%eax
  80042006d5:	09 45 f0             	or     %eax,-0x10(%rbp)

	crt_buf = (uint16_t*) cp;
  80042006d8:	48 b8 48 c4 2b 04 80 	movabs $0x80042bc448,%rax
  80042006df:	00 00 00 
  80042006e2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042006e6:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  80042006e9:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80042006ec:	89 c2                	mov    %eax,%edx
  80042006ee:	48 b8 50 c4 2b 04 80 	movabs $0x80042bc450,%rax
  80042006f5:	00 00 00 
  80042006f8:	66 89 10             	mov    %dx,(%rax)
}
  80042006fb:	c9                   	leaveq 
  80042006fc:	c3                   	retq   

00000080042006fd <cga_putc>:



static void
cga_putc(int c)
{
  80042006fd:	55                   	push   %rbp
  80042006fe:	48 89 e5             	mov    %rsp,%rbp
  8004200701:	48 83 ec 40          	sub    $0x40,%rsp
  8004200705:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
  8004200708:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420070b:	b0 00                	mov    $0x0,%al
  800420070d:	85 c0                	test   %eax,%eax
  800420070f:	75 07                	jne    8004200718 <cga_putc+0x1b>
		c |= 0x0700;
  8004200711:	81 4d cc 00 07 00 00 	orl    $0x700,-0x34(%rbp)

	switch (c & 0xff) {
  8004200718:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420071b:	0f b6 c0             	movzbl %al,%eax
  800420071e:	83 f8 09             	cmp    $0x9,%eax
  8004200721:	0f 84 f6 00 00 00    	je     800420081d <cga_putc+0x120>
  8004200727:	83 f8 09             	cmp    $0x9,%eax
  800420072a:	7f 0a                	jg     8004200736 <cga_putc+0x39>
  800420072c:	83 f8 08             	cmp    $0x8,%eax
  800420072f:	74 18                	je     8004200749 <cga_putc+0x4c>
  8004200731:	e9 3e 01 00 00       	jmpq   8004200874 <cga_putc+0x177>
  8004200736:	83 f8 0a             	cmp    $0xa,%eax
  8004200739:	74 75                	je     80042007b0 <cga_putc+0xb3>
  800420073b:	83 f8 0d             	cmp    $0xd,%eax
  800420073e:	0f 84 89 00 00 00    	je     80042007cd <cga_putc+0xd0>
  8004200744:	e9 2b 01 00 00       	jmpq   8004200874 <cga_putc+0x177>
	case '\b':
		if (crt_pos > 0) {
  8004200749:	48 b8 50 c4 2b 04 80 	movabs $0x80042bc450,%rax
  8004200750:	00 00 00 
  8004200753:	0f b7 00             	movzwl (%rax),%eax
  8004200756:	66 85 c0             	test   %ax,%ax
  8004200759:	74 50                	je     80042007ab <cga_putc+0xae>
			crt_pos--;
  800420075b:	48 b8 50 c4 2b 04 80 	movabs $0x80042bc450,%rax
  8004200762:	00 00 00 
  8004200765:	0f b7 00             	movzwl (%rax),%eax
  8004200768:	8d 50 ff             	lea    -0x1(%rax),%edx
  800420076b:	48 b8 50 c4 2b 04 80 	movabs $0x80042bc450,%rax
  8004200772:	00 00 00 
  8004200775:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200778:	48 b8 48 c4 2b 04 80 	movabs $0x80042bc448,%rax
  800420077f:	00 00 00 
  8004200782:	48 8b 10             	mov    (%rax),%rdx
  8004200785:	48 b8 50 c4 2b 04 80 	movabs $0x80042bc450,%rax
  800420078c:	00 00 00 
  800420078f:	0f b7 00             	movzwl (%rax),%eax
  8004200792:	0f b7 c0             	movzwl %ax,%eax
  8004200795:	48 01 c0             	add    %rax,%rax
  8004200798:	48 01 c2             	add    %rax,%rdx
  800420079b:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420079e:	b0 00                	mov    $0x0,%al
  80042007a0:	83 c8 20             	or     $0x20,%eax
  80042007a3:	66 89 02             	mov    %ax,(%rdx)
		}
		break;
  80042007a6:	e9 04 01 00 00       	jmpq   80042008af <cga_putc+0x1b2>
  80042007ab:	e9 ff 00 00 00       	jmpq   80042008af <cga_putc+0x1b2>
	case '\n':
		crt_pos += CRT_COLS;
  80042007b0:	48 b8 50 c4 2b 04 80 	movabs $0x80042bc450,%rax
  80042007b7:	00 00 00 
  80042007ba:	0f b7 00             	movzwl (%rax),%eax
  80042007bd:	8d 50 50             	lea    0x50(%rax),%edx
  80042007c0:	48 b8 50 c4 2b 04 80 	movabs $0x80042bc450,%rax
  80042007c7:	00 00 00 
  80042007ca:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  80042007cd:	48 b8 50 c4 2b 04 80 	movabs $0x80042bc450,%rax
  80042007d4:	00 00 00 
  80042007d7:	0f b7 30             	movzwl (%rax),%esi
  80042007da:	48 b8 50 c4 2b 04 80 	movabs $0x80042bc450,%rax
  80042007e1:	00 00 00 
  80042007e4:	0f b7 08             	movzwl (%rax),%ecx
  80042007e7:	0f b7 c1             	movzwl %cx,%eax
  80042007ea:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  80042007f0:	c1 e8 10             	shr    $0x10,%eax
  80042007f3:	89 c2                	mov    %eax,%edx
  80042007f5:	66 c1 ea 06          	shr    $0x6,%dx
  80042007f9:	89 d0                	mov    %edx,%eax
  80042007fb:	c1 e0 02             	shl    $0x2,%eax
  80042007fe:	01 d0                	add    %edx,%eax
  8004200800:	c1 e0 04             	shl    $0x4,%eax
  8004200803:	29 c1                	sub    %eax,%ecx
  8004200805:	89 ca                	mov    %ecx,%edx
  8004200807:	29 d6                	sub    %edx,%esi
  8004200809:	89 f2                	mov    %esi,%edx
  800420080b:	48 b8 50 c4 2b 04 80 	movabs $0x80042bc450,%rax
  8004200812:	00 00 00 
  8004200815:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200818:	e9 92 00 00 00       	jmpq   80042008af <cga_putc+0x1b2>
	case '\t':
		cons_putc(' ');
  800420081d:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200822:	48 b8 72 0d 20 04 80 	movabs $0x8004200d72,%rax
  8004200829:	00 00 00 
  800420082c:	ff d0                	callq  *%rax
		cons_putc(' ');
  800420082e:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200833:	48 b8 72 0d 20 04 80 	movabs $0x8004200d72,%rax
  800420083a:	00 00 00 
  800420083d:	ff d0                	callq  *%rax
		cons_putc(' ');
  800420083f:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200844:	48 b8 72 0d 20 04 80 	movabs $0x8004200d72,%rax
  800420084b:	00 00 00 
  800420084e:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200850:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200855:	48 b8 72 0d 20 04 80 	movabs $0x8004200d72,%rax
  800420085c:	00 00 00 
  800420085f:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200861:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200866:	48 b8 72 0d 20 04 80 	movabs $0x8004200d72,%rax
  800420086d:	00 00 00 
  8004200870:	ff d0                	callq  *%rax
		break;
  8004200872:	eb 3b                	jmp    80042008af <cga_putc+0x1b2>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200874:	48 b8 48 c4 2b 04 80 	movabs $0x80042bc448,%rax
  800420087b:	00 00 00 
  800420087e:	48 8b 30             	mov    (%rax),%rsi
  8004200881:	48 b8 50 c4 2b 04 80 	movabs $0x80042bc450,%rax
  8004200888:	00 00 00 
  800420088b:	0f b7 00             	movzwl (%rax),%eax
  800420088e:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200891:	48 ba 50 c4 2b 04 80 	movabs $0x80042bc450,%rdx
  8004200898:	00 00 00 
  800420089b:	66 89 0a             	mov    %cx,(%rdx)
  800420089e:	0f b7 c0             	movzwl %ax,%eax
  80042008a1:	48 01 c0             	add    %rax,%rax
  80042008a4:	48 8d 14 06          	lea    (%rsi,%rax,1),%rdx
  80042008a8:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80042008ab:	66 89 02             	mov    %ax,(%rdx)
		break;
  80042008ae:	90                   	nop
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
  80042008af:	48 b8 50 c4 2b 04 80 	movabs $0x80042bc450,%rax
  80042008b6:	00 00 00 
  80042008b9:	0f b7 00             	movzwl (%rax),%eax
  80042008bc:	66 3d cf 07          	cmp    $0x7cf,%ax
  80042008c0:	0f 86 89 00 00 00    	jbe    800420094f <cga_putc+0x252>
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  80042008c6:	48 b8 48 c4 2b 04 80 	movabs $0x80042bc448,%rax
  80042008cd:	00 00 00 
  80042008d0:	48 8b 00             	mov    (%rax),%rax
  80042008d3:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  80042008da:	48 b8 48 c4 2b 04 80 	movabs $0x80042bc448,%rax
  80042008e1:	00 00 00 
  80042008e4:	48 8b 00             	mov    (%rax),%rax
  80042008e7:	ba 00 0f 00 00       	mov    $0xf00,%edx
  80042008ec:	48 89 ce             	mov    %rcx,%rsi
  80042008ef:	48 89 c7             	mov    %rax,%rdi
  80042008f2:	48 b8 21 bb 20 04 80 	movabs $0x800420bb21,%rax
  80042008f9:	00 00 00 
  80042008fc:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  80042008fe:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200905:	eb 22                	jmp    8004200929 <cga_putc+0x22c>
			crt_buf[i] = 0x0700 | ' ';
  8004200907:	48 b8 48 c4 2b 04 80 	movabs $0x80042bc448,%rax
  800420090e:	00 00 00 
  8004200911:	48 8b 00             	mov    (%rax),%rax
  8004200914:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200917:	48 63 d2             	movslq %edx,%rdx
  800420091a:	48 01 d2             	add    %rdx,%rdx
  800420091d:	48 01 d0             	add    %rdx,%rax
  8004200920:	66 c7 00 20 07       	movw   $0x720,(%rax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200925:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200929:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200930:	7e d5                	jle    8004200907 <cga_putc+0x20a>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
  8004200932:	48 b8 50 c4 2b 04 80 	movabs $0x80042bc450,%rax
  8004200939:	00 00 00 
  800420093c:	0f b7 00             	movzwl (%rax),%eax
  800420093f:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200942:	48 b8 50 c4 2b 04 80 	movabs $0x80042bc450,%rax
  8004200949:	00 00 00 
  800420094c:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  800420094f:	48 b8 44 c4 2b 04 80 	movabs $0x80042bc444,%rax
  8004200956:	00 00 00 
  8004200959:	8b 00                	mov    (%rax),%eax
  800420095b:	89 45 f8             	mov    %eax,-0x8(%rbp)
  800420095e:	c6 45 f7 0e          	movb   $0xe,-0x9(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200962:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200966:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200969:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  800420096a:	48 b8 50 c4 2b 04 80 	movabs $0x80042bc450,%rax
  8004200971:	00 00 00 
  8004200974:	0f b7 00             	movzwl (%rax),%eax
  8004200977:	66 c1 e8 08          	shr    $0x8,%ax
  800420097b:	0f b6 c0             	movzbl %al,%eax
  800420097e:	48 ba 44 c4 2b 04 80 	movabs $0x80042bc444,%rdx
  8004200985:	00 00 00 
  8004200988:	8b 12                	mov    (%rdx),%edx
  800420098a:	83 c2 01             	add    $0x1,%edx
  800420098d:	89 55 f0             	mov    %edx,-0x10(%rbp)
  8004200990:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004200993:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200997:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800420099a:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  800420099b:	48 b8 44 c4 2b 04 80 	movabs $0x80042bc444,%rax
  80042009a2:	00 00 00 
  80042009a5:	8b 00                	mov    (%rax),%eax
  80042009a7:	89 45 e8             	mov    %eax,-0x18(%rbp)
  80042009aa:	c6 45 e7 0f          	movb   $0xf,-0x19(%rbp)
  80042009ae:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042009b2:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042009b5:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  80042009b6:	48 b8 50 c4 2b 04 80 	movabs $0x80042bc450,%rax
  80042009bd:	00 00 00 
  80042009c0:	0f b7 00             	movzwl (%rax),%eax
  80042009c3:	0f b6 c0             	movzbl %al,%eax
  80042009c6:	48 ba 44 c4 2b 04 80 	movabs $0x80042bc444,%rdx
  80042009cd:	00 00 00 
  80042009d0:	8b 12                	mov    (%rdx),%edx
  80042009d2:	83 c2 01             	add    $0x1,%edx
  80042009d5:	89 55 e0             	mov    %edx,-0x20(%rbp)
  80042009d8:	88 45 df             	mov    %al,-0x21(%rbp)
  80042009db:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80042009df:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80042009e2:	ee                   	out    %al,(%dx)
}
  80042009e3:	c9                   	leaveq 
  80042009e4:	c3                   	retq   

00000080042009e5 <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  80042009e5:	55                   	push   %rbp
  80042009e6:	48 89 e5             	mov    %rsp,%rbp
  80042009e9:	48 83 ec 20          	sub    $0x20,%rsp
  80042009ed:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042009f4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042009f7:	89 c2                	mov    %eax,%edx
  80042009f9:	ec                   	in     (%dx),%al
  80042009fa:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  80042009fd:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;
	int r;
	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200a01:	0f b6 c0             	movzbl %al,%eax
  8004200a04:	83 e0 01             	and    $0x1,%eax
  8004200a07:	85 c0                	test   %eax,%eax
  8004200a09:	75 0a                	jne    8004200a15 <kbd_proc_data+0x30>
		return -1;
  8004200a0b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200a10:	e9 fc 01 00 00       	jmpq   8004200c11 <kbd_proc_data+0x22c>
  8004200a15:	c7 45 ec 60 00 00 00 	movl   $0x60,-0x14(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a1c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200a1f:	89 c2                	mov    %eax,%edx
  8004200a21:	ec                   	in     (%dx),%al
  8004200a22:	88 45 eb             	mov    %al,-0x15(%rbp)
	return data;
  8004200a25:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax

	data = inb(KBDATAP);
  8004200a29:	88 45 fb             	mov    %al,-0x5(%rbp)

	if (data == 0xE0) {
  8004200a2c:	80 7d fb e0          	cmpb   $0xe0,-0x5(%rbp)
  8004200a30:	75 27                	jne    8004200a59 <kbd_proc_data+0x74>
		// E0 escape character
		shift |= E0ESC;
  8004200a32:	48 b8 68 c6 2b 04 80 	movabs $0x80042bc668,%rax
  8004200a39:	00 00 00 
  8004200a3c:	8b 00                	mov    (%rax),%eax
  8004200a3e:	83 c8 40             	or     $0x40,%eax
  8004200a41:	89 c2                	mov    %eax,%edx
  8004200a43:	48 b8 68 c6 2b 04 80 	movabs $0x80042bc668,%rax
  8004200a4a:	00 00 00 
  8004200a4d:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200a4f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200a54:	e9 b8 01 00 00       	jmpq   8004200c11 <kbd_proc_data+0x22c>
	} else if (data & 0x80) {
  8004200a59:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200a5d:	84 c0                	test   %al,%al
  8004200a5f:	79 65                	jns    8004200ac6 <kbd_proc_data+0xe1>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200a61:	48 b8 68 c6 2b 04 80 	movabs $0x80042bc668,%rax
  8004200a68:	00 00 00 
  8004200a6b:	8b 00                	mov    (%rax),%eax
  8004200a6d:	83 e0 40             	and    $0x40,%eax
  8004200a70:	85 c0                	test   %eax,%eax
  8004200a72:	75 09                	jne    8004200a7d <kbd_proc_data+0x98>
  8004200a74:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200a78:	83 e0 7f             	and    $0x7f,%eax
  8004200a7b:	eb 04                	jmp    8004200a81 <kbd_proc_data+0x9c>
  8004200a7d:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200a81:	88 45 fb             	mov    %al,-0x5(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200a84:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200a88:	48 ba 60 60 22 04 80 	movabs $0x8004226060,%rdx
  8004200a8f:	00 00 00 
  8004200a92:	48 98                	cltq   
  8004200a94:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200a98:	83 c8 40             	or     $0x40,%eax
  8004200a9b:	0f b6 c0             	movzbl %al,%eax
  8004200a9e:	f7 d0                	not    %eax
  8004200aa0:	89 c2                	mov    %eax,%edx
  8004200aa2:	48 b8 68 c6 2b 04 80 	movabs $0x80042bc668,%rax
  8004200aa9:	00 00 00 
  8004200aac:	8b 00                	mov    (%rax),%eax
  8004200aae:	21 c2                	and    %eax,%edx
  8004200ab0:	48 b8 68 c6 2b 04 80 	movabs $0x80042bc668,%rax
  8004200ab7:	00 00 00 
  8004200aba:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200abc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200ac1:	e9 4b 01 00 00       	jmpq   8004200c11 <kbd_proc_data+0x22c>
	} else if (shift & E0ESC) {
  8004200ac6:	48 b8 68 c6 2b 04 80 	movabs $0x80042bc668,%rax
  8004200acd:	00 00 00 
  8004200ad0:	8b 00                	mov    (%rax),%eax
  8004200ad2:	83 e0 40             	and    $0x40,%eax
  8004200ad5:	85 c0                	test   %eax,%eax
  8004200ad7:	74 21                	je     8004200afa <kbd_proc_data+0x115>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004200ad9:	80 4d fb 80          	orb    $0x80,-0x5(%rbp)
		shift &= ~E0ESC;
  8004200add:	48 b8 68 c6 2b 04 80 	movabs $0x80042bc668,%rax
  8004200ae4:	00 00 00 
  8004200ae7:	8b 00                	mov    (%rax),%eax
  8004200ae9:	83 e0 bf             	and    $0xffffffbf,%eax
  8004200aec:	89 c2                	mov    %eax,%edx
  8004200aee:	48 b8 68 c6 2b 04 80 	movabs $0x80042bc668,%rax
  8004200af5:	00 00 00 
  8004200af8:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004200afa:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200afe:	48 ba 60 60 22 04 80 	movabs $0x8004226060,%rdx
  8004200b05:	00 00 00 
  8004200b08:	48 98                	cltq   
  8004200b0a:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200b0e:	0f b6 d0             	movzbl %al,%edx
  8004200b11:	48 b8 68 c6 2b 04 80 	movabs $0x80042bc668,%rax
  8004200b18:	00 00 00 
  8004200b1b:	8b 00                	mov    (%rax),%eax
  8004200b1d:	09 c2                	or     %eax,%edx
  8004200b1f:	48 b8 68 c6 2b 04 80 	movabs $0x80042bc668,%rax
  8004200b26:	00 00 00 
  8004200b29:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004200b2b:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200b2f:	48 ba 60 61 22 04 80 	movabs $0x8004226160,%rdx
  8004200b36:	00 00 00 
  8004200b39:	48 98                	cltq   
  8004200b3b:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200b3f:	0f b6 d0             	movzbl %al,%edx
  8004200b42:	48 b8 68 c6 2b 04 80 	movabs $0x80042bc668,%rax
  8004200b49:	00 00 00 
  8004200b4c:	8b 00                	mov    (%rax),%eax
  8004200b4e:	31 c2                	xor    %eax,%edx
  8004200b50:	48 b8 68 c6 2b 04 80 	movabs $0x80042bc668,%rax
  8004200b57:	00 00 00 
  8004200b5a:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  8004200b5c:	48 b8 68 c6 2b 04 80 	movabs $0x80042bc668,%rax
  8004200b63:	00 00 00 
  8004200b66:	8b 00                	mov    (%rax),%eax
  8004200b68:	83 e0 03             	and    $0x3,%eax
  8004200b6b:	89 c2                	mov    %eax,%edx
  8004200b6d:	48 b8 60 65 22 04 80 	movabs $0x8004226560,%rax
  8004200b74:	00 00 00 
  8004200b77:	89 d2                	mov    %edx,%edx
  8004200b79:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8004200b7d:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200b81:	48 01 d0             	add    %rdx,%rax
  8004200b84:	0f b6 00             	movzbl (%rax),%eax
  8004200b87:	0f b6 c0             	movzbl %al,%eax
  8004200b8a:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (shift & CAPSLOCK) {
  8004200b8d:	48 b8 68 c6 2b 04 80 	movabs $0x80042bc668,%rax
  8004200b94:	00 00 00 
  8004200b97:	8b 00                	mov    (%rax),%eax
  8004200b99:	83 e0 08             	and    $0x8,%eax
  8004200b9c:	85 c0                	test   %eax,%eax
  8004200b9e:	74 22                	je     8004200bc2 <kbd_proc_data+0x1dd>
		if ('a' <= c && c <= 'z')
  8004200ba0:	83 7d fc 60          	cmpl   $0x60,-0x4(%rbp)
  8004200ba4:	7e 0c                	jle    8004200bb2 <kbd_proc_data+0x1cd>
  8004200ba6:	83 7d fc 7a          	cmpl   $0x7a,-0x4(%rbp)
  8004200baa:	7f 06                	jg     8004200bb2 <kbd_proc_data+0x1cd>
			c += 'A' - 'a';
  8004200bac:	83 6d fc 20          	subl   $0x20,-0x4(%rbp)
  8004200bb0:	eb 10                	jmp    8004200bc2 <kbd_proc_data+0x1dd>
		else if ('A' <= c && c <= 'Z')
  8004200bb2:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
  8004200bb6:	7e 0a                	jle    8004200bc2 <kbd_proc_data+0x1dd>
  8004200bb8:	83 7d fc 5a          	cmpl   $0x5a,-0x4(%rbp)
  8004200bbc:	7f 04                	jg     8004200bc2 <kbd_proc_data+0x1dd>
			c += 'a' - 'A';
  8004200bbe:	83 45 fc 20          	addl   $0x20,-0x4(%rbp)
	}

	// Process special keys
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  8004200bc2:	48 b8 68 c6 2b 04 80 	movabs $0x80042bc668,%rax
  8004200bc9:	00 00 00 
  8004200bcc:	8b 00                	mov    (%rax),%eax
  8004200bce:	f7 d0                	not    %eax
  8004200bd0:	83 e0 06             	and    $0x6,%eax
  8004200bd3:	85 c0                	test   %eax,%eax
  8004200bd5:	75 37                	jne    8004200c0e <kbd_proc_data+0x229>
  8004200bd7:	81 7d fc e9 00 00 00 	cmpl   $0xe9,-0x4(%rbp)
  8004200bde:	75 2e                	jne    8004200c0e <kbd_proc_data+0x229>
		cprintf("Rebooting!\n");
  8004200be0:	48 bf cf 1e 21 04 80 	movabs $0x8004211ecf,%rdi
  8004200be7:	00 00 00 
  8004200bea:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200bef:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004200bf6:	00 00 00 
  8004200bf9:	ff d2                	callq  *%rdx
  8004200bfb:	c7 45 e4 92 00 00 00 	movl   $0x92,-0x1c(%rbp)
  8004200c02:	c6 45 e3 03          	movb   $0x3,-0x1d(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200c06:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200c0a:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200c0d:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}
	return c;
  8004200c0e:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004200c11:	c9                   	leaveq 
  8004200c12:	c3                   	retq   

0000008004200c13 <kbd_intr>:

void
kbd_intr(void)
{
  8004200c13:	55                   	push   %rbp
  8004200c14:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  8004200c17:	48 bf e5 09 20 04 80 	movabs $0x80042009e5,%rdi
  8004200c1e:	00 00 00 
  8004200c21:	48 b8 35 0c 20 04 80 	movabs $0x8004200c35,%rax
  8004200c28:	00 00 00 
  8004200c2b:	ff d0                	callq  *%rax
}
  8004200c2d:	5d                   	pop    %rbp
  8004200c2e:	c3                   	retq   

0000008004200c2f <kbd_init>:

static void
kbd_init(void)
{
  8004200c2f:	55                   	push   %rbp
  8004200c30:	48 89 e5             	mov    %rsp,%rbp
}
  8004200c33:	5d                   	pop    %rbp
  8004200c34:	c3                   	retq   

0000008004200c35 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  8004200c35:	55                   	push   %rbp
  8004200c36:	48 89 e5             	mov    %rsp,%rbp
  8004200c39:	48 83 ec 20          	sub    $0x20,%rsp
  8004200c3d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  8004200c41:	eb 6a                	jmp    8004200cad <cons_intr+0x78>
		if (c == 0)
  8004200c43:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004200c47:	75 02                	jne    8004200c4b <cons_intr+0x16>
			continue;
  8004200c49:	eb 62                	jmp    8004200cad <cons_intr+0x78>
		cons.buf[cons.wpos++] = c;
  8004200c4b:	48 b8 60 c4 2b 04 80 	movabs $0x80042bc460,%rax
  8004200c52:	00 00 00 
  8004200c55:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004200c5b:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200c5e:	48 ba 60 c4 2b 04 80 	movabs $0x80042bc460,%rdx
  8004200c65:	00 00 00 
  8004200c68:	89 8a 04 02 00 00    	mov    %ecx,0x204(%rdx)
  8004200c6e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200c71:	89 d1                	mov    %edx,%ecx
  8004200c73:	48 ba 60 c4 2b 04 80 	movabs $0x80042bc460,%rdx
  8004200c7a:	00 00 00 
  8004200c7d:	89 c0                	mov    %eax,%eax
  8004200c7f:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
		if (cons.wpos == CONSBUFSIZE)
  8004200c82:	48 b8 60 c4 2b 04 80 	movabs $0x80042bc460,%rax
  8004200c89:	00 00 00 
  8004200c8c:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004200c92:	3d 00 02 00 00       	cmp    $0x200,%eax
  8004200c97:	75 14                	jne    8004200cad <cons_intr+0x78>
			cons.wpos = 0;
  8004200c99:	48 b8 60 c4 2b 04 80 	movabs $0x80042bc460,%rax
  8004200ca0:	00 00 00 
  8004200ca3:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  8004200caa:	00 00 00 
static void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
  8004200cad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004200cb1:	ff d0                	callq  *%rax
  8004200cb3:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004200cb6:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  8004200cba:	75 87                	jne    8004200c43 <cons_intr+0xe>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
  8004200cbc:	c9                   	leaveq 
  8004200cbd:	c3                   	retq   

0000008004200cbe <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  8004200cbe:	55                   	push   %rbp
  8004200cbf:	48 89 e5             	mov    %rsp,%rbp
  8004200cc2:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  8004200cc6:	48 b8 f8 03 20 04 80 	movabs $0x80042003f8,%rax
  8004200ccd:	00 00 00 
  8004200cd0:	ff d0                	callq  *%rax
	kbd_intr();
  8004200cd2:	48 b8 13 0c 20 04 80 	movabs $0x8004200c13,%rax
  8004200cd9:	00 00 00 
  8004200cdc:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  8004200cde:	48 b8 60 c4 2b 04 80 	movabs $0x80042bc460,%rax
  8004200ce5:	00 00 00 
  8004200ce8:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  8004200cee:	48 b8 60 c4 2b 04 80 	movabs $0x80042bc460,%rax
  8004200cf5:	00 00 00 
  8004200cf8:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004200cfe:	39 c2                	cmp    %eax,%edx
  8004200d00:	74 69                	je     8004200d6b <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  8004200d02:	48 b8 60 c4 2b 04 80 	movabs $0x80042bc460,%rax
  8004200d09:	00 00 00 
  8004200d0c:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004200d12:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200d15:	48 ba 60 c4 2b 04 80 	movabs $0x80042bc460,%rdx
  8004200d1c:	00 00 00 
  8004200d1f:	89 8a 00 02 00 00    	mov    %ecx,0x200(%rdx)
  8004200d25:	48 ba 60 c4 2b 04 80 	movabs $0x80042bc460,%rdx
  8004200d2c:	00 00 00 
  8004200d2f:	89 c0                	mov    %eax,%eax
  8004200d31:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200d35:	0f b6 c0             	movzbl %al,%eax
  8004200d38:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (cons.rpos == CONSBUFSIZE)
  8004200d3b:	48 b8 60 c4 2b 04 80 	movabs $0x80042bc460,%rax
  8004200d42:	00 00 00 
  8004200d45:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004200d4b:	3d 00 02 00 00       	cmp    $0x200,%eax
  8004200d50:	75 14                	jne    8004200d66 <cons_getc+0xa8>
			cons.rpos = 0;
  8004200d52:	48 b8 60 c4 2b 04 80 	movabs $0x80042bc460,%rax
  8004200d59:	00 00 00 
  8004200d5c:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  8004200d63:	00 00 00 
		return c;
  8004200d66:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004200d69:	eb 05                	jmp    8004200d70 <cons_getc+0xb2>
	}
	return 0;
  8004200d6b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004200d70:	c9                   	leaveq 
  8004200d71:	c3                   	retq   

0000008004200d72 <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  8004200d72:	55                   	push   %rbp
  8004200d73:	48 89 e5             	mov    %rsp,%rbp
  8004200d76:	48 83 ec 10          	sub    $0x10,%rsp
  8004200d7a:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  8004200d7d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004200d80:	89 c7                	mov    %eax,%edi
  8004200d82:	48 b8 25 04 20 04 80 	movabs $0x8004200425,%rax
  8004200d89:	00 00 00 
  8004200d8c:	ff d0                	callq  *%rax
	lpt_putc(c);
  8004200d8e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004200d91:	89 c7                	mov    %eax,%edi
  8004200d93:	48 b8 5e 05 20 04 80 	movabs $0x800420055e,%rax
  8004200d9a:	00 00 00 
  8004200d9d:	ff d0                	callq  *%rax
	cga_putc(c);
  8004200d9f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004200da2:	89 c7                	mov    %eax,%edi
  8004200da4:	48 b8 fd 06 20 04 80 	movabs $0x80042006fd,%rax
  8004200dab:	00 00 00 
  8004200dae:	ff d0                	callq  *%rax
}
  8004200db0:	c9                   	leaveq 
  8004200db1:	c3                   	retq   

0000008004200db2 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  8004200db2:	55                   	push   %rbp
  8004200db3:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  8004200db6:	48 b8 e3 05 20 04 80 	movabs $0x80042005e3,%rax
  8004200dbd:	00 00 00 
  8004200dc0:	ff d0                	callq  *%rax
	kbd_init();
  8004200dc2:	48 b8 2f 0c 20 04 80 	movabs $0x8004200c2f,%rax
  8004200dc9:	00 00 00 
  8004200dcc:	ff d0                	callq  *%rax
	serial_init();
  8004200dce:	48 b8 8a 04 20 04 80 	movabs $0x800420048a,%rax
  8004200dd5:	00 00 00 
  8004200dd8:	ff d0                	callq  *%rax

	if (!serial_exists)
  8004200dda:	48 b8 40 c4 2b 04 80 	movabs $0x80042bc440,%rax
  8004200de1:	00 00 00 
  8004200de4:	0f b6 00             	movzbl (%rax),%eax
  8004200de7:	83 f0 01             	xor    $0x1,%eax
  8004200dea:	84 c0                	test   %al,%al
  8004200dec:	74 1b                	je     8004200e09 <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  8004200dee:	48 bf db 1e 21 04 80 	movabs $0x8004211edb,%rdi
  8004200df5:	00 00 00 
  8004200df8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200dfd:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004200e04:	00 00 00 
  8004200e07:	ff d2                	callq  *%rdx
}
  8004200e09:	5d                   	pop    %rbp
  8004200e0a:	c3                   	retq   

0000008004200e0b <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  8004200e0b:	55                   	push   %rbp
  8004200e0c:	48 89 e5             	mov    %rsp,%rbp
  8004200e0f:	48 83 ec 10          	sub    $0x10,%rsp
  8004200e13:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  8004200e16:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004200e19:	89 c7                	mov    %eax,%edi
  8004200e1b:	48 b8 72 0d 20 04 80 	movabs $0x8004200d72,%rax
  8004200e22:	00 00 00 
  8004200e25:	ff d0                	callq  *%rax
}
  8004200e27:	c9                   	leaveq 
  8004200e28:	c3                   	retq   

0000008004200e29 <getchar>:

int
getchar(void)
{
  8004200e29:	55                   	push   %rbp
  8004200e2a:	48 89 e5             	mov    %rsp,%rbp
  8004200e2d:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  8004200e31:	48 b8 be 0c 20 04 80 	movabs $0x8004200cbe,%rax
  8004200e38:	00 00 00 
  8004200e3b:	ff d0                	callq  *%rax
  8004200e3d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004200e40:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004200e44:	74 eb                	je     8004200e31 <getchar+0x8>
		/* do nothing */;
	return c;
  8004200e46:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004200e49:	c9                   	leaveq 
  8004200e4a:	c3                   	retq   

0000008004200e4b <iscons>:

int
iscons(int fdnum)
{
  8004200e4b:	55                   	push   %rbp
  8004200e4c:	48 89 e5             	mov    %rsp,%rbp
  8004200e4f:	48 83 ec 04          	sub    $0x4,%rsp
  8004200e53:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  8004200e56:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004200e5b:	c9                   	leaveq 
  8004200e5c:	c3                   	retq   

0000008004200e5d <mon_help>:

/***** Implementations of basic kernel monitor commands *****/

int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  8004200e5d:	55                   	push   %rbp
  8004200e5e:	48 89 e5             	mov    %rsp,%rbp
  8004200e61:	48 83 ec 30          	sub    $0x30,%rsp
  8004200e65:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004200e68:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004200e6c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004200e70:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004200e77:	eb 6c                	jmp    8004200ee5 <mon_help+0x88>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  8004200e79:	48 b9 80 65 22 04 80 	movabs $0x8004226580,%rcx
  8004200e80:	00 00 00 
  8004200e83:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004200e86:	48 63 d0             	movslq %eax,%rdx
  8004200e89:	48 89 d0             	mov    %rdx,%rax
  8004200e8c:	48 01 c0             	add    %rax,%rax
  8004200e8f:	48 01 d0             	add    %rdx,%rax
  8004200e92:	48 c1 e0 03          	shl    $0x3,%rax
  8004200e96:	48 01 c8             	add    %rcx,%rax
  8004200e99:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004200e9d:	48 be 80 65 22 04 80 	movabs $0x8004226580,%rsi
  8004200ea4:	00 00 00 
  8004200ea7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004200eaa:	48 63 d0             	movslq %eax,%rdx
  8004200ead:	48 89 d0             	mov    %rdx,%rax
  8004200eb0:	48 01 c0             	add    %rax,%rax
  8004200eb3:	48 01 d0             	add    %rdx,%rax
  8004200eb6:	48 c1 e0 03          	shl    $0x3,%rax
  8004200eba:	48 01 f0             	add    %rsi,%rax
  8004200ebd:	48 8b 00             	mov    (%rax),%rax
  8004200ec0:	48 89 ca             	mov    %rcx,%rdx
  8004200ec3:	48 89 c6             	mov    %rax,%rsi
  8004200ec6:	48 bf 4d 1f 21 04 80 	movabs $0x8004211f4d,%rdi
  8004200ecd:	00 00 00 
  8004200ed0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200ed5:	48 b9 46 7b 20 04 80 	movabs $0x8004207b46,%rcx
  8004200edc:	00 00 00 
  8004200edf:	ff d1                	callq  *%rcx
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004200ee1:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200ee5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004200ee8:	83 f8 01             	cmp    $0x1,%eax
  8004200eeb:	76 8c                	jbe    8004200e79 <mon_help+0x1c>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
	return 0;
  8004200eed:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004200ef2:	c9                   	leaveq 
  8004200ef3:	c3                   	retq   

0000008004200ef4 <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  8004200ef4:	55                   	push   %rbp
  8004200ef5:	48 89 e5             	mov    %rsp,%rbp
  8004200ef8:	48 83 ec 30          	sub    $0x30,%rsp
  8004200efc:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004200eff:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004200f03:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  8004200f07:	48 bf 56 1f 21 04 80 	movabs $0x8004211f56,%rdi
  8004200f0e:	00 00 00 
  8004200f11:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200f16:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004200f1d:	00 00 00 
  8004200f20:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  8004200f22:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  8004200f29:	00 00 00 
  8004200f2c:	48 bf 70 1f 21 04 80 	movabs $0x8004211f70,%rdi
  8004200f33:	00 00 00 
  8004200f36:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200f3b:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004200f42:	00 00 00 
  8004200f45:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  8004200f47:	48 ba 0c 00 20 00 00 	movabs $0x20000c,%rdx
  8004200f4e:	00 00 00 
  8004200f51:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  8004200f58:	00 00 00 
  8004200f5b:	48 bf 98 1f 21 04 80 	movabs $0x8004211f98,%rdi
  8004200f62:	00 00 00 
  8004200f65:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200f6a:	48 b9 46 7b 20 04 80 	movabs $0x8004207b46,%rcx
  8004200f71:	00 00 00 
  8004200f74:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  8004200f76:	48 ba 7f 1e 21 00 00 	movabs $0x211e7f,%rdx
  8004200f7d:	00 00 00 
  8004200f80:	48 be 7f 1e 21 04 80 	movabs $0x8004211e7f,%rsi
  8004200f87:	00 00 00 
  8004200f8a:	48 bf c0 1f 21 04 80 	movabs $0x8004211fc0,%rdi
  8004200f91:	00 00 00 
  8004200f94:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200f99:	48 b9 46 7b 20 04 80 	movabs $0x8004207b46,%rcx
  8004200fa0:	00 00 00 
  8004200fa3:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  8004200fa5:	48 ba 29 c4 2b 00 00 	movabs $0x2bc429,%rdx
  8004200fac:	00 00 00 
  8004200faf:	48 be 29 c4 2b 04 80 	movabs $0x80042bc429,%rsi
  8004200fb6:	00 00 00 
  8004200fb9:	48 bf e8 1f 21 04 80 	movabs $0x8004211fe8,%rdi
  8004200fc0:	00 00 00 
  8004200fc3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200fc8:	48 b9 46 7b 20 04 80 	movabs $0x8004207b46,%rcx
  8004200fcf:	00 00 00 
  8004200fd2:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  8004200fd4:	48 ba e0 eb 2b 00 00 	movabs $0x2bebe0,%rdx
  8004200fdb:	00 00 00 
  8004200fde:	48 be e0 eb 2b 04 80 	movabs $0x80042bebe0,%rsi
  8004200fe5:	00 00 00 
  8004200fe8:	48 bf 10 20 21 04 80 	movabs $0x8004212010,%rdi
  8004200fef:	00 00 00 
  8004200ff2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200ff7:	48 b9 46 7b 20 04 80 	movabs $0x8004207b46,%rcx
  8004200ffe:	00 00 00 
  8004201001:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  8004201003:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  800420100a:	00 
  800420100b:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  8004201012:	00 00 00 
  8004201015:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201019:	48 29 c2             	sub    %rax,%rdx
  800420101c:	48 b8 e0 eb 2b 04 80 	movabs $0x80042bebe0,%rax
  8004201023:	00 00 00 
  8004201026:	48 83 e8 01          	sub    $0x1,%rax
  800420102a:	48 01 d0             	add    %rdx,%rax
  800420102d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004201031:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201035:	ba 00 00 00 00       	mov    $0x0,%edx
  800420103a:	48 f7 75 f8          	divq   -0x8(%rbp)
  800420103e:	48 89 d0             	mov    %rdx,%rax
  8004201041:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004201045:	48 29 c2             	sub    %rax,%rdx
  8004201048:	48 89 d0             	mov    %rdx,%rax
	cprintf("  _start                  %08x (phys)\n", _start);
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
	cprintf("Kernel executable memory footprint: %dKB\n",
  800420104b:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  8004201052:	48 85 c0             	test   %rax,%rax
  8004201055:	48 0f 48 c2          	cmovs  %rdx,%rax
  8004201059:	48 c1 f8 0a          	sar    $0xa,%rax
  800420105d:	48 89 c6             	mov    %rax,%rsi
  8004201060:	48 bf 38 20 21 04 80 	movabs $0x8004212038,%rdi
  8004201067:	00 00 00 
  800420106a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420106f:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004201076:	00 00 00 
  8004201079:	ff d2                	callq  *%rdx
		ROUNDUP(end - entry, 1024) / 1024);
	return 0;
  800420107b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201080:	c9                   	leaveq 
  8004201081:	c3                   	retq   

0000008004201082 <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  8004201082:	55                   	push   %rbp
  8004201083:	48 89 e5             	mov    %rsp,%rbp
  8004201086:	48 83 ec 18          	sub    $0x18,%rsp
  800420108a:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420108d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004201091:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	// Your code here.
	return 0;
  8004201095:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420109a:	c9                   	leaveq 
  800420109b:	c3                   	retq   

000000800420109c <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  800420109c:	55                   	push   %rbp
  800420109d:	48 89 e5             	mov    %rsp,%rbp
  80042010a0:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  80042010a7:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  80042010ae:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  80042010b5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  80042010bc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042010bf:	48 98                	cltq   
  80042010c1:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  80042010c8:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  80042010cd:	eb 15                	jmp    80042010e4 <runcmd+0x48>
			*buf++ = 0;
  80042010cf:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042010d6:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042010da:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
  80042010e1:	c6 00 00             	movb   $0x0,(%rax)
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  80042010e4:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042010eb:	0f b6 00             	movzbl (%rax),%eax
  80042010ee:	84 c0                	test   %al,%al
  80042010f0:	74 2a                	je     800420111c <runcmd+0x80>
  80042010f2:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042010f9:	0f b6 00             	movzbl (%rax),%eax
  80042010fc:	0f be c0             	movsbl %al,%eax
  80042010ff:	89 c6                	mov    %eax,%esi
  8004201101:	48 bf 62 20 21 04 80 	movabs $0x8004212062,%rdi
  8004201108:	00 00 00 
  800420110b:	48 b8 23 ba 20 04 80 	movabs $0x800420ba23,%rax
  8004201112:	00 00 00 
  8004201115:	ff d0                	callq  *%rax
  8004201117:	48 85 c0             	test   %rax,%rax
  800420111a:	75 b3                	jne    80042010cf <runcmd+0x33>
			*buf++ = 0;
		if (*buf == 0)
  800420111c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201123:	0f b6 00             	movzbl (%rax),%eax
  8004201126:	84 c0                	test   %al,%al
  8004201128:	75 21                	jne    800420114b <runcmd+0xaf>
			break;
  800420112a:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  800420112b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420112e:	48 98                	cltq   
  8004201130:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004201137:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  800420113c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201140:	0f 85 a1 00 00 00    	jne    80042011e7 <runcmd+0x14b>
  8004201146:	e9 92 00 00 00       	jmpq   80042011dd <runcmd+0x141>
			*buf++ = 0;
		if (*buf == 0)
			break;

		// save and scan past next arg
		if (argc == MAXARGS-1) {
  800420114b:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  800420114f:	75 2a                	jne    800420117b <runcmd+0xdf>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  8004201151:	be 10 00 00 00       	mov    $0x10,%esi
  8004201156:	48 bf 67 20 21 04 80 	movabs $0x8004212067,%rdi
  800420115d:	00 00 00 
  8004201160:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201165:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  800420116c:	00 00 00 
  800420116f:	ff d2                	callq  *%rdx
			return 0;
  8004201171:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201176:	e9 30 01 00 00       	jmpq   80042012ab <runcmd+0x20f>
		}
		argv[argc++] = buf;
  800420117b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420117e:	8d 50 01             	lea    0x1(%rax),%edx
  8004201181:	89 55 fc             	mov    %edx,-0x4(%rbp)
  8004201184:	48 98                	cltq   
  8004201186:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  800420118d:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  8004201194:	ff 
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201195:	eb 08                	jmp    800420119f <runcmd+0x103>
			buf++;
  8004201197:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  800420119e:	01 
		if (argc == MAXARGS-1) {
			cprintf("Too many arguments (max %d)\n", MAXARGS);
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
  800420119f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042011a6:	0f b6 00             	movzbl (%rax),%eax
  80042011a9:	84 c0                	test   %al,%al
  80042011ab:	74 2a                	je     80042011d7 <runcmd+0x13b>
  80042011ad:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042011b4:	0f b6 00             	movzbl (%rax),%eax
  80042011b7:	0f be c0             	movsbl %al,%eax
  80042011ba:	89 c6                	mov    %eax,%esi
  80042011bc:	48 bf 62 20 21 04 80 	movabs $0x8004212062,%rdi
  80042011c3:	00 00 00 
  80042011c6:	48 b8 23 ba 20 04 80 	movabs $0x800420ba23,%rax
  80042011cd:	00 00 00 
  80042011d0:	ff d0                	callq  *%rax
  80042011d2:	48 85 c0             	test   %rax,%rax
  80042011d5:	74 c0                	je     8004201197 <runcmd+0xfb>
			buf++;
	}
  80042011d7:	90                   	nop
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  80042011d8:	e9 07 ff ff ff       	jmpq   80042010e4 <runcmd+0x48>
	}
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
  80042011dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042011e2:	e9 c4 00 00 00       	jmpq   80042012ab <runcmd+0x20f>
	for (i = 0; i < NCOMMANDS; i++) {
  80042011e7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  80042011ee:	e9 82 00 00 00       	jmpq   8004201275 <runcmd+0x1d9>
		if (strcmp(argv[0], commands[i].name) == 0)
  80042011f3:	48 b9 80 65 22 04 80 	movabs $0x8004226580,%rcx
  80042011fa:	00 00 00 
  80042011fd:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201200:	48 63 d0             	movslq %eax,%rdx
  8004201203:	48 89 d0             	mov    %rdx,%rax
  8004201206:	48 01 c0             	add    %rax,%rax
  8004201209:	48 01 d0             	add    %rdx,%rax
  800420120c:	48 c1 e0 03          	shl    $0x3,%rax
  8004201210:	48 01 c8             	add    %rcx,%rax
  8004201213:	48 8b 10             	mov    (%rax),%rdx
  8004201216:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420121d:	48 89 d6             	mov    %rdx,%rsi
  8004201220:	48 89 c7             	mov    %rax,%rdi
  8004201223:	48 b8 5f b9 20 04 80 	movabs $0x800420b95f,%rax
  800420122a:	00 00 00 
  800420122d:	ff d0                	callq  *%rax
  800420122f:	85 c0                	test   %eax,%eax
  8004201231:	75 3e                	jne    8004201271 <runcmd+0x1d5>
			return commands[i].func(argc, argv, tf);
  8004201233:	48 b9 80 65 22 04 80 	movabs $0x8004226580,%rcx
  800420123a:	00 00 00 
  800420123d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201240:	48 63 d0             	movslq %eax,%rdx
  8004201243:	48 89 d0             	mov    %rdx,%rax
  8004201246:	48 01 c0             	add    %rax,%rax
  8004201249:	48 01 d0             	add    %rdx,%rax
  800420124c:	48 c1 e0 03          	shl    $0x3,%rax
  8004201250:	48 01 c8             	add    %rcx,%rax
  8004201253:	48 83 c0 10          	add    $0x10,%rax
  8004201257:	48 8b 00             	mov    (%rax),%rax
  800420125a:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004201261:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
  8004201268:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800420126b:	89 cf                	mov    %ecx,%edi
  800420126d:	ff d0                	callq  *%rax
  800420126f:	eb 3a                	jmp    80042012ab <runcmd+0x20f>
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
	for (i = 0; i < NCOMMANDS; i++) {
  8004201271:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004201275:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201278:	83 f8 01             	cmp    $0x1,%eax
  800420127b:	0f 86 72 ff ff ff    	jbe    80042011f3 <runcmd+0x157>
		if (strcmp(argv[0], commands[i].name) == 0)
			return commands[i].func(argc, argv, tf);
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  8004201281:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201288:	48 89 c6             	mov    %rax,%rsi
  800420128b:	48 bf 84 20 21 04 80 	movabs $0x8004212084,%rdi
  8004201292:	00 00 00 
  8004201295:	b8 00 00 00 00       	mov    $0x0,%eax
  800420129a:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  80042012a1:	00 00 00 
  80042012a4:	ff d2                	callq  *%rdx
	return 0;
  80042012a6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042012ab:	c9                   	leaveq 
  80042012ac:	c3                   	retq   

00000080042012ad <monitor>:

void
monitor(struct Trapframe *tf)
{
  80042012ad:	55                   	push   %rbp
  80042012ae:	48 89 e5             	mov    %rsp,%rbp
  80042012b1:	48 83 ec 20          	sub    $0x20,%rsp
  80042012b5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  80042012b9:	48 bf a0 20 21 04 80 	movabs $0x80042120a0,%rdi
  80042012c0:	00 00 00 
  80042012c3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042012c8:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  80042012cf:	00 00 00 
  80042012d2:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  80042012d4:	48 bf c8 20 21 04 80 	movabs $0x80042120c8,%rdi
  80042012db:	00 00 00 
  80042012de:	b8 00 00 00 00       	mov    $0x0,%eax
  80042012e3:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  80042012ea:	00 00 00 
  80042012ed:	ff d2                	callq  *%rdx

	if (tf != NULL)
  80042012ef:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042012f4:	74 13                	je     8004201309 <monitor+0x5c>
		print_trapframe(tf);
  80042012f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042012fa:	48 89 c7             	mov    %rax,%rdi
  80042012fd:	48 b8 10 94 20 04 80 	movabs $0x8004209410,%rax
  8004201304:	00 00 00 
  8004201307:	ff d0                	callq  *%rax

	while (1) {
		buf = readline("K> ");
  8004201309:	48 bf ed 20 21 04 80 	movabs $0x80042120ed,%rdi
  8004201310:	00 00 00 
  8004201313:	48 b8 42 b6 20 04 80 	movabs $0x800420b642,%rax
  800420131a:	00 00 00 
  800420131d:	ff d0                	callq  *%rax
  800420131f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  8004201323:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201328:	74 20                	je     800420134a <monitor+0x9d>
			if (runcmd(buf, tf) < 0)
  800420132a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420132e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201332:	48 89 d6             	mov    %rdx,%rsi
  8004201335:	48 89 c7             	mov    %rax,%rdi
  8004201338:	48 b8 9c 10 20 04 80 	movabs $0x800420109c,%rax
  800420133f:	00 00 00 
  8004201342:	ff d0                	callq  *%rax
  8004201344:	85 c0                	test   %eax,%eax
  8004201346:	79 02                	jns    800420134a <monitor+0x9d>
				break;
  8004201348:	eb 02                	jmp    800420134c <monitor+0x9f>
	}
  800420134a:	eb bd                	jmp    8004201309 <monitor+0x5c>
}
  800420134c:	c9                   	leaveq 
  800420134d:	c3                   	retq   

000000800420134e <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  800420134e:	55                   	push   %rbp
  800420134f:	48 89 e5             	mov    %rsp,%rbp
  8004201352:	48 83 ec 08          	sub    $0x8,%rsp
  8004201356:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  800420135a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420135e:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  8004201365:	00 00 00 
  8004201368:	48 8b 00             	mov    (%rax),%rax
  800420136b:	48 29 c2             	sub    %rax,%rdx
  800420136e:	48 89 d0             	mov    %rdx,%rax
  8004201371:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004201375:	c9                   	leaveq 
  8004201376:	c3                   	retq   

0000008004201377 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004201377:	55                   	push   %rbp
  8004201378:	48 89 e5             	mov    %rsp,%rbp
  800420137b:	48 83 ec 08          	sub    $0x8,%rsp
  800420137f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004201383:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201387:	48 89 c7             	mov    %rax,%rdi
  800420138a:	48 b8 4e 13 20 04 80 	movabs $0x800420134e,%rax
  8004201391:	00 00 00 
  8004201394:	ff d0                	callq  *%rax
  8004201396:	48 c1 e0 0c          	shl    $0xc,%rax
}
  800420139a:	c9                   	leaveq 
  800420139b:	c3                   	retq   

000000800420139c <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  800420139c:	55                   	push   %rbp
  800420139d:	48 89 e5             	mov    %rsp,%rbp
  80042013a0:	48 83 ec 10          	sub    $0x10,%rsp
  80042013a4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  80042013a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042013ac:	48 c1 e8 0c          	shr    $0xc,%rax
  80042013b0:	48 89 c2             	mov    %rax,%rdx
  80042013b3:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  80042013ba:	00 00 00 
  80042013bd:	48 8b 00             	mov    (%rax),%rax
  80042013c0:	48 39 c2             	cmp    %rax,%rdx
  80042013c3:	72 2a                	jb     80042013ef <pa2page+0x53>
		panic("pa2page called with invalid pa");
  80042013c5:	48 ba f8 20 21 04 80 	movabs $0x80042120f8,%rdx
  80042013cc:	00 00 00 
  80042013cf:	be 52 00 00 00       	mov    $0x52,%esi
  80042013d4:	48 bf 17 21 21 04 80 	movabs $0x8004212117,%rdi
  80042013db:	00 00 00 
  80042013de:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013e3:	48 b9 50 01 20 04 80 	movabs $0x8004200150,%rcx
  80042013ea:	00 00 00 
  80042013ed:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  80042013ef:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  80042013f6:	00 00 00 
  80042013f9:	48 8b 00             	mov    (%rax),%rax
  80042013fc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201400:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004201404:	48 c1 e2 04          	shl    $0x4,%rdx
  8004201408:	48 01 d0             	add    %rdx,%rax
}
  800420140b:	c9                   	leaveq 
  800420140c:	c3                   	retq   

000000800420140d <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  800420140d:	55                   	push   %rbp
  800420140e:	48 89 e5             	mov    %rsp,%rbp
  8004201411:	48 83 ec 20          	sub    $0x20,%rsp
  8004201415:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004201419:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420141d:	48 89 c7             	mov    %rax,%rdi
  8004201420:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  8004201427:	00 00 00 
  800420142a:	ff d0                	callq  *%rax
  800420142c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004201430:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201434:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201438:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800420143b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420143e:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004201445:	00 00 00 
  8004201448:	48 8b 00             	mov    (%rax),%rax
  800420144b:	48 39 c2             	cmp    %rax,%rdx
  800420144e:	72 32                	jb     8004201482 <page2kva+0x75>
  8004201450:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201454:	48 89 c1             	mov    %rax,%rcx
  8004201457:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  800420145e:	00 00 00 
  8004201461:	be 59 00 00 00       	mov    $0x59,%esi
  8004201466:	48 bf 17 21 21 04 80 	movabs $0x8004212117,%rdi
  800420146d:	00 00 00 
  8004201470:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201475:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420147c:	00 00 00 
  800420147f:	41 ff d0             	callq  *%r8
  8004201482:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004201489:	00 00 00 
  800420148c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201490:	48 01 d0             	add    %rdx,%rax
}
  8004201493:	c9                   	leaveq 
  8004201494:	c3                   	retq   

0000008004201495 <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

static __inline uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  8004201495:	55                   	push   %rbp
  8004201496:	48 89 e5             	mov    %rsp,%rbp
  8004201499:	48 83 ec 08          	sub    $0x8,%rsp
  800420149d:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80042014a0:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  80042014a3:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  80042014a7:	74 06                	je     80042014af <restrictive_type+0x1a>
  80042014a9:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  80042014ad:	75 07                	jne    80042014b6 <restrictive_type+0x21>
    return MB_TYPE_BAD;
  80042014af:	b8 05 00 00 00       	mov    $0x5,%eax
  80042014b4:	eb 3e                	jmp    80042014f4 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  80042014b6:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  80042014ba:	74 06                	je     80042014c2 <restrictive_type+0x2d>
  80042014bc:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  80042014c0:	75 07                	jne    80042014c9 <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  80042014c2:	b8 04 00 00 00       	mov    $0x4,%eax
  80042014c7:	eb 2b                	jmp    80042014f4 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  80042014c9:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  80042014cd:	74 06                	je     80042014d5 <restrictive_type+0x40>
  80042014cf:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  80042014d3:	75 07                	jne    80042014dc <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  80042014d5:	b8 02 00 00 00       	mov    $0x2,%eax
  80042014da:	eb 18                	jmp    80042014f4 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  80042014dc:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  80042014e0:	74 06                	je     80042014e8 <restrictive_type+0x53>
  80042014e2:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  80042014e6:	75 07                	jne    80042014ef <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  80042014e8:	b8 03 00 00 00       	mov    $0x3,%eax
  80042014ed:	eb 05                	jmp    80042014f4 <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  80042014ef:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80042014f4:	c9                   	leaveq 
  80042014f5:	c3                   	retq   

00000080042014f6 <nvram_read>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
  80042014f6:	55                   	push   %rbp
  80042014f7:	48 89 e5             	mov    %rsp,%rbp
  80042014fa:	53                   	push   %rbx
  80042014fb:	48 83 ec 18          	sub    $0x18,%rsp
  80042014ff:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  8004201502:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201505:	89 c7                	mov    %eax,%edi
  8004201507:	48 b8 3d 7a 20 04 80 	movabs $0x8004207a3d,%rax
  800420150e:	00 00 00 
  8004201511:	ff d0                	callq  *%rax
  8004201513:	89 c3                	mov    %eax,%ebx
  8004201515:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201518:	83 c0 01             	add    $0x1,%eax
  800420151b:	89 c7                	mov    %eax,%edi
  800420151d:	48 b8 3d 7a 20 04 80 	movabs $0x8004207a3d,%rax
  8004201524:	00 00 00 
  8004201527:	ff d0                	callq  *%rax
  8004201529:	c1 e0 08             	shl    $0x8,%eax
  800420152c:	09 d8                	or     %ebx,%eax
}
  800420152e:	48 83 c4 18          	add    $0x18,%rsp
  8004201532:	5b                   	pop    %rbx
  8004201533:	5d                   	pop    %rbp
  8004201534:	c3                   	retq   

0000008004201535 <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  8004201535:	55                   	push   %rbp
  8004201536:	48 89 e5             	mov    %rsp,%rbp
  8004201539:	41 54                	push   %r12
  800420153b:	53                   	push   %rbx
  800420153c:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004201543:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  800420154a:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  8004201551:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  8004201558:	48 89 e0             	mov    %rsp,%rax
  800420155b:	49 89 c4             	mov    %rax,%r12
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  800420155e:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201565:	8b 40 30             	mov    0x30(%rax),%eax
  8004201568:	89 c0                	mov    %eax,%eax
  800420156a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  800420156e:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201575:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201578:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  800420157d:	f7 e2                	mul    %edx
  800420157f:	89 d0                	mov    %edx,%eax
  8004201581:	c1 e8 04             	shr    $0x4,%eax
  8004201584:	89 c0                	mov    %eax,%eax
  8004201586:	48 89 c2             	mov    %rax,%rdx
  8004201589:	48 83 ea 01          	sub    $0x1,%rdx
  800420158d:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004201591:	49 89 c0             	mov    %rax,%r8
  8004201594:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420159a:	48 89 c1             	mov    %rax,%rcx
  800420159d:	bb 00 00 00 00       	mov    $0x0,%ebx
  80042015a2:	48 c1 e0 03          	shl    $0x3,%rax
  80042015a6:	48 8d 50 07          	lea    0x7(%rax),%rdx
  80042015aa:	b8 10 00 00 00       	mov    $0x10,%eax
  80042015af:	48 83 e8 01          	sub    $0x1,%rax
  80042015b3:	48 01 d0             	add    %rdx,%rax
  80042015b6:	bb 10 00 00 00       	mov    $0x10,%ebx
  80042015bb:	ba 00 00 00 00       	mov    $0x0,%edx
  80042015c0:	48 f7 f3             	div    %rbx
  80042015c3:	48 6b c0 10          	imul   $0x10,%rax,%rax
  80042015c7:	48 29 c4             	sub    %rax,%rsp
  80042015ca:	48 89 e0             	mov    %rsp,%rax
  80042015cd:	48 83 c0 07          	add    $0x7,%rax
  80042015d1:	48 c1 e8 03          	shr    $0x3,%rax
  80042015d5:	48 c1 e0 03          	shl    $0x3,%rax
  80042015d9:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	cprintf("\ne820 MEMORY MAP\n");
  80042015dd:	48 bf 4b 21 21 04 80 	movabs $0x800421214b,%rdi
  80042015e4:	00 00 00 
  80042015e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015ec:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  80042015f3:	00 00 00 
  80042015f6:	ff d2                	callq  *%rdx
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042015f8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042015ff:	e9 6c 01 00 00       	jmpq   8004201770 <multiboot_read+0x23b>
		memory_map_t* mmap = &mmap_base[i];
  8004201604:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201607:	48 63 d0             	movslq %eax,%rdx
  800420160a:	48 89 d0             	mov    %rdx,%rax
  800420160d:	48 01 c0             	add    %rax,%rax
  8004201610:	48 01 d0             	add    %rdx,%rax
  8004201613:	48 c1 e0 03          	shl    $0x3,%rax
  8004201617:	48 89 c2             	mov    %rax,%rdx
  800420161a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420161e:	48 01 d0             	add    %rdx,%rax
  8004201621:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

		uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  8004201625:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201629:	8b 40 08             	mov    0x8(%rax),%eax
  800420162c:	89 c0                	mov    %eax,%eax
  800420162e:	48 c1 e0 20          	shl    $0x20,%rax
  8004201632:	48 89 c2             	mov    %rax,%rdx
  8004201635:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201639:	8b 40 04             	mov    0x4(%rax),%eax
  800420163c:	89 c0                	mov    %eax,%eax
  800420163e:	48 01 d0             	add    %rdx,%rax
  8004201641:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201645:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201649:	8b 40 10             	mov    0x10(%rax),%eax
  800420164c:	89 c0                	mov    %eax,%eax
  800420164e:	48 c1 e0 20          	shl    $0x20,%rax
  8004201652:	48 89 c2             	mov    %rax,%rdx
  8004201655:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201659:	8b 40 0c             	mov    0xc(%rax),%eax
  800420165c:	89 c0                	mov    %eax,%eax
  800420165e:	48 01 d0             	add    %rdx,%rax
  8004201661:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        
		cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size, 
  8004201665:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201669:	8b 70 14             	mov    0x14(%rax),%esi
  800420166c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201670:	8b 00                	mov    (%rax),%eax
  8004201672:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004201676:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420167a:	41 89 f0             	mov    %esi,%r8d
  800420167d:	89 c6                	mov    %eax,%esi
  800420167f:	48 bf 60 21 21 04 80 	movabs $0x8004212160,%rdi
  8004201686:	00 00 00 
  8004201689:	b8 00 00 00 00       	mov    $0x0,%eax
  800420168e:	49 b9 46 7b 20 04 80 	movabs $0x8004207b46,%r9
  8004201695:	00 00 00 
  8004201698:	41 ff d1             	callq  *%r9
			addr, len, mmap->type);

		if(mmap->type > 5 || mmap->type < 1)
  800420169b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420169f:	8b 40 14             	mov    0x14(%rax),%eax
  80042016a2:	83 f8 05             	cmp    $0x5,%eax
  80042016a5:	77 0b                	ja     80042016b2 <multiboot_read+0x17d>
  80042016a7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042016ab:	8b 40 14             	mov    0x14(%rax),%eax
  80042016ae:	85 c0                	test   %eax,%eax
  80042016b0:	75 0b                	jne    80042016bd <multiboot_read+0x188>
			mmap->type = MB_TYPE_RESERVED;
  80042016b2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042016b6:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)
       
		//Insert into the sorted list
		int j = 0;
  80042016bd:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
		for(;j<i;j++) {
  80042016c4:	e9 85 00 00 00       	jmpq   800420174e <multiboot_read+0x219>
			memory_map_t* this = mmap_list[j];
  80042016c9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042016cd:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042016d0:	48 63 d2             	movslq %edx,%rdx
  80042016d3:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80042016d7:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  80042016db:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042016df:	8b 40 08             	mov    0x8(%rax),%eax
  80042016e2:	89 c0                	mov    %eax,%eax
  80042016e4:	48 c1 e0 20          	shl    $0x20,%rax
  80042016e8:	48 89 c2             	mov    %rax,%rdx
  80042016eb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042016ef:	8b 40 04             	mov    0x4(%rax),%eax
  80042016f2:	89 c0                	mov    %eax,%eax
  80042016f4:	48 01 d0             	add    %rdx,%rax
  80042016f7:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			if(this_addr > addr) {
  80042016fb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042016ff:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004201703:	76 45                	jbe    800420174a <multiboot_read+0x215>
				int last = i+1;
  8004201705:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201708:	83 c0 01             	add    $0x1,%eax
  800420170b:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				while(last != j) {
  800420170e:	eb 30                	jmp    8004201740 <multiboot_read+0x20b>
					*(mmap_list + last) = *(mmap_list + last - 1);
  8004201710:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201714:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004201717:	48 63 d2             	movslq %edx,%rdx
  800420171a:	48 c1 e2 03          	shl    $0x3,%rdx
  800420171e:	48 01 c2             	add    %rax,%rdx
  8004201721:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201725:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004201728:	48 63 c9             	movslq %ecx,%rcx
  800420172b:	48 c1 e1 03          	shl    $0x3,%rcx
  800420172f:	48 83 e9 08          	sub    $0x8,%rcx
  8004201733:	48 01 c8             	add    %rcx,%rax
  8004201736:	48 8b 00             	mov    (%rax),%rax
  8004201739:	48 89 02             	mov    %rax,(%rdx)
					last--;
  800420173c:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
		for(;j<i;j++) {
			memory_map_t* this = mmap_list[j];
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
			if(this_addr > addr) {
				int last = i+1;
				while(last != j) {
  8004201740:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004201743:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004201746:	75 c8                	jne    8004201710 <multiboot_read+0x1db>
					*(mmap_list + last) = *(mmap_list + last - 1);
					last--;
				}
				break; 
  8004201748:	eb 10                	jmp    800420175a <multiboot_read+0x225>
		if(mmap->type > 5 || mmap->type < 1)
			mmap->type = MB_TYPE_RESERVED;
       
		//Insert into the sorted list
		int j = 0;
		for(;j<i;j++) {
  800420174a:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  800420174e:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004201751:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004201754:	0f 8c 6f ff ff ff    	jl     80042016c9 <multiboot_read+0x194>
					last--;
				}
				break; 
			}
		}
		mmap_list[j] = mmap;  
  800420175a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420175e:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201761:	48 63 d2             	movslq %edx,%rdx
  8004201764:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004201768:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];

	cprintf("\ne820 MEMORY MAP\n");
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  800420176c:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201770:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201773:	48 63 c8             	movslq %eax,%rcx
  8004201776:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420177d:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201780:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201785:	f7 e2                	mul    %edx
  8004201787:	89 d0                	mov    %edx,%eax
  8004201789:	c1 e8 04             	shr    $0x4,%eax
  800420178c:	89 c0                	mov    %eax,%eax
  800420178e:	48 39 c1             	cmp    %rax,%rcx
  8004201791:	0f 82 6d fe ff ff    	jb     8004201604 <multiboot_read+0xcf>
				break; 
			}
		}
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
  8004201797:	48 bf 97 21 21 04 80 	movabs $0x8004212197,%rdi
  800420179e:	00 00 00 
  80042017a1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017a6:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  80042017ad:	00 00 00 
  80042017b0:	ff d2                	callq  *%rdx
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042017b2:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  80042017b9:	e9 93 01 00 00       	jmpq   8004201951 <multiboot_read+0x41c>
		memory_map_t* prev = mmap_list[i-1];
  80042017be:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042017c1:	8d 50 ff             	lea    -0x1(%rax),%edx
  80042017c4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042017c8:	48 63 d2             	movslq %edx,%rdx
  80042017cb:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80042017cf:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  80042017d3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042017d7:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042017da:	48 63 d2             	movslq %edx,%rdx
  80042017dd:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80042017e1:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  80042017e5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042017e9:	8b 40 08             	mov    0x8(%rax),%eax
  80042017ec:	89 c0                	mov    %eax,%eax
  80042017ee:	48 c1 e0 20          	shl    $0x20,%rax
  80042017f2:	48 89 c2             	mov    %rax,%rdx
  80042017f5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042017f9:	8b 40 04             	mov    0x4(%rax),%eax
  80042017fc:	89 c0                	mov    %eax,%eax
  80042017fe:	48 01 d0             	add    %rdx,%rax
  8004201801:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  8004201805:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201809:	8b 40 08             	mov    0x8(%rax),%eax
  800420180c:	89 c0                	mov    %eax,%eax
  800420180e:	48 c1 e0 20          	shl    $0x20,%rax
  8004201812:	48 89 c2             	mov    %rax,%rdx
  8004201815:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201819:	8b 40 04             	mov    0x4(%rax),%eax
  800420181c:	89 c0                	mov    %eax,%eax
  800420181e:	48 01 d0             	add    %rdx,%rax
  8004201821:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  8004201825:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201829:	8b 40 10             	mov    0x10(%rax),%eax
  800420182c:	89 c0                	mov    %eax,%eax
  800420182e:	48 c1 e0 20          	shl    $0x20,%rax
  8004201832:	48 89 c2             	mov    %rax,%rdx
  8004201835:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201839:	8b 40 0c             	mov    0xc(%rax),%eax
  800420183c:	89 c0                	mov    %eax,%eax
  800420183e:	48 01 d0             	add    %rdx,%rax
  8004201841:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  8004201848:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420184c:	8b 40 10             	mov    0x10(%rax),%eax
  800420184f:	89 c0                	mov    %eax,%eax
  8004201851:	48 c1 e0 20          	shl    $0x20,%rax
  8004201855:	48 89 c2             	mov    %rax,%rdx
  8004201858:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420185c:	8b 40 0c             	mov    0xc(%rax),%eax
  800420185f:	89 c0                	mov    %eax,%eax
  8004201861:	48 01 d0             	add    %rdx,%rax
  8004201864:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if(prev_addr + prev_length == this_addr && prev->type == this->type) {
  800420186b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201872:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004201876:	48 01 d0             	add    %rdx,%rax
  8004201879:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  800420187d:	75 7c                	jne    80042018fb <multiboot_read+0x3c6>
  800420187f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201883:	8b 50 14             	mov    0x14(%rax),%edx
  8004201886:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420188a:	8b 40 14             	mov    0x14(%rax),%eax
  800420188d:	39 c2                	cmp    %eax,%edx
  800420188f:	75 6a                	jne    80042018fb <multiboot_read+0x3c6>
			this->length_low = (uint32_t)prev_length + this_length;
  8004201891:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201898:	89 c2                	mov    %eax,%edx
  800420189a:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042018a1:	01 c2                	add    %eax,%edx
  80042018a3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042018a7:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  80042018aa:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042018b1:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  80042018b8:	48 01 d0             	add    %rdx,%rax
  80042018bb:	48 c1 e8 20          	shr    $0x20,%rax
  80042018bf:	89 c2                	mov    %eax,%edx
  80042018c1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042018c5:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  80042018c8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042018cc:	8b 50 04             	mov    0x4(%rax),%edx
  80042018cf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042018d3:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  80042018d6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042018da:	8b 50 08             	mov    0x8(%rax),%edx
  80042018dd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042018e1:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  80042018e4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042018e7:	8d 50 ff             	lea    -0x1(%rax),%edx
  80042018ea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042018ee:	48 63 d2             	movslq %edx,%rdx
  80042018f1:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  80042018f8:	00 
  80042018f9:	eb 52                	jmp    800420194d <multiboot_read+0x418>
		} else if(prev_addr + prev_length > this_addr) {
  80042018fb:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201902:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004201906:	48 01 d0             	add    %rdx,%rax
  8004201909:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  800420190d:	76 3e                	jbe    800420194d <multiboot_read+0x418>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  800420190f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201913:	8b 50 14             	mov    0x14(%rax),%edx
  8004201916:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420191a:	8b 40 14             	mov    0x14(%rax),%eax
  800420191d:	89 d6                	mov    %edx,%esi
  800420191f:	89 c7                	mov    %eax,%edi
  8004201921:	48 b8 95 14 20 04 80 	movabs $0x8004201495,%rax
  8004201928:	00 00 00 
  800420192b:	ff d0                	callq  *%rax
  800420192d:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  8004201933:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201937:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  800420193d:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  8004201940:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201944:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  800420194a:	89 50 14             	mov    %edx,0x14(%rax)
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  800420194d:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201951:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201954:	48 63 c8             	movslq %eax,%rcx
  8004201957:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420195e:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201961:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201966:	f7 e2                	mul    %edx
  8004201968:	89 d0                	mov    %edx,%eax
  800420196a:	c1 e8 04             	shr    $0x4,%eax
  800420196d:	89 c0                	mov    %eax,%eax
  800420196f:	48 39 c1             	cmp    %rax,%rcx
  8004201972:	0f 82 46 fe ff ff    	jb     80042017be <multiboot_read+0x289>
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201978:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  800420197f:	e9 dc 00 00 00       	jmpq   8004201a60 <multiboot_read+0x52b>
		memory_map_t* mmap = mmap_list[i];
  8004201984:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201988:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420198b:	48 63 d2             	movslq %edx,%rdx
  800420198e:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201992:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if(mmap) {
  8004201999:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  80042019a0:	00 
  80042019a1:	0f 84 b5 00 00 00    	je     8004201a5c <multiboot_read+0x527>
			if(mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  80042019a7:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042019ae:	8b 40 14             	mov    0x14(%rax),%eax
  80042019b1:	83 f8 01             	cmp    $0x1,%eax
  80042019b4:	74 13                	je     80042019c9 <multiboot_read+0x494>
  80042019b6:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042019bd:	8b 40 14             	mov    0x14(%rax),%eax
  80042019c0:	83 f8 03             	cmp    $0x3,%eax
  80042019c3:	0f 85 93 00 00 00    	jne    8004201a5c <multiboot_read+0x527>
				if(mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  80042019c9:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042019d0:	8b 40 04             	mov    0x4(%rax),%eax
  80042019d3:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  80042019d8:	77 49                	ja     8004201a23 <multiboot_read+0x4ee>
  80042019da:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042019e1:	8b 40 08             	mov    0x8(%rax),%eax
  80042019e4:	85 c0                	test   %eax,%eax
  80042019e6:	75 3b                	jne    8004201a23 <multiboot_read+0x4ee>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  80042019e8:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042019ef:	48 8b 10             	mov    (%rax),%rdx
  80042019f2:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042019f9:	8b 40 10             	mov    0x10(%rax),%eax
  80042019fc:	89 c0                	mov    %eax,%eax
  80042019fe:	48 c1 e0 20          	shl    $0x20,%rax
  8004201a02:	48 89 c1             	mov    %rax,%rcx
  8004201a05:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201a0c:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201a0f:	89 c0                	mov    %eax,%eax
  8004201a11:	48 01 c8             	add    %rcx,%rax
  8004201a14:	48 01 c2             	add    %rax,%rdx
  8004201a17:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004201a1e:	48 89 10             	mov    %rdx,(%rax)
  8004201a21:	eb 39                	jmp    8004201a5c <multiboot_read+0x527>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201a23:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004201a2a:	48 8b 10             	mov    (%rax),%rdx
  8004201a2d:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201a34:	8b 40 10             	mov    0x10(%rax),%eax
  8004201a37:	89 c0                	mov    %eax,%eax
  8004201a39:	48 c1 e0 20          	shl    $0x20,%rax
  8004201a3d:	48 89 c1             	mov    %rax,%rcx
  8004201a40:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201a47:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201a4a:	89 c0                	mov    %eax,%eax
  8004201a4c:	48 01 c8             	add    %rcx,%rax
  8004201a4f:	48 01 c2             	add    %rax,%rdx
  8004201a52:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004201a59:	48 89 10             	mov    %rdx,(%rax)
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201a5c:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201a60:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201a63:	48 63 c8             	movslq %eax,%rcx
  8004201a66:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201a6d:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201a70:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201a75:	f7 e2                	mul    %edx
  8004201a77:	89 d0                	mov    %edx,%eax
  8004201a79:	c1 e8 04             	shr    $0x4,%eax
  8004201a7c:	89 c0                	mov    %eax,%eax
  8004201a7e:	48 39 c1             	cmp    %rax,%rcx
  8004201a81:	0f 82 fd fe ff ff    	jb     8004201984 <multiboot_read+0x44f>
  8004201a87:	4c 89 e4             	mov    %r12,%rsp
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
			}
		}
	}
}
  8004201a8a:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  8004201a8e:	5b                   	pop    %rbx
  8004201a8f:	41 5c                	pop    %r12
  8004201a91:	5d                   	pop    %rbp
  8004201a92:	c3                   	retq   

0000008004201a93 <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  8004201a93:	55                   	push   %rbp
  8004201a94:	48 89 e5             	mov    %rsp,%rbp
  8004201a97:	48 83 ec 50          	sub    $0x50,%rsp
	size_t npages_extmem;
	size_t basemem = 0;
  8004201a9b:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8004201aa2:	00 
	size_t extmem = 0;
  8004201aa3:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004201aaa:	00 

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  8004201aab:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  8004201ab2:	00 00 00 
  8004201ab5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  8004201ab9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201abd:	48 8b 00             	mov    (%rax),%rax
  8004201ac0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if(mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  8004201ac4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201ac9:	74 2d                	je     8004201af8 <i386_detect_memory+0x65>
  8004201acb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201acf:	8b 00                	mov    (%rax),%eax
  8004201ad1:	83 e0 40             	and    $0x40,%eax
  8004201ad4:	85 c0                	test   %eax,%eax
  8004201ad6:	74 20                	je     8004201af8 <i386_detect_memory+0x65>
		multiboot_read(mbinfo, &basemem, &extmem);
  8004201ad8:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  8004201adc:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  8004201ae0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201ae4:	48 89 ce             	mov    %rcx,%rsi
  8004201ae7:	48 89 c7             	mov    %rax,%rdi
  8004201aea:	48 b8 35 15 20 04 80 	movabs $0x8004201535,%rax
  8004201af1:	00 00 00 
  8004201af4:	ff d0                	callq  *%rax
  8004201af6:	eb 34                	jmp    8004201b2c <i386_detect_memory+0x99>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  8004201af8:	bf 15 00 00 00       	mov    $0x15,%edi
  8004201afd:	48 b8 f6 14 20 04 80 	movabs $0x80042014f6,%rax
  8004201b04:	00 00 00 
  8004201b07:	ff d0                	callq  *%rax
  8004201b09:	c1 e0 0a             	shl    $0xa,%eax
  8004201b0c:	48 98                	cltq   
  8004201b0e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  8004201b12:	bf 17 00 00 00       	mov    $0x17,%edi
  8004201b17:	48 b8 f6 14 20 04 80 	movabs $0x80042014f6,%rax
  8004201b1e:	00 00 00 
  8004201b21:	ff d0                	callq  *%rax
  8004201b23:	c1 e0 0a             	shl    $0xa,%eax
  8004201b26:	48 98                	cltq   
  8004201b28:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	}

	assert(basemem);
  8004201b2c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201b30:	48 85 c0             	test   %rax,%rax
  8004201b33:	75 35                	jne    8004201b6a <i386_detect_memory+0xd7>
  8004201b35:	48 b9 99 21 21 04 80 	movabs $0x8004212199,%rcx
  8004201b3c:	00 00 00 
  8004201b3f:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004201b46:	00 00 00 
  8004201b49:	be 86 00 00 00       	mov    $0x86,%esi
  8004201b4e:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004201b55:	00 00 00 
  8004201b58:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b5d:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004201b64:	00 00 00 
  8004201b67:	41 ff d0             	callq  *%r8

	npages_basemem = basemem / PGSIZE;
  8004201b6a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201b6e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201b72:	48 89 c2             	mov    %rax,%rdx
  8004201b75:	48 b8 70 c6 2b 04 80 	movabs $0x80042bc670,%rax
  8004201b7c:	00 00 00 
  8004201b7f:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  8004201b82:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004201b86:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201b8a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	
	if(nvram_read(NVRAM_EXTLO) == 0xffff) {
  8004201b8e:	bf 17 00 00 00       	mov    $0x17,%edi
  8004201b93:	48 b8 f6 14 20 04 80 	movabs $0x80042014f6,%rax
  8004201b9a:	00 00 00 
  8004201b9d:	ff d0                	callq  *%rax
  8004201b9f:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004201ba4:	75 2c                	jne    8004201bd2 <i386_detect_memory+0x13f>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  8004201ba6:	bf 34 00 00 00       	mov    $0x34,%edi
  8004201bab:	48 b8 f6 14 20 04 80 	movabs $0x80042014f6,%rax
  8004201bb2:	00 00 00 
  8004201bb5:	ff d0                	callq  *%rax
  8004201bb7:	c1 e0 10             	shl    $0x10,%eax
  8004201bba:	48 98                	cltq   
  8004201bbc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  8004201bc0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201bc4:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  8004201bca:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201bce:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	
	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  8004201bd2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201bd7:	74 1a                	je     8004201bf3 <i386_detect_memory+0x160>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  8004201bd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201bdd:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  8004201be4:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004201beb:	00 00 00 
  8004201bee:	48 89 10             	mov    %rdx,(%rax)
  8004201bf1:	eb 1a                	jmp    8004201c0d <i386_detect_memory+0x17a>
	else
		npages = npages_basemem;
  8004201bf3:	48 b8 70 c6 2b 04 80 	movabs $0x80042bc670,%rax
  8004201bfa:	00 00 00 
  8004201bfd:	48 8b 10             	mov    (%rax),%rdx
  8004201c00:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004201c07:	00 00 00 
  8004201c0a:	48 89 10             	mov    %rdx,(%rax)

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004201c0d:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004201c14:	00 00 00 
  8004201c17:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  8004201c1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c1e:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004201c22:	48 c1 e8 0a          	shr    $0xa,%rax
  8004201c26:	48 89 c1             	mov    %rax,%rcx
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
  8004201c29:	48 b8 70 c6 2b 04 80 	movabs $0x80042bc670,%rax
  8004201c30:	00 00 00 
  8004201c33:	48 8b 00             	mov    (%rax),%rax
  8004201c36:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004201c3a:	48 c1 e8 0a          	shr    $0xa,%rax
  8004201c3e:	48 89 c2             	mov    %rax,%rdx
		npages * PGSIZE / (1024 * 1024),
  8004201c41:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004201c48:	00 00 00 
  8004201c4b:	48 8b 00             	mov    (%rax),%rax
  8004201c4e:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004201c52:	48 c1 e8 14          	shr    $0x14,%rax
  8004201c56:	49 89 f0             	mov    %rsi,%r8
  8004201c59:	48 89 c6             	mov    %rax,%rsi
  8004201c5c:	48 bf c8 21 21 04 80 	movabs $0x80042121c8,%rdi
  8004201c63:	00 00 00 
  8004201c66:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c6b:	49 b9 46 7b 20 04 80 	movabs $0x8004207b46,%r9
  8004201c72:	00 00 00 
  8004201c75:	41 ff d1             	callq  *%r9
	//JOS 64 pages are limited by the size of both the UPAGES
	//  virtual address space, and the range from KERNBASE to UVPT.
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
  8004201c78:	48 c7 45 d8 00 00 32 	movq   $0x320000,-0x28(%rbp)
  8004201c7f:	00 
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
  8004201c80:	48 c7 45 d0 00 c0 ff 	movq   $0x7ffc000,-0x30(%rbp)
  8004201c87:	07 
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
  8004201c88:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201c8c:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  8004201c90:	48 c1 e8 14          	shr    $0x14,%rax
  8004201c94:	48 89 c1             	mov    %rax,%rcx
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
  8004201c97:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201c9b:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  8004201c9f:	48 c1 e8 14          	shr    $0x14,%rax
  8004201ca3:	48 89 c6             	mov    %rax,%rsi
  8004201ca6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004201caa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201cae:	49 89 c8             	mov    %rcx,%r8
  8004201cb1:	48 89 d1             	mov    %rdx,%rcx
  8004201cb4:	48 89 f2             	mov    %rsi,%rdx
  8004201cb7:	48 89 c6             	mov    %rax,%rsi
  8004201cba:	48 bf 18 22 21 04 80 	movabs $0x8004212218,%rdi
  8004201cc1:	00 00 00 
  8004201cc4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201cc9:	49 b9 46 7b 20 04 80 	movabs $0x8004207b46,%r9
  8004201cd0:	00 00 00 
  8004201cd3:	41 ff d1             	callq  *%r9
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
	uint64_t max_npages = upages_max < kern_mem_max ? upages_max : kern_mem_max;
  8004201cd6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201cda:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  8004201cde:	48 0f 46 45 d0       	cmovbe -0x30(%rbp),%rax
  8004201ce3:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if(npages > max_npages) {
  8004201ce7:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004201cee:	00 00 00 
  8004201cf1:	48 8b 00             	mov    (%rax),%rax
  8004201cf4:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004201cf8:	76 3a                	jbe    8004201d34 <i386_detect_memory+0x2a1>
		npages = max_npages - 1024;
  8004201cfa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201cfe:	48 8d 90 00 fc ff ff 	lea    -0x400(%rax),%rdx
  8004201d05:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004201d0c:	00 00 00 
  8004201d0f:	48 89 10             	mov    %rdx,(%rax)
		cprintf("Using only %uK of the available memory.\n", max_npages);
  8004201d12:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201d16:	48 89 c6             	mov    %rax,%rsi
  8004201d19:	48 bf 80 22 21 04 80 	movabs $0x8004212280,%rdi
  8004201d20:	00 00 00 
  8004201d23:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201d28:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004201d2f:	00 00 00 
  8004201d32:	ff d2                	callq  *%rdx
	}
}
  8004201d34:	c9                   	leaveq 
  8004201d35:	c3                   	retq   

0000008004201d36 <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  8004201d36:	55                   	push   %rbp
  8004201d37:	48 89 e5             	mov    %rsp,%rbp
  8004201d3a:	48 83 ec 40          	sub    $0x40,%rsp
  8004201d3e:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  8004201d41:	48 b8 88 c6 2b 04 80 	movabs $0x80042bc688,%rax
  8004201d48:	00 00 00 
  8004201d4b:	48 8b 00             	mov    (%rax),%rax
  8004201d4e:	48 85 c0             	test   %rax,%rax
  8004201d51:	75 4b                	jne    8004201d9e <boot_alloc+0x68>
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
  8004201d53:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  8004201d5a:	00 
  8004201d5b:	48 b8 e0 eb 2b 04 80 	movabs $0x80042bebe0,%rax
  8004201d62:	00 00 00 
  8004201d65:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  8004201d69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201d6d:	48 01 d0             	add    %rdx,%rax
  8004201d70:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004201d74:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201d78:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201d7d:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004201d81:	48 89 d0             	mov    %rdx,%rax
  8004201d84:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004201d88:	48 29 c2             	sub    %rax,%rdx
  8004201d8b:	48 89 d0             	mov    %rdx,%rax
  8004201d8e:	48 89 c2             	mov    %rax,%rdx
  8004201d91:	48 b8 88 c6 2b 04 80 	movabs $0x80042bc688,%rax
  8004201d98:	00 00 00 
  8004201d9b:	48 89 10             	mov    %rdx,(%rax)
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.


	if((uint64_t)(nextfree + n) > (npages * PGSIZE + KERNBASE))
  8004201d9e:	48 b8 88 c6 2b 04 80 	movabs $0x80042bc688,%rax
  8004201da5:	00 00 00 
  8004201da8:	48 8b 10             	mov    (%rax),%rdx
  8004201dab:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004201dae:	48 01 d0             	add    %rdx,%rax
  8004201db1:	48 89 c2             	mov    %rax,%rdx
  8004201db4:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004201dbb:	00 00 00 
  8004201dbe:	48 8b 00             	mov    (%rax),%rax
  8004201dc1:	48 05 00 40 00 08    	add    $0x8004000,%rax
  8004201dc7:	48 c1 e0 0c          	shl    $0xc,%rax
  8004201dcb:	48 39 c2             	cmp    %rax,%rdx
  8004201dce:	76 2a                	jbe    8004201dfa <boot_alloc+0xc4>
		panic("out of memory in boot_alloc");
  8004201dd0:	48 ba a9 22 21 04 80 	movabs $0x80042122a9,%rdx
  8004201dd7:	00 00 00 
  8004201dda:	be e0 00 00 00       	mov    $0xe0,%esi
  8004201ddf:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004201de6:	00 00 00 
  8004201de9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201dee:	48 b9 50 01 20 04 80 	movabs $0x8004200150,%rcx
  8004201df5:	00 00 00 
  8004201df8:	ff d1                	callq  *%rcx
	result = nextfree;
  8004201dfa:	48 b8 88 c6 2b 04 80 	movabs $0x80042bc688,%rax
  8004201e01:	00 00 00 
  8004201e04:	48 8b 00             	mov    (%rax),%rax
  8004201e07:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if(n != 0)
  8004201e0b:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004201e0f:	74 57                	je     8004201e68 <boot_alloc+0x132>
		nextfree = ROUNDUP(nextfree + n,PGSIZE);
  8004201e11:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8004201e18:	00 
  8004201e19:	48 b8 88 c6 2b 04 80 	movabs $0x80042bc688,%rax
  8004201e20:	00 00 00 
  8004201e23:	48 8b 10             	mov    (%rax),%rdx
  8004201e26:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004201e29:	48 01 d0             	add    %rdx,%rax
  8004201e2c:	48 89 c2             	mov    %rax,%rdx
  8004201e2f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201e33:	48 01 d0             	add    %rdx,%rax
  8004201e36:	48 83 e8 01          	sub    $0x1,%rax
  8004201e3a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004201e3e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201e42:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201e47:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004201e4b:	48 89 d0             	mov    %rdx,%rax
  8004201e4e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004201e52:	48 29 c2             	sub    %rax,%rdx
  8004201e55:	48 89 d0             	mov    %rdx,%rax
  8004201e58:	48 89 c2             	mov    %rax,%rdx
  8004201e5b:	48 b8 88 c6 2b 04 80 	movabs $0x80042bc688,%rax
  8004201e62:	00 00 00 
  8004201e65:	48 89 10             	mov    %rdx,(%rax)
	return result;
  8004201e68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax

}
  8004201e6c:	c9                   	leaveq 
  8004201e6d:	c3                   	retq   

0000008004201e6e <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  8004201e6e:	55                   	push   %rbp
  8004201e6f:	48 89 e5             	mov    %rsp,%rbp
  8004201e72:	48 83 ec 70          	sub    $0x70,%rsp
	pml4e_t* pml4e;
	uint32_t cr0;
	uint64_t n;
	int r;
	struct Env *env;
	i386_detect_memory();
  8004201e76:	48 b8 93 1a 20 04 80 	movabs $0x8004201a93,%rax
  8004201e7d:	00 00 00 
  8004201e80:	ff d0                	callq  *%rax
	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	//panic("x64_vm_init: this function is not finished\n");

	pml4e = boot_alloc(PGSIZE);
  8004201e82:	bf 00 10 00 00       	mov    $0x1000,%edi
  8004201e87:	48 b8 36 1d 20 04 80 	movabs $0x8004201d36,%rax
  8004201e8e:	00 00 00 
  8004201e91:	ff d0                	callq  *%rax
  8004201e93:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  8004201e97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201e9b:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004201ea0:	be 00 00 00 00       	mov    $0x0,%esi
  8004201ea5:	48 89 c7             	mov    %rax,%rdi
  8004201ea8:	48 b8 96 ba 20 04 80 	movabs $0x800420ba96,%rax
  8004201eaf:	00 00 00 
  8004201eb2:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  8004201eb4:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004201ebb:	00 00 00 
  8004201ebe:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201ec2:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  8004201ec5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201ec9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004201ecd:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004201ed4:	00 00 00 
  8004201ed7:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  8004201edb:	77 32                	ja     8004201f0f <x64_vm_init+0xa1>
  8004201edd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201ee1:	48 89 c1             	mov    %rax,%rcx
  8004201ee4:	48 ba c8 22 21 04 80 	movabs $0x80042122c8,%rdx
  8004201eeb:	00 00 00 
  8004201eee:	be 03 01 00 00       	mov    $0x103,%esi
  8004201ef3:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004201efa:	00 00 00 
  8004201efd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201f02:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004201f09:	00 00 00 
  8004201f0c:	41 ff d0             	callq  *%r8
  8004201f0f:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004201f16:	ff ff ff 
  8004201f19:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201f1d:	48 01 c2             	add    %rax,%rdx
  8004201f20:	48 b8 d8 db 2b 04 80 	movabs $0x80042bdbd8,%rax
  8004201f27:	00 00 00 
  8004201f2a:	48 89 10             	mov    %rdx,(%rax)
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:
	pages = (struct PageInfo*)boot_alloc(npages * sizeof(struct PageInfo));
  8004201f2d:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004201f34:	00 00 00 
  8004201f37:	48 8b 00             	mov    (%rax),%rax
  8004201f3a:	c1 e0 04             	shl    $0x4,%eax
  8004201f3d:	89 c7                	mov    %eax,%edi
  8004201f3f:	48 b8 36 1d 20 04 80 	movabs $0x8004201d36,%rax
  8004201f46:	00 00 00 
  8004201f49:	ff d0                	callq  *%rax
  8004201f4b:	48 ba f0 db 2b 04 80 	movabs $0x80042bdbf0,%rdx
  8004201f52:	00 00 00 
  8004201f55:	48 89 02             	mov    %rax,(%rdx)

	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.
	envs = (struct Env*) boot_alloc(NENV * sizeof(struct Env));
  8004201f58:	bf 00 e0 03 00       	mov    $0x3e000,%edi
  8004201f5d:	48 b8 36 1d 20 04 80 	movabs $0x8004201d36,%rax
  8004201f64:	00 00 00 
  8004201f67:	ff d0                	callq  *%rax
  8004201f69:	48 ba 90 c6 2b 04 80 	movabs $0x80042bc690,%rdx
  8004201f70:	00 00 00 
  8004201f73:	48 89 02             	mov    %rax,(%rdx)
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	page_init();
  8004201f76:	48 b8 30 23 20 04 80 	movabs $0x8004202330,%rax
  8004201f7d:	00 00 00 
  8004201f80:	ff d0                	callq  *%rax
	check_page_free_list(1);
  8004201f82:	bf 01 00 00 00       	mov    $0x1,%edi
  8004201f87:	48 b8 06 32 20 04 80 	movabs $0x8004203206,%rax
  8004201f8e:	00 00 00 
  8004201f91:	ff d0                	callq  *%rax
	check_page_alloc();
  8004201f93:	48 b8 e3 36 20 04 80 	movabs $0x80042036e3,%rax
  8004201f9a:	00 00 00 
  8004201f9d:	ff d0                	callq  *%rax
	page_check();
  8004201f9f:	48 b8 31 4a 20 04 80 	movabs $0x8004204a31,%rax
  8004201fa6:	00 00 00 
  8004201fa9:	ff d0                	callq  *%rax
	//    - the new image at UPAGES -- kernel R, us/er R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:

	boot_map_region(pml4e, UPAGES, ROUNDUP(sizeof(struct PageInfo) * npages, PGSIZE), PADDR(pages), PTE_U);
  8004201fab:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  8004201fb2:	00 00 00 
  8004201fb5:	48 8b 00             	mov    (%rax),%rax
  8004201fb8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004201fbc:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004201fc3:	00 00 00 
  8004201fc6:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004201fca:	77 32                	ja     8004201ffe <x64_vm_init+0x190>
  8004201fcc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201fd0:	48 89 c1             	mov    %rax,%rcx
  8004201fd3:	48 ba c8 22 21 04 80 	movabs $0x80042122c8,%rdx
  8004201fda:	00 00 00 
  8004201fdd:	be 27 01 00 00       	mov    $0x127,%esi
  8004201fe2:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004201fe9:	00 00 00 
  8004201fec:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201ff1:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004201ff8:	00 00 00 
  8004201ffb:	41 ff d0             	callq  *%r8
  8004201ffe:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202005:	ff ff ff 
  8004202008:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420200c:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004202010:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8004202017:	00 
  8004202018:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  800420201f:	00 00 00 
  8004202022:	48 8b 00             	mov    (%rax),%rax
  8004202025:	48 c1 e0 04          	shl    $0x4,%rax
  8004202029:	48 89 c2             	mov    %rax,%rdx
  800420202c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202030:	48 01 d0             	add    %rdx,%rax
  8004202033:	48 83 e8 01          	sub    $0x1,%rax
  8004202037:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420203b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420203f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202044:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004202048:	48 89 d0             	mov    %rdx,%rax
  800420204b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420204f:	48 29 c2             	sub    %rax,%rdx
  8004202052:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202056:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  800420205c:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  8004202063:	00 00 00 
  8004202066:	48 89 c7             	mov    %rax,%rdi
  8004202069:	48 b8 77 2d 20 04 80 	movabs $0x8004202d77,%rax
  8004202070:	00 00 00 
  8004202073:	ff d0                	callq  *%rax
	// (ie. perm = PTE_U | PTE_P).
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.
	boot_map_region(pml4e, UENVS, PTSIZE, PADDR(envs), PTE_U);
  8004202075:	48 b8 90 c6 2b 04 80 	movabs $0x80042bc690,%rax
  800420207c:	00 00 00 
  800420207f:	48 8b 00             	mov    (%rax),%rax
  8004202082:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004202086:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420208d:	00 00 00 
  8004202090:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  8004202094:	77 32                	ja     80042020c8 <x64_vm_init+0x25a>
  8004202096:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420209a:	48 89 c1             	mov    %rax,%rcx
  800420209d:	48 ba c8 22 21 04 80 	movabs $0x80042122c8,%rdx
  80042020a4:	00 00 00 
  80042020a7:	be 2f 01 00 00       	mov    $0x12f,%esi
  80042020ac:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042020b3:	00 00 00 
  80042020b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042020bb:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042020c2:	00 00 00 
  80042020c5:	41 ff d0             	callq  *%r8
  80042020c8:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042020cf:	ff ff ff 
  80042020d2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042020d6:	48 01 c2             	add    %rax,%rdx
  80042020d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042020dd:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  80042020e3:	48 89 d1             	mov    %rdx,%rcx
  80042020e6:	ba 00 00 20 00       	mov    $0x200000,%edx
  80042020eb:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  80042020f2:	00 00 00 
  80042020f5:	48 89 c7             	mov    %rax,%rdi
  80042020f8:	48 b8 77 2d 20 04 80 	movabs $0x8004202d77,%rax
  80042020ff:	00 00 00 
  8004202102:	ff d0                	callq  *%rax
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:

	boot_map_region(pml4e, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);
  8004202104:	48 b8 00 60 21 04 80 	movabs $0x8004216000,%rax
  800420210b:	00 00 00 
  800420210e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004202112:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202119:	00 00 00 
  800420211c:	48 39 45 c8          	cmp    %rax,-0x38(%rbp)
  8004202120:	77 32                	ja     8004202154 <x64_vm_init+0x2e6>
  8004202122:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202126:	48 89 c1             	mov    %rax,%rcx
  8004202129:	48 ba c8 22 21 04 80 	movabs $0x80042122c8,%rdx
  8004202130:	00 00 00 
  8004202133:	be 40 01 00 00       	mov    $0x140,%esi
  8004202138:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420213f:	00 00 00 
  8004202142:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202147:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420214e:	00 00 00 
  8004202151:	41 ff d0             	callq  *%r8
  8004202154:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420215b:	ff ff ff 
  800420215e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202162:	48 01 c2             	add    %rax,%rdx
  8004202165:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202169:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  800420216f:	48 89 d1             	mov    %rdx,%rcx
  8004202172:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004202177:	48 be 00 00 ff 03 80 	movabs $0x8003ff0000,%rsi
  800420217e:	00 00 00 
  8004202181:	48 89 c7             	mov    %rax,%rdi
  8004202184:	48 b8 77 2d 20 04 80 	movabs $0x8004202d77,%rax
  800420218b:	00 00 00 
  800420218e:	ff d0                	callq  *%rax
	// Ie.  the VA range [KERNBASE, npages*PGSIZE) should map to
	//      the PA range [0, npages*PGSIZE)
	// Permissions: kernel RW, user NONE
	// Your code goes here: 

	boot_map_region(pml4e, KERNBASE, (npages * PGSIZE), 0x0, PTE_W);
  8004202190:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004202197:	00 00 00 
  800420219a:	48 8b 00             	mov    (%rax),%rax
  800420219d:	48 c1 e0 0c          	shl    $0xc,%rax
  80042021a1:	48 89 c2             	mov    %rax,%rdx
  80042021a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042021a8:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  80042021ae:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042021b3:	48 be 00 00 00 04 80 	movabs $0x8004000000,%rsi
  80042021ba:	00 00 00 
  80042021bd:	48 89 c7             	mov    %rax,%rdi
  80042021c0:	48 b8 77 2d 20 04 80 	movabs $0x8004202d77,%rax
  80042021c7:	00 00 00 
  80042021ca:	ff d0                	callq  *%rax

	// Check that the initial page directory has been set up correctly.
	check_page_free_list(1);
  80042021cc:	bf 01 00 00 00       	mov    $0x1,%edi
  80042021d1:	48 b8 06 32 20 04 80 	movabs $0x8004203206,%rax
  80042021d8:	00 00 00 
  80042021db:	ff d0                	callq  *%rax
	check_page_alloc();
  80042021dd:	48 b8 e3 36 20 04 80 	movabs $0x80042036e3,%rax
  80042021e4:	00 00 00 
  80042021e7:	ff d0                	callq  *%rax
	page_check();
  80042021e9:	48 b8 31 4a 20 04 80 	movabs $0x8004204a31,%rax
  80042021f0:	00 00 00 
  80042021f3:	ff d0                	callq  *%rax
	check_page_free_list(0);
  80042021f5:	bf 00 00 00 00       	mov    $0x0,%edi
  80042021fa:	48 b8 06 32 20 04 80 	movabs $0x8004203206,%rax
  8004202201:	00 00 00 
  8004202204:	ff d0                	callq  *%rax
	check_boot_pml4e(boot_pml4e);
  8004202206:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  800420220d:	00 00 00 
  8004202210:	48 8b 00             	mov    (%rax),%rax
  8004202213:	48 89 c7             	mov    %rax,%rdi
  8004202216:	48 b8 cf 40 20 04 80 	movabs $0x80042040cf,%rax
  800420221d:	00 00 00 
  8004202220:	ff d0                	callq  *%rax

	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE
	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  8004202222:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202226:	48 83 c0 08          	add    $0x8,%rax
  800420222a:	48 8b 00             	mov    (%rax),%rax
  800420222d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202233:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004202237:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420223b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420223f:	89 45 bc             	mov    %eax,-0x44(%rbp)
  8004202242:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004202245:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  800420224c:	00 00 00 
  800420224f:	48 8b 00             	mov    (%rax),%rax
  8004202252:	48 39 c2             	cmp    %rax,%rdx
  8004202255:	72 32                	jb     8004202289 <x64_vm_init+0x41b>
  8004202257:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420225b:	48 89 c1             	mov    %rax,%rcx
  800420225e:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  8004202265:	00 00 00 
  8004202268:	be 55 01 00 00       	mov    $0x155,%esi
  800420226d:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004202274:	00 00 00 
  8004202277:	b8 00 00 00 00       	mov    $0x0,%eax
  800420227c:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004202283:	00 00 00 
  8004202286:	41 ff d0             	callq  *%r8
  8004202289:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202290:	00 00 00 
  8004202293:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202297:	48 01 d0             	add    %rdx,%rax
  800420229a:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  800420229e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042022a2:	48 8b 00             	mov    (%rax),%rax
  80042022a5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042022ab:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  80042022af:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042022b3:	48 c1 e8 0c          	shr    $0xc,%rax
  80042022b7:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  80042022ba:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  80042022bd:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  80042022c4:	00 00 00 
  80042022c7:	48 8b 00             	mov    (%rax),%rax
  80042022ca:	48 39 c2             	cmp    %rax,%rdx
  80042022cd:	72 32                	jb     8004202301 <x64_vm_init+0x493>
  80042022cf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042022d3:	48 89 c1             	mov    %rax,%rcx
  80042022d6:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  80042022dd:	00 00 00 
  80042022e0:	be 56 01 00 00       	mov    $0x156,%esi
  80042022e5:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042022ec:	00 00 00 
  80042022ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80042022f4:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042022fb:	00 00 00 
  80042022fe:	41 ff d0             	callq  *%r8
  8004202301:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202308:	00 00 00 
  800420230b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420230f:	48 01 d0             	add    %rdx,%rax
  8004202312:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	lcr3(boot_cr3);
  8004202316:	48 b8 d8 db 2b 04 80 	movabs $0x80042bdbd8,%rax
  800420231d:	00 00 00 
  8004202320:	48 8b 00             	mov    (%rax),%rax
  8004202323:	48 89 45 90          	mov    %rax,-0x70(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004202327:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420232b:	0f 22 d8             	mov    %rax,%cr3
}
  800420232e:	c9                   	leaveq 
  800420232f:	c3                   	retq   

0000008004202330 <page_init>:
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
  8004202330:	55                   	push   %rbp
  8004202331:	48 89 e5             	mov    %rsp,%rbp
  8004202334:	53                   	push   %rbx
  8004202335:	48 83 ec 28          	sub    $0x28,%rsp
	// free pages!
	// NB: Make sure you preserve the direction in which your page_free_list 
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)
	size_t i;
	struct PageInfo* last = NULL;
  8004202339:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004202340:	00 

	char*  first_free_page = (char *) boot_alloc(0);
  8004202341:	bf 00 00 00 00       	mov    $0x0,%edi
  8004202346:	48 b8 36 1d 20 04 80 	movabs $0x8004201d36,%rax
  800420234d:	00 00 00 
  8004202350:	ff d0                	callq  *%rax
  8004202352:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (i = 0; i < npages; i++) {
  8004202356:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420235d:	00 
  800420235e:	e9 b8 01 00 00       	jmpq   800420251b <page_init+0x1eb>
		if((i == 0) || (&pages[i] >= pa2page((physaddr_t)IOPHYSMEM) && (uintptr_t)page2kva(&pages[i]) < (uintptr_t)first_free_page)
  8004202363:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202368:	0f 84 c0 00 00 00    	je     800420242e <page_init+0xfe>
  800420236e:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  8004202375:	00 00 00 
  8004202378:	48 8b 00             	mov    (%rax),%rax
  800420237b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420237f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202383:	48 8d 1c 10          	lea    (%rax,%rdx,1),%rbx
  8004202387:	bf 00 00 0a 00       	mov    $0xa0000,%edi
  800420238c:	48 b8 9c 13 20 04 80 	movabs $0x800420139c,%rax
  8004202393:	00 00 00 
  8004202396:	ff d0                	callq  *%rax
  8004202398:	48 39 c3             	cmp    %rax,%rbx
  800420239b:	72 33                	jb     80042023d0 <page_init+0xa0>
  800420239d:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  80042023a4:	00 00 00 
  80042023a7:	48 8b 00             	mov    (%rax),%rax
  80042023aa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042023ae:	48 c1 e2 04          	shl    $0x4,%rdx
  80042023b2:	48 01 d0             	add    %rdx,%rax
  80042023b5:	48 89 c7             	mov    %rax,%rdi
  80042023b8:	48 b8 0d 14 20 04 80 	movabs $0x800420140d,%rax
  80042023bf:	00 00 00 
  80042023c2:	ff d0                	callq  *%rax
  80042023c4:	48 89 c2             	mov    %rax,%rdx
  80042023c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042023cb:	48 39 c2             	cmp    %rax,%rdx
  80042023ce:	72 5e                	jb     800420242e <page_init+0xfe>
			|| (&pages[i] >= pa2page((physaddr_t)0x8000) && &pages[i] < pa2page((physaddr_t)0xe000))){
  80042023d0:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  80042023d7:	00 00 00 
  80042023da:	48 8b 00             	mov    (%rax),%rax
  80042023dd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042023e1:	48 c1 e2 04          	shl    $0x4,%rdx
  80042023e5:	48 8d 1c 10          	lea    (%rax,%rdx,1),%rbx
  80042023e9:	bf 00 80 00 00       	mov    $0x8000,%edi
  80042023ee:	48 b8 9c 13 20 04 80 	movabs $0x800420139c,%rax
  80042023f5:	00 00 00 
  80042023f8:	ff d0                	callq  *%rax
  80042023fa:	48 39 c3             	cmp    %rax,%rbx
  80042023fd:	72 71                	jb     8004202470 <page_init+0x140>
  80042023ff:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  8004202406:	00 00 00 
  8004202409:	48 8b 00             	mov    (%rax),%rax
  800420240c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202410:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202414:	48 8d 1c 10          	lea    (%rax,%rdx,1),%rbx
  8004202418:	bf 00 e0 00 00       	mov    $0xe000,%edi
  800420241d:	48 b8 9c 13 20 04 80 	movabs $0x800420139c,%rax
  8004202424:	00 00 00 
  8004202427:	ff d0                	callq  *%rax
  8004202429:	48 39 c3             	cmp    %rax,%rbx
  800420242c:	73 42                	jae    8004202470 <page_init+0x140>

			pages[i].pp_ref = 1;
  800420242e:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  8004202435:	00 00 00 
  8004202438:	48 8b 00             	mov    (%rax),%rax
  800420243b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420243f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202443:	48 01 d0             	add    %rdx,%rax
  8004202446:	66 c7 40 08 01 00    	movw   $0x1,0x8(%rax)
			pages[i].pp_link = NULL;
  800420244c:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  8004202453:	00 00 00 
  8004202456:	48 8b 00             	mov    (%rax),%rax
  8004202459:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420245d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202461:	48 01 d0             	add    %rdx,%rax
  8004202464:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  800420246b:	e9 a6 00 00 00       	jmpq   8004202516 <page_init+0x1e6>
		}
		else
		{
			
			pages[i].pp_ref = 0;
  8004202470:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  8004202477:	00 00 00 
  800420247a:	48 8b 00             	mov    (%rax),%rax
  800420247d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202481:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202485:	48 01 d0             	add    %rdx,%rax
  8004202488:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
			pages[i].pp_link = NULL;
  800420248e:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  8004202495:	00 00 00 
  8004202498:	48 8b 00             	mov    (%rax),%rax
  800420249b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420249f:	48 c1 e2 04          	shl    $0x4,%rdx
  80042024a3:	48 01 d0             	add    %rdx,%rax
  80042024a6:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			if(last)
  80042024ad:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042024b2:	74 21                	je     80042024d5 <page_init+0x1a5>
				last->pp_link = &pages[i];
  80042024b4:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  80042024bb:	00 00 00 
  80042024be:	48 8b 00             	mov    (%rax),%rax
  80042024c1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042024c5:	48 c1 e2 04          	shl    $0x4,%rdx
  80042024c9:	48 01 c2             	add    %rax,%rdx
  80042024cc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042024d0:	48 89 10             	mov    %rdx,(%rax)
  80042024d3:	eb 25                	jmp    80042024fa <page_init+0x1ca>
			else
				page_free_list = &pages[i];
  80042024d5:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  80042024dc:	00 00 00 
  80042024df:	48 8b 00             	mov    (%rax),%rax
  80042024e2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042024e6:	48 c1 e2 04          	shl    $0x4,%rdx
  80042024ea:	48 01 c2             	add    %rax,%rdx
  80042024ed:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  80042024f4:	00 00 00 
  80042024f7:	48 89 10             	mov    %rdx,(%rax)
			
			last = &pages[i];
  80042024fa:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  8004202501:	00 00 00 
  8004202504:	48 8b 00             	mov    (%rax),%rax
  8004202507:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420250b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420250f:	48 01 d0             	add    %rdx,%rax
  8004202512:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)
	size_t i;
	struct PageInfo* last = NULL;

	char*  first_free_page = (char *) boot_alloc(0);
	for (i = 0; i < npages; i++) {
  8004202516:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420251b:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004202522:	00 00 00 
  8004202525:	48 8b 00             	mov    (%rax),%rax
  8004202528:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420252c:	0f 82 31 fe ff ff    	jb     8004202363 <page_init+0x33>
			
			last = &pages[i];
		}

	}
}
  8004202532:	48 83 c4 28          	add    $0x28,%rsp
  8004202536:	5b                   	pop    %rbx
  8004202537:	5d                   	pop    %rbp
  8004202538:	c3                   	retq   

0000008004202539 <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  8004202539:	55                   	push   %rbp
  800420253a:	48 89 e5             	mov    %rsp,%rbp
  800420253d:	48 83 ec 20          	sub    $0x20,%rsp
  8004202541:	89 7d ec             	mov    %edi,-0x14(%rbp)
	// Fill this function in

	struct PageInfo *newPage;
	newPage = page_free_list;
  8004202544:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  800420254b:	00 00 00 
  800420254e:	48 8b 00             	mov    (%rax),%rax
  8004202551:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (newPage == NULL)
  8004202555:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420255a:	75 07                	jne    8004202563 <page_alloc+0x2a>
		return NULL;
  800420255c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202561:	eb 62                	jmp    80042025c5 <page_alloc+0x8c>
	else{
		
		if (alloc_flags & ALLOC_ZERO)
  8004202563:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202566:	83 e0 01             	and    $0x1,%eax
  8004202569:	85 c0                	test   %eax,%eax
  800420256b:	74 2c                	je     8004202599 <page_alloc+0x60>
			memset(page2kva(newPage), 0, PGSIZE);
  800420256d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202571:	48 89 c7             	mov    %rax,%rdi
  8004202574:	48 b8 0d 14 20 04 80 	movabs $0x800420140d,%rax
  800420257b:	00 00 00 
  800420257e:	ff d0                	callq  *%rax
  8004202580:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202585:	be 00 00 00 00       	mov    $0x0,%esi
  800420258a:	48 89 c7             	mov    %rax,%rdi
  800420258d:	48 b8 96 ba 20 04 80 	movabs $0x800420ba96,%rax
  8004202594:	00 00 00 
  8004202597:	ff d0                	callq  *%rax
		
		page_free_list = page_free_list->pp_link;
  8004202599:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  80042025a0:	00 00 00 
  80042025a3:	48 8b 00             	mov    (%rax),%rax
  80042025a6:	48 8b 10             	mov    (%rax),%rdx
  80042025a9:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  80042025b0:	00 00 00 
  80042025b3:	48 89 10             	mov    %rdx,(%rax)
		newPage->pp_link = NULL;
  80042025b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042025ba:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return newPage;
  80042025c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	}

}
  80042025c5:	c9                   	leaveq 
  80042025c6:	c3                   	retq   

00000080042025c7 <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!
//
static void
page_initpp(struct PageInfo *pp)
{
  80042025c7:	55                   	push   %rbp
  80042025c8:	48 89 e5             	mov    %rsp,%rbp
  80042025cb:	48 83 ec 10          	sub    $0x10,%rsp
  80042025cf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	memset(pp, 0, sizeof(*pp));
  80042025d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042025d7:	ba 10 00 00 00       	mov    $0x10,%edx
  80042025dc:	be 00 00 00 00       	mov    $0x0,%esi
  80042025e1:	48 89 c7             	mov    %rax,%rdi
  80042025e4:	48 b8 96 ba 20 04 80 	movabs $0x800420ba96,%rax
  80042025eb:	00 00 00 
  80042025ee:	ff d0                	callq  *%rax
}
  80042025f0:	c9                   	leaveq 
  80042025f1:	c3                   	retq   

00000080042025f2 <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  80042025f2:	55                   	push   %rbp
  80042025f3:	48 89 e5             	mov    %rsp,%rbp
  80042025f6:	48 83 ec 10          	sub    $0x10,%rsp
  80042025fa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.

	if (pp->pp_ref != 0 || pp->pp_link != NULL)
  80042025fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202602:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202606:	66 85 c0             	test   %ax,%ax
  8004202609:	75 0c                	jne    8004202617 <page_free+0x25>
  800420260b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420260f:	48 8b 00             	mov    (%rax),%rax
  8004202612:	48 85 c0             	test   %rax,%rax
  8004202615:	74 2a                	je     8004202641 <page_free+0x4f>
		panic("we have problem");
  8004202617:	48 ba ec 22 21 04 80 	movabs $0x80042122ec,%rdx
  800420261e:	00 00 00 
  8004202621:	be d0 01 00 00       	mov    $0x1d0,%esi
  8004202626:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420262d:	00 00 00 
  8004202630:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202635:	48 b9 50 01 20 04 80 	movabs $0x8004200150,%rcx
  800420263c:	00 00 00 
  800420263f:	ff d1                	callq  *%rcx
	
	pp->pp_link = page_free_list;
  8004202641:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  8004202648:	00 00 00 
  800420264b:	48 8b 10             	mov    (%rax),%rdx
  800420264e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202652:	48 89 10             	mov    %rdx,(%rax)
	page_free_list = pp;
  8004202655:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  800420265c:	00 00 00 
  800420265f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202663:	48 89 10             	mov    %rdx,(%rax)

}
  8004202666:	c9                   	leaveq 
  8004202667:	c3                   	retq   

0000008004202668 <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  8004202668:	55                   	push   %rbp
  8004202669:	48 89 e5             	mov    %rsp,%rbp
  800420266c:	48 83 ec 10          	sub    $0x10,%rsp
  8004202670:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (--pp->pp_ref == 0)
  8004202674:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202678:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420267c:	8d 50 ff             	lea    -0x1(%rax),%edx
  800420267f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202683:	66 89 50 08          	mov    %dx,0x8(%rax)
  8004202687:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420268b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420268f:	66 85 c0             	test   %ax,%ax
  8004202692:	75 13                	jne    80042026a7 <page_decref+0x3f>
		page_free(pp);
  8004202694:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202698:	48 89 c7             	mov    %rax,%rdi
  800420269b:	48 b8 f2 25 20 04 80 	movabs $0x80042025f2,%rax
  80042026a2:	00 00 00 
  80042026a5:	ff d0                	callq  *%rax
}
  80042026a7:	c9                   	leaveq 
  80042026a8:	c3                   	retq   

00000080042026a9 <pml4e_walk>:
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *
pml4e_walk(pml4e_t *pml4e, const void *va, int create)
{
  80042026a9:	55                   	push   %rbp
  80042026aa:	48 89 e5             	mov    %rsp,%rbp
  80042026ad:	53                   	push   %rbx
  80042026ae:	48 83 ec 68          	sub    $0x68,%rsp
  80042026b2:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80042026b6:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  80042026ba:	89 55 9c             	mov    %edx,-0x64(%rbp)

	pte_t *pte = NULL;
  80042026bd:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042026c4:	00 
	pdpe_t *pdpe = NULL;
  80042026c5:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042026cc:	00 
	

	if((pml4e[PML4(va)] & PTE_P))
  80042026cd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042026d1:	48 c1 e8 27          	shr    $0x27,%rax
  80042026d5:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042026da:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042026e1:	00 
  80042026e2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042026e6:	48 01 d0             	add    %rdx,%rax
  80042026e9:	48 8b 00             	mov    (%rax),%rax
  80042026ec:	83 e0 01             	and    $0x1,%eax
  80042026ef:	48 85 c0             	test   %rax,%rax
  80042026f2:	0f 84 ba 00 00 00    	je     80042027b2 <pml4e_walk+0x109>
	{
		
		pdpe = (pdpe_t *) KADDR(PTE_ADDR(pml4e[PML4(va)]));
  80042026f8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042026fc:	48 c1 e8 27          	shr    $0x27,%rax
  8004202700:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202705:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420270c:	00 
  800420270d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202711:	48 01 d0             	add    %rdx,%rax
  8004202714:	48 8b 00             	mov    (%rax),%rax
  8004202717:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420271d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004202721:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202725:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202729:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  800420272c:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420272f:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004202736:	00 00 00 
  8004202739:	48 8b 00             	mov    (%rax),%rax
  800420273c:	48 39 c2             	cmp    %rax,%rdx
  800420273f:	72 32                	jb     8004202773 <pml4e_walk+0xca>
  8004202741:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202745:	48 89 c1             	mov    %rax,%rcx
  8004202748:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  800420274f:	00 00 00 
  8004202752:	be 06 02 00 00       	mov    $0x206,%esi
  8004202757:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420275e:	00 00 00 
  8004202761:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202766:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420276d:	00 00 00 
  8004202770:	41 ff d0             	callq  *%r8
  8004202773:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420277a:	00 00 00 
  800420277d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202781:	48 01 d0             	add    %rdx,%rax
  8004202784:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		pte = pdpe_walk(pdpe, va, create);
  8004202788:	8b 55 9c             	mov    -0x64(%rbp),%edx
  800420278b:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420278f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202793:	48 89 ce             	mov    %rcx,%rsi
  8004202796:	48 89 c7             	mov    %rax,%rdi
  8004202799:	48 b8 f7 28 20 04 80 	movabs $0x80042028f7,%rax
  80042027a0:	00 00 00 
  80042027a3:	ff d0                	callq  *%rax
  80042027a5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		return pte;
  80042027a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042027ad:	e9 3e 01 00 00       	jmpq   80042028f0 <pml4e_walk+0x247>
	}
	else if(create)
  80042027b2:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  80042027b6:	0f 84 2f 01 00 00    	je     80042028eb <pml4e_walk+0x242>
	{
		struct PageInfo* newPDPT = page_alloc(ALLOC_ZERO);
  80042027bc:	bf 01 00 00 00       	mov    $0x1,%edi
  80042027c1:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  80042027c8:	00 00 00 
  80042027cb:	ff d0                	callq  *%rax
  80042027cd:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		if (newPDPT == NULL)
  80042027d1:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042027d6:	75 0a                	jne    80042027e2 <pml4e_walk+0x139>
			return NULL;
  80042027d8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042027dd:	e9 0e 01 00 00       	jmpq   80042028f0 <pml4e_walk+0x247>
		newPDPT->pp_ref++;	
  80042027e2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042027e6:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042027ea:	8d 50 01             	lea    0x1(%rax),%edx
  80042027ed:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042027f1:	66 89 50 08          	mov    %dx,0x8(%rax)

		pml4e[PML4(va)] = (page2pa(newPDPT) & ~0xFFF) | PTE_USER;
  80042027f5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042027f9:	48 c1 e8 27          	shr    $0x27,%rax
  80042027fd:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202802:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202809:	00 
  800420280a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420280e:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004202812:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202816:	48 89 c7             	mov    %rax,%rdi
  8004202819:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  8004202820:	00 00 00 
  8004202823:	ff d0                	callq  *%rax
  8004202825:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420282b:	48 0d 07 0e 00 00    	or     $0xe07,%rax
  8004202831:	48 89 03             	mov    %rax,(%rbx)
		pdpe = (pdpe_t *) KADDR(PTE_ADDR(pml4e[PML4(va)]));
  8004202834:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202838:	48 c1 e8 27          	shr    $0x27,%rax
  800420283c:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202841:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202848:	00 
  8004202849:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420284d:	48 01 d0             	add    %rdx,%rax
  8004202850:	48 8b 00             	mov    (%rax),%rax
  8004202853:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202859:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800420285d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202861:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202865:	89 45 bc             	mov    %eax,-0x44(%rbp)
  8004202868:	8b 55 bc             	mov    -0x44(%rbp),%edx
  800420286b:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004202872:	00 00 00 
  8004202875:	48 8b 00             	mov    (%rax),%rax
  8004202878:	48 39 c2             	cmp    %rax,%rdx
  800420287b:	72 32                	jb     80042028af <pml4e_walk+0x206>
  800420287d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202881:	48 89 c1             	mov    %rax,%rcx
  8004202884:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  800420288b:	00 00 00 
  800420288e:	be 12 02 00 00       	mov    $0x212,%esi
  8004202893:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420289a:	00 00 00 
  800420289d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042028a2:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042028a9:	00 00 00 
  80042028ac:	41 ff d0             	callq  *%r8
  80042028af:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042028b6:	00 00 00 
  80042028b9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042028bd:	48 01 d0             	add    %rdx,%rax
  80042028c0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		pte = pdpe_walk(pdpe, va, create);
  80042028c4:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042028c7:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042028cb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042028cf:	48 89 ce             	mov    %rcx,%rsi
  80042028d2:	48 89 c7             	mov    %rax,%rdi
  80042028d5:	48 b8 f7 28 20 04 80 	movabs $0x80042028f7,%rax
  80042028dc:	00 00 00 
  80042028df:	ff d0                	callq  *%rax
  80042028e1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		
		return pte;
  80042028e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042028e9:	eb 05                	jmp    80042028f0 <pml4e_walk+0x247>
	}
	else
		return NULL;
  80042028eb:	b8 00 00 00 00       	mov    $0x0,%eax

}
  80042028f0:	48 83 c4 68          	add    $0x68,%rsp
  80042028f4:	5b                   	pop    %rbx
  80042028f5:	5d                   	pop    %rbp
  80042028f6:	c3                   	retq   

00000080042028f7 <pdpe_walk>:
// Given a pdpe i.e page directory pointer pdpe_walk returns the pointer to page table entry
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create){
  80042028f7:	55                   	push   %rbp
  80042028f8:	48 89 e5             	mov    %rsp,%rbp
  80042028fb:	53                   	push   %rbx
  80042028fc:	48 83 ec 68          	sub    $0x68,%rsp
  8004202900:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004202904:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8004202908:	89 55 9c             	mov    %edx,-0x64(%rbp)


	pte_t *pte = NULL;
  800420290b:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004202912:	00 
	pde_t *pde = NULL;
  8004202913:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420291a:	00 
	
	
	if((pdpe[PDPE(va)] & PTE_P))
  800420291b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420291f:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004202923:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202928:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420292f:	00 
  8004202930:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202934:	48 01 d0             	add    %rdx,%rax
  8004202937:	48 8b 00             	mov    (%rax),%rax
  800420293a:	83 e0 01             	and    $0x1,%eax
  800420293d:	48 85 c0             	test   %rax,%rax
  8004202940:	0f 84 ba 00 00 00    	je     8004202a00 <pdpe_walk+0x109>
	{
		pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004202946:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420294a:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420294e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202953:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420295a:	00 
  800420295b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420295f:	48 01 d0             	add    %rdx,%rax
  8004202962:	48 8b 00             	mov    (%rax),%rax
  8004202965:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420296b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420296f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202973:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202977:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  800420297a:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420297d:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004202984:	00 00 00 
  8004202987:	48 8b 00             	mov    (%rax),%rax
  800420298a:	48 39 c2             	cmp    %rax,%rdx
  800420298d:	72 32                	jb     80042029c1 <pdpe_walk+0xca>
  800420298f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202993:	48 89 c1             	mov    %rax,%rcx
  8004202996:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  800420299d:	00 00 00 
  80042029a0:	be 2b 02 00 00       	mov    $0x22b,%esi
  80042029a5:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042029ac:	00 00 00 
  80042029af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042029b4:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042029bb:	00 00 00 
  80042029be:	41 ff d0             	callq  *%r8
  80042029c1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042029c8:	00 00 00 
  80042029cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042029cf:	48 01 d0             	add    %rdx,%rax
  80042029d2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		pte = pgdir_walk(pde, va, create);
  80042029d6:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042029d9:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042029dd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042029e1:	48 89 ce             	mov    %rcx,%rsi
  80042029e4:	48 89 c7             	mov    %rax,%rdi
  80042029e7:	48 b8 45 2b 20 04 80 	movabs $0x8004202b45,%rax
  80042029ee:	00 00 00 
  80042029f1:	ff d0                	callq  *%rax
  80042029f3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		return pte;
  80042029f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042029fb:	e9 3e 01 00 00       	jmpq   8004202b3e <pdpe_walk+0x247>
	}
	else if(create)
  8004202a00:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  8004202a04:	0f 84 2f 01 00 00    	je     8004202b39 <pdpe_walk+0x242>
	{
		struct PageInfo* newPDT = page_alloc(ALLOC_ZERO);
  8004202a0a:	bf 01 00 00 00       	mov    $0x1,%edi
  8004202a0f:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  8004202a16:	00 00 00 
  8004202a19:	ff d0                	callq  *%rax
  8004202a1b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		if (newPDT == NULL)
  8004202a1f:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004202a24:	75 0a                	jne    8004202a30 <pdpe_walk+0x139>
			return NULL;
  8004202a26:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202a2b:	e9 0e 01 00 00       	jmpq   8004202b3e <pdpe_walk+0x247>
		newPDT->pp_ref++;	
  8004202a30:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202a34:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202a38:	8d 50 01             	lea    0x1(%rax),%edx
  8004202a3b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202a3f:	66 89 50 08          	mov    %dx,0x8(%rax)
		
		pdpe[PDPE(va)] = (page2pa(newPDT) & ~0xFFF) | PTE_USER;
  8004202a43:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202a47:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004202a4b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202a50:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202a57:	00 
  8004202a58:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202a5c:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004202a60:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202a64:	48 89 c7             	mov    %rax,%rdi
  8004202a67:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  8004202a6e:	00 00 00 
  8004202a71:	ff d0                	callq  *%rax
  8004202a73:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202a79:	48 0d 07 0e 00 00    	or     $0xe07,%rax
  8004202a7f:	48 89 03             	mov    %rax,(%rbx)
		pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004202a82:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202a86:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004202a8a:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202a8f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202a96:	00 
  8004202a97:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202a9b:	48 01 d0             	add    %rdx,%rax
  8004202a9e:	48 8b 00             	mov    (%rax),%rax
  8004202aa1:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202aa7:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004202aab:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202aaf:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202ab3:	89 45 bc             	mov    %eax,-0x44(%rbp)
  8004202ab6:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004202ab9:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004202ac0:	00 00 00 
  8004202ac3:	48 8b 00             	mov    (%rax),%rax
  8004202ac6:	48 39 c2             	cmp    %rax,%rdx
  8004202ac9:	72 32                	jb     8004202afd <pdpe_walk+0x206>
  8004202acb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202acf:	48 89 c1             	mov    %rax,%rcx
  8004202ad2:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  8004202ad9:	00 00 00 
  8004202adc:	be 37 02 00 00       	mov    $0x237,%esi
  8004202ae1:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004202ae8:	00 00 00 
  8004202aeb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202af0:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004202af7:	00 00 00 
  8004202afa:	41 ff d0             	callq  *%r8
  8004202afd:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202b04:	00 00 00 
  8004202b07:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202b0b:	48 01 d0             	add    %rdx,%rax
  8004202b0e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		
		pte = pgdir_walk(pde, va, create);
  8004202b12:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004202b15:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004202b19:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202b1d:	48 89 ce             	mov    %rcx,%rsi
  8004202b20:	48 89 c7             	mov    %rax,%rdi
  8004202b23:	48 b8 45 2b 20 04 80 	movabs $0x8004202b45,%rax
  8004202b2a:	00 00 00 
  8004202b2d:	ff d0                	callq  *%rax
  8004202b2f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		
		return pte;
  8004202b33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202b37:	eb 05                	jmp    8004202b3e <pdpe_walk+0x247>
	}
	else
		return NULL;
  8004202b39:	b8 00 00 00 00       	mov    $0x0,%eax

}
  8004202b3e:	48 83 c4 68          	add    $0x68,%rsp
  8004202b42:	5b                   	pop    %rbx
  8004202b43:	5d                   	pop    %rbp
  8004202b44:	c3                   	retq   

0000008004202b45 <pgdir_walk>:
// The logic here is slightly different, in that it needs to look
// not just at the page directory, but also get the last-level page table entry.

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
  8004202b45:	55                   	push   %rbp
  8004202b46:	48 89 e5             	mov    %rsp,%rbp
  8004202b49:	53                   	push   %rbx
  8004202b4a:	48 83 ec 58          	sub    $0x58,%rsp
  8004202b4e:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004202b52:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004202b56:	89 55 ac             	mov    %edx,-0x54(%rbp)
	// Fill this function in

	pte_t *pte = NULL;
  8004202b59:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004202b60:	00 
	
	
	if((pgdir[PDX(va)] & PTE_P))
  8004202b61:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202b65:	48 c1 e8 15          	shr    $0x15,%rax
  8004202b69:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202b6e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202b75:	00 
  8004202b76:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202b7a:	48 01 d0             	add    %rdx,%rax
  8004202b7d:	48 8b 00             	mov    (%rax),%rax
  8004202b80:	83 e0 01             	and    $0x1,%eax
  8004202b83:	48 85 c0             	test   %rax,%rax
  8004202b86:	0f 84 b0 00 00 00    	je     8004202c3c <pgdir_walk+0xf7>
	{
		pte = (pte_t*)KADDR((PTE_ADDR(pgdir[PDX(va)]) & ~0xFFF) + PTX(va)*8);
  8004202b8c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202b90:	48 c1 e8 15          	shr    $0x15,%rax
  8004202b94:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202b99:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202ba0:	00 
  8004202ba1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202ba5:	48 01 d0             	add    %rdx,%rax
  8004202ba8:	48 8b 00             	mov    (%rax),%rax
  8004202bab:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202bb1:	48 89 c2             	mov    %rax,%rdx
  8004202bb4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202bb8:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202bbc:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202bc1:	48 c1 e0 03          	shl    $0x3,%rax
  8004202bc5:	48 01 d0             	add    %rdx,%rax
  8004202bc8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004202bcc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202bd0:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202bd4:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004202bd7:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004202bda:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004202be1:	00 00 00 
  8004202be4:	48 8b 00             	mov    (%rax),%rax
  8004202be7:	48 39 c2             	cmp    %rax,%rdx
  8004202bea:	72 32                	jb     8004202c1e <pgdir_walk+0xd9>
  8004202bec:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202bf0:	48 89 c1             	mov    %rax,%rcx
  8004202bf3:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  8004202bfa:	00 00 00 
  8004202bfd:	be 53 02 00 00       	mov    $0x253,%esi
  8004202c02:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004202c09:	00 00 00 
  8004202c0c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202c11:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004202c18:	00 00 00 
  8004202c1b:	41 ff d0             	callq  *%r8
  8004202c1e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202c25:	00 00 00 
  8004202c28:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202c2c:	48 01 d0             	add    %rdx,%rax
  8004202c2f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		return pte;
  8004202c33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202c37:	e9 34 01 00 00       	jmpq   8004202d70 <pgdir_walk+0x22b>
	}
	else if(create)
  8004202c3c:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004202c40:	0f 84 25 01 00 00    	je     8004202d6b <pgdir_walk+0x226>
	{
		struct PageInfo* newPT = page_alloc(ALLOC_ZERO);
  8004202c46:	bf 01 00 00 00       	mov    $0x1,%edi
  8004202c4b:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  8004202c52:	00 00 00 
  8004202c55:	ff d0                	callq  *%rax
  8004202c57:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if (newPT == NULL)
  8004202c5b:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004202c60:	75 0a                	jne    8004202c6c <pgdir_walk+0x127>
			return NULL;
  8004202c62:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202c67:	e9 04 01 00 00       	jmpq   8004202d70 <pgdir_walk+0x22b>
		newPT->pp_ref++;	
  8004202c6c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202c70:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202c74:	8d 50 01             	lea    0x1(%rax),%edx
  8004202c77:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202c7b:	66 89 50 08          	mov    %dx,0x8(%rax)
		
		pgdir[PDX(va)] = (page2pa(newPT) & ~0xFFF) | PTE_USER;
  8004202c7f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202c83:	48 c1 e8 15          	shr    $0x15,%rax
  8004202c87:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202c8c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202c93:	00 
  8004202c94:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202c98:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004202c9c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202ca0:	48 89 c7             	mov    %rax,%rdi
  8004202ca3:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  8004202caa:	00 00 00 
  8004202cad:	ff d0                	callq  *%rax
  8004202caf:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202cb5:	48 0d 07 0e 00 00    	or     $0xe07,%rax
  8004202cbb:	48 89 03             	mov    %rax,(%rbx)
		pte = (pte_t*)KADDR((PTE_ADDR(pgdir[PDX(va)]) & ~0xFFF) + PTX(va)*8);
  8004202cbe:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202cc2:	48 c1 e8 15          	shr    $0x15,%rax
  8004202cc6:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202ccb:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202cd2:	00 
  8004202cd3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202cd7:	48 01 d0             	add    %rdx,%rax
  8004202cda:	48 8b 00             	mov    (%rax),%rax
  8004202cdd:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202ce3:	48 89 c2             	mov    %rax,%rdx
  8004202ce6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202cea:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202cee:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202cf3:	48 c1 e0 03          	shl    $0x3,%rax
  8004202cf7:	48 01 d0             	add    %rdx,%rax
  8004202cfa:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004202cfe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202d02:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202d06:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004202d09:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004202d0c:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004202d13:	00 00 00 
  8004202d16:	48 8b 00             	mov    (%rax),%rax
  8004202d19:	48 39 c2             	cmp    %rax,%rdx
  8004202d1c:	72 32                	jb     8004202d50 <pgdir_walk+0x20b>
  8004202d1e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202d22:	48 89 c1             	mov    %rax,%rcx
  8004202d25:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  8004202d2c:	00 00 00 
  8004202d2f:	be 5e 02 00 00       	mov    $0x25e,%esi
  8004202d34:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004202d3b:	00 00 00 
  8004202d3e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202d43:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004202d4a:	00 00 00 
  8004202d4d:	41 ff d0             	callq  *%r8
  8004202d50:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202d57:	00 00 00 
  8004202d5a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202d5e:	48 01 d0             	add    %rdx,%rax
  8004202d61:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		return pte;
  8004202d65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202d69:	eb 05                	jmp    8004202d70 <pgdir_walk+0x22b>
	}
	else
		return NULL;
  8004202d6b:	b8 00 00 00 00       	mov    $0x0,%eax

}
  8004202d70:	48 83 c4 58          	add    $0x58,%rsp
  8004202d74:	5b                   	pop    %rbx
  8004202d75:	5d                   	pop    %rbp
  8004202d76:	c3                   	retq   

0000008004202d77 <boot_map_region>:
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  8004202d77:	55                   	push   %rbp
  8004202d78:	48 89 e5             	mov    %rsp,%rbp
  8004202d7b:	48 83 ec 60          	sub    $0x60,%rsp
  8004202d7f:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004202d83:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004202d87:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004202d8b:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004202d8f:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
	// Fill this function in

	uintptr_t top = ROUNDUP(la + size, PGSIZE);
  8004202d93:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004202d9a:	00 
  8004202d9b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202d9f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004202da3:	48 01 c2             	add    %rax,%rdx
  8004202da6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202daa:	48 01 d0             	add    %rdx,%rax
  8004202dad:	48 83 e8 01          	sub    $0x1,%rax
  8004202db1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004202db5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202db9:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202dbe:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004202dc2:	48 89 d0             	mov    %rdx,%rax
  8004202dc5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004202dc9:	48 29 c2             	sub    %rax,%rdx
  8004202dcc:	48 89 d0             	mov    %rdx,%rax
  8004202dcf:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	char *vaTemp, *paTemp;
	for(vaTemp = (char*)la, paTemp = (char*)pa; (uintptr_t)vaTemp < top; vaTemp+=PGSIZE, paTemp+=PGSIZE)
  8004202dd3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202dd7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004202ddb:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202ddf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202de3:	eb 4e                	jmp    8004202e33 <boot_map_region+0xbc>
	{
		pte_t *pte = pml4e_walk(pml4e, (char*)vaTemp, 1);
  8004202de5:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004202de9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202ded:	ba 01 00 00 00       	mov    $0x1,%edx
  8004202df2:	48 89 ce             	mov    %rcx,%rsi
  8004202df5:	48 89 c7             	mov    %rax,%rdi
  8004202df8:	48 b8 a9 26 20 04 80 	movabs $0x80042026a9,%rax
  8004202dff:	00 00 00 
  8004202e02:	ff d0                	callq  *%rax
  8004202e04:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		*pte = (uintptr_t)paTemp | perm | PTE_P;
  8004202e08:	8b 45 ac             	mov    -0x54(%rbp),%eax
  8004202e0b:	48 63 d0             	movslq %eax,%rdx
  8004202e0e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202e12:	48 09 d0             	or     %rdx,%rax
  8004202e15:	48 83 c8 01          	or     $0x1,%rax
  8004202e19:	48 89 c2             	mov    %rax,%rdx
  8004202e1c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202e20:	48 89 10             	mov    %rdx,(%rax)
{
	// Fill this function in

	uintptr_t top = ROUNDUP(la + size, PGSIZE);
	char *vaTemp, *paTemp;
	for(vaTemp = (char*)la, paTemp = (char*)pa; (uintptr_t)vaTemp < top; vaTemp+=PGSIZE, paTemp+=PGSIZE)
  8004202e23:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004202e2a:	00 
  8004202e2b:	48 81 45 f0 00 10 00 	addq   $0x1000,-0x10(%rbp)
  8004202e32:	00 
  8004202e33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202e37:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004202e3b:	72 a8                	jb     8004202de5 <boot_map_region+0x6e>
	{
		pte_t *pte = pml4e_walk(pml4e, (char*)vaTemp, 1);
		*pte = (uintptr_t)paTemp | perm | PTE_P;
	}
}
  8004202e3d:	c9                   	leaveq 
  8004202e3e:	c3                   	retq   

0000008004202e3f <page_insert>:
// Hint: The TA solution is implemented using pml4e_walk, page_remove,
// and page2pa.
//
int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  8004202e3f:	55                   	push   %rbp
  8004202e40:	48 89 e5             	mov    %rsp,%rbp
  8004202e43:	48 83 ec 30          	sub    $0x30,%rsp
  8004202e47:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004202e4b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004202e4f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004202e53:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
	// Fill this function in

	pte_t *pte = pml4e_walk(pml4e, va, 1);
  8004202e56:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004202e5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202e5e:	ba 01 00 00 00       	mov    $0x1,%edx
  8004202e63:	48 89 ce             	mov    %rcx,%rsi
  8004202e66:	48 89 c7             	mov    %rax,%rdi
  8004202e69:	48 b8 a9 26 20 04 80 	movabs $0x80042026a9,%rax
  8004202e70:	00 00 00 
  8004202e73:	ff d0                	callq  *%rax
  8004202e75:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (pte == NULL)
  8004202e79:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202e7e:	75 07                	jne    8004202e87 <page_insert+0x48>
		return -E_NO_MEM;
  8004202e80:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004202e85:	eb 6f                	jmp    8004202ef6 <page_insert+0xb7>
	if (*pte & PTE_P)
  8004202e87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202e8b:	48 8b 00             	mov    (%rax),%rax
  8004202e8e:	83 e0 01             	and    $0x1,%eax
  8004202e91:	48 85 c0             	test   %rax,%rax
  8004202e94:	74 1a                	je     8004202eb0 <page_insert+0x71>
		page_remove(pml4e, va);
  8004202e96:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004202e9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202e9e:	48 89 d6             	mov    %rdx,%rsi
  8004202ea1:	48 89 c7             	mov    %rax,%rdi
  8004202ea4:	48 b8 8c 2f 20 04 80 	movabs $0x8004202f8c,%rax
  8004202eab:	00 00 00 
  8004202eae:	ff d0                	callq  *%rax
	
	pp->pp_ref++;
  8004202eb0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202eb4:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202eb8:	8d 50 01             	lea    0x1(%rax),%edx
  8004202ebb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202ebf:	66 89 50 08          	mov    %dx,0x8(%rax)
	*pte = (page2pa(pp) & ~0xFFF) | (perm|PTE_P);
  8004202ec3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202ec7:	48 89 c7             	mov    %rax,%rdi
  8004202eca:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  8004202ed1:	00 00 00 
  8004202ed4:	ff d0                	callq  *%rax
  8004202ed6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202edc:	48 89 c2             	mov    %rax,%rdx
  8004202edf:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004202ee2:	83 c8 01             	or     $0x1,%eax
  8004202ee5:	48 98                	cltq   
  8004202ee7:	48 09 c2             	or     %rax,%rdx
  8004202eea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202eee:	48 89 10             	mov    %rdx,(%rax)
	
	

	return 0;
  8004202ef1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004202ef6:	c9                   	leaveq 
  8004202ef7:	c3                   	retq   

0000008004202ef8 <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  8004202ef8:	55                   	push   %rbp
  8004202ef9:	48 89 e5             	mov    %rsp,%rbp
  8004202efc:	48 83 ec 40          	sub    $0x40,%rsp
  8004202f00:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004202f04:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004202f08:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	// Fill this function in

	struct PageInfo *result;
	pte_t *pte = pml4e_walk(pml4e, va, 0);
  8004202f0c:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8004202f10:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202f14:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202f19:	48 89 ce             	mov    %rcx,%rsi
  8004202f1c:	48 89 c7             	mov    %rax,%rdi
  8004202f1f:	48 b8 a9 26 20 04 80 	movabs $0x80042026a9,%rax
  8004202f26:	00 00 00 
  8004202f29:	ff d0                	callq  *%rax
  8004202f2b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(pte == NULL) 
  8004202f2f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202f34:	75 07                	jne    8004202f3d <page_lookup+0x45>
		return NULL;
  8004202f36:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202f3b:	eb 4d                	jmp    8004202f8a <page_lookup+0x92>
	
	physaddr_t pa = (physaddr_t)((*pte & ~0xFFF) + PGOFF(va));
  8004202f3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202f41:	48 8b 00             	mov    (%rax),%rax
  8004202f44:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202f4a:	48 89 c2             	mov    %rax,%rdx
  8004202f4d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202f51:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004202f56:	48 01 d0             	add    %rdx,%rax
  8004202f59:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	result = pa2page(pa);
  8004202f5d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202f61:	48 89 c7             	mov    %rax,%rdi
  8004202f64:	48 b8 9c 13 20 04 80 	movabs $0x800420139c,%rax
  8004202f6b:	00 00 00 
  8004202f6e:	ff d0                	callq  *%rax
  8004202f70:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if(pte_store != NULL)
  8004202f74:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004202f79:	74 0b                	je     8004202f86 <page_lookup+0x8e>
		*pte_store = pte;
  8004202f7b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202f7f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202f83:	48 89 10             	mov    %rdx,(%rax)
	return result;
  8004202f86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax

}
  8004202f8a:	c9                   	leaveq 
  8004202f8b:	c3                   	retq   

0000008004202f8c <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  8004202f8c:	55                   	push   %rbp
  8004202f8d:	48 89 e5             	mov    %rsp,%rbp
  8004202f90:	48 83 ec 20          	sub    $0x20,%rsp
  8004202f94:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004202f98:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Fill this function in

	struct PageInfo *PageRemove = page_lookup(pml4e, va, 0);
  8004202f9c:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004202fa0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202fa4:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202fa9:	48 89 ce             	mov    %rcx,%rsi
  8004202fac:	48 89 c7             	mov    %rax,%rdi
  8004202faf:	48 b8 f8 2e 20 04 80 	movabs $0x8004202ef8,%rax
  8004202fb6:	00 00 00 
  8004202fb9:	ff d0                	callq  *%rax
  8004202fbb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(PageRemove != NULL)
  8004202fbf:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202fc4:	74 62                	je     8004203028 <page_remove+0x9c>
	{
		page_decref(PageRemove);
  8004202fc6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202fca:	48 89 c7             	mov    %rax,%rdi
  8004202fcd:	48 b8 68 26 20 04 80 	movabs $0x8004202668,%rax
  8004202fd4:	00 00 00 
  8004202fd7:	ff d0                	callq  *%rax
		pte_t *pte = pml4e_walk(pml4e, va, 0);
  8004202fd9:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004202fdd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202fe1:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202fe6:	48 89 ce             	mov    %rcx,%rsi
  8004202fe9:	48 89 c7             	mov    %rax,%rdi
  8004202fec:	48 b8 a9 26 20 04 80 	movabs $0x80042026a9,%rax
  8004202ff3:	00 00 00 
  8004202ff6:	ff d0                	callq  *%rax
  8004202ff8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if (pte != NULL)
  8004202ffc:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004203001:	74 0b                	je     800420300e <page_remove+0x82>
			*pte = 0;
  8004203003:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203007:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		tlb_invalidate(pml4e, va);
  800420300e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203012:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203016:	48 89 d6             	mov    %rdx,%rsi
  8004203019:	48 89 c7             	mov    %rax,%rdi
  800420301c:	48 b8 2a 30 20 04 80 	movabs $0x800420302a,%rax
  8004203023:	00 00 00 
  8004203026:	ff d0                	callq  *%rax
	}

}
  8004203028:	c9                   	leaveq 
  8004203029:	c3                   	retq   

000000800420302a <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  800420302a:	55                   	push   %rbp
  800420302b:	48 89 e5             	mov    %rsp,%rbp
  800420302e:	48 83 ec 20          	sub    $0x20,%rsp
  8004203032:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203036:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420303a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420303e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void 
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  8004203042:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203046:	0f 01 38             	invlpg (%rax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(va);
}
  8004203049:	c9                   	leaveq 
  800420304a:	c3                   	retq   

000000800420304b <user_mem_check>:
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  800420304b:	55                   	push   %rbp
  800420304c:	48 89 e5             	mov    %rsp,%rbp
  800420304f:	48 83 ec 50          	sub    $0x50,%rsp
  8004203053:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004203057:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420305b:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420305f:	89 4d b4             	mov    %ecx,-0x4c(%rbp)
	// LAB 3: Your code here.
	uintptr_t vaCurrent = (uintptr_t)ROUNDDOWN(va, PGSIZE);
  8004203062:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203066:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420306a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420306e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203074:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	uintptr_t vaLast = (uintptr_t)ROUNDUP(va + len, PGSIZE);
  8004203078:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  800420307f:	00 
  8004203080:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203084:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004203088:	48 01 d0             	add    %rdx,%rax
  800420308b:	48 89 c2             	mov    %rax,%rdx
  800420308e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203092:	48 01 d0             	add    %rdx,%rax
  8004203095:	48 83 e8 01          	sub    $0x1,%rax
  8004203099:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420309d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042030a1:	ba 00 00 00 00       	mov    $0x0,%edx
  80042030a6:	48 f7 75 e8          	divq   -0x18(%rbp)
  80042030aa:	48 89 d0             	mov    %rdx,%rax
  80042030ad:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042030b1:	48 29 c2             	sub    %rax,%rdx
  80042030b4:	48 89 d0             	mov    %rdx,%rax
  80042030b7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	
	perm = perm | PTE_P;
  80042030bb:	83 4d b4 01          	orl    $0x1,-0x4c(%rbp)
	pte_t* pte = NULL;
  80042030bf:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  80042030c6:	00 
	
	for( ;vaCurrent < vaLast; vaCurrent += PGSIZE) {
  80042030c7:	e9 9e 00 00 00       	jmpq   800420316a <user_mem_check+0x11f>
		if(vaCurrent < PGSIZE)
  80042030cc:	48 81 7d f8 ff 0f 00 	cmpq   $0xfff,-0x8(%rbp)
  80042030d3:	00 
  80042030d4:	77 13                	ja     80042030e9 <user_mem_check+0x9e>
			user_mem_check_addr = (uintptr_t) va;
  80042030d6:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042030da:	48 b8 80 c6 2b 04 80 	movabs $0x80042bc680,%rax
  80042030e1:	00 00 00 
  80042030e4:	48 89 10             	mov    %rdx,(%rax)
  80042030e7:	eb 11                	jmp    80042030fa <user_mem_check+0xaf>
		else
			user_mem_check_addr = vaCurrent;
  80042030e9:	48 b8 80 c6 2b 04 80 	movabs $0x80042bc680,%rax
  80042030f0:	00 00 00 
  80042030f3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042030f7:	48 89 10             	mov    %rdx,(%rax)
		
		if(vaCurrent >= ULIM) {
  80042030fa:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004203101:	00 00 00 
  8004203104:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004203108:	76 07                	jbe    8004203111 <user_mem_check+0xc6>
			return -E_FAULT;
  800420310a:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  800420310f:	eb 6c                	jmp    800420317d <user_mem_check+0x132>
		}else {
			pte = pml4e_walk(env->env_pml4e, (void*)vaCurrent, 0);
  8004203111:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004203115:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203119:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004203120:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203125:	48 89 ce             	mov    %rcx,%rsi
  8004203128:	48 89 c7             	mov    %rax,%rdi
  800420312b:	48 b8 a9 26 20 04 80 	movabs $0x80042026a9,%rax
  8004203132:	00 00 00 
  8004203135:	ff d0                	callq  *%rax
  8004203137:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

			if(!pte || (*pte & perm) != perm)
  800420313b:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004203140:	74 19                	je     800420315b <user_mem_check+0x110>
  8004203142:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203146:	48 8b 10             	mov    (%rax),%rdx
  8004203149:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420314c:	48 98                	cltq   
  800420314e:	48 21 c2             	and    %rax,%rdx
  8004203151:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004203154:	48 98                	cltq   
  8004203156:	48 39 c2             	cmp    %rax,%rdx
  8004203159:	74 07                	je     8004203162 <user_mem_check+0x117>
				return -E_FAULT;
  800420315b:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8004203160:	eb 1b                	jmp    800420317d <user_mem_check+0x132>

	
	perm = perm | PTE_P;
	pte_t* pte = NULL;
	
	for( ;vaCurrent < vaLast; vaCurrent += PGSIZE) {
  8004203162:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004203169:	00 
  800420316a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420316e:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004203172:	0f 82 54 ff ff ff    	jb     80042030cc <user_mem_check+0x81>
			if(!pte || (*pte & perm) != perm)
				return -E_FAULT;
		}
	}

	return 0;
  8004203178:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420317d:	c9                   	leaveq 
  800420317e:	c3                   	retq   

000000800420317f <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  800420317f:	55                   	push   %rbp
  8004203180:	48 89 e5             	mov    %rsp,%rbp
  8004203183:	48 83 ec 20          	sub    $0x20,%rsp
  8004203187:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420318b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420318f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004203193:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  8004203196:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203199:	83 c8 04             	or     $0x4,%eax
  800420319c:	89 c1                	mov    %eax,%ecx
  800420319e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042031a2:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042031a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042031aa:	48 89 c7             	mov    %rax,%rdi
  80042031ad:	48 b8 4b 30 20 04 80 	movabs $0x800420304b,%rax
  80042031b4:	00 00 00 
  80042031b7:	ff d0                	callq  *%rax
  80042031b9:	85 c0                	test   %eax,%eax
  80042031bb:	79 47                	jns    8004203204 <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  80042031bd:	48 b8 80 c6 2b 04 80 	movabs $0x80042bc680,%rax
  80042031c4:	00 00 00 
  80042031c7:	48 8b 10             	mov    (%rax),%rdx
  80042031ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042031ce:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042031d4:	89 c6                	mov    %eax,%esi
  80042031d6:	48 bf 00 23 21 04 80 	movabs $0x8004212300,%rdi
  80042031dd:	00 00 00 
  80042031e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042031e5:	48 b9 46 7b 20 04 80 	movabs $0x8004207b46,%rcx
  80042031ec:	00 00 00 
  80042031ef:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  80042031f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042031f5:	48 89 c7             	mov    %rax,%rdi
  80042031f8:	48 b8 fe 77 20 04 80 	movabs $0x80042077fe,%rax
  80042031ff:	00 00 00 
  8004203202:	ff d0                	callq  *%rax
	}
}
  8004203204:	c9                   	leaveq 
  8004203205:	c3                   	retq   

0000008004203206 <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  8004203206:	55                   	push   %rbp
  8004203207:	48 89 e5             	mov    %rsp,%rbp
  800420320a:	48 83 ec 60          	sub    $0x60,%rsp
  800420320e:	89 f8                	mov    %edi,%eax
  8004203210:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  8004203213:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203217:	74 07                	je     8004203220 <check_page_free_list+0x1a>
  8004203219:	b8 01 00 00 00       	mov    $0x1,%eax
  800420321e:	eb 05                	jmp    8004203225 <check_page_free_list+0x1f>
  8004203220:	b8 00 02 00 00       	mov    $0x200,%eax
  8004203225:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  8004203228:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420322f:	00 
  8004203230:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203237:	00 
	void *first_free_page;

	if (!page_free_list)
  8004203238:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  800420323f:	00 00 00 
  8004203242:	48 8b 00             	mov    (%rax),%rax
  8004203245:	48 85 c0             	test   %rax,%rax
  8004203248:	75 2a                	jne    8004203274 <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  800420324a:	48 ba 38 23 21 04 80 	movabs $0x8004212338,%rdx
  8004203251:	00 00 00 
  8004203254:	be 4b 03 00 00       	mov    $0x34b,%esi
  8004203259:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203260:	00 00 00 
  8004203263:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203268:	48 b9 50 01 20 04 80 	movabs $0x8004200150,%rcx
  800420326f:	00 00 00 
  8004203272:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  8004203274:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203278:	0f 84 a9 00 00 00    	je     8004203327 <check_page_free_list+0x121>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  800420327e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8004203282:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004203286:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  800420328a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  800420328e:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  8004203295:	00 00 00 
  8004203298:	48 8b 00             	mov    (%rax),%rax
  800420329b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420329f:	eb 58                	jmp    80042032f9 <check_page_free_list+0xf3>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  80042032a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042032a5:	48 89 c7             	mov    %rax,%rdi
  80042032a8:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  80042032af:	00 00 00 
  80042032b2:	ff d0                	callq  *%rax
  80042032b4:	48 c1 e8 15          	shr    $0x15,%rax
  80042032b8:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042032bd:	48 89 c2             	mov    %rax,%rdx
  80042032c0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042032c3:	48 39 c2             	cmp    %rax,%rdx
  80042032c6:	0f 93 c0             	setae  %al
  80042032c9:	0f b6 c0             	movzbl %al,%eax
  80042032cc:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  80042032cf:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042032d2:	48 98                	cltq   
  80042032d4:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  80042032d9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042032dd:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  80042032e0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042032e4:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042032e7:	48 98                	cltq   
  80042032e9:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042032ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042032f2:	48 8b 00             	mov    (%rax),%rax
  80042032f5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042032f9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042032fe:	75 a1                	jne    80042032a1 <check_page_free_list+0x9b>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
  8004203300:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203304:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  800420330b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420330f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203313:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  8004203316:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420331a:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  8004203321:	00 00 00 
  8004203324:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203327:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  800420332e:	00 00 00 
  8004203331:	48 8b 00             	mov    (%rax),%rax
  8004203334:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203338:	eb 5e                	jmp    8004203398 <check_page_free_list+0x192>
		if (PDX(page2pa(pp)) < pdx_limit)
  800420333a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420333e:	48 89 c7             	mov    %rax,%rdi
  8004203341:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  8004203348:	00 00 00 
  800420334b:	ff d0                	callq  *%rax
  800420334d:	48 c1 e8 15          	shr    $0x15,%rax
  8004203351:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203356:	48 89 c2             	mov    %rax,%rdx
  8004203359:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420335c:	48 39 c2             	cmp    %rax,%rdx
  800420335f:	73 2c                	jae    800420338d <check_page_free_list+0x187>
			memset(page2kva(pp), 0x97, 128);
  8004203361:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203365:	48 89 c7             	mov    %rax,%rdi
  8004203368:	48 b8 0d 14 20 04 80 	movabs $0x800420140d,%rax
  800420336f:	00 00 00 
  8004203372:	ff d0                	callq  *%rax
  8004203374:	ba 80 00 00 00       	mov    $0x80,%edx
  8004203379:	be 97 00 00 00       	mov    $0x97,%esi
  800420337e:	48 89 c7             	mov    %rax,%rdi
  8004203381:	48 b8 96 ba 20 04 80 	movabs $0x800420ba96,%rax
  8004203388:	00 00 00 
  800420338b:	ff d0                	callq  *%rax
		page_free_list = pp1;
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  800420338d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203391:	48 8b 00             	mov    (%rax),%rax
  8004203394:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203398:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420339d:	75 9b                	jne    800420333a <check_page_free_list+0x134>
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = boot_alloc(0);
  800420339f:	bf 00 00 00 00       	mov    $0x0,%edi
  80042033a4:	48 b8 36 1d 20 04 80 	movabs $0x8004201d36,%rax
  80042033ab:	00 00 00 
  80042033ae:	ff d0                	callq  *%rax
  80042033b0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042033b4:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  80042033bb:	00 00 00 
  80042033be:	48 8b 00             	mov    (%rax),%rax
  80042033c1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042033c5:	e9 d0 02 00 00       	jmpq   800420369a <check_page_free_list+0x494>
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
  80042033ca:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  80042033d1:	00 00 00 
  80042033d4:	48 8b 00             	mov    (%rax),%rax
  80042033d7:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042033db:	73 35                	jae    8004203412 <check_page_free_list+0x20c>
  80042033dd:	48 b9 5c 23 21 04 80 	movabs $0x800421235c,%rcx
  80042033e4:	00 00 00 
  80042033e7:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042033ee:	00 00 00 
  80042033f1:	be 65 03 00 00       	mov    $0x365,%esi
  80042033f6:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042033fd:	00 00 00 
  8004203400:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203405:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420340c:	00 00 00 
  800420340f:	41 ff d0             	callq  *%r8
		assert(pp < pages + npages);
  8004203412:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  8004203419:	00 00 00 
  800420341c:	48 8b 10             	mov    (%rax),%rdx
  800420341f:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004203426:	00 00 00 
  8004203429:	48 8b 00             	mov    (%rax),%rax
  800420342c:	48 c1 e0 04          	shl    $0x4,%rax
  8004203430:	48 01 d0             	add    %rdx,%rax
  8004203433:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203437:	77 35                	ja     800420346e <check_page_free_list+0x268>
  8004203439:	48 b9 68 23 21 04 80 	movabs $0x8004212368,%rcx
  8004203440:	00 00 00 
  8004203443:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420344a:	00 00 00 
  800420344d:	be 66 03 00 00       	mov    $0x366,%esi
  8004203452:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203459:	00 00 00 
  800420345c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203461:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203468:	00 00 00 
  800420346b:	41 ff d0             	callq  *%r8
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  800420346e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203472:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  8004203479:	00 00 00 
  800420347c:	48 8b 00             	mov    (%rax),%rax
  800420347f:	48 29 c2             	sub    %rax,%rdx
  8004203482:	48 89 d0             	mov    %rdx,%rax
  8004203485:	83 e0 0f             	and    $0xf,%eax
  8004203488:	48 85 c0             	test   %rax,%rax
  800420348b:	74 35                	je     80042034c2 <check_page_free_list+0x2bc>
  800420348d:	48 b9 80 23 21 04 80 	movabs $0x8004212380,%rcx
  8004203494:	00 00 00 
  8004203497:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420349e:	00 00 00 
  80042034a1:	be 67 03 00 00       	mov    $0x367,%esi
  80042034a6:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042034ad:	00 00 00 
  80042034b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042034b5:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042034bc:	00 00 00 
  80042034bf:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
  80042034c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042034c6:	48 89 c7             	mov    %rax,%rdi
  80042034c9:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  80042034d0:	00 00 00 
  80042034d3:	ff d0                	callq  *%rax
  80042034d5:	48 85 c0             	test   %rax,%rax
  80042034d8:	75 35                	jne    800420350f <check_page_free_list+0x309>
  80042034da:	48 b9 b2 23 21 04 80 	movabs $0x80042123b2,%rcx
  80042034e1:	00 00 00 
  80042034e4:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042034eb:	00 00 00 
  80042034ee:	be 6a 03 00 00       	mov    $0x36a,%esi
  80042034f3:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042034fa:	00 00 00 
  80042034fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203502:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203509:	00 00 00 
  800420350c:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != IOPHYSMEM);
  800420350f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203513:	48 89 c7             	mov    %rax,%rdi
  8004203516:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  800420351d:	00 00 00 
  8004203520:	ff d0                	callq  *%rax
  8004203522:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004203528:	75 35                	jne    800420355f <check_page_free_list+0x359>
  800420352a:	48 b9 c3 23 21 04 80 	movabs $0x80042123c3,%rcx
  8004203531:	00 00 00 
  8004203534:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420353b:	00 00 00 
  800420353e:	be 6b 03 00 00       	mov    $0x36b,%esi
  8004203543:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420354a:	00 00 00 
  800420354d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203552:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203559:	00 00 00 
  800420355c:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  800420355f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203563:	48 89 c7             	mov    %rax,%rdi
  8004203566:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  800420356d:	00 00 00 
  8004203570:	ff d0                	callq  *%rax
  8004203572:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004203578:	75 35                	jne    80042035af <check_page_free_list+0x3a9>
  800420357a:	48 b9 e0 23 21 04 80 	movabs $0x80042123e0,%rcx
  8004203581:	00 00 00 
  8004203584:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420358b:	00 00 00 
  800420358e:	be 6c 03 00 00       	mov    $0x36c,%esi
  8004203593:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420359a:	00 00 00 
  800420359d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042035a2:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042035a9:	00 00 00 
  80042035ac:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM);
  80042035af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042035b3:	48 89 c7             	mov    %rax,%rdi
  80042035b6:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  80042035bd:	00 00 00 
  80042035c0:	ff d0                	callq  *%rax
  80042035c2:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  80042035c8:	75 35                	jne    80042035ff <check_page_free_list+0x3f9>
  80042035ca:	48 b9 03 24 21 04 80 	movabs $0x8004212403,%rcx
  80042035d1:	00 00 00 
  80042035d4:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042035db:	00 00 00 
  80042035de:	be 6d 03 00 00       	mov    $0x36d,%esi
  80042035e3:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042035ea:	00 00 00 
  80042035ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042035f2:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042035f9:	00 00 00 
  80042035fc:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) < EXTPHYSMEM || page2kva(pp) >= first_free_page);
  80042035ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203603:	48 89 c7             	mov    %rax,%rdi
  8004203606:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  800420360d:	00 00 00 
  8004203610:	ff d0                	callq  *%rax
  8004203612:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004203618:	76 4e                	jbe    8004203668 <check_page_free_list+0x462>
  800420361a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420361e:	48 89 c7             	mov    %rax,%rdi
  8004203621:	48 b8 0d 14 20 04 80 	movabs $0x800420140d,%rax
  8004203628:	00 00 00 
  800420362b:	ff d0                	callq  *%rax
  800420362d:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004203631:	73 35                	jae    8004203668 <check_page_free_list+0x462>
  8004203633:	48 b9 20 24 21 04 80 	movabs $0x8004212420,%rcx
  800420363a:	00 00 00 
  800420363d:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203644:	00 00 00 
  8004203647:	be 6e 03 00 00       	mov    $0x36e,%esi
  800420364c:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203653:	00 00 00 
  8004203656:	b8 00 00 00 00       	mov    $0x0,%eax
  800420365b:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203662:	00 00 00 
  8004203665:	41 ff d0             	callq  *%r8

		if (page2pa(pp) < EXTPHYSMEM)
  8004203668:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420366c:	48 89 c7             	mov    %rax,%rdi
  800420366f:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  8004203676:	00 00 00 
  8004203679:	ff d0                	callq  *%rax
  800420367b:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004203681:	77 07                	ja     800420368a <check_page_free_list+0x484>
			++nfree_basemem;
  8004203683:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004203688:	eb 05                	jmp    800420368f <check_page_free_list+0x489>
		else
			++nfree_extmem;
  800420368a:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link)
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = boot_alloc(0);
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  800420368f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203693:	48 8b 00             	mov    (%rax),%rax
  8004203696:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420369a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420369f:	0f 85 25 fd ff ff    	jne    80042033ca <check_page_free_list+0x1c4>
			++nfree_basemem;
		else
			++nfree_extmem;
	}

	assert(nfree_extmem > 0);
  80042036a5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042036aa:	75 35                	jne    80042036e1 <check_page_free_list+0x4db>
  80042036ac:	48 b9 5c 24 21 04 80 	movabs $0x800421245c,%rcx
  80042036b3:	00 00 00 
  80042036b6:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042036bd:	00 00 00 
  80042036c0:	be 76 03 00 00       	mov    $0x376,%esi
  80042036c5:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042036cc:	00 00 00 
  80042036cf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042036d4:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042036db:	00 00 00 
  80042036de:	41 ff d0             	callq  *%r8
}
  80042036e1:	c9                   	leaveq 
  80042036e2:	c3                   	retq   

00000080042036e3 <check_page_alloc>:
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
  80042036e3:	55                   	push   %rbp
  80042036e4:	48 89 e5             	mov    %rsp,%rbp
  80042036e7:	48 83 ec 40          	sub    $0x40,%rsp
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  80042036eb:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  80042036f2:	00 00 00 
  80042036f5:	48 8b 00             	mov    (%rax),%rax
  80042036f8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042036fc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004203703:	eb 37                	jmp    800420373c <check_page_alloc+0x59>
		memset(page2kva(pp0), 0x97, PGSIZE);
  8004203705:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203709:	48 89 c7             	mov    %rax,%rdi
  800420370c:	48 b8 0d 14 20 04 80 	movabs $0x800420140d,%rax
  8004203713:	00 00 00 
  8004203716:	ff d0                	callq  *%rax
  8004203718:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420371d:	be 97 00 00 00       	mov    $0x97,%esi
  8004203722:	48 89 c7             	mov    %rax,%rdi
  8004203725:	48 b8 96 ba 20 04 80 	movabs $0x800420ba96,%rax
  800420372c:	00 00 00 
  800420372f:	ff d0                	callq  *%rax
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004203731:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203735:	48 8b 00             	mov    (%rax),%rax
  8004203738:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420373c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203741:	75 c2                	jne    8004203705 <check_page_alloc+0x22>
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004203743:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  800420374a:	00 00 00 
  800420374d:	48 8b 00             	mov    (%rax),%rax
  8004203750:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203754:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  800420375b:	e9 ec 01 00 00       	jmpq   800420394c <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
		assert(pp0 >= pages);
  8004203760:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  8004203767:	00 00 00 
  800420376a:	48 8b 00             	mov    (%rax),%rax
  800420376d:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004203771:	73 35                	jae    80042037a8 <check_page_alloc+0xc5>
  8004203773:	48 b9 6d 24 21 04 80 	movabs $0x800421246d,%rcx
  800420377a:	00 00 00 
  800420377d:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203784:	00 00 00 
  8004203787:	be 90 03 00 00       	mov    $0x390,%esi
  800420378c:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203793:	00 00 00 
  8004203796:	b8 00 00 00 00       	mov    $0x0,%eax
  800420379b:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042037a2:	00 00 00 
  80042037a5:	41 ff d0             	callq  *%r8
		assert(pp0 < pages + npages);
  80042037a8:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  80042037af:	00 00 00 
  80042037b2:	48 8b 10             	mov    (%rax),%rdx
  80042037b5:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  80042037bc:	00 00 00 
  80042037bf:	48 8b 00             	mov    (%rax),%rax
  80042037c2:	48 c1 e0 04          	shl    $0x4,%rax
  80042037c6:	48 01 d0             	add    %rdx,%rax
  80042037c9:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042037cd:	77 35                	ja     8004203804 <check_page_alloc+0x121>
  80042037cf:	48 b9 7a 24 21 04 80 	movabs $0x800421247a,%rcx
  80042037d6:	00 00 00 
  80042037d9:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042037e0:	00 00 00 
  80042037e3:	be 91 03 00 00       	mov    $0x391,%esi
  80042037e8:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042037ef:	00 00 00 
  80042037f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042037f7:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042037fe:	00 00 00 
  8004203801:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp0) != 0);
  8004203804:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203808:	48 89 c7             	mov    %rax,%rdi
  800420380b:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  8004203812:	00 00 00 
  8004203815:	ff d0                	callq  *%rax
  8004203817:	48 85 c0             	test   %rax,%rax
  800420381a:	75 35                	jne    8004203851 <check_page_alloc+0x16e>
  800420381c:	48 b9 8f 24 21 04 80 	movabs $0x800421248f,%rcx
  8004203823:	00 00 00 
  8004203826:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420382d:	00 00 00 
  8004203830:	be 94 03 00 00       	mov    $0x394,%esi
  8004203835:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420383c:	00 00 00 
  800420383f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203844:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420384b:	00 00 00 
  800420384e:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != IOPHYSMEM);
  8004203851:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203855:	48 89 c7             	mov    %rax,%rdi
  8004203858:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  800420385f:	00 00 00 
  8004203862:	ff d0                	callq  *%rax
  8004203864:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  800420386a:	75 35                	jne    80042038a1 <check_page_alloc+0x1be>
  800420386c:	48 b9 a1 24 21 04 80 	movabs $0x80042124a1,%rcx
  8004203873:	00 00 00 
  8004203876:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420387d:	00 00 00 
  8004203880:	be 95 03 00 00       	mov    $0x395,%esi
  8004203885:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420388c:	00 00 00 
  800420388f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203894:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420389b:	00 00 00 
  800420389e:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  80042038a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042038a5:	48 89 c7             	mov    %rax,%rdi
  80042038a8:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  80042038af:	00 00 00 
  80042038b2:	ff d0                	callq  *%rax
  80042038b4:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  80042038ba:	75 35                	jne    80042038f1 <check_page_alloc+0x20e>
  80042038bc:	48 b9 c0 24 21 04 80 	movabs $0x80042124c0,%rcx
  80042038c3:	00 00 00 
  80042038c6:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042038cd:	00 00 00 
  80042038d0:	be 96 03 00 00       	mov    $0x396,%esi
  80042038d5:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042038dc:	00 00 00 
  80042038df:	b8 00 00 00 00       	mov    $0x0,%eax
  80042038e4:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042038eb:	00 00 00 
  80042038ee:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM);
  80042038f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042038f5:	48 89 c7             	mov    %rax,%rdi
  80042038f8:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  80042038ff:	00 00 00 
  8004203902:	ff d0                	callq  *%rax
  8004203904:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  800420390a:	75 35                	jne    8004203941 <check_page_alloc+0x25e>
  800420390c:	48 b9 e4 24 21 04 80 	movabs $0x80042124e4,%rcx
  8004203913:	00 00 00 
  8004203916:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420391d:	00 00 00 
  8004203920:	be 97 03 00 00       	mov    $0x397,%esi
  8004203925:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420392c:	00 00 00 
  800420392f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203934:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420393b:	00 00 00 
  800420393e:	41 ff d0             	callq  *%r8
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004203941:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203945:	48 8b 00             	mov    (%rax),%rax
  8004203948:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420394c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203951:	0f 85 09 fe ff ff    	jne    8004203760 <check_page_alloc+0x7d>
		assert(page2pa(pp0) != IOPHYSMEM);
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
		assert(page2pa(pp0) != EXTPHYSMEM);
	}
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
  8004203957:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420395e:	00 
  800420395f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203963:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203967:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420396b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  800420396f:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203974:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  800420397b:	00 00 00 
  800420397e:	ff d0                	callq  *%rax
  8004203980:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203984:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203989:	75 35                	jne    80042039c0 <check_page_alloc+0x2dd>
  800420398b:	48 b9 ff 24 21 04 80 	movabs $0x80042124ff,%rcx
  8004203992:	00 00 00 
  8004203995:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420399c:	00 00 00 
  800420399f:	be 9b 03 00 00       	mov    $0x39b,%esi
  80042039a4:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042039ab:	00 00 00 
  80042039ae:	b8 00 00 00 00       	mov    $0x0,%eax
  80042039b3:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042039ba:	00 00 00 
  80042039bd:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  80042039c0:	bf 00 00 00 00       	mov    $0x0,%edi
  80042039c5:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  80042039cc:	00 00 00 
  80042039cf:	ff d0                	callq  *%rax
  80042039d1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042039d5:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042039da:	75 35                	jne    8004203a11 <check_page_alloc+0x32e>
  80042039dc:	48 b9 15 25 21 04 80 	movabs $0x8004212515,%rcx
  80042039e3:	00 00 00 
  80042039e6:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042039ed:	00 00 00 
  80042039f0:	be 9c 03 00 00       	mov    $0x39c,%esi
  80042039f5:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042039fc:	00 00 00 
  80042039ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203a04:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203a0b:	00 00 00 
  8004203a0e:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004203a11:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203a16:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  8004203a1d:	00 00 00 
  8004203a20:	ff d0                	callq  *%rax
  8004203a22:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004203a26:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203a2b:	75 35                	jne    8004203a62 <check_page_alloc+0x37f>
  8004203a2d:	48 b9 2b 25 21 04 80 	movabs $0x800421252b,%rcx
  8004203a34:	00 00 00 
  8004203a37:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203a3e:	00 00 00 
  8004203a41:	be 9d 03 00 00       	mov    $0x39d,%esi
  8004203a46:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203a4d:	00 00 00 
  8004203a50:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203a55:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203a5c:	00 00 00 
  8004203a5f:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004203a62:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203a67:	75 35                	jne    8004203a9e <check_page_alloc+0x3bb>
  8004203a69:	48 b9 41 25 21 04 80 	movabs $0x8004212541,%rcx
  8004203a70:	00 00 00 
  8004203a73:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203a7a:	00 00 00 
  8004203a7d:	be 9e 03 00 00       	mov    $0x39e,%esi
  8004203a82:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203a89:	00 00 00 
  8004203a8c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203a91:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203a98:	00 00 00 
  8004203a9b:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004203a9e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004203aa3:	74 0a                	je     8004203aaf <check_page_alloc+0x3cc>
  8004203aa5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203aa9:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203aad:	75 35                	jne    8004203ae4 <check_page_alloc+0x401>
  8004203aaf:	48 b9 45 25 21 04 80 	movabs $0x8004212545,%rcx
  8004203ab6:	00 00 00 
  8004203ab9:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203ac0:	00 00 00 
  8004203ac3:	be 9f 03 00 00       	mov    $0x39f,%esi
  8004203ac8:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203acf:	00 00 00 
  8004203ad2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203ad7:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203ade:	00 00 00 
  8004203ae1:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004203ae4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203ae9:	74 14                	je     8004203aff <check_page_alloc+0x41c>
  8004203aeb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203aef:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004203af3:	74 0a                	je     8004203aff <check_page_alloc+0x41c>
  8004203af5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203af9:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203afd:	75 35                	jne    8004203b34 <check_page_alloc+0x451>
  8004203aff:	48 b9 58 25 21 04 80 	movabs $0x8004212558,%rcx
  8004203b06:	00 00 00 
  8004203b09:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203b10:	00 00 00 
  8004203b13:	be a0 03 00 00       	mov    $0x3a0,%esi
  8004203b18:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203b1f:	00 00 00 
  8004203b22:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203b27:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203b2e:	00 00 00 
  8004203b31:	41 ff d0             	callq  *%r8
	assert(page2pa(pp0) < npages*PGSIZE);
  8004203b34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b38:	48 89 c7             	mov    %rax,%rdi
  8004203b3b:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  8004203b42:	00 00 00 
  8004203b45:	ff d0                	callq  *%rax
  8004203b47:	48 ba e8 db 2b 04 80 	movabs $0x80042bdbe8,%rdx
  8004203b4e:	00 00 00 
  8004203b51:	48 8b 12             	mov    (%rdx),%rdx
  8004203b54:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004203b58:	48 39 d0             	cmp    %rdx,%rax
  8004203b5b:	72 35                	jb     8004203b92 <check_page_alloc+0x4af>
  8004203b5d:	48 b9 78 25 21 04 80 	movabs $0x8004212578,%rcx
  8004203b64:	00 00 00 
  8004203b67:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203b6e:	00 00 00 
  8004203b71:	be a1 03 00 00       	mov    $0x3a1,%esi
  8004203b76:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203b7d:	00 00 00 
  8004203b80:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203b85:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203b8c:	00 00 00 
  8004203b8f:	41 ff d0             	callq  *%r8
	assert(page2pa(pp1) < npages*PGSIZE);
  8004203b92:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203b96:	48 89 c7             	mov    %rax,%rdi
  8004203b99:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  8004203ba0:	00 00 00 
  8004203ba3:	ff d0                	callq  *%rax
  8004203ba5:	48 ba e8 db 2b 04 80 	movabs $0x80042bdbe8,%rdx
  8004203bac:	00 00 00 
  8004203baf:	48 8b 12             	mov    (%rdx),%rdx
  8004203bb2:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004203bb6:	48 39 d0             	cmp    %rdx,%rax
  8004203bb9:	72 35                	jb     8004203bf0 <check_page_alloc+0x50d>
  8004203bbb:	48 b9 95 25 21 04 80 	movabs $0x8004212595,%rcx
  8004203bc2:	00 00 00 
  8004203bc5:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203bcc:	00 00 00 
  8004203bcf:	be a2 03 00 00       	mov    $0x3a2,%esi
  8004203bd4:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203bdb:	00 00 00 
  8004203bde:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203be3:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203bea:	00 00 00 
  8004203bed:	41 ff d0             	callq  *%r8
	assert(page2pa(pp2) < npages*PGSIZE);
  8004203bf0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203bf4:	48 89 c7             	mov    %rax,%rdi
  8004203bf7:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  8004203bfe:	00 00 00 
  8004203c01:	ff d0                	callq  *%rax
  8004203c03:	48 ba e8 db 2b 04 80 	movabs $0x80042bdbe8,%rdx
  8004203c0a:	00 00 00 
  8004203c0d:	48 8b 12             	mov    (%rdx),%rdx
  8004203c10:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004203c14:	48 39 d0             	cmp    %rdx,%rax
  8004203c17:	72 35                	jb     8004203c4e <check_page_alloc+0x56b>
  8004203c19:	48 b9 b2 25 21 04 80 	movabs $0x80042125b2,%rcx
  8004203c20:	00 00 00 
  8004203c23:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203c2a:	00 00 00 
  8004203c2d:	be a3 03 00 00       	mov    $0x3a3,%esi
  8004203c32:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203c39:	00 00 00 
  8004203c3c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203c41:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203c48:	00 00 00 
  8004203c4b:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004203c4e:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  8004203c55:	00 00 00 
  8004203c58:	48 8b 00             	mov    (%rax),%rax
  8004203c5b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	page_free_list = 0;
  8004203c5f:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  8004203c66:	00 00 00 
  8004203c69:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004203c70:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203c75:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  8004203c7c:	00 00 00 
  8004203c7f:	ff d0                	callq  *%rax
  8004203c81:	48 85 c0             	test   %rax,%rax
  8004203c84:	74 35                	je     8004203cbb <check_page_alloc+0x5d8>
  8004203c86:	48 b9 cf 25 21 04 80 	movabs $0x80042125cf,%rcx
  8004203c8d:	00 00 00 
  8004203c90:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203c97:	00 00 00 
  8004203c9a:	be aa 03 00 00       	mov    $0x3aa,%esi
  8004203c9f:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203ca6:	00 00 00 
  8004203ca9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203cae:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203cb5:	00 00 00 
  8004203cb8:	41 ff d0             	callq  *%r8

	// free and re-allocate?
	page_free(pp0);
  8004203cbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203cbf:	48 89 c7             	mov    %rax,%rdi
  8004203cc2:	48 b8 f2 25 20 04 80 	movabs $0x80042025f2,%rax
  8004203cc9:	00 00 00 
  8004203ccc:	ff d0                	callq  *%rax
	page_free(pp1);
  8004203cce:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203cd2:	48 89 c7             	mov    %rax,%rdi
  8004203cd5:	48 b8 f2 25 20 04 80 	movabs $0x80042025f2,%rax
  8004203cdc:	00 00 00 
  8004203cdf:	ff d0                	callq  *%rax
	page_free(pp2);
  8004203ce1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203ce5:	48 89 c7             	mov    %rax,%rdi
  8004203ce8:	48 b8 f2 25 20 04 80 	movabs $0x80042025f2,%rax
  8004203cef:	00 00 00 
  8004203cf2:	ff d0                	callq  *%rax
	pp0 = pp1 = pp2 = 0;
  8004203cf4:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203cfb:	00 
  8004203cfc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203d00:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203d04:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203d08:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004203d0c:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203d11:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  8004203d18:	00 00 00 
  8004203d1b:	ff d0                	callq  *%rax
  8004203d1d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203d21:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203d26:	75 35                	jne    8004203d5d <check_page_alloc+0x67a>
  8004203d28:	48 b9 ff 24 21 04 80 	movabs $0x80042124ff,%rcx
  8004203d2f:	00 00 00 
  8004203d32:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203d39:	00 00 00 
  8004203d3c:	be b1 03 00 00       	mov    $0x3b1,%esi
  8004203d41:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203d48:	00 00 00 
  8004203d4b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d50:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203d57:	00 00 00 
  8004203d5a:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004203d5d:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203d62:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  8004203d69:	00 00 00 
  8004203d6c:	ff d0                	callq  *%rax
  8004203d6e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203d72:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004203d77:	75 35                	jne    8004203dae <check_page_alloc+0x6cb>
  8004203d79:	48 b9 15 25 21 04 80 	movabs $0x8004212515,%rcx
  8004203d80:	00 00 00 
  8004203d83:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203d8a:	00 00 00 
  8004203d8d:	be b2 03 00 00       	mov    $0x3b2,%esi
  8004203d92:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203d99:	00 00 00 
  8004203d9c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203da1:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203da8:	00 00 00 
  8004203dab:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004203dae:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203db3:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  8004203dba:	00 00 00 
  8004203dbd:	ff d0                	callq  *%rax
  8004203dbf:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004203dc3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203dc8:	75 35                	jne    8004203dff <check_page_alloc+0x71c>
  8004203dca:	48 b9 2b 25 21 04 80 	movabs $0x800421252b,%rcx
  8004203dd1:	00 00 00 
  8004203dd4:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203ddb:	00 00 00 
  8004203dde:	be b3 03 00 00       	mov    $0x3b3,%esi
  8004203de3:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203dea:	00 00 00 
  8004203ded:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203df2:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203df9:	00 00 00 
  8004203dfc:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004203dff:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203e04:	75 35                	jne    8004203e3b <check_page_alloc+0x758>
  8004203e06:	48 b9 41 25 21 04 80 	movabs $0x8004212541,%rcx
  8004203e0d:	00 00 00 
  8004203e10:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203e17:	00 00 00 
  8004203e1a:	be b4 03 00 00       	mov    $0x3b4,%esi
  8004203e1f:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203e26:	00 00 00 
  8004203e29:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e2e:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203e35:	00 00 00 
  8004203e38:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004203e3b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004203e40:	74 0a                	je     8004203e4c <check_page_alloc+0x769>
  8004203e42:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203e46:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203e4a:	75 35                	jne    8004203e81 <check_page_alloc+0x79e>
  8004203e4c:	48 b9 45 25 21 04 80 	movabs $0x8004212545,%rcx
  8004203e53:	00 00 00 
  8004203e56:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203e5d:	00 00 00 
  8004203e60:	be b5 03 00 00       	mov    $0x3b5,%esi
  8004203e65:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203e6c:	00 00 00 
  8004203e6f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e74:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203e7b:	00 00 00 
  8004203e7e:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004203e81:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203e86:	74 14                	je     8004203e9c <check_page_alloc+0x7b9>
  8004203e88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203e8c:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004203e90:	74 0a                	je     8004203e9c <check_page_alloc+0x7b9>
  8004203e92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203e96:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203e9a:	75 35                	jne    8004203ed1 <check_page_alloc+0x7ee>
  8004203e9c:	48 b9 58 25 21 04 80 	movabs $0x8004212558,%rcx
  8004203ea3:	00 00 00 
  8004203ea6:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203ead:	00 00 00 
  8004203eb0:	be b6 03 00 00       	mov    $0x3b6,%esi
  8004203eb5:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203ebc:	00 00 00 
  8004203ebf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203ec4:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203ecb:	00 00 00 
  8004203ece:	41 ff d0             	callq  *%r8
	assert(!page_alloc(0));
  8004203ed1:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203ed6:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  8004203edd:	00 00 00 
  8004203ee0:	ff d0                	callq  *%rax
  8004203ee2:	48 85 c0             	test   %rax,%rax
  8004203ee5:	74 35                	je     8004203f1c <check_page_alloc+0x839>
  8004203ee7:	48 b9 cf 25 21 04 80 	movabs $0x80042125cf,%rcx
  8004203eee:	00 00 00 
  8004203ef1:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203ef8:	00 00 00 
  8004203efb:	be b7 03 00 00       	mov    $0x3b7,%esi
  8004203f00:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203f07:	00 00 00 
  8004203f0a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f0f:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203f16:	00 00 00 
  8004203f19:	41 ff d0             	callq  *%r8

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
  8004203f1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f20:	48 89 c7             	mov    %rax,%rdi
  8004203f23:	48 b8 0d 14 20 04 80 	movabs $0x800420140d,%rax
  8004203f2a:	00 00 00 
  8004203f2d:	ff d0                	callq  *%rax
  8004203f2f:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004203f34:	be 01 00 00 00       	mov    $0x1,%esi
  8004203f39:	48 89 c7             	mov    %rax,%rdi
  8004203f3c:	48 b8 96 ba 20 04 80 	movabs $0x800420ba96,%rax
  8004203f43:	00 00 00 
  8004203f46:	ff d0                	callq  *%rax
	page_free(pp0);
  8004203f48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f4c:	48 89 c7             	mov    %rax,%rdi
  8004203f4f:	48 b8 f2 25 20 04 80 	movabs $0x80042025f2,%rax
  8004203f56:	00 00 00 
  8004203f59:	ff d0                	callq  *%rax
	assert((pp = page_alloc(ALLOC_ZERO)));
  8004203f5b:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203f60:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  8004203f67:	00 00 00 
  8004203f6a:	ff d0                	callq  *%rax
  8004203f6c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004203f70:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004203f75:	75 35                	jne    8004203fac <check_page_alloc+0x8c9>
  8004203f77:	48 b9 de 25 21 04 80 	movabs $0x80042125de,%rcx
  8004203f7e:	00 00 00 
  8004203f81:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203f88:	00 00 00 
  8004203f8b:	be bc 03 00 00       	mov    $0x3bc,%esi
  8004203f90:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203f97:	00 00 00 
  8004203f9a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f9f:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203fa6:	00 00 00 
  8004203fa9:	41 ff d0             	callq  *%r8
	assert(pp && pp0 == pp);
  8004203fac:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004203fb1:	74 0a                	je     8004203fbd <check_page_alloc+0x8da>
  8004203fb3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203fb7:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004203fbb:	74 35                	je     8004203ff2 <check_page_alloc+0x90f>
  8004203fbd:	48 b9 fc 25 21 04 80 	movabs $0x80042125fc,%rcx
  8004203fc4:	00 00 00 
  8004203fc7:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004203fce:	00 00 00 
  8004203fd1:	be bd 03 00 00       	mov    $0x3bd,%esi
  8004203fd6:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004203fdd:	00 00 00 
  8004203fe0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203fe5:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004203fec:	00 00 00 
  8004203fef:	41 ff d0             	callq  *%r8
	c = page2kva(pp);
  8004203ff2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203ff6:	48 89 c7             	mov    %rax,%rdi
  8004203ff9:	48 b8 0d 14 20 04 80 	movabs $0x800420140d,%rax
  8004204000:	00 00 00 
  8004204003:	ff d0                	callq  *%rax
  8004204005:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < PGSIZE; i++)
  8004204009:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004204010:	eb 4d                	jmp    800420405f <check_page_alloc+0x97c>
		assert(c[i] == 0);
  8004204012:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004204015:	48 63 d0             	movslq %eax,%rdx
  8004204018:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420401c:	48 01 d0             	add    %rdx,%rax
  800420401f:	0f b6 00             	movzbl (%rax),%eax
  8004204022:	84 c0                	test   %al,%al
  8004204024:	74 35                	je     800420405b <check_page_alloc+0x978>
  8004204026:	48 b9 0c 26 21 04 80 	movabs $0x800421260c,%rcx
  800420402d:	00 00 00 
  8004204030:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204037:	00 00 00 
  800420403a:	be c0 03 00 00       	mov    $0x3c0,%esi
  800420403f:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204046:	00 00 00 
  8004204049:	b8 00 00 00 00       	mov    $0x0,%eax
  800420404e:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204055:	00 00 00 
  8004204058:	41 ff d0             	callq  *%r8
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
  800420405b:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800420405f:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  8004204066:	7e aa                	jle    8004204012 <check_page_alloc+0x92f>
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;
  8004204068:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  800420406f:	00 00 00 
  8004204072:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004204076:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_free(pp0);
  8004204079:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420407d:	48 89 c7             	mov    %rax,%rdi
  8004204080:	48 b8 f2 25 20 04 80 	movabs $0x80042025f2,%rax
  8004204087:	00 00 00 
  800420408a:	ff d0                	callq  *%rax
	page_free(pp1);
  800420408c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204090:	48 89 c7             	mov    %rax,%rdi
  8004204093:	48 b8 f2 25 20 04 80 	movabs $0x80042025f2,%rax
  800420409a:	00 00 00 
  800420409d:	ff d0                	callq  *%rax
	page_free(pp2);
  800420409f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042040a3:	48 89 c7             	mov    %rax,%rdi
  80042040a6:	48 b8 f2 25 20 04 80 	movabs $0x80042025f2,%rax
  80042040ad:	00 00 00 
  80042040b0:	ff d0                	callq  *%rax

	cprintf("check_page_alloc() succeeded!\n");
  80042040b2:	48 bf 18 26 21 04 80 	movabs $0x8004212618,%rdi
  80042040b9:	00 00 00 
  80042040bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042040c1:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  80042040c8:	00 00 00 
  80042040cb:	ff d2                	callq  *%rdx
}
  80042040cd:	c9                   	leaveq 
  80042040ce:	c3                   	retq   

00000080042040cf <check_boot_pml4e>:
// but it is a pretty good sanity check.
//

static void
check_boot_pml4e(pml4e_t *pml4e)
{
  80042040cf:	55                   	push   %rbp
  80042040d0:	48 89 e5             	mov    %rsp,%rbp
  80042040d3:	53                   	push   %rbx
  80042040d4:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  80042040db:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
	uint64_t i, n;

	pml4e = boot_pml4e;
  80042040e2:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  80042040e9:	00 00 00 
  80042040ec:	48 8b 00             	mov    (%rax),%rax
  80042040ef:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  80042040f3:	48 c7 45 d8 00 10 00 	movq   $0x1000,-0x28(%rbp)
  80042040fa:	00 
  80042040fb:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004204102:	00 00 00 
  8004204105:	48 8b 00             	mov    (%rax),%rax
  8004204108:	48 c1 e0 04          	shl    $0x4,%rax
  800420410c:	48 89 c2             	mov    %rax,%rdx
  800420410f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204113:	48 01 d0             	add    %rdx,%rax
  8004204116:	48 83 e8 01          	sub    $0x1,%rax
  800420411a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420411e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204122:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204127:	48 f7 75 d8          	divq   -0x28(%rbp)
  800420412b:	48 89 d0             	mov    %rdx,%rax
  800420412e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204132:	48 29 c2             	sub    %rax,%rdx
  8004204135:	48 89 d0             	mov    %rdx,%rax
  8004204138:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < n; i += PGSIZE) {
  800420413c:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204143:	00 
  8004204144:	e9 d4 00 00 00       	jmpq   800420421d <check_boot_pml4e+0x14e>
		// cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  8004204149:	48 ba 00 00 a0 00 80 	movabs $0x8000a00000,%rdx
  8004204150:	00 00 00 
  8004204153:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204157:	48 01 c2             	add    %rax,%rdx
  800420415a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420415e:	48 89 d6             	mov    %rdx,%rsi
  8004204161:	48 89 c7             	mov    %rax,%rdi
  8004204164:	48 b8 b7 47 20 04 80 	movabs $0x80042047b7,%rax
  800420416b:	00 00 00 
  800420416e:	ff d0                	callq  *%rax
  8004204170:	48 ba f0 db 2b 04 80 	movabs $0x80042bdbf0,%rdx
  8004204177:	00 00 00 
  800420417a:	48 8b 12             	mov    (%rdx),%rdx
  800420417d:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8004204181:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004204188:	00 00 00 
  800420418b:	48 39 55 c0          	cmp    %rdx,-0x40(%rbp)
  800420418f:	77 32                	ja     80042041c3 <check_boot_pml4e+0xf4>
  8004204191:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004204195:	48 89 c1             	mov    %rax,%rcx
  8004204198:	48 ba c8 22 21 04 80 	movabs $0x80042122c8,%rdx
  800420419f:	00 00 00 
  80042041a2:	be e0 03 00 00       	mov    $0x3e0,%esi
  80042041a7:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042041ae:	00 00 00 
  80042041b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042041b6:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042041bd:	00 00 00 
  80042041c0:	41 ff d0             	callq  *%r8
  80042041c3:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  80042041ca:	ff ff ff 
  80042041cd:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042041d1:	48 01 d1             	add    %rdx,%rcx
  80042041d4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042041d8:	48 01 ca             	add    %rcx,%rdx
  80042041db:	48 39 d0             	cmp    %rdx,%rax
  80042041de:	74 35                	je     8004204215 <check_boot_pml4e+0x146>
  80042041e0:	48 b9 38 26 21 04 80 	movabs $0x8004212638,%rcx
  80042041e7:	00 00 00 
  80042041ea:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042041f1:	00 00 00 
  80042041f4:	be e0 03 00 00       	mov    $0x3e0,%esi
  80042041f9:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204200:	00 00 00 
  8004204203:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204208:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420420f:	00 00 00 
  8004204212:	41 ff d0             	callq  *%r8

	pml4e = boot_pml4e;

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
	for (i = 0; i < n; i += PGSIZE) {
  8004204215:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  800420421c:	00 
  800420421d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204221:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004204225:	0f 82 1e ff ff ff    	jb     8004204149 <check_boot_pml4e+0x7a>
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}


	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  800420422b:	48 c7 45 b8 00 10 00 	movq   $0x1000,-0x48(%rbp)
  8004204232:	00 
  8004204233:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004204237:	48 05 ff df 03 00    	add    $0x3dfff,%rax
  800420423d:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004204241:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004204245:	ba 00 00 00 00       	mov    $0x0,%edx
  800420424a:	48 f7 75 b8          	divq   -0x48(%rbp)
  800420424e:	48 89 d0             	mov    %rdx,%rax
  8004204251:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004204255:	48 29 c2             	sub    %rax,%rdx
  8004204258:	48 89 d0             	mov    %rdx,%rax
  800420425b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < n; i += PGSIZE)
  800420425f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204266:	00 
  8004204267:	e9 d4 00 00 00       	jmpq   8004204340 <check_boot_pml4e+0x271>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  800420426c:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  8004204273:	00 00 00 
  8004204276:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420427a:	48 01 c2             	add    %rax,%rdx
  800420427d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204281:	48 89 d6             	mov    %rdx,%rsi
  8004204284:	48 89 c7             	mov    %rax,%rdi
  8004204287:	48 b8 b7 47 20 04 80 	movabs $0x80042047b7,%rax
  800420428e:	00 00 00 
  8004204291:	ff d0                	callq  *%rax
  8004204293:	48 ba 90 c6 2b 04 80 	movabs $0x80042bc690,%rdx
  800420429a:	00 00 00 
  800420429d:	48 8b 12             	mov    (%rdx),%rdx
  80042042a0:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  80042042a4:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  80042042ab:	00 00 00 
  80042042ae:	48 39 55 a8          	cmp    %rdx,-0x58(%rbp)
  80042042b2:	77 32                	ja     80042042e6 <check_boot_pml4e+0x217>
  80042042b4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042042b8:	48 89 c1             	mov    %rax,%rcx
  80042042bb:	48 ba c8 22 21 04 80 	movabs $0x80042122c8,%rdx
  80042042c2:	00 00 00 
  80042042c5:	be e7 03 00 00       	mov    $0x3e7,%esi
  80042042ca:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042042d1:	00 00 00 
  80042042d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042042d9:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042042e0:	00 00 00 
  80042042e3:	41 ff d0             	callq  *%r8
  80042042e6:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  80042042ed:	ff ff ff 
  80042042f0:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80042042f4:	48 01 d1             	add    %rdx,%rcx
  80042042f7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042042fb:	48 01 ca             	add    %rcx,%rdx
  80042042fe:	48 39 d0             	cmp    %rdx,%rax
  8004204301:	74 35                	je     8004204338 <check_boot_pml4e+0x269>
  8004204303:	48 b9 70 26 21 04 80 	movabs $0x8004212670,%rcx
  800420430a:	00 00 00 
  800420430d:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204314:	00 00 00 
  8004204317:	be e7 03 00 00       	mov    $0x3e7,%esi
  800420431c:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204323:	00 00 00 
  8004204326:	b8 00 00 00 00       	mov    $0x0,%eax
  800420432b:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204332:	00 00 00 
  8004204335:	41 ff d0             	callq  *%r8
	}


	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
  8004204338:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  800420433f:	00 
  8004204340:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204344:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004204348:	0f 82 1e ff ff ff    	jb     800420426c <check_boot_pml4e+0x19d>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);


	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  800420434e:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204355:	00 
  8004204356:	eb 6a                	jmp    80042043c2 <check_boot_pml4e+0x2f3>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);
  8004204358:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420435f:	00 00 00 
  8004204362:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204366:	48 01 c2             	add    %rax,%rdx
  8004204369:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420436d:	48 89 d6             	mov    %rdx,%rsi
  8004204370:	48 89 c7             	mov    %rax,%rdi
  8004204373:	48 b8 b7 47 20 04 80 	movabs $0x80042047b7,%rax
  800420437a:	00 00 00 
  800420437d:	ff d0                	callq  *%rax
  800420437f:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004204383:	74 35                	je     80042043ba <check_boot_pml4e+0x2eb>
  8004204385:	48 b9 a8 26 21 04 80 	movabs $0x80042126a8,%rcx
  800420438c:	00 00 00 
  800420438f:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204396:	00 00 00 
  8004204399:	be ec 03 00 00       	mov    $0x3ec,%esi
  800420439e:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042043a5:	00 00 00 
  80042043a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042043ad:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042043b4:	00 00 00 
  80042043b7:	41 ff d0             	callq  *%r8
	for (i = 0; i < n; i += PGSIZE)
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);


	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  80042043ba:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  80042043c1:	00 
  80042043c2:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  80042043c9:	00 00 00 
  80042043cc:	48 8b 00             	mov    (%rax),%rax
  80042043cf:	48 c1 e0 0c          	shl    $0xc,%rax
  80042043d3:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042043d7:	0f 87 7b ff ff ff    	ja     8004204358 <check_boot_pml4e+0x289>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	for (i = 0; i < KSTKSIZE; i += PGSIZE) {
  80042043dd:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042043e4:	00 
  80042043e5:	e9 d1 00 00 00       	jmpq   80042044bb <check_boot_pml4e+0x3ec>
		assert(check_va2pa(pml4e, KSTACKTOP - KSTKSIZE + i) == PADDR(bootstack) + i);
  80042043ea:	48 ba 00 00 ff 03 80 	movabs $0x8003ff0000,%rdx
  80042043f1:	00 00 00 
  80042043f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042043f8:	48 01 c2             	add    %rax,%rdx
  80042043fb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042043ff:	48 89 d6             	mov    %rdx,%rsi
  8004204402:	48 89 c7             	mov    %rax,%rdi
  8004204405:	48 b8 b7 47 20 04 80 	movabs $0x80042047b7,%rax
  800420440c:	00 00 00 
  800420440f:	ff d0                	callq  *%rax
  8004204411:	48 bb 00 60 21 04 80 	movabs $0x8004216000,%rbx
  8004204418:	00 00 00 
  800420441b:	48 89 5d a0          	mov    %rbx,-0x60(%rbp)
  800420441f:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004204426:	00 00 00 
  8004204429:	48 39 55 a0          	cmp    %rdx,-0x60(%rbp)
  800420442d:	77 32                	ja     8004204461 <check_boot_pml4e+0x392>
  800420442f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204433:	48 89 c1             	mov    %rax,%rcx
  8004204436:	48 ba c8 22 21 04 80 	movabs $0x80042122c8,%rdx
  800420443d:	00 00 00 
  8004204440:	be f0 03 00 00       	mov    $0x3f0,%esi
  8004204445:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420444c:	00 00 00 
  800420444f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204454:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420445b:	00 00 00 
  800420445e:	41 ff d0             	callq  *%r8
  8004204461:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004204468:	ff ff ff 
  800420446b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420446f:	48 01 d1             	add    %rdx,%rcx
  8004204472:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004204476:	48 01 ca             	add    %rcx,%rdx
  8004204479:	48 39 d0             	cmp    %rdx,%rax
  800420447c:	74 35                	je     80042044b3 <check_boot_pml4e+0x3e4>
  800420447e:	48 b9 d0 26 21 04 80 	movabs $0x80042126d0,%rcx
  8004204485:	00 00 00 
  8004204488:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420448f:	00 00 00 
  8004204492:	be f0 03 00 00       	mov    $0x3f0,%esi
  8004204497:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420449e:	00 00 00 
  80042044a1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042044a6:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042044ad:	00 00 00 
  80042044b0:	41 ff d0             	callq  *%r8
	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	for (i = 0; i < KSTKSIZE; i += PGSIZE) {
  80042044b3:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  80042044ba:	00 
  80042044bb:	48 81 7d e8 ff ff 00 	cmpq   $0xffff,-0x18(%rbp)
  80042044c2:	00 
  80042044c3:	0f 86 21 ff ff ff    	jbe    80042043ea <check_boot_pml4e+0x31b>
		assert(check_va2pa(pml4e, KSTACKTOP - KSTKSIZE + i) == PADDR(bootstack) + i);
	}
	assert(check_va2pa(pml4e, KSTACKTOP - KSTKSIZE - 1 )  == ~0);
  80042044c9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042044cd:	48 be ff ff fe 03 80 	movabs $0x8003feffff,%rsi
  80042044d4:	00 00 00 
  80042044d7:	48 89 c7             	mov    %rax,%rdi
  80042044da:	48 b8 b7 47 20 04 80 	movabs $0x80042047b7,%rax
  80042044e1:	00 00 00 
  80042044e4:	ff d0                	callq  *%rax
  80042044e6:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  80042044ea:	74 35                	je     8004204521 <check_boot_pml4e+0x452>
  80042044ec:	48 b9 18 27 21 04 80 	movabs $0x8004212718,%rcx
  80042044f3:	00 00 00 
  80042044f6:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042044fd:	00 00 00 
  8004204500:	be f2 03 00 00       	mov    $0x3f2,%esi
  8004204505:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420450c:	00 00 00 
  800420450f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204514:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420451b:	00 00 00 
  800420451e:	41 ff d0             	callq  *%r8

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  8004204521:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004204528:	00 00 00 
  800420452b:	48 8b 00             	mov    (%rax),%rax
  800420452e:	48 83 c0 08          	add    $0x8,%rax
  8004204532:	48 8b 00             	mov    (%rax),%rax
  8004204535:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420453b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  800420453f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004204543:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204547:	89 45 94             	mov    %eax,-0x6c(%rbp)
  800420454a:	8b 55 94             	mov    -0x6c(%rbp),%edx
  800420454d:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004204554:	00 00 00 
  8004204557:	48 8b 00             	mov    (%rax),%rax
  800420455a:	48 39 c2             	cmp    %rax,%rdx
  800420455d:	72 32                	jb     8004204591 <check_boot_pml4e+0x4c2>
  800420455f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004204563:	48 89 c1             	mov    %rax,%rcx
  8004204566:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  800420456d:	00 00 00 
  8004204570:	be f4 03 00 00       	mov    $0x3f4,%esi
  8004204575:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420457c:	00 00 00 
  800420457f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204584:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420458b:	00 00 00 
  800420458e:	41 ff d0             	callq  *%r8
  8004204591:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204598:	00 00 00 
  800420459b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420459f:	48 01 d0             	add    %rdx,%rax
  80042045a2:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  80042045a6:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042045aa:	48 8b 00             	mov    (%rax),%rax
  80042045ad:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042045b3:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  80042045b7:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042045bb:	48 c1 e8 0c          	shr    $0xc,%rax
  80042045bf:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
  80042045c5:	8b 95 7c ff ff ff    	mov    -0x84(%rbp),%edx
  80042045cb:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  80042045d2:	00 00 00 
  80042045d5:	48 8b 00             	mov    (%rax),%rax
  80042045d8:	48 39 c2             	cmp    %rax,%rdx
  80042045db:	72 32                	jb     800420460f <check_boot_pml4e+0x540>
  80042045dd:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042045e1:	48 89 c1             	mov    %rax,%rcx
  80042045e4:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  80042045eb:	00 00 00 
  80042045ee:	be f5 03 00 00       	mov    $0x3f5,%esi
  80042045f3:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042045fa:	00 00 00 
  80042045fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204602:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204609:	00 00 00 
  800420460c:	41 ff d0             	callq  *%r8
  800420460f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204616:	00 00 00 
  8004204619:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800420461d:	48 01 d0             	add    %rdx,%rax
  8004204620:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004204627:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420462e:	00 
  800420462f:	e9 50 01 00 00       	jmpq   8004204784 <check_boot_pml4e+0x6b5>
		switch (i) {
  8004204634:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204638:	48 83 f8 04          	cmp    $0x4,%rax
  800420463c:	72 67                	jb     80042046a5 <check_boot_pml4e+0x5d6>
  800420463e:	48 83 f8 05          	cmp    $0x5,%rax
  8004204642:	76 06                	jbe    800420464a <check_boot_pml4e+0x57b>
  8004204644:	48 83 f8 1f          	cmp    $0x1f,%rax
  8004204648:	75 5b                	jne    80042046a5 <check_boot_pml4e+0x5d6>
		case PDX(KSTACKTOP - 1):
		case PDX(UPAGES):

		case PDX(UENVS):

			assert(pgdir[i] & PTE_P);
  800420464a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420464e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204655:	00 
  8004204656:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420465d:	48 01 d0             	add    %rdx,%rax
  8004204660:	48 8b 00             	mov    (%rax),%rax
  8004204663:	83 e0 01             	and    $0x1,%eax
  8004204666:	48 85 c0             	test   %rax,%rax
  8004204669:	75 35                	jne    80042046a0 <check_boot_pml4e+0x5d1>
  800420466b:	48 b9 4c 27 21 04 80 	movabs $0x800421274c,%rcx
  8004204672:	00 00 00 
  8004204675:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420467c:	00 00 00 
  800420467f:	be ff 03 00 00       	mov    $0x3ff,%esi
  8004204684:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420468b:	00 00 00 
  800420468e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204693:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420469a:	00 00 00 
  800420469d:	41 ff d0             	callq  *%r8
			break;
  80042046a0:	e9 da 00 00 00       	jmpq   800420477f <check_boot_pml4e+0x6b0>
		default:
			if (i >= PDX(KERNBASE)) {
  80042046a5:	48 83 7d e8 1f       	cmpq   $0x1f,-0x18(%rbp)
  80042046aa:	0f 86 ce 00 00 00    	jbe    800420477e <check_boot_pml4e+0x6af>
				if (pgdir[i] & PTE_P)
  80042046b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042046b4:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042046bb:	00 
  80042046bc:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042046c3:	48 01 d0             	add    %rdx,%rax
  80042046c6:	48 8b 00             	mov    (%rax),%rax
  80042046c9:	83 e0 01             	and    $0x1,%eax
  80042046cc:	48 85 c0             	test   %rax,%rax
  80042046cf:	74 5a                	je     800420472b <check_boot_pml4e+0x65c>
					assert(pgdir[i] & PTE_W);
  80042046d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042046d5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042046dc:	00 
  80042046dd:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042046e4:	48 01 d0             	add    %rdx,%rax
  80042046e7:	48 8b 00             	mov    (%rax),%rax
  80042046ea:	83 e0 02             	and    $0x2,%eax
  80042046ed:	48 85 c0             	test   %rax,%rax
  80042046f0:	0f 85 88 00 00 00    	jne    800420477e <check_boot_pml4e+0x6af>
  80042046f6:	48 b9 5d 27 21 04 80 	movabs $0x800421275d,%rcx
  80042046fd:	00 00 00 
  8004204700:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204707:	00 00 00 
  800420470a:	be 04 04 00 00       	mov    $0x404,%esi
  800420470f:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204716:	00 00 00 
  8004204719:	b8 00 00 00 00       	mov    $0x0,%eax
  800420471e:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204725:	00 00 00 
  8004204728:	41 ff d0             	callq  *%r8
				else
					assert(pgdir[i] == 0);
  800420472b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420472f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204736:	00 
  8004204737:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420473e:	48 01 d0             	add    %rdx,%rax
  8004204741:	48 8b 00             	mov    (%rax),%rax
  8004204744:	48 85 c0             	test   %rax,%rax
  8004204747:	74 35                	je     800420477e <check_boot_pml4e+0x6af>
  8004204749:	48 b9 6e 27 21 04 80 	movabs $0x800421276e,%rcx
  8004204750:	00 00 00 
  8004204753:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420475a:	00 00 00 
  800420475d:	be 06 04 00 00       	mov    $0x406,%esi
  8004204762:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204769:	00 00 00 
  800420476c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204771:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204778:	00 00 00 
  800420477b:	41 ff d0             	callq  *%r8
			} 
			break;
  800420477e:	90                   	nop
	assert(check_va2pa(pml4e, KSTACKTOP - KSTKSIZE - 1 )  == ~0);

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  800420477f:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004204784:	48 81 7d e8 ff 01 00 	cmpq   $0x1ff,-0x18(%rbp)
  800420478b:	00 
  800420478c:	0f 86 a2 fe ff ff    	jbe    8004204634 <check_boot_pml4e+0x565>
					assert(pgdir[i] == 0);
			} 
			break;
		}
	}
	cprintf("check_boot_pml4e() succeeded!\n");
  8004204792:	48 bf 80 27 21 04 80 	movabs $0x8004212780,%rdi
  8004204799:	00 00 00 
  800420479c:	b8 00 00 00 00       	mov    $0x0,%eax
  80042047a1:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  80042047a8:	00 00 00 
  80042047ab:	ff d2                	callq  *%rdx
}
  80042047ad:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  80042047b4:	5b                   	pop    %rbx
  80042047b5:	5d                   	pop    %rbp
  80042047b6:	c3                   	retq   

00000080042047b7 <check_va2pa>:
// this functionality for us!  We define our own version to help check
// the check_boot_pml4e() function; it shouldn't be used elsewhere.

static physaddr_t
check_va2pa(pml4e_t *pml4e, uintptr_t va)
{
  80042047b7:	55                   	push   %rbp
  80042047b8:	48 89 e5             	mov    %rsp,%rbp
  80042047bb:	48 83 ec 60          	sub    $0x60,%rsp
  80042047bf:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80042047c3:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	pte_t *pte;
	pdpe_t *pdpe;
	pde_t *pde;
	// cprintf("%x", va);
	pml4e = &pml4e[PML4(va)];
  80042047c7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042047cb:	48 c1 e8 27          	shr    $0x27,%rax
  80042047cf:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042047d4:	48 c1 e0 03          	shl    $0x3,%rax
  80042047d8:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	// cprintf(" %x %x " , PML4(va), *pml4e);
	if(!(*pml4e & PTE_P))
  80042047dc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042047e0:	48 8b 00             	mov    (%rax),%rax
  80042047e3:	83 e0 01             	and    $0x1,%eax
  80042047e6:	48 85 c0             	test   %rax,%rax
  80042047e9:	75 0c                	jne    80042047f7 <check_va2pa+0x40>
		return ~0;
  80042047eb:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80042047f2:	e9 38 02 00 00       	jmpq   8004204a2f <check_va2pa+0x278>
	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  80042047f7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042047fb:	48 8b 00             	mov    (%rax),%rax
  80042047fe:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204804:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204808:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420480c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204810:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004204813:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004204816:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  800420481d:	00 00 00 
  8004204820:	48 8b 00             	mov    (%rax),%rax
  8004204823:	48 39 c2             	cmp    %rax,%rdx
  8004204826:	72 32                	jb     800420485a <check_va2pa+0xa3>
  8004204828:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420482c:	48 89 c1             	mov    %rax,%rcx
  800420482f:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  8004204836:	00 00 00 
  8004204839:	be 1e 04 00 00       	mov    $0x41e,%esi
  800420483e:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204845:	00 00 00 
  8004204848:	b8 00 00 00 00       	mov    $0x0,%eax
  800420484d:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204854:	00 00 00 
  8004204857:	41 ff d0             	callq  *%r8
  800420485a:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204861:	00 00 00 
  8004204864:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204868:	48 01 d0             	add    %rdx,%rax
  800420486b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// cprintf(" %x %x " , pdpe, *pdpe);
	if (!(pdpe[PDPE(va)] & PTE_P))
  800420486f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204873:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004204877:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420487c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204883:	00 
  8004204884:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204888:	48 01 d0             	add    %rdx,%rax
  800420488b:	48 8b 00             	mov    (%rax),%rax
  800420488e:	83 e0 01             	and    $0x1,%eax
  8004204891:	48 85 c0             	test   %rax,%rax
  8004204894:	75 0c                	jne    80042048a2 <check_va2pa+0xeb>
		return ~0;
  8004204896:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  800420489d:	e9 8d 01 00 00       	jmpq   8004204a2f <check_va2pa+0x278>
	pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  80042048a2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042048a6:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042048aa:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042048af:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042048b6:	00 
  80042048b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042048bb:	48 01 d0             	add    %rdx,%rax
  80042048be:	48 8b 00             	mov    (%rax),%rax
  80042048c1:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042048c7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042048cb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042048cf:	48 c1 e8 0c          	shr    $0xc,%rax
  80042048d3:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042048d6:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042048d9:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  80042048e0:	00 00 00 
  80042048e3:	48 8b 00             	mov    (%rax),%rax
  80042048e6:	48 39 c2             	cmp    %rax,%rdx
  80042048e9:	72 32                	jb     800420491d <check_va2pa+0x166>
  80042048eb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042048ef:	48 89 c1             	mov    %rax,%rcx
  80042048f2:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  80042048f9:	00 00 00 
  80042048fc:	be 22 04 00 00       	mov    $0x422,%esi
  8004204901:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204908:	00 00 00 
  800420490b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204910:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204917:	00 00 00 
  800420491a:	41 ff d0             	callq  *%r8
  800420491d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204924:	00 00 00 
  8004204927:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420492b:	48 01 d0             	add    %rdx,%rax
  800420492e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	// cprintf(" %x %x " , pde, *pde);
	pde = &pde[PDX(va)];
  8004204932:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204936:	48 c1 e8 15          	shr    $0x15,%rax
  800420493a:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420493f:	48 c1 e0 03          	shl    $0x3,%rax
  8004204943:	48 01 45 d0          	add    %rax,-0x30(%rbp)
	if (!(*pde & PTE_P))
  8004204947:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420494b:	48 8b 00             	mov    (%rax),%rax
  800420494e:	83 e0 01             	and    $0x1,%eax
  8004204951:	48 85 c0             	test   %rax,%rax
  8004204954:	75 0c                	jne    8004204962 <check_va2pa+0x1ab>
		return ~0;
  8004204956:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  800420495d:	e9 cd 00 00 00       	jmpq   8004204a2f <check_va2pa+0x278>
	pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  8004204962:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204966:	48 8b 00             	mov    (%rax),%rax
  8004204969:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420496f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004204973:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204977:	48 c1 e8 0c          	shr    $0xc,%rax
  800420497b:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  800420497e:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004204981:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004204988:	00 00 00 
  800420498b:	48 8b 00             	mov    (%rax),%rax
  800420498e:	48 39 c2             	cmp    %rax,%rdx
  8004204991:	72 32                	jb     80042049c5 <check_va2pa+0x20e>
  8004204993:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204997:	48 89 c1             	mov    %rax,%rcx
  800420499a:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  80042049a1:	00 00 00 
  80042049a4:	be 27 04 00 00       	mov    $0x427,%esi
  80042049a9:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042049b0:	00 00 00 
  80042049b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042049b8:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042049bf:	00 00 00 
  80042049c2:	41 ff d0             	callq  *%r8
  80042049c5:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042049cc:	00 00 00 
  80042049cf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042049d3:	48 01 d0             	add    %rdx,%rax
  80042049d6:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	// cprintf(" %x %x " , pte, *pte);
	if (!(pte[PTX(va)] & PTE_P))
  80042049da:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042049de:	48 c1 e8 0c          	shr    $0xc,%rax
  80042049e2:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042049e7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042049ee:	00 
  80042049ef:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042049f3:	48 01 d0             	add    %rdx,%rax
  80042049f6:	48 8b 00             	mov    (%rax),%rax
  80042049f9:	83 e0 01             	and    $0x1,%eax
  80042049fc:	48 85 c0             	test   %rax,%rax
  80042049ff:	75 09                	jne    8004204a0a <check_va2pa+0x253>
		return ~0;
  8004204a01:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004204a08:	eb 25                	jmp    8004204a2f <check_va2pa+0x278>
	// cprintf(" %x %x\n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
	return PTE_ADDR(pte[PTX(va)]);
  8004204a0a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004204a0e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204a12:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204a17:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004204a1e:	00 
  8004204a1f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004204a23:	48 01 d0             	add    %rdx,%rax
  8004204a26:	48 8b 00             	mov    (%rax),%rax
  8004204a29:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  8004204a2f:	c9                   	leaveq 
  8004204a30:	c3                   	retq   

0000008004204a31 <page_check>:


// check page_insert, page_remove, &c
static void
page_check(void)
{
  8004204a31:	55                   	push   %rbp
  8004204a32:	48 89 e5             	mov    %rsp,%rbp
  8004204a35:	53                   	push   %rbx
  8004204a36:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
	pte_t *ptep, *ptep1;
	pdpe_t *pdpe;
	pde_t *pde;
	void *va;
	int i;
	pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  8004204a3d:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004204a44:	00 
  8004204a45:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204a49:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004204a4d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204a51:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004204a55:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204a59:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004204a5d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204a61:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004204a65:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004204a69:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	assert(pp0 = page_alloc(0));
  8004204a6d:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204a72:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  8004204a79:	00 00 00 
  8004204a7c:	ff d0                	callq  *%rax
  8004204a7e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004204a82:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004204a87:	75 35                	jne    8004204abe <page_check+0x8d>
  8004204a89:	48 b9 9f 27 21 04 80 	movabs $0x800421279f,%rcx
  8004204a90:	00 00 00 
  8004204a93:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204a9a:	00 00 00 
  8004204a9d:	be 3c 04 00 00       	mov    $0x43c,%esi
  8004204aa2:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204aa9:	00 00 00 
  8004204aac:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ab1:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204ab8:	00 00 00 
  8004204abb:	41 ff d0             	callq  *%r8
	assert(pp1 = page_alloc(0));
  8004204abe:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204ac3:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  8004204aca:	00 00 00 
  8004204acd:	ff d0                	callq  *%rax
  8004204acf:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004204ad3:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004204ad8:	75 35                	jne    8004204b0f <page_check+0xde>
  8004204ada:	48 b9 b3 27 21 04 80 	movabs $0x80042127b3,%rcx
  8004204ae1:	00 00 00 
  8004204ae4:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204aeb:	00 00 00 
  8004204aee:	be 3d 04 00 00       	mov    $0x43d,%esi
  8004204af3:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204afa:	00 00 00 
  8004204afd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b02:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204b09:	00 00 00 
  8004204b0c:	41 ff d0             	callq  *%r8
	assert(pp2 = page_alloc(0));
  8004204b0f:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204b14:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  8004204b1b:	00 00 00 
  8004204b1e:	ff d0                	callq  *%rax
  8004204b20:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004204b24:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004204b29:	75 35                	jne    8004204b60 <page_check+0x12f>
  8004204b2b:	48 b9 c7 27 21 04 80 	movabs $0x80042127c7,%rcx
  8004204b32:	00 00 00 
  8004204b35:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204b3c:	00 00 00 
  8004204b3f:	be 3e 04 00 00       	mov    $0x43e,%esi
  8004204b44:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204b4b:	00 00 00 
  8004204b4e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b53:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204b5a:	00 00 00 
  8004204b5d:	41 ff d0             	callq  *%r8
	assert(pp3 = page_alloc(0));
  8004204b60:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204b65:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  8004204b6c:	00 00 00 
  8004204b6f:	ff d0                	callq  *%rax
  8004204b71:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004204b75:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004204b7a:	75 35                	jne    8004204bb1 <page_check+0x180>
  8004204b7c:	48 b9 db 27 21 04 80 	movabs $0x80042127db,%rcx
  8004204b83:	00 00 00 
  8004204b86:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204b8d:	00 00 00 
  8004204b90:	be 3f 04 00 00       	mov    $0x43f,%esi
  8004204b95:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204b9c:	00 00 00 
  8004204b9f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ba4:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204bab:	00 00 00 
  8004204bae:	41 ff d0             	callq  *%r8
	assert(pp4 = page_alloc(0));
  8004204bb1:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204bb6:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  8004204bbd:	00 00 00 
  8004204bc0:	ff d0                	callq  *%rax
  8004204bc2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004204bc6:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004204bcb:	75 35                	jne    8004204c02 <page_check+0x1d1>
  8004204bcd:	48 b9 ef 27 21 04 80 	movabs $0x80042127ef,%rcx
  8004204bd4:	00 00 00 
  8004204bd7:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204bde:	00 00 00 
  8004204be1:	be 40 04 00 00       	mov    $0x440,%esi
  8004204be6:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204bed:	00 00 00 
  8004204bf0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204bf5:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204bfc:	00 00 00 
  8004204bff:	41 ff d0             	callq  *%r8
	assert(pp5 = page_alloc(0));
  8004204c02:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204c07:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  8004204c0e:	00 00 00 
  8004204c11:	ff d0                	callq  *%rax
  8004204c13:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204c17:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204c1c:	75 35                	jne    8004204c53 <page_check+0x222>
  8004204c1e:	48 b9 03 28 21 04 80 	movabs $0x8004212803,%rcx
  8004204c25:	00 00 00 
  8004204c28:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204c2f:	00 00 00 
  8004204c32:	be 41 04 00 00       	mov    $0x441,%esi
  8004204c37:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204c3e:	00 00 00 
  8004204c41:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c46:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204c4d:	00 00 00 
  8004204c50:	41 ff d0             	callq  *%r8

	assert(pp0);
  8004204c53:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004204c58:	75 35                	jne    8004204c8f <page_check+0x25e>
  8004204c5a:	48 b9 41 25 21 04 80 	movabs $0x8004212541,%rcx
  8004204c61:	00 00 00 
  8004204c64:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204c6b:	00 00 00 
  8004204c6e:	be 43 04 00 00       	mov    $0x443,%esi
  8004204c73:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204c7a:	00 00 00 
  8004204c7d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c82:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204c89:	00 00 00 
  8004204c8c:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204c8f:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004204c94:	74 0a                	je     8004204ca0 <page_check+0x26f>
  8004204c96:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004204c9a:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004204c9e:	75 35                	jne    8004204cd5 <page_check+0x2a4>
  8004204ca0:	48 b9 45 25 21 04 80 	movabs $0x8004212545,%rcx
  8004204ca7:	00 00 00 
  8004204caa:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204cb1:	00 00 00 
  8004204cb4:	be 44 04 00 00       	mov    $0x444,%esi
  8004204cb9:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204cc0:	00 00 00 
  8004204cc3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204cc8:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204ccf:	00 00 00 
  8004204cd2:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204cd5:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004204cda:	74 14                	je     8004204cf0 <page_check+0x2bf>
  8004204cdc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204ce0:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004204ce4:	74 0a                	je     8004204cf0 <page_check+0x2bf>
  8004204ce6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204cea:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004204cee:	75 35                	jne    8004204d25 <page_check+0x2f4>
  8004204cf0:	48 b9 58 25 21 04 80 	movabs $0x8004212558,%rcx
  8004204cf7:	00 00 00 
  8004204cfa:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204d01:	00 00 00 
  8004204d04:	be 45 04 00 00       	mov    $0x445,%esi
  8004204d09:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204d10:	00 00 00 
  8004204d13:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d18:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204d1f:	00 00 00 
  8004204d22:	41 ff d0             	callq  *%r8
	assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  8004204d25:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004204d2a:	74 1e                	je     8004204d4a <page_check+0x319>
  8004204d2c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204d30:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004204d34:	74 14                	je     8004204d4a <page_check+0x319>
  8004204d36:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204d3a:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004204d3e:	74 0a                	je     8004204d4a <page_check+0x319>
  8004204d40:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204d44:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004204d48:	75 35                	jne    8004204d7f <page_check+0x34e>
  8004204d4a:	48 b9 18 28 21 04 80 	movabs $0x8004212818,%rcx
  8004204d51:	00 00 00 
  8004204d54:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204d5b:	00 00 00 
  8004204d5e:	be 46 04 00 00       	mov    $0x446,%esi
  8004204d63:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204d6a:	00 00 00 
  8004204d6d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d72:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204d79:	00 00 00 
  8004204d7c:	41 ff d0             	callq  *%r8
	assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  8004204d7f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004204d84:	74 28                	je     8004204dae <page_check+0x37d>
  8004204d86:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204d8a:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004204d8e:	74 1e                	je     8004204dae <page_check+0x37d>
  8004204d90:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204d94:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004204d98:	74 14                	je     8004204dae <page_check+0x37d>
  8004204d9a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204d9e:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004204da2:	74 0a                	je     8004204dae <page_check+0x37d>
  8004204da4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204da8:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004204dac:	75 35                	jne    8004204de3 <page_check+0x3b2>
  8004204dae:	48 b9 48 28 21 04 80 	movabs $0x8004212848,%rcx
  8004204db5:	00 00 00 
  8004204db8:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204dbf:	00 00 00 
  8004204dc2:	be 47 04 00 00       	mov    $0x447,%esi
  8004204dc7:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204dce:	00 00 00 
  8004204dd1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204dd6:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204ddd:	00 00 00 
  8004204de0:	41 ff d0             	callq  *%r8
	assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  8004204de3:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204de8:	74 32                	je     8004204e1c <page_check+0x3eb>
  8004204dea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204dee:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004204df2:	74 28                	je     8004204e1c <page_check+0x3eb>
  8004204df4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204df8:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004204dfc:	74 1e                	je     8004204e1c <page_check+0x3eb>
  8004204dfe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204e02:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004204e06:	74 14                	je     8004204e1c <page_check+0x3eb>
  8004204e08:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204e0c:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004204e10:	74 0a                	je     8004204e1c <page_check+0x3eb>
  8004204e12:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204e16:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004204e1a:	75 35                	jne    8004204e51 <page_check+0x420>
  8004204e1c:	48 b9 88 28 21 04 80 	movabs $0x8004212888,%rcx
  8004204e23:	00 00 00 
  8004204e26:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204e2d:	00 00 00 
  8004204e30:	be 48 04 00 00       	mov    $0x448,%esi
  8004204e35:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204e3c:	00 00 00 
  8004204e3f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e44:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204e4b:	00 00 00 
  8004204e4e:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004204e51:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  8004204e58:	00 00 00 
  8004204e5b:	48 8b 00             	mov    (%rax),%rax
  8004204e5e:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	page_free_list = NULL;
  8004204e62:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  8004204e69:	00 00 00 
  8004204e6c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004204e73:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204e78:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  8004204e7f:	00 00 00 
  8004204e82:	ff d0                	callq  *%rax
  8004204e84:	48 85 c0             	test   %rax,%rax
  8004204e87:	74 35                	je     8004204ebe <page_check+0x48d>
  8004204e89:	48 b9 cf 25 21 04 80 	movabs $0x80042125cf,%rcx
  8004204e90:	00 00 00 
  8004204e93:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204e9a:	00 00 00 
  8004204e9d:	be 4f 04 00 00       	mov    $0x44f,%esi
  8004204ea2:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204ea9:	00 00 00 
  8004204eac:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204eb1:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204eb8:	00 00 00 
  8004204ebb:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
	assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  8004204ebe:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004204ec5:	00 00 00 
  8004204ec8:	48 8b 00             	mov    (%rax),%rax
  8004204ecb:	48 8d 95 f0 fe ff ff 	lea    -0x110(%rbp),%rdx
  8004204ed2:	be 00 00 00 00       	mov    $0x0,%esi
  8004204ed7:	48 89 c7             	mov    %rax,%rdi
  8004204eda:	48 b8 f8 2e 20 04 80 	movabs $0x8004202ef8,%rax
  8004204ee1:	00 00 00 
  8004204ee4:	ff d0                	callq  *%rax
  8004204ee6:	48 85 c0             	test   %rax,%rax
  8004204ee9:	74 35                	je     8004204f20 <page_check+0x4ef>
  8004204eeb:	48 b9 d8 28 21 04 80 	movabs $0x80042128d8,%rcx
  8004204ef2:	00 00 00 
  8004204ef5:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204efc:	00 00 00 
  8004204eff:	be 52 04 00 00       	mov    $0x452,%esi
  8004204f04:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204f0b:	00 00 00 
  8004204f0e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f13:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204f1a:	00 00 00 
  8004204f1d:	41 ff d0             	callq  *%r8

	// there is no free memory, so we can't allocate a page table 
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004204f20:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004204f27:	00 00 00 
  8004204f2a:	48 8b 00             	mov    (%rax),%rax
  8004204f2d:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004204f31:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004204f36:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204f3b:	48 89 c7             	mov    %rax,%rdi
  8004204f3e:	48 b8 3f 2e 20 04 80 	movabs $0x8004202e3f,%rax
  8004204f45:	00 00 00 
  8004204f48:	ff d0                	callq  *%rax
  8004204f4a:	85 c0                	test   %eax,%eax
  8004204f4c:	78 35                	js     8004204f83 <page_check+0x552>
  8004204f4e:	48 b9 10 29 21 04 80 	movabs $0x8004212910,%rcx
  8004204f55:	00 00 00 
  8004204f58:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204f5f:	00 00 00 
  8004204f62:	be 55 04 00 00       	mov    $0x455,%esi
  8004204f67:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204f6e:	00 00 00 
  8004204f71:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f76:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204f7d:	00 00 00 
  8004204f80:	41 ff d0             	callq  *%r8

	// free pp0 and try again: pp0 should be used for page table
	page_free(pp0);
  8004204f83:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004204f87:	48 89 c7             	mov    %rax,%rdi
  8004204f8a:	48 b8 f2 25 20 04 80 	movabs $0x80042025f2,%rax
  8004204f91:	00 00 00 
  8004204f94:	ff d0                	callq  *%rax
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004204f96:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004204f9d:	00 00 00 
  8004204fa0:	48 8b 00             	mov    (%rax),%rax
  8004204fa3:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004204fa7:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004204fac:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204fb1:	48 89 c7             	mov    %rax,%rdi
  8004204fb4:	48 b8 3f 2e 20 04 80 	movabs $0x8004202e3f,%rax
  8004204fbb:	00 00 00 
  8004204fbe:	ff d0                	callq  *%rax
  8004204fc0:	85 c0                	test   %eax,%eax
  8004204fc2:	78 35                	js     8004204ff9 <page_check+0x5c8>
  8004204fc4:	48 b9 10 29 21 04 80 	movabs $0x8004212910,%rcx
  8004204fcb:	00 00 00 
  8004204fce:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004204fd5:	00 00 00 
  8004204fd8:	be 59 04 00 00       	mov    $0x459,%esi
  8004204fdd:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004204fe4:	00 00 00 
  8004204fe7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204fec:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004204ff3:	00 00 00 
  8004204ff6:	41 ff d0             	callq  *%r8
	page_free(pp2);
  8004204ff9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204ffd:	48 89 c7             	mov    %rax,%rdi
  8004205000:	48 b8 f2 25 20 04 80 	movabs $0x80042025f2,%rax
  8004205007:	00 00 00 
  800420500a:	ff d0                	callq  *%rax
	page_free(pp3);
  800420500c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205010:	48 89 c7             	mov    %rax,%rdi
  8004205013:	48 b8 f2 25 20 04 80 	movabs $0x80042025f2,%rax
  800420501a:	00 00 00 
  800420501d:	ff d0                	callq  *%rax
	//cprintf("pp1 ref count = %d\n",pp1->pp_ref);
	//cprintf("pp0 ref count = %d\n",pp0->pp_ref);
	//cprintf("pp2 ref count = %d\n",pp2->pp_ref);
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  800420501f:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004205026:	00 00 00 
  8004205029:	48 8b 00             	mov    (%rax),%rax
  800420502c:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205030:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205035:	ba 00 00 00 00       	mov    $0x0,%edx
  800420503a:	48 89 c7             	mov    %rax,%rdi
  800420503d:	48 b8 3f 2e 20 04 80 	movabs $0x8004202e3f,%rax
  8004205044:	00 00 00 
  8004205047:	ff d0                	callq  *%rax
  8004205049:	85 c0                	test   %eax,%eax
  800420504b:	74 35                	je     8004205082 <page_check+0x651>
  800420504d:	48 b9 40 29 21 04 80 	movabs $0x8004212940,%rcx
  8004205054:	00 00 00 
  8004205057:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420505e:	00 00 00 
  8004205061:	be 5f 04 00 00       	mov    $0x45f,%esi
  8004205066:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420506d:	00 00 00 
  8004205070:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205075:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420507c:	00 00 00 
  800420507f:	41 ff d0             	callq  *%r8
	assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  8004205082:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004205089:	00 00 00 
  800420508c:	48 8b 00             	mov    (%rax),%rax
  800420508f:	48 8b 00             	mov    (%rax),%rax
  8004205092:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205098:	48 89 c3             	mov    %rax,%rbx
  800420509b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420509f:	48 89 c7             	mov    %rax,%rdi
  80042050a2:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  80042050a9:	00 00 00 
  80042050ac:	ff d0                	callq  *%rax
  80042050ae:	48 39 c3             	cmp    %rax,%rbx
  80042050b1:	0f 84 97 00 00 00    	je     800420514e <page_check+0x71d>
  80042050b7:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  80042050be:	00 00 00 
  80042050c1:	48 8b 00             	mov    (%rax),%rax
  80042050c4:	48 8b 00             	mov    (%rax),%rax
  80042050c7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042050cd:	48 89 c3             	mov    %rax,%rbx
  80042050d0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042050d4:	48 89 c7             	mov    %rax,%rdi
  80042050d7:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  80042050de:	00 00 00 
  80042050e1:	ff d0                	callq  *%rax
  80042050e3:	48 39 c3             	cmp    %rax,%rbx
  80042050e6:	74 66                	je     800420514e <page_check+0x71d>
  80042050e8:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  80042050ef:	00 00 00 
  80042050f2:	48 8b 00             	mov    (%rax),%rax
  80042050f5:	48 8b 00             	mov    (%rax),%rax
  80042050f8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042050fe:	48 89 c3             	mov    %rax,%rbx
  8004205101:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205105:	48 89 c7             	mov    %rax,%rdi
  8004205108:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  800420510f:	00 00 00 
  8004205112:	ff d0                	callq  *%rax
  8004205114:	48 39 c3             	cmp    %rax,%rbx
  8004205117:	74 35                	je     800420514e <page_check+0x71d>
  8004205119:	48 b9 70 29 21 04 80 	movabs $0x8004212970,%rcx
  8004205120:	00 00 00 
  8004205123:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420512a:	00 00 00 
  800420512d:	be 60 04 00 00       	mov    $0x460,%esi
  8004205132:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205139:	00 00 00 
  800420513c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205141:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205148:	00 00 00 
  800420514b:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  800420514e:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004205155:	00 00 00 
  8004205158:	48 8b 00             	mov    (%rax),%rax
  800420515b:	be 00 00 00 00       	mov    $0x0,%esi
  8004205160:	48 89 c7             	mov    %rax,%rdi
  8004205163:	48 b8 b7 47 20 04 80 	movabs $0x80042047b7,%rax
  800420516a:	00 00 00 
  800420516d:	ff d0                	callq  *%rax
  800420516f:	48 89 c3             	mov    %rax,%rbx
  8004205172:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205176:	48 89 c7             	mov    %rax,%rdi
  8004205179:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  8004205180:	00 00 00 
  8004205183:	ff d0                	callq  *%rax
  8004205185:	48 39 c3             	cmp    %rax,%rbx
  8004205188:	74 35                	je     80042051bf <page_check+0x78e>
  800420518a:	48 b9 f8 29 21 04 80 	movabs $0x80042129f8,%rcx
  8004205191:	00 00 00 
  8004205194:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420519b:	00 00 00 
  800420519e:	be 61 04 00 00       	mov    $0x461,%esi
  80042051a3:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042051aa:	00 00 00 
  80042051ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80042051b2:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042051b9:	00 00 00 
  80042051bc:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  80042051bf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042051c3:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042051c7:	66 83 f8 01          	cmp    $0x1,%ax
  80042051cb:	74 35                	je     8004205202 <page_check+0x7d1>
  80042051cd:	48 b9 25 2a 21 04 80 	movabs $0x8004212a25,%rcx
  80042051d4:	00 00 00 
  80042051d7:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042051de:	00 00 00 
  80042051e1:	be 62 04 00 00       	mov    $0x462,%esi
  80042051e6:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042051ed:	00 00 00 
  80042051f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042051f5:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042051fc:	00 00 00 
  80042051ff:	41 ff d0             	callq  *%r8
	assert(pp0->pp_ref == 1);
  8004205202:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205206:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420520a:	66 83 f8 01          	cmp    $0x1,%ax
  800420520e:	74 35                	je     8004205245 <page_check+0x814>
  8004205210:	48 b9 36 2a 21 04 80 	movabs $0x8004212a36,%rcx
  8004205217:	00 00 00 
  800420521a:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205221:	00 00 00 
  8004205224:	be 63 04 00 00       	mov    $0x463,%esi
  8004205229:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205230:	00 00 00 
  8004205233:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205238:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420523f:	00 00 00 
  8004205242:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 1);
  8004205245:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205249:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420524d:	66 83 f8 01          	cmp    $0x1,%ax
  8004205251:	74 35                	je     8004205288 <page_check+0x857>
  8004205253:	48 b9 47 2a 21 04 80 	movabs $0x8004212a47,%rcx
  800420525a:	00 00 00 
  800420525d:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205264:	00 00 00 
  8004205267:	be 64 04 00 00       	mov    $0x464,%esi
  800420526c:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205273:	00 00 00 
  8004205276:	b8 00 00 00 00       	mov    $0x0,%eax
  800420527b:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205282:	00 00 00 
  8004205285:	41 ff d0             	callq  *%r8
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004205288:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  800420528f:	00 00 00 
  8004205292:	48 8b 00             	mov    (%rax),%rax
  8004205295:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205299:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420529e:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042052a3:	48 89 c7             	mov    %rax,%rdi
  80042052a6:	48 b8 3f 2e 20 04 80 	movabs $0x8004202e3f,%rax
  80042052ad:	00 00 00 
  80042052b0:	ff d0                	callq  *%rax
  80042052b2:	85 c0                	test   %eax,%eax
  80042052b4:	74 35                	je     80042052eb <page_check+0x8ba>
  80042052b6:	48 b9 58 2a 21 04 80 	movabs $0x8004212a58,%rcx
  80042052bd:	00 00 00 
  80042052c0:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042052c7:	00 00 00 
  80042052ca:	be 66 04 00 00       	mov    $0x466,%esi
  80042052cf:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042052d6:	00 00 00 
  80042052d9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042052de:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042052e5:	00 00 00 
  80042052e8:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  80042052eb:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  80042052f2:	00 00 00 
  80042052f5:	48 8b 00             	mov    (%rax),%rax
  80042052f8:	be 00 10 00 00       	mov    $0x1000,%esi
  80042052fd:	48 89 c7             	mov    %rax,%rdi
  8004205300:	48 b8 b7 47 20 04 80 	movabs $0x80042047b7,%rax
  8004205307:	00 00 00 
  800420530a:	ff d0                	callq  *%rax
  800420530c:	48 89 c3             	mov    %rax,%rbx
  800420530f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205313:	48 89 c7             	mov    %rax,%rdi
  8004205316:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  800420531d:	00 00 00 
  8004205320:	ff d0                	callq  *%rax
  8004205322:	48 39 c3             	cmp    %rax,%rbx
  8004205325:	74 35                	je     800420535c <page_check+0x92b>
  8004205327:	48 b9 90 2a 21 04 80 	movabs $0x8004212a90,%rcx
  800420532e:	00 00 00 
  8004205331:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205338:	00 00 00 
  800420533b:	be 67 04 00 00       	mov    $0x467,%esi
  8004205340:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205347:	00 00 00 
  800420534a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420534f:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205356:	00 00 00 
  8004205359:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  800420535c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205360:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205364:	66 83 f8 02          	cmp    $0x2,%ax
  8004205368:	74 35                	je     800420539f <page_check+0x96e>
  800420536a:	48 b9 c0 2a 21 04 80 	movabs $0x8004212ac0,%rcx
  8004205371:	00 00 00 
  8004205374:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420537b:	00 00 00 
  800420537e:	be 68 04 00 00       	mov    $0x468,%esi
  8004205383:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420538a:	00 00 00 
  800420538d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205392:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205399:	00 00 00 
  800420539c:	41 ff d0             	callq  *%r8

	// should be no free memory
	assert(!page_alloc(0));
  800420539f:	bf 00 00 00 00       	mov    $0x0,%edi
  80042053a4:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  80042053ab:	00 00 00 
  80042053ae:	ff d0                	callq  *%rax
  80042053b0:	48 85 c0             	test   %rax,%rax
  80042053b3:	74 35                	je     80042053ea <page_check+0x9b9>
  80042053b5:	48 b9 cf 25 21 04 80 	movabs $0x80042125cf,%rcx
  80042053bc:	00 00 00 
  80042053bf:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042053c6:	00 00 00 
  80042053c9:	be 6b 04 00 00       	mov    $0x46b,%esi
  80042053ce:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042053d5:	00 00 00 
  80042053d8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042053dd:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042053e4:	00 00 00 
  80042053e7:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  80042053ea:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  80042053f1:	00 00 00 
  80042053f4:	48 8b 00             	mov    (%rax),%rax
  80042053f7:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042053fb:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205400:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205405:	48 89 c7             	mov    %rax,%rdi
  8004205408:	48 b8 3f 2e 20 04 80 	movabs $0x8004202e3f,%rax
  800420540f:	00 00 00 
  8004205412:	ff d0                	callq  *%rax
  8004205414:	85 c0                	test   %eax,%eax
  8004205416:	74 35                	je     800420544d <page_check+0xa1c>
  8004205418:	48 b9 58 2a 21 04 80 	movabs $0x8004212a58,%rcx
  800420541f:	00 00 00 
  8004205422:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205429:	00 00 00 
  800420542c:	be 6e 04 00 00       	mov    $0x46e,%esi
  8004205431:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205438:	00 00 00 
  800420543b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205440:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205447:	00 00 00 
  800420544a:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  800420544d:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004205454:	00 00 00 
  8004205457:	48 8b 00             	mov    (%rax),%rax
  800420545a:	be 00 10 00 00       	mov    $0x1000,%esi
  800420545f:	48 89 c7             	mov    %rax,%rdi
  8004205462:	48 b8 b7 47 20 04 80 	movabs $0x80042047b7,%rax
  8004205469:	00 00 00 
  800420546c:	ff d0                	callq  *%rax
  800420546e:	48 89 c3             	mov    %rax,%rbx
  8004205471:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205475:	48 89 c7             	mov    %rax,%rdi
  8004205478:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  800420547f:	00 00 00 
  8004205482:	ff d0                	callq  *%rax
  8004205484:	48 39 c3             	cmp    %rax,%rbx
  8004205487:	74 35                	je     80042054be <page_check+0xa8d>
  8004205489:	48 b9 90 2a 21 04 80 	movabs $0x8004212a90,%rcx
  8004205490:	00 00 00 
  8004205493:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420549a:	00 00 00 
  800420549d:	be 6f 04 00 00       	mov    $0x46f,%esi
  80042054a2:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042054a9:	00 00 00 
  80042054ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054b1:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042054b8:	00 00 00 
  80042054bb:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  80042054be:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042054c2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042054c6:	66 83 f8 02          	cmp    $0x2,%ax
  80042054ca:	74 35                	je     8004205501 <page_check+0xad0>
  80042054cc:	48 b9 c0 2a 21 04 80 	movabs $0x8004212ac0,%rcx
  80042054d3:	00 00 00 
  80042054d6:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042054dd:	00 00 00 
  80042054e0:	be 70 04 00 00       	mov    $0x470,%esi
  80042054e5:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042054ec:	00 00 00 
  80042054ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054f4:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042054fb:	00 00 00 
  80042054fe:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));
  8004205501:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205506:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  800420550d:	00 00 00 
  8004205510:	ff d0                	callq  *%rax
  8004205512:	48 85 c0             	test   %rax,%rax
  8004205515:	74 35                	je     800420554c <page_check+0xb1b>
  8004205517:	48 b9 cf 25 21 04 80 	movabs $0x80042125cf,%rcx
  800420551e:	00 00 00 
  8004205521:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205528:	00 00 00 
  800420552b:	be 74 04 00 00       	mov    $0x474,%esi
  8004205530:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205537:	00 00 00 
  800420553a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420553f:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205546:	00 00 00 
  8004205549:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  800420554c:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004205553:	00 00 00 
  8004205556:	48 8b 00             	mov    (%rax),%rax
  8004205559:	48 8b 00             	mov    (%rax),%rax
  800420555c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205562:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  8004205566:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420556a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420556e:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  8004205571:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004205574:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  800420557b:	00 00 00 
  800420557e:	48 8b 00             	mov    (%rax),%rax
  8004205581:	48 39 c2             	cmp    %rax,%rdx
  8004205584:	72 32                	jb     80042055b8 <page_check+0xb87>
  8004205586:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420558a:	48 89 c1             	mov    %rax,%rcx
  800420558d:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  8004205594:	00 00 00 
  8004205597:	be 76 04 00 00       	mov    $0x476,%esi
  800420559c:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042055a3:	00 00 00 
  80042055a6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042055ab:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042055b2:	00 00 00 
  80042055b5:	41 ff d0             	callq  *%r8
  80042055b8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042055bf:	00 00 00 
  80042055c2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042055c6:	48 01 d0             	add    %rdx,%rax
  80042055c9:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  80042055cd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042055d1:	48 8b 00             	mov    (%rax),%rax
  80042055d4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042055da:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  80042055de:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042055e2:	48 c1 e8 0c          	shr    $0xc,%rax
  80042055e6:	89 45 8c             	mov    %eax,-0x74(%rbp)
  80042055e9:	8b 55 8c             	mov    -0x74(%rbp),%edx
  80042055ec:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  80042055f3:	00 00 00 
  80042055f6:	48 8b 00             	mov    (%rax),%rax
  80042055f9:	48 39 c2             	cmp    %rax,%rdx
  80042055fc:	72 32                	jb     8004205630 <page_check+0xbff>
  80042055fe:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205602:	48 89 c1             	mov    %rax,%rcx
  8004205605:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  800420560c:	00 00 00 
  800420560f:	be 77 04 00 00       	mov    $0x477,%esi
  8004205614:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420561b:	00 00 00 
  800420561e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205623:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420562a:	00 00 00 
  800420562d:	41 ff d0             	callq  *%r8
  8004205630:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205637:	00 00 00 
  800420563a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420563e:	48 01 d0             	add    %rdx,%rax
  8004205641:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  8004205645:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004205649:	48 8b 00             	mov    (%rax),%rax
  800420564c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205652:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004205659:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205660:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205664:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  800420566a:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  8004205670:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004205677:	00 00 00 
  800420567a:	48 8b 00             	mov    (%rax),%rax
  800420567d:	48 39 c2             	cmp    %rax,%rdx
  8004205680:	72 35                	jb     80042056b7 <page_check+0xc86>
  8004205682:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205689:	48 89 c1             	mov    %rax,%rcx
  800420568c:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  8004205693:	00 00 00 
  8004205696:	be 78 04 00 00       	mov    $0x478,%esi
  800420569b:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042056a2:	00 00 00 
  80042056a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042056aa:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042056b1:	00 00 00 
  80042056b4:	41 ff d0             	callq  *%r8
  80042056b7:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042056be:	00 00 00 
  80042056c1:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042056c8:	48 01 d0             	add    %rdx,%rax
  80042056cb:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  80042056d2:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  80042056d9:	00 00 00 
  80042056dc:	48 8b 00             	mov    (%rax),%rax
  80042056df:	ba 00 00 00 00       	mov    $0x0,%edx
  80042056e4:	be 00 10 00 00       	mov    $0x1000,%esi
  80042056e9:	48 89 c7             	mov    %rax,%rdi
  80042056ec:	48 b8 a9 26 20 04 80 	movabs $0x80042026a9,%rax
  80042056f3:	00 00 00 
  80042056f6:	ff d0                	callq  *%rax
  80042056f8:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  80042056ff:	48 83 c2 08          	add    $0x8,%rdx
  8004205703:	48 39 d0             	cmp    %rdx,%rax
  8004205706:	74 35                	je     800420573d <page_check+0xd0c>
  8004205708:	48 b9 d8 2a 21 04 80 	movabs $0x8004212ad8,%rcx
  800420570f:	00 00 00 
  8004205712:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205719:	00 00 00 
  800420571c:	be 79 04 00 00       	mov    $0x479,%esi
  8004205721:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205728:	00 00 00 
  800420572b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205730:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205737:	00 00 00 
  800420573a:	41 ff d0             	callq  *%r8

	// should be able to change permissions too.
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  800420573d:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004205744:	00 00 00 
  8004205747:	48 8b 00             	mov    (%rax),%rax
  800420574a:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420574e:	b9 04 00 00 00       	mov    $0x4,%ecx
  8004205753:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205758:	48 89 c7             	mov    %rax,%rdi
  800420575b:	48 b8 3f 2e 20 04 80 	movabs $0x8004202e3f,%rax
  8004205762:	00 00 00 
  8004205765:	ff d0                	callq  *%rax
  8004205767:	85 c0                	test   %eax,%eax
  8004205769:	74 35                	je     80042057a0 <page_check+0xd6f>
  800420576b:	48 b9 18 2b 21 04 80 	movabs $0x8004212b18,%rcx
  8004205772:	00 00 00 
  8004205775:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420577c:	00 00 00 
  800420577f:	be 7c 04 00 00       	mov    $0x47c,%esi
  8004205784:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420578b:	00 00 00 
  800420578e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205793:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420579a:	00 00 00 
  800420579d:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  80042057a0:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  80042057a7:	00 00 00 
  80042057aa:	48 8b 00             	mov    (%rax),%rax
  80042057ad:	be 00 10 00 00       	mov    $0x1000,%esi
  80042057b2:	48 89 c7             	mov    %rax,%rdi
  80042057b5:	48 b8 b7 47 20 04 80 	movabs $0x80042047b7,%rax
  80042057bc:	00 00 00 
  80042057bf:	ff d0                	callq  *%rax
  80042057c1:	48 89 c3             	mov    %rax,%rbx
  80042057c4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042057c8:	48 89 c7             	mov    %rax,%rdi
  80042057cb:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  80042057d2:	00 00 00 
  80042057d5:	ff d0                	callq  *%rax
  80042057d7:	48 39 c3             	cmp    %rax,%rbx
  80042057da:	74 35                	je     8004205811 <page_check+0xde0>
  80042057dc:	48 b9 90 2a 21 04 80 	movabs $0x8004212a90,%rcx
  80042057e3:	00 00 00 
  80042057e6:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042057ed:	00 00 00 
  80042057f0:	be 7d 04 00 00       	mov    $0x47d,%esi
  80042057f5:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042057fc:	00 00 00 
  80042057ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205804:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420580b:	00 00 00 
  800420580e:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004205811:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205815:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205819:	66 83 f8 02          	cmp    $0x2,%ax
  800420581d:	74 35                	je     8004205854 <page_check+0xe23>
  800420581f:	48 b9 c0 2a 21 04 80 	movabs $0x8004212ac0,%rcx
  8004205826:	00 00 00 
  8004205829:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205830:	00 00 00 
  8004205833:	be 7e 04 00 00       	mov    $0x47e,%esi
  8004205838:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420583f:	00 00 00 
  8004205842:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205847:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420584e:	00 00 00 
  8004205851:	41 ff d0             	callq  *%r8
	assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  8004205854:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  800420585b:	00 00 00 
  800420585e:	48 8b 00             	mov    (%rax),%rax
  8004205861:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205866:	be 00 10 00 00       	mov    $0x1000,%esi
  800420586b:	48 89 c7             	mov    %rax,%rdi
  800420586e:	48 b8 a9 26 20 04 80 	movabs $0x80042026a9,%rax
  8004205875:	00 00 00 
  8004205878:	ff d0                	callq  *%rax
  800420587a:	48 8b 00             	mov    (%rax),%rax
  800420587d:	83 e0 04             	and    $0x4,%eax
  8004205880:	48 85 c0             	test   %rax,%rax
  8004205883:	75 35                	jne    80042058ba <page_check+0xe89>
  8004205885:	48 b9 58 2b 21 04 80 	movabs $0x8004212b58,%rcx
  800420588c:	00 00 00 
  800420588f:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205896:	00 00 00 
  8004205899:	be 7f 04 00 00       	mov    $0x47f,%esi
  800420589e:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042058a5:	00 00 00 
  80042058a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042058ad:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042058b4:	00 00 00 
  80042058b7:	41 ff d0             	callq  *%r8
	assert(boot_pml4e[0] & PTE_U);
  80042058ba:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  80042058c1:	00 00 00 
  80042058c4:	48 8b 00             	mov    (%rax),%rax
  80042058c7:	48 8b 00             	mov    (%rax),%rax
  80042058ca:	83 e0 04             	and    $0x4,%eax
  80042058cd:	48 85 c0             	test   %rax,%rax
  80042058d0:	75 35                	jne    8004205907 <page_check+0xed6>
  80042058d2:	48 b9 8b 2b 21 04 80 	movabs $0x8004212b8b,%rcx
  80042058d9:	00 00 00 
  80042058dc:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042058e3:	00 00 00 
  80042058e6:	be 80 04 00 00       	mov    $0x480,%esi
  80042058eb:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042058f2:	00 00 00 
  80042058f5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042058fa:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205901:	00 00 00 
  8004205904:	41 ff d0             	callq  *%r8


	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  8004205907:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  800420590e:	00 00 00 
  8004205911:	48 8b 00             	mov    (%rax),%rax
  8004205914:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004205918:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420591d:	ba 00 00 20 00       	mov    $0x200000,%edx
  8004205922:	48 89 c7             	mov    %rax,%rdi
  8004205925:	48 b8 3f 2e 20 04 80 	movabs $0x8004202e3f,%rax
  800420592c:	00 00 00 
  800420592f:	ff d0                	callq  *%rax
  8004205931:	85 c0                	test   %eax,%eax
  8004205933:	78 35                	js     800420596a <page_check+0xf39>
  8004205935:	48 b9 a8 2b 21 04 80 	movabs $0x8004212ba8,%rcx
  800420593c:	00 00 00 
  800420593f:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205946:	00 00 00 
  8004205949:	be 84 04 00 00       	mov    $0x484,%esi
  800420594e:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205955:	00 00 00 
  8004205958:	b8 00 00 00 00       	mov    $0x0,%eax
  800420595d:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205964:	00 00 00 
  8004205967:	41 ff d0             	callq  *%r8

	// insert pp1 at PGSIZE (replacing pp3)
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  800420596a:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004205971:	00 00 00 
  8004205974:	48 8b 00             	mov    (%rax),%rax
  8004205977:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420597b:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205980:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205985:	48 89 c7             	mov    %rax,%rdi
  8004205988:	48 b8 3f 2e 20 04 80 	movabs $0x8004202e3f,%rax
  800420598f:	00 00 00 
  8004205992:	ff d0                	callq  *%rax
  8004205994:	85 c0                	test   %eax,%eax
  8004205996:	74 35                	je     80042059cd <page_check+0xf9c>
  8004205998:	48 b9 e0 2b 21 04 80 	movabs $0x8004212be0,%rcx
  800420599f:	00 00 00 
  80042059a2:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042059a9:	00 00 00 
  80042059ac:	be 87 04 00 00       	mov    $0x487,%esi
  80042059b1:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042059b8:	00 00 00 
  80042059bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042059c0:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042059c7:	00 00 00 
  80042059ca:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  80042059cd:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  80042059d4:	00 00 00 
  80042059d7:	48 8b 00             	mov    (%rax),%rax
  80042059da:	ba 00 00 00 00       	mov    $0x0,%edx
  80042059df:	be 00 10 00 00       	mov    $0x1000,%esi
  80042059e4:	48 89 c7             	mov    %rax,%rdi
  80042059e7:	48 b8 a9 26 20 04 80 	movabs $0x80042026a9,%rax
  80042059ee:	00 00 00 
  80042059f1:	ff d0                	callq  *%rax
  80042059f3:	48 8b 00             	mov    (%rax),%rax
  80042059f6:	83 e0 04             	and    $0x4,%eax
  80042059f9:	48 85 c0             	test   %rax,%rax
  80042059fc:	74 35                	je     8004205a33 <page_check+0x1002>
  80042059fe:	48 b9 18 2c 21 04 80 	movabs $0x8004212c18,%rcx
  8004205a05:	00 00 00 
  8004205a08:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205a0f:	00 00 00 
  8004205a12:	be 88 04 00 00       	mov    $0x488,%esi
  8004205a17:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205a1e:	00 00 00 
  8004205a21:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a26:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205a2d:	00 00 00 
  8004205a30:	41 ff d0             	callq  *%r8

	// should have pp1 at both 0 and PGSIZE
	assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  8004205a33:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004205a3a:	00 00 00 
  8004205a3d:	48 8b 00             	mov    (%rax),%rax
  8004205a40:	be 00 00 00 00       	mov    $0x0,%esi
  8004205a45:	48 89 c7             	mov    %rax,%rdi
  8004205a48:	48 b8 b7 47 20 04 80 	movabs $0x80042047b7,%rax
  8004205a4f:	00 00 00 
  8004205a52:	ff d0                	callq  *%rax
  8004205a54:	48 89 c3             	mov    %rax,%rbx
  8004205a57:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205a5b:	48 89 c7             	mov    %rax,%rdi
  8004205a5e:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  8004205a65:	00 00 00 
  8004205a68:	ff d0                	callq  *%rax
  8004205a6a:	48 39 c3             	cmp    %rax,%rbx
  8004205a6d:	74 35                	je     8004205aa4 <page_check+0x1073>
  8004205a6f:	48 b9 50 2c 21 04 80 	movabs $0x8004212c50,%rcx
  8004205a76:	00 00 00 
  8004205a79:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205a80:	00 00 00 
  8004205a83:	be 8b 04 00 00       	mov    $0x48b,%esi
  8004205a88:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205a8f:	00 00 00 
  8004205a92:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a97:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205a9e:	00 00 00 
  8004205aa1:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004205aa4:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004205aab:	00 00 00 
  8004205aae:	48 8b 00             	mov    (%rax),%rax
  8004205ab1:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205ab6:	48 89 c7             	mov    %rax,%rdi
  8004205ab9:	48 b8 b7 47 20 04 80 	movabs $0x80042047b7,%rax
  8004205ac0:	00 00 00 
  8004205ac3:	ff d0                	callq  *%rax
  8004205ac5:	48 89 c3             	mov    %rax,%rbx
  8004205ac8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205acc:	48 89 c7             	mov    %rax,%rdi
  8004205acf:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  8004205ad6:	00 00 00 
  8004205ad9:	ff d0                	callq  *%rax
  8004205adb:	48 39 c3             	cmp    %rax,%rbx
  8004205ade:	74 35                	je     8004205b15 <page_check+0x10e4>
  8004205ae0:	48 b9 80 2c 21 04 80 	movabs $0x8004212c80,%rcx
  8004205ae7:	00 00 00 
  8004205aea:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205af1:	00 00 00 
  8004205af4:	be 8c 04 00 00       	mov    $0x48c,%esi
  8004205af9:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205b00:	00 00 00 
  8004205b03:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b08:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205b0f:	00 00 00 
  8004205b12:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
  8004205b15:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205b19:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205b1d:	66 83 f8 02          	cmp    $0x2,%ax
  8004205b21:	74 35                	je     8004205b58 <page_check+0x1127>
  8004205b23:	48 b9 b0 2c 21 04 80 	movabs $0x8004212cb0,%rcx
  8004205b2a:	00 00 00 
  8004205b2d:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205b34:	00 00 00 
  8004205b37:	be 8e 04 00 00       	mov    $0x48e,%esi
  8004205b3c:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205b43:	00 00 00 
  8004205b46:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b4b:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205b52:	00 00 00 
  8004205b55:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004205b58:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205b5c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205b60:	66 83 f8 01          	cmp    $0x1,%ax
  8004205b64:	74 35                	je     8004205b9b <page_check+0x116a>
  8004205b66:	48 b9 c1 2c 21 04 80 	movabs $0x8004212cc1,%rcx
  8004205b6d:	00 00 00 
  8004205b70:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205b77:	00 00 00 
  8004205b7a:	be 8f 04 00 00       	mov    $0x48f,%esi
  8004205b7f:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205b86:	00 00 00 
  8004205b89:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b8e:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205b95:	00 00 00 
  8004205b98:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(boot_pml4e, 0x0);
  8004205b9b:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004205ba2:	00 00 00 
  8004205ba5:	48 8b 00             	mov    (%rax),%rax
  8004205ba8:	be 00 00 00 00       	mov    $0x0,%esi
  8004205bad:	48 89 c7             	mov    %rax,%rdi
  8004205bb0:	48 b8 8c 2f 20 04 80 	movabs $0x8004202f8c,%rax
  8004205bb7:	00 00 00 
  8004205bba:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004205bbc:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004205bc3:	00 00 00 
  8004205bc6:	48 8b 00             	mov    (%rax),%rax
  8004205bc9:	be 00 00 00 00       	mov    $0x0,%esi
  8004205bce:	48 89 c7             	mov    %rax,%rdi
  8004205bd1:	48 b8 b7 47 20 04 80 	movabs $0x80042047b7,%rax
  8004205bd8:	00 00 00 
  8004205bdb:	ff d0                	callq  *%rax
  8004205bdd:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004205be1:	74 35                	je     8004205c18 <page_check+0x11e7>
  8004205be3:	48 b9 d8 2c 21 04 80 	movabs $0x8004212cd8,%rcx
  8004205bea:	00 00 00 
  8004205bed:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205bf4:	00 00 00 
  8004205bf7:	be 94 04 00 00       	mov    $0x494,%esi
  8004205bfc:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205c03:	00 00 00 
  8004205c06:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c0b:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205c12:	00 00 00 
  8004205c15:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004205c18:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004205c1f:	00 00 00 
  8004205c22:	48 8b 00             	mov    (%rax),%rax
  8004205c25:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205c2a:	48 89 c7             	mov    %rax,%rdi
  8004205c2d:	48 b8 b7 47 20 04 80 	movabs $0x80042047b7,%rax
  8004205c34:	00 00 00 
  8004205c37:	ff d0                	callq  *%rax
  8004205c39:	48 89 c3             	mov    %rax,%rbx
  8004205c3c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205c40:	48 89 c7             	mov    %rax,%rdi
  8004205c43:	48 b8 77 13 20 04 80 	movabs $0x8004201377,%rax
  8004205c4a:	00 00 00 
  8004205c4d:	ff d0                	callq  *%rax
  8004205c4f:	48 39 c3             	cmp    %rax,%rbx
  8004205c52:	74 35                	je     8004205c89 <page_check+0x1258>
  8004205c54:	48 b9 80 2c 21 04 80 	movabs $0x8004212c80,%rcx
  8004205c5b:	00 00 00 
  8004205c5e:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205c65:	00 00 00 
  8004205c68:	be 95 04 00 00       	mov    $0x495,%esi
  8004205c6d:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205c74:	00 00 00 
  8004205c77:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c7c:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205c83:	00 00 00 
  8004205c86:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004205c89:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205c8d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205c91:	66 83 f8 01          	cmp    $0x1,%ax
  8004205c95:	74 35                	je     8004205ccc <page_check+0x129b>
  8004205c97:	48 b9 25 2a 21 04 80 	movabs $0x8004212a25,%rcx
  8004205c9e:	00 00 00 
  8004205ca1:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205ca8:	00 00 00 
  8004205cab:	be 96 04 00 00       	mov    $0x496,%esi
  8004205cb0:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205cb7:	00 00 00 
  8004205cba:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205cbf:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205cc6:	00 00 00 
  8004205cc9:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004205ccc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205cd0:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205cd4:	66 83 f8 01          	cmp    $0x1,%ax
  8004205cd8:	74 35                	je     8004205d0f <page_check+0x12de>
  8004205cda:	48 b9 c1 2c 21 04 80 	movabs $0x8004212cc1,%rcx
  8004205ce1:	00 00 00 
  8004205ce4:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205ceb:	00 00 00 
  8004205cee:	be 97 04 00 00       	mov    $0x497,%esi
  8004205cf3:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205cfa:	00 00 00 
  8004205cfd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d02:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205d09:	00 00 00 
  8004205d0c:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004205d0f:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004205d16:	00 00 00 
  8004205d19:	48 8b 00             	mov    (%rax),%rax
  8004205d1c:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205d20:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205d25:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205d2a:	48 89 c7             	mov    %rax,%rdi
  8004205d2d:	48 b8 3f 2e 20 04 80 	movabs $0x8004202e3f,%rax
  8004205d34:	00 00 00 
  8004205d37:	ff d0                	callq  *%rax
  8004205d39:	85 c0                	test   %eax,%eax
  8004205d3b:	74 35                	je     8004205d72 <page_check+0x1341>
  8004205d3d:	48 b9 e0 2b 21 04 80 	movabs $0x8004212be0,%rcx
  8004205d44:	00 00 00 
  8004205d47:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205d4e:	00 00 00 
  8004205d51:	be 9b 04 00 00       	mov    $0x49b,%esi
  8004205d56:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205d5d:	00 00 00 
  8004205d60:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d65:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205d6c:	00 00 00 
  8004205d6f:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref);
  8004205d72:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205d76:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205d7a:	66 85 c0             	test   %ax,%ax
  8004205d7d:	75 35                	jne    8004205db4 <page_check+0x1383>
  8004205d7f:	48 b9 fb 2c 21 04 80 	movabs $0x8004212cfb,%rcx
  8004205d86:	00 00 00 
  8004205d89:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205d90:	00 00 00 
  8004205d93:	be 9c 04 00 00       	mov    $0x49c,%esi
  8004205d98:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205d9f:	00 00 00 
  8004205da2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205da7:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205dae:	00 00 00 
  8004205db1:	41 ff d0             	callq  *%r8
	assert(pp1->pp_link == NULL);
  8004205db4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205db8:	48 8b 00             	mov    (%rax),%rax
  8004205dbb:	48 85 c0             	test   %rax,%rax
  8004205dbe:	74 35                	je     8004205df5 <page_check+0x13c4>
  8004205dc0:	48 b9 07 2d 21 04 80 	movabs $0x8004212d07,%rcx
  8004205dc7:	00 00 00 
  8004205dca:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205dd1:	00 00 00 
  8004205dd4:	be 9d 04 00 00       	mov    $0x49d,%esi
  8004205dd9:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205de0:	00 00 00 
  8004205de3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205de8:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205def:	00 00 00 
  8004205df2:	41 ff d0             	callq  *%r8

	// unmapping pp1 at PGSIZE should free it
	page_remove(boot_pml4e, (void*) PGSIZE);
  8004205df5:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004205dfc:	00 00 00 
  8004205dff:	48 8b 00             	mov    (%rax),%rax
  8004205e02:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205e07:	48 89 c7             	mov    %rax,%rdi
  8004205e0a:	48 b8 8c 2f 20 04 80 	movabs $0x8004202f8c,%rax
  8004205e11:	00 00 00 
  8004205e14:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004205e16:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004205e1d:	00 00 00 
  8004205e20:	48 8b 00             	mov    (%rax),%rax
  8004205e23:	be 00 00 00 00       	mov    $0x0,%esi
  8004205e28:	48 89 c7             	mov    %rax,%rdi
  8004205e2b:	48 b8 b7 47 20 04 80 	movabs $0x80042047b7,%rax
  8004205e32:	00 00 00 
  8004205e35:	ff d0                	callq  *%rax
  8004205e37:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004205e3b:	74 35                	je     8004205e72 <page_check+0x1441>
  8004205e3d:	48 b9 d8 2c 21 04 80 	movabs $0x8004212cd8,%rcx
  8004205e44:	00 00 00 
  8004205e47:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205e4e:	00 00 00 
  8004205e51:	be a1 04 00 00       	mov    $0x4a1,%esi
  8004205e56:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205e5d:	00 00 00 
  8004205e60:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e65:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205e6c:	00 00 00 
  8004205e6f:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  8004205e72:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004205e79:	00 00 00 
  8004205e7c:	48 8b 00             	mov    (%rax),%rax
  8004205e7f:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205e84:	48 89 c7             	mov    %rax,%rdi
  8004205e87:	48 b8 b7 47 20 04 80 	movabs $0x80042047b7,%rax
  8004205e8e:	00 00 00 
  8004205e91:	ff d0                	callq  *%rax
  8004205e93:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004205e97:	74 35                	je     8004205ece <page_check+0x149d>
  8004205e99:	48 b9 20 2d 21 04 80 	movabs $0x8004212d20,%rcx
  8004205ea0:	00 00 00 
  8004205ea3:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205eaa:	00 00 00 
  8004205ead:	be a2 04 00 00       	mov    $0x4a2,%esi
  8004205eb2:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205eb9:	00 00 00 
  8004205ebc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ec1:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205ec8:	00 00 00 
  8004205ecb:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  8004205ece:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205ed2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205ed6:	66 85 c0             	test   %ax,%ax
  8004205ed9:	74 35                	je     8004205f10 <page_check+0x14df>
  8004205edb:	48 b9 46 2d 21 04 80 	movabs $0x8004212d46,%rcx
  8004205ee2:	00 00 00 
  8004205ee5:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205eec:	00 00 00 
  8004205eef:	be a3 04 00 00       	mov    $0x4a3,%esi
  8004205ef4:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205efb:	00 00 00 
  8004205efe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f03:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205f0a:	00 00 00 
  8004205f0d:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004205f10:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205f14:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205f18:	66 83 f8 01          	cmp    $0x1,%ax
  8004205f1c:	74 35                	je     8004205f53 <page_check+0x1522>
  8004205f1e:	48 b9 c1 2c 21 04 80 	movabs $0x8004212cc1,%rcx
  8004205f25:	00 00 00 
  8004205f28:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205f2f:	00 00 00 
  8004205f32:	be a4 04 00 00       	mov    $0x4a4,%esi
  8004205f37:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205f3e:	00 00 00 
  8004205f41:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f46:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205f4d:	00 00 00 
  8004205f50:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif

	// forcibly take pp3 back
	struct PageInfo *pp_l1 = pa2page(PTE_ADDR(boot_pml4e[0]));
  8004205f53:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004205f5a:	00 00 00 
  8004205f5d:	48 8b 00             	mov    (%rax),%rax
  8004205f60:	48 8b 00             	mov    (%rax),%rax
  8004205f63:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205f69:	48 89 c7             	mov    %rax,%rdi
  8004205f6c:	48 b8 9c 13 20 04 80 	movabs $0x800420139c,%rax
  8004205f73:	00 00 00 
  8004205f76:	ff d0                	callq  *%rax
  8004205f78:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
	boot_pml4e[0] = 0;
  8004205f7f:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004205f86:	00 00 00 
  8004205f89:	48 8b 00             	mov    (%rax),%rax
  8004205f8c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  8004205f93:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205f97:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205f9b:	66 83 f8 01          	cmp    $0x1,%ax
  8004205f9f:	74 35                	je     8004205fd6 <page_check+0x15a5>
  8004205fa1:	48 b9 c1 2c 21 04 80 	movabs $0x8004212cc1,%rcx
  8004205fa8:	00 00 00 
  8004205fab:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004205fb2:	00 00 00 
  8004205fb5:	be ba 04 00 00       	mov    $0x4ba,%esi
  8004205fba:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004205fc1:	00 00 00 
  8004205fc4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205fc9:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004205fd0:	00 00 00 
  8004205fd3:	41 ff d0             	callq  *%r8
	page_decref(pp_l1);
  8004205fd6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004205fdd:	48 89 c7             	mov    %rax,%rdi
  8004205fe0:	48 b8 68 26 20 04 80 	movabs $0x8004202668,%rax
  8004205fe7:	00 00 00 
  8004205fea:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	if (pp_l1 != pp3) page_decref(pp3);
  8004205fec:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004205ff3:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205ff7:	74 13                	je     800420600c <page_check+0x15db>
  8004205ff9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205ffd:	48 89 c7             	mov    %rax,%rdi
  8004206000:	48 b8 68 26 20 04 80 	movabs $0x8004202668,%rax
  8004206007:	00 00 00 
  800420600a:	ff d0                	callq  *%rax
	if (pp_l1 != pp2) page_decref(pp2);
  800420600c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206013:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004206017:	74 13                	je     800420602c <page_check+0x15fb>
  8004206019:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420601d:	48 89 c7             	mov    %rax,%rdi
  8004206020:	48 b8 68 26 20 04 80 	movabs $0x8004202668,%rax
  8004206027:	00 00 00 
  800420602a:	ff d0                	callq  *%rax
	if (pp_l1 != pp0) page_decref(pp0);
  800420602c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206033:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004206037:	74 13                	je     800420604c <page_check+0x161b>
  8004206039:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420603d:	48 89 c7             	mov    %rax,%rdi
  8004206040:	48 b8 68 26 20 04 80 	movabs $0x8004202668,%rax
  8004206047:	00 00 00 
  800420604a:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  800420604c:	48 c7 85 60 ff ff ff 	movq   $0x64000,-0xa0(%rbp)
  8004206053:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  8004206057:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  800420605e:	00 00 00 
  8004206061:	48 8b 00             	mov    (%rax),%rax
  8004206064:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420606b:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206070:	48 89 ce             	mov    %rcx,%rsi
  8004206073:	48 89 c7             	mov    %rax,%rdi
  8004206076:	48 b8 a9 26 20 04 80 	movabs $0x80042026a9,%rax
  800420607d:	00 00 00 
  8004206080:	ff d0                	callq  *%rax
  8004206082:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  8004206089:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004206090:	00 00 00 
  8004206093:	48 8b 00             	mov    (%rax),%rax
  8004206096:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420609d:	48 c1 ea 27          	shr    $0x27,%rdx
  80042060a1:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  80042060a7:	48 c1 e2 03          	shl    $0x3,%rdx
  80042060ab:	48 01 d0             	add    %rdx,%rax
  80042060ae:	48 8b 00             	mov    (%rax),%rax
  80042060b1:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042060b7:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  80042060be:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042060c5:	48 c1 e8 0c          	shr    $0xc,%rax
  80042060c9:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
  80042060cf:	8b 95 54 ff ff ff    	mov    -0xac(%rbp),%edx
  80042060d5:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  80042060dc:	00 00 00 
  80042060df:	48 8b 00             	mov    (%rax),%rax
  80042060e2:	48 39 c2             	cmp    %rax,%rdx
  80042060e5:	72 35                	jb     800420611c <page_check+0x16eb>
  80042060e7:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042060ee:	48 89 c1             	mov    %rax,%rcx
  80042060f1:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  80042060f8:	00 00 00 
  80042060fb:	be c2 04 00 00       	mov    $0x4c2,%esi
  8004206100:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004206107:	00 00 00 
  800420610a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420610f:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004206116:	00 00 00 
  8004206119:	41 ff d0             	callq  *%r8
  800420611c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206123:	00 00 00 
  8004206126:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420612d:	48 01 d0             	add    %rdx,%rax
  8004206130:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004206134:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420613b:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420613f:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206144:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420614b:	00 
  800420614c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206150:	48 01 d0             	add    %rdx,%rax
  8004206153:	48 8b 00             	mov    (%rax),%rax
  8004206156:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420615c:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
  8004206163:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420616a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420616e:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
  8004206174:	8b 95 44 ff ff ff    	mov    -0xbc(%rbp),%edx
  800420617a:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004206181:	00 00 00 
  8004206184:	48 8b 00             	mov    (%rax),%rax
  8004206187:	48 39 c2             	cmp    %rax,%rdx
  800420618a:	72 35                	jb     80042061c1 <page_check+0x1790>
  800420618c:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004206193:	48 89 c1             	mov    %rax,%rcx
  8004206196:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  800420619d:	00 00 00 
  80042061a0:	be c3 04 00 00       	mov    $0x4c3,%esi
  80042061a5:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042061ac:	00 00 00 
  80042061af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061b4:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042061bb:	00 00 00 
  80042061be:	41 ff d0             	callq  *%r8
  80042061c1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042061c8:	00 00 00 
  80042061cb:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042061d2:	48 01 d0             	add    %rdx,%rax
  80042061d5:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  80042061d9:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042061e0:	48 c1 e8 15          	shr    $0x15,%rax
  80042061e4:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042061e9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042061f0:	00 
  80042061f1:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042061f5:	48 01 d0             	add    %rdx,%rax
  80042061f8:	48 8b 00             	mov    (%rax),%rax
  80042061fb:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206201:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004206208:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  800420620f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206213:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)
  8004206219:	8b 95 34 ff ff ff    	mov    -0xcc(%rbp),%edx
  800420621f:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004206226:	00 00 00 
  8004206229:	48 8b 00             	mov    (%rax),%rax
  800420622c:	48 39 c2             	cmp    %rax,%rdx
  800420622f:	72 35                	jb     8004206266 <page_check+0x1835>
  8004206231:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004206238:	48 89 c1             	mov    %rax,%rcx
  800420623b:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  8004206242:	00 00 00 
  8004206245:	be c4 04 00 00       	mov    $0x4c4,%esi
  800420624a:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004206251:	00 00 00 
  8004206254:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206259:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004206260:	00 00 00 
  8004206263:	41 ff d0             	callq  *%r8
  8004206266:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420626d:	00 00 00 
  8004206270:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004206277:	48 01 d0             	add    %rdx,%rax
  800420627a:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	assert(ptep == ptep1 + PTX(va));
  8004206281:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206288:	48 c1 e8 0c          	shr    $0xc,%rax
  800420628c:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206291:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206298:	00 
  8004206299:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042062a0:	48 01 c2             	add    %rax,%rdx
  80042062a3:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  80042062aa:	48 39 c2             	cmp    %rax,%rdx
  80042062ad:	74 35                	je     80042062e4 <page_check+0x18b3>
  80042062af:	48 b9 57 2d 21 04 80 	movabs $0x8004212d57,%rcx
  80042062b6:	00 00 00 
  80042062b9:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042062c0:	00 00 00 
  80042062c3:	be c5 04 00 00       	mov    $0x4c5,%esi
  80042062c8:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042062cf:	00 00 00 
  80042062d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042062d7:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042062de:	00 00 00 
  80042062e1:	41 ff d0             	callq  *%r8

	// check that new page tables get cleared
	memset(page2kva(pp4), 0xFF, PGSIZE);
  80042062e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042062e8:	48 89 c7             	mov    %rax,%rdi
  80042062eb:	48 b8 0d 14 20 04 80 	movabs $0x800420140d,%rax
  80042062f2:	00 00 00 
  80042062f5:	ff d0                	callq  *%rax
  80042062f7:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042062fc:	be ff 00 00 00       	mov    $0xff,%esi
  8004206301:	48 89 c7             	mov    %rax,%rdi
  8004206304:	48 b8 96 ba 20 04 80 	movabs $0x800420ba96,%rax
  800420630b:	00 00 00 
  800420630e:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  8004206310:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004206317:	00 00 00 
  800420631a:	48 8b 00             	mov    (%rax),%rax
  800420631d:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206322:	be 00 00 00 00       	mov    $0x0,%esi
  8004206327:	48 89 c7             	mov    %rax,%rdi
  800420632a:	48 b8 a9 26 20 04 80 	movabs $0x80042026a9,%rax
  8004206331:	00 00 00 
  8004206334:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  8004206336:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  800420633d:	00 00 00 
  8004206340:	48 8b 00             	mov    (%rax),%rax
  8004206343:	48 8b 00             	mov    (%rax),%rax
  8004206346:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420634c:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  8004206353:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  800420635a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420635e:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
  8004206364:	8b 95 1c ff ff ff    	mov    -0xe4(%rbp),%edx
  800420636a:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004206371:	00 00 00 
  8004206374:	48 8b 00             	mov    (%rax),%rax
  8004206377:	48 39 c2             	cmp    %rax,%rdx
  800420637a:	72 35                	jb     80042063b1 <page_check+0x1980>
  800420637c:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  8004206383:	48 89 c1             	mov    %rax,%rcx
  8004206386:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  800420638d:	00 00 00 
  8004206390:	be ca 04 00 00       	mov    $0x4ca,%esi
  8004206395:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420639c:	00 00 00 
  800420639f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063a4:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042063ab:	00 00 00 
  80042063ae:	41 ff d0             	callq  *%r8
  80042063b1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042063b8:	00 00 00 
  80042063bb:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  80042063c2:	48 01 d0             	add    %rdx,%rax
  80042063c5:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[0]));
  80042063c9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042063cd:	48 8b 00             	mov    (%rax),%rax
  80042063d0:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042063d6:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  80042063dd:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042063e4:	48 c1 e8 0c          	shr    $0xc,%rax
  80042063e8:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
  80042063ee:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  80042063f4:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  80042063fb:	00 00 00 
  80042063fe:	48 8b 00             	mov    (%rax),%rax
  8004206401:	48 39 c2             	cmp    %rax,%rdx
  8004206404:	72 35                	jb     800420643b <page_check+0x1a0a>
  8004206406:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  800420640d:	48 89 c1             	mov    %rax,%rcx
  8004206410:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  8004206417:	00 00 00 
  800420641a:	be cb 04 00 00       	mov    $0x4cb,%esi
  800420641f:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004206426:	00 00 00 
  8004206429:	b8 00 00 00 00       	mov    $0x0,%eax
  800420642e:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004206435:	00 00 00 
  8004206438:	41 ff d0             	callq  *%r8
  800420643b:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206442:	00 00 00 
  8004206445:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  800420644c:	48 01 d0             	add    %rdx,%rax
  800420644f:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep  = KADDR(PTE_ADDR(pde[0]));
  8004206453:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004206457:	48 8b 00             	mov    (%rax),%rax
  800420645a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206460:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  8004206467:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  800420646e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206472:	89 85 fc fe ff ff    	mov    %eax,-0x104(%rbp)
  8004206478:	8b 95 fc fe ff ff    	mov    -0x104(%rbp),%edx
  800420647e:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004206485:	00 00 00 
  8004206488:	48 8b 00             	mov    (%rax),%rax
  800420648b:	48 39 c2             	cmp    %rax,%rdx
  800420648e:	72 35                	jb     80042064c5 <page_check+0x1a94>
  8004206490:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  8004206497:	48 89 c1             	mov    %rax,%rcx
  800420649a:	48 ba 28 21 21 04 80 	movabs $0x8004212128,%rdx
  80042064a1:	00 00 00 
  80042064a4:	be cc 04 00 00       	mov    $0x4cc,%esi
  80042064a9:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042064b0:	00 00 00 
  80042064b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064b8:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042064bf:	00 00 00 
  80042064c2:	41 ff d0             	callq  *%r8
  80042064c5:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042064cc:	00 00 00 
  80042064cf:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  80042064d6:	48 01 d0             	add    %rdx,%rax
  80042064d9:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	for(i=0; i<NPTENTRIES; i++)
  80042064e0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042064e7:	eb 58                	jmp    8004206541 <page_check+0x1b10>
		assert((ptep[i] & PTE_P) == 0);
  80042064e9:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  80042064f0:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042064f3:	48 63 d2             	movslq %edx,%rdx
  80042064f6:	48 c1 e2 03          	shl    $0x3,%rdx
  80042064fa:	48 01 d0             	add    %rdx,%rax
  80042064fd:	48 8b 00             	mov    (%rax),%rax
  8004206500:	83 e0 01             	and    $0x1,%eax
  8004206503:	48 85 c0             	test   %rax,%rax
  8004206506:	74 35                	je     800420653d <page_check+0x1b0c>
  8004206508:	48 b9 6f 2d 21 04 80 	movabs $0x8004212d6f,%rcx
  800420650f:	00 00 00 
  8004206512:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004206519:	00 00 00 
  800420651c:	be ce 04 00 00       	mov    $0x4ce,%esi
  8004206521:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004206528:	00 00 00 
  800420652b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206530:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004206537:	00 00 00 
  800420653a:	41 ff d0             	callq  *%r8
	memset(page2kva(pp4), 0xFF, PGSIZE);
	pml4e_walk(boot_pml4e, 0x0, 1);
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
	pde  = KADDR(PTE_ADDR(pdpe[0]));
	ptep  = KADDR(PTE_ADDR(pde[0]));
	for(i=0; i<NPTENTRIES; i++)
  800420653d:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004206541:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  8004206548:	7e 9f                	jle    80042064e9 <page_check+0x1ab8>
		assert((ptep[i] & PTE_P) == 0);
	boot_pml4e[0] = 0;
  800420654a:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004206551:	00 00 00 
  8004206554:	48 8b 00             	mov    (%rax),%rax
  8004206557:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  800420655e:	48 b8 78 c6 2b 04 80 	movabs $0x80042bc678,%rax
  8004206565:	00 00 00 
  8004206568:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420656c:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  800420656f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206573:	48 89 c7             	mov    %rax,%rdi
  8004206576:	48 b8 68 26 20 04 80 	movabs $0x8004202668,%rax
  800420657d:	00 00 00 
  8004206580:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004206582:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206586:	48 89 c7             	mov    %rax,%rdi
  8004206589:	48 b8 68 26 20 04 80 	movabs $0x8004202668,%rax
  8004206590:	00 00 00 
  8004206593:	ff d0                	callq  *%rax
	page_decref(pp3);
  8004206595:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206599:	48 89 c7             	mov    %rax,%rdi
  800420659c:	48 b8 68 26 20 04 80 	movabs $0x8004202668,%rax
  80042065a3:	00 00 00 
  80042065a6:	ff d0                	callq  *%rax

	// Triple check that we got the ref counts right
	assert(pp0->pp_ref == 0);
  80042065a8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042065ac:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042065b0:	66 85 c0             	test   %ax,%ax
  80042065b3:	74 35                	je     80042065ea <page_check+0x1bb9>
  80042065b5:	48 b9 86 2d 21 04 80 	movabs $0x8004212d86,%rcx
  80042065bc:	00 00 00 
  80042065bf:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042065c6:	00 00 00 
  80042065c9:	be da 04 00 00       	mov    $0x4da,%esi
  80042065ce:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042065d5:	00 00 00 
  80042065d8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042065dd:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042065e4:	00 00 00 
  80042065e7:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  80042065ea:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042065ee:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042065f2:	66 85 c0             	test   %ax,%ax
  80042065f5:	74 35                	je     800420662c <page_check+0x1bfb>
  80042065f7:	48 b9 46 2d 21 04 80 	movabs $0x8004212d46,%rcx
  80042065fe:	00 00 00 
  8004206601:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004206608:	00 00 00 
  800420660b:	be db 04 00 00       	mov    $0x4db,%esi
  8004206610:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004206617:	00 00 00 
  800420661a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420661f:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004206626:	00 00 00 
  8004206629:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 0);
  800420662c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206630:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206634:	66 85 c0             	test   %ax,%ax
  8004206637:	74 35                	je     800420666e <page_check+0x1c3d>
  8004206639:	48 b9 97 2d 21 04 80 	movabs $0x8004212d97,%rcx
  8004206640:	00 00 00 
  8004206643:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420664a:	00 00 00 
  800420664d:	be dc 04 00 00       	mov    $0x4dc,%esi
  8004206652:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  8004206659:	00 00 00 
  800420665c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206661:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004206668:	00 00 00 
  800420666b:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 0);
  800420666e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206672:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206676:	66 85 c0             	test   %ax,%ax
  8004206679:	74 35                	je     80042066b0 <page_check+0x1c7f>
  800420667b:	48 b9 a8 2d 21 04 80 	movabs $0x8004212da8,%rcx
  8004206682:	00 00 00 
  8004206685:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  800420668c:	00 00 00 
  800420668f:	be dd 04 00 00       	mov    $0x4dd,%esi
  8004206694:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420669b:	00 00 00 
  800420669e:	b8 00 00 00 00       	mov    $0x0,%eax
  80042066a3:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042066aa:	00 00 00 
  80042066ad:	41 ff d0             	callq  *%r8
	assert(pp4->pp_ref == 0);
  80042066b0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042066b4:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042066b8:	66 85 c0             	test   %ax,%ax
  80042066bb:	74 35                	je     80042066f2 <page_check+0x1cc1>
  80042066bd:	48 b9 b9 2d 21 04 80 	movabs $0x8004212db9,%rcx
  80042066c4:	00 00 00 
  80042066c7:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  80042066ce:	00 00 00 
  80042066d1:	be de 04 00 00       	mov    $0x4de,%esi
  80042066d6:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  80042066dd:	00 00 00 
  80042066e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042066e5:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042066ec:	00 00 00 
  80042066ef:	41 ff d0             	callq  *%r8
	assert(pp5->pp_ref == 0);
  80042066f2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042066f6:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042066fa:	66 85 c0             	test   %ax,%ax
  80042066fd:	74 35                	je     8004206734 <page_check+0x1d03>
  80042066ff:	48 b9 ca 2d 21 04 80 	movabs $0x8004212dca,%rcx
  8004206706:	00 00 00 
  8004206709:	48 ba a1 21 21 04 80 	movabs $0x80042121a1,%rdx
  8004206710:	00 00 00 
  8004206713:	be df 04 00 00       	mov    $0x4df,%esi
  8004206718:	48 bf b6 21 21 04 80 	movabs $0x80042121b6,%rdi
  800420671f:	00 00 00 
  8004206722:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206727:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420672e:	00 00 00 
  8004206731:	41 ff d0             	callq  *%r8

	cprintf("check_page() succeeded!\n");
  8004206734:	48 bf db 2d 21 04 80 	movabs $0x8004212ddb,%rdi
  800420673b:	00 00 00 
  800420673e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206743:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  800420674a:	00 00 00 
  800420674d:	ff d2                	callq  *%rdx
}
  800420674f:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  8004206756:	5b                   	pop    %rbx
  8004206757:	5d                   	pop    %rbp
  8004206758:	c3                   	retq   

0000008004206759 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004206759:	55                   	push   %rbp
  800420675a:	48 89 e5             	mov    %rsp,%rbp
  800420675d:	48 83 ec 08          	sub    $0x8,%rsp
  8004206761:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004206765:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004206769:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  8004206770:	00 00 00 
  8004206773:	48 8b 00             	mov    (%rax),%rax
  8004206776:	48 29 c2             	sub    %rax,%rdx
  8004206779:	48 89 d0             	mov    %rdx,%rax
  800420677c:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004206780:	c9                   	leaveq 
  8004206781:	c3                   	retq   

0000008004206782 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004206782:	55                   	push   %rbp
  8004206783:	48 89 e5             	mov    %rsp,%rbp
  8004206786:	48 83 ec 08          	sub    $0x8,%rsp
  800420678a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  800420678e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004206792:	48 89 c7             	mov    %rax,%rdi
  8004206795:	48 b8 59 67 20 04 80 	movabs $0x8004206759,%rax
  800420679c:	00 00 00 
  800420679f:	ff d0                	callq  *%rax
  80042067a1:	48 c1 e0 0c          	shl    $0xc,%rax
}
  80042067a5:	c9                   	leaveq 
  80042067a6:	c3                   	retq   

00000080042067a7 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  80042067a7:	55                   	push   %rbp
  80042067a8:	48 89 e5             	mov    %rsp,%rbp
  80042067ab:	48 83 ec 10          	sub    $0x10,%rsp
  80042067af:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  80042067b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042067b7:	48 c1 e8 0c          	shr    $0xc,%rax
  80042067bb:	48 89 c2             	mov    %rax,%rdx
  80042067be:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  80042067c5:	00 00 00 
  80042067c8:	48 8b 00             	mov    (%rax),%rax
  80042067cb:	48 39 c2             	cmp    %rax,%rdx
  80042067ce:	72 2a                	jb     80042067fa <pa2page+0x53>
		panic("pa2page called with invalid pa");
  80042067d0:	48 ba f8 2d 21 04 80 	movabs $0x8004212df8,%rdx
  80042067d7:	00 00 00 
  80042067da:	be 52 00 00 00       	mov    $0x52,%esi
  80042067df:	48 bf 17 2e 21 04 80 	movabs $0x8004212e17,%rdi
  80042067e6:	00 00 00 
  80042067e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042067ee:	48 b9 50 01 20 04 80 	movabs $0x8004200150,%rcx
  80042067f5:	00 00 00 
  80042067f8:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  80042067fa:	48 b8 f0 db 2b 04 80 	movabs $0x80042bdbf0,%rax
  8004206801:	00 00 00 
  8004206804:	48 8b 00             	mov    (%rax),%rax
  8004206807:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420680b:	48 c1 ea 0c          	shr    $0xc,%rdx
  800420680f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004206813:	48 01 d0             	add    %rdx,%rax
}
  8004206816:	c9                   	leaveq 
  8004206817:	c3                   	retq   

0000008004206818 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004206818:	55                   	push   %rbp
  8004206819:	48 89 e5             	mov    %rsp,%rbp
  800420681c:	48 83 ec 20          	sub    $0x20,%rsp
  8004206820:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004206824:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004206828:	48 89 c7             	mov    %rax,%rdi
  800420682b:	48 b8 82 67 20 04 80 	movabs $0x8004206782,%rax
  8004206832:	00 00 00 
  8004206835:	ff d0                	callq  *%rax
  8004206837:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420683b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420683f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206843:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004206846:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004206849:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004206850:	00 00 00 
  8004206853:	48 8b 00             	mov    (%rax),%rax
  8004206856:	48 39 c2             	cmp    %rax,%rdx
  8004206859:	72 32                	jb     800420688d <page2kva+0x75>
  800420685b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420685f:	48 89 c1             	mov    %rax,%rcx
  8004206862:	48 ba 28 2e 21 04 80 	movabs $0x8004212e28,%rdx
  8004206869:	00 00 00 
  800420686c:	be 59 00 00 00       	mov    $0x59,%esi
  8004206871:	48 bf 17 2e 21 04 80 	movabs $0x8004212e17,%rdi
  8004206878:	00 00 00 
  800420687b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206880:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004206887:	00 00 00 
  800420688a:	41 ff d0             	callq  *%r8
  800420688d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206894:	00 00 00 
  8004206897:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420689b:	48 01 d0             	add    %rdx,%rax
}
  800420689e:	c9                   	leaveq 
  800420689f:	c3                   	retq   

00000080042068a0 <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  80042068a0:	55                   	push   %rbp
  80042068a1:	48 89 e5             	mov    %rsp,%rbp
  80042068a4:	48 83 ec 20          	sub    $0x20,%rsp
  80042068a8:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042068ab:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042068af:	89 d0                	mov    %edx,%eax
  80042068b1:	88 45 e8             	mov    %al,-0x18(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  80042068b4:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80042068b8:	75 1e                	jne    80042068d8 <envid2env+0x38>
		*env_store = curenv;
  80042068ba:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  80042068c1:	00 00 00 
  80042068c4:	48 8b 10             	mov    (%rax),%rdx
  80042068c7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042068cb:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  80042068ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80042068d3:	e9 ba 00 00 00       	jmpq   8004206992 <envid2env+0xf2>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  80042068d8:	48 b8 90 c6 2b 04 80 	movabs $0x80042bc690,%rax
  80042068df:	00 00 00 
  80042068e2:	48 8b 10             	mov    (%rax),%rdx
  80042068e5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042068e8:	48 98                	cltq   
  80042068ea:	25 ff 03 00 00       	and    $0x3ff,%eax
  80042068ef:	48 c1 e0 03          	shl    $0x3,%rax
  80042068f3:	48 89 c1             	mov    %rax,%rcx
  80042068f6:	48 c1 e1 05          	shl    $0x5,%rcx
  80042068fa:	48 29 c1             	sub    %rax,%rcx
  80042068fd:	48 89 c8             	mov    %rcx,%rax
  8004206900:	48 01 d0             	add    %rdx,%rax
  8004206903:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  8004206907:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420690b:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004206911:	85 c0                	test   %eax,%eax
  8004206913:	74 0f                	je     8004206924 <envid2env+0x84>
  8004206915:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004206919:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420691f:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004206922:	74 12                	je     8004206936 <envid2env+0x96>
		*env_store = 0;
  8004206924:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206928:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  800420692f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004206934:	eb 5c                	jmp    8004206992 <envid2env+0xf2>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  8004206936:	80 7d e8 00          	cmpb   $0x0,-0x18(%rbp)
  800420693a:	74 46                	je     8004206982 <envid2env+0xe2>
  800420693c:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004206943:	00 00 00 
  8004206946:	48 8b 00             	mov    (%rax),%rax
  8004206949:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800420694d:	74 33                	je     8004206982 <envid2env+0xe2>
  800420694f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004206953:	8b 90 cc 00 00 00    	mov    0xcc(%rax),%edx
  8004206959:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004206960:	00 00 00 
  8004206963:	48 8b 00             	mov    (%rax),%rax
  8004206966:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420696c:	39 c2                	cmp    %eax,%edx
  800420696e:	74 12                	je     8004206982 <envid2env+0xe2>
		*env_store = 0;
  8004206970:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206974:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  800420697b:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004206980:	eb 10                	jmp    8004206992 <envid2env+0xf2>
	}

	*env_store = e;
  8004206982:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206986:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420698a:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  800420698d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004206992:	c9                   	leaveq 
  8004206993:	c3                   	retq   

0000008004206994 <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
void
env_init(void)
{
  8004206994:	55                   	push   %rbp
  8004206995:	48 89 e5             	mov    %rsp,%rbp
  8004206998:	48 83 ec 10          	sub    $0x10,%rsp
	// Set up envs array
	// LAB 3: Your code here.
	size_t i;
	struct Env* last = NULL;
  800420699c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042069a3:	00 
	for (i = 0; i < NENV; i++) {
  80042069a4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042069ab:	00 
  80042069ac:	e9 e5 01 00 00       	jmpq   8004206b96 <env_init+0x202>
		envs[i].env_status = ENV_FREE;
  80042069b1:	48 b8 90 c6 2b 04 80 	movabs $0x80042bc690,%rax
  80042069b8:	00 00 00 
  80042069bb:	48 8b 10             	mov    (%rax),%rdx
  80042069be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042069c2:	48 c1 e0 03          	shl    $0x3,%rax
  80042069c6:	48 89 c1             	mov    %rax,%rcx
  80042069c9:	48 c1 e1 05          	shl    $0x5,%rcx
  80042069cd:	48 29 c1             	sub    %rax,%rcx
  80042069d0:	48 89 c8             	mov    %rcx,%rax
  80042069d3:	48 01 d0             	add    %rdx,%rax
  80042069d6:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  80042069dd:	00 00 00 
		envs[i].env_id = 0;
  80042069e0:	48 b8 90 c6 2b 04 80 	movabs $0x80042bc690,%rax
  80042069e7:	00 00 00 
  80042069ea:	48 8b 10             	mov    (%rax),%rdx
  80042069ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042069f1:	48 c1 e0 03          	shl    $0x3,%rax
  80042069f5:	48 89 c1             	mov    %rax,%rcx
  80042069f8:	48 c1 e1 05          	shl    $0x5,%rcx
  80042069fc:	48 29 c1             	sub    %rax,%rcx
  80042069ff:	48 89 c8             	mov    %rcx,%rax
  8004206a02:	48 01 d0             	add    %rdx,%rax
  8004206a05:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%rax)
  8004206a0c:	00 00 00 
		envs[i].env_link = NULL;
  8004206a0f:	48 b8 90 c6 2b 04 80 	movabs $0x80042bc690,%rax
  8004206a16:	00 00 00 
  8004206a19:	48 8b 10             	mov    (%rax),%rdx
  8004206a1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004206a20:	48 c1 e0 03          	shl    $0x3,%rax
  8004206a24:	48 89 c1             	mov    %rax,%rcx
  8004206a27:	48 c1 e1 05          	shl    $0x5,%rcx
  8004206a2b:	48 29 c1             	sub    %rax,%rcx
  8004206a2e:	48 89 c8             	mov    %rcx,%rax
  8004206a31:	48 01 d0             	add    %rdx,%rax
  8004206a34:	48 c7 80 c0 00 00 00 	movq   $0x0,0xc0(%rax)
  8004206a3b:	00 00 00 00 
		envs[i].env_parent_id = 0;
  8004206a3f:	48 b8 90 c6 2b 04 80 	movabs $0x80042bc690,%rax
  8004206a46:	00 00 00 
  8004206a49:	48 8b 10             	mov    (%rax),%rdx
  8004206a4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004206a50:	48 c1 e0 03          	shl    $0x3,%rax
  8004206a54:	48 89 c1             	mov    %rax,%rcx
  8004206a57:	48 c1 e1 05          	shl    $0x5,%rcx
  8004206a5b:	48 29 c1             	sub    %rax,%rcx
  8004206a5e:	48 89 c8             	mov    %rcx,%rax
  8004206a61:	48 01 d0             	add    %rdx,%rax
  8004206a64:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  8004206a6b:	00 00 00 
		envs[i].env_runs = 0;
  8004206a6e:	48 b8 90 c6 2b 04 80 	movabs $0x80042bc690,%rax
  8004206a75:	00 00 00 
  8004206a78:	48 8b 10             	mov    (%rax),%rdx
  8004206a7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004206a7f:	48 c1 e0 03          	shl    $0x3,%rax
  8004206a83:	48 89 c1             	mov    %rax,%rcx
  8004206a86:	48 c1 e1 05          	shl    $0x5,%rcx
  8004206a8a:	48 29 c1             	sub    %rax,%rcx
  8004206a8d:	48 89 c8             	mov    %rcx,%rax
  8004206a90:	48 01 d0             	add    %rdx,%rax
  8004206a93:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  8004206a9a:	00 00 00 
		envs[i].env_pml4e = NULL;
  8004206a9d:	48 b8 90 c6 2b 04 80 	movabs $0x80042bc690,%rax
  8004206aa4:	00 00 00 
  8004206aa7:	48 8b 10             	mov    (%rax),%rdx
  8004206aaa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004206aae:	48 c1 e0 03          	shl    $0x3,%rax
  8004206ab2:	48 89 c1             	mov    %rax,%rcx
  8004206ab5:	48 c1 e1 05          	shl    $0x5,%rcx
  8004206ab9:	48 29 c1             	sub    %rax,%rcx
  8004206abc:	48 89 c8             	mov    %rcx,%rax
  8004206abf:	48 01 d0             	add    %rdx,%rax
  8004206ac2:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  8004206ac9:	00 00 00 00 
		envs[i].env_cr3 = 0;
  8004206acd:	48 b8 90 c6 2b 04 80 	movabs $0x80042bc690,%rax
  8004206ad4:	00 00 00 
  8004206ad7:	48 8b 10             	mov    (%rax),%rdx
  8004206ada:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004206ade:	48 c1 e0 03          	shl    $0x3,%rax
  8004206ae2:	48 89 c1             	mov    %rax,%rcx
  8004206ae5:	48 c1 e1 05          	shl    $0x5,%rcx
  8004206ae9:	48 29 c1             	sub    %rax,%rcx
  8004206aec:	48 89 c8             	mov    %rcx,%rax
  8004206aef:	48 01 d0             	add    %rdx,%rax
  8004206af2:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8004206af9:	00 00 00 00 
		
		if (last)
  8004206afd:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004206b02:	74 32                	je     8004206b36 <env_init+0x1a2>
			last->env_link = &envs[i];
  8004206b04:	48 b8 90 c6 2b 04 80 	movabs $0x80042bc690,%rax
  8004206b0b:	00 00 00 
  8004206b0e:	48 8b 10             	mov    (%rax),%rdx
  8004206b11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004206b15:	48 c1 e0 03          	shl    $0x3,%rax
  8004206b19:	48 89 c1             	mov    %rax,%rcx
  8004206b1c:	48 c1 e1 05          	shl    $0x5,%rcx
  8004206b20:	48 29 c1             	sub    %rax,%rcx
  8004206b23:	48 89 c8             	mov    %rcx,%rax
  8004206b26:	48 01 c2             	add    %rax,%rdx
  8004206b29:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004206b2d:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
  8004206b34:	eb 32                	jmp    8004206b68 <env_init+0x1d4>
		else
			env_free_list = &envs[i];
  8004206b36:	48 b8 90 c6 2b 04 80 	movabs $0x80042bc690,%rax
  8004206b3d:	00 00 00 
  8004206b40:	48 8b 10             	mov    (%rax),%rdx
  8004206b43:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004206b47:	48 c1 e0 03          	shl    $0x3,%rax
  8004206b4b:	48 89 c1             	mov    %rax,%rcx
  8004206b4e:	48 c1 e1 05          	shl    $0x5,%rcx
  8004206b52:	48 29 c1             	sub    %rax,%rcx
  8004206b55:	48 89 c8             	mov    %rcx,%rax
  8004206b58:	48 01 c2             	add    %rax,%rdx
  8004206b5b:	48 b8 a0 c6 2b 04 80 	movabs $0x80042bc6a0,%rax
  8004206b62:	00 00 00 
  8004206b65:	48 89 10             	mov    %rdx,(%rax)
		last = &envs[i];
  8004206b68:	48 b8 90 c6 2b 04 80 	movabs $0x80042bc690,%rax
  8004206b6f:	00 00 00 
  8004206b72:	48 8b 10             	mov    (%rax),%rdx
  8004206b75:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004206b79:	48 c1 e0 03          	shl    $0x3,%rax
  8004206b7d:	48 89 c1             	mov    %rax,%rcx
  8004206b80:	48 c1 e1 05          	shl    $0x5,%rcx
  8004206b84:	48 29 c1             	sub    %rax,%rcx
  8004206b87:	48 89 c8             	mov    %rcx,%rax
  8004206b8a:	48 01 d0             	add    %rdx,%rax
  8004206b8d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
{
	// Set up envs array
	// LAB 3: Your code here.
	size_t i;
	struct Env* last = NULL;
	for (i = 0; i < NENV; i++) {
  8004206b91:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004206b96:	48 81 7d f8 ff 03 00 	cmpq   $0x3ff,-0x8(%rbp)
  8004206b9d:	00 
  8004206b9e:	0f 86 0d fe ff ff    	jbe    80042069b1 <env_init+0x1d>
		last = &envs[i];
		
	}

	// Per-CPU part of the initialization
	env_init_percpu();
  8004206ba4:	48 b8 b2 6b 20 04 80 	movabs $0x8004206bb2,%rax
  8004206bab:	00 00 00 
  8004206bae:	ff d0                	callq  *%rax
}
  8004206bb0:	c9                   	leaveq 
  8004206bb1:	c3                   	retq   

0000008004206bb2 <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  8004206bb2:	55                   	push   %rbp
  8004206bb3:	48 89 e5             	mov    %rsp,%rbp
  8004206bb6:	53                   	push   %rbx
  8004206bb7:	48 83 ec 10          	sub    $0x10,%rsp
  8004206bbb:	48 b8 f8 65 22 04 80 	movabs $0x80042265f8,%rax
  8004206bc2:	00 00 00 
  8004206bc5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}

static __inline void
lgdt(void *p)
{
	__asm __volatile("lgdt (%0)" : : "r" (p));
  8004206bc9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004206bcd:	0f 01 10             	lgdt   (%rax)
	lgdt(&gdt_pd);

	// The kernel never uses GS or FS, so we leave those set to
	// the user data segment.
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  8004206bd0:	b8 23 00 00 00       	mov    $0x23,%eax
  8004206bd5:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  8004206bd7:	b8 23 00 00 00       	mov    $0x23,%eax
  8004206bdc:	8e e0                	mov    %eax,%fs
	// The kernel does use ES, DS, and SS.  We'll change between
	// the kernel and user data segments as needed.
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  8004206bde:	b8 10 00 00 00       	mov    $0x10,%eax
  8004206be3:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  8004206be5:	b8 10 00 00 00       	mov    $0x10,%eax
  8004206bea:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  8004206bec:	b8 10 00 00 00       	mov    $0x10,%eax
  8004206bf1:	8e d0                	mov    %eax,%ss
	// Load the kernel text segment into CS.
	asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  8004206bf3:	b8 08 00 00 00       	mov    $0x8,%eax
  8004206bf8:	89 c3                	mov    %eax,%ebx
  8004206bfa:	53                   	push   %rbx
  8004206bfb:	48 b8 08 6c 20 04 80 	movabs $0x8004206c08,%rax
  8004206c02:	00 00 00 
  8004206c05:	50                   	push   %rax
  8004206c06:	48 cb                	lretq  
  8004206c08:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
}

static __inline void
lldt(uint16_t sel)
{
	__asm __volatile("lldt %0" : : "r" (sel));
  8004206c0e:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  8004206c12:	0f 00 d0             	lldt   %ax
	// For good measure, clear the local descriptor table (LDT),
	// since we don't use it.
	lldt(0);
}
  8004206c15:	48 83 c4 10          	add    $0x10,%rsp
  8004206c19:	5b                   	pop    %rbx
  8004206c1a:	5d                   	pop    %rbp
  8004206c1b:	c3                   	retq   

0000008004206c1c <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
static int
env_setup_vm(struct Env *e)
{
  8004206c1c:	55                   	push   %rbp
  8004206c1d:	48 89 e5             	mov    %rsp,%rbp
  8004206c20:	48 83 ec 20          	sub    $0x20,%rsp
  8004206c24:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  8004206c28:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004206c2f:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(ALLOC_ZERO)))
  8004206c30:	bf 01 00 00 00       	mov    $0x1,%edi
  8004206c35:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  8004206c3c:	00 00 00 
  8004206c3f:	ff d0                	callq  *%rax
  8004206c41:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004206c45:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004206c4a:	75 0a                	jne    8004206c56 <env_setup_vm+0x3a>
		return -E_NO_MEM;
  8004206c4c:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004206c51:	e9 ef 00 00 00       	jmpq   8004206d45 <env_setup_vm+0x129>
	//	is an exception -- you need to increment env_pml4e's
	//	pp_ref for env_free to work correctly.
	//    - The functions in kern/pmap.h are handy.

	// LAB 3: Your code here.
	memset(page2kva(p), 0, PGSIZE);
  8004206c56:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004206c5a:	48 89 c7             	mov    %rax,%rdi
  8004206c5d:	48 b8 18 68 20 04 80 	movabs $0x8004206818,%rax
  8004206c64:	00 00 00 
  8004206c67:	ff d0                	callq  *%rax
  8004206c69:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206c6e:	be 00 00 00 00       	mov    $0x0,%esi
  8004206c73:	48 89 c7             	mov    %rax,%rdi
  8004206c76:	48 b8 96 ba 20 04 80 	movabs $0x800420ba96,%rax
  8004206c7d:	00 00 00 
  8004206c80:	ff d0                	callq  *%rax
	e->env_pml4e = page2kva(p);
  8004206c82:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004206c86:	48 89 c7             	mov    %rax,%rdi
  8004206c89:	48 b8 18 68 20 04 80 	movabs $0x8004206818,%rax
  8004206c90:	00 00 00 
  8004206c93:	ff d0                	callq  *%rax
  8004206c95:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004206c99:	48 89 82 e0 00 00 00 	mov    %rax,0xe0(%rdx)
	e->env_cr3 = (physaddr_t)page2pa(p);
  8004206ca0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004206ca4:	48 89 c7             	mov    %rax,%rdi
  8004206ca7:	48 b8 82 67 20 04 80 	movabs $0x8004206782,%rax
  8004206cae:	00 00 00 
  8004206cb1:	ff d0                	callq  *%rax
  8004206cb3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004206cb7:	48 89 82 e8 00 00 00 	mov    %rax,0xe8(%rdx)
	p->pp_ref++;
  8004206cbe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004206cc2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206cc6:	8d 50 01             	lea    0x1(%rax),%edx
  8004206cc9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004206ccd:	66 89 50 08          	mov    %dx,0x8(%rax)
	boot_map_region(e->env_pml4e, UENVS, ROUNDUP(sizeof(struct Env) * NENV, PGSIZE), PADDR(envs), PTE_USER);
	boot_map_region(e->env_pml4e, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_USER);
	boot_map_region(e->env_pml4e, KERNBASE, (npages * PGSIZE), 0x0, PTE_USER);
	*/
	
	for (i = PML4(UTOP); i < NPMLENTRIES; i++)
  8004206cd1:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
  8004206cd8:	eb 3c                	jmp    8004206d16 <env_setup_vm+0xfa>
		e->env_pml4e[i] = boot_pml4e[i];
  8004206cda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004206cde:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004206ce5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004206ce8:	48 63 d2             	movslq %edx,%rdx
  8004206ceb:	48 c1 e2 03          	shl    $0x3,%rdx
  8004206cef:	48 01 c2             	add    %rax,%rdx
  8004206cf2:	48 b8 e0 db 2b 04 80 	movabs $0x80042bdbe0,%rax
  8004206cf9:	00 00 00 
  8004206cfc:	48 8b 00             	mov    (%rax),%rax
  8004206cff:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004206d02:	48 63 c9             	movslq %ecx,%rcx
  8004206d05:	48 c1 e1 03          	shl    $0x3,%rcx
  8004206d09:	48 01 c8             	add    %rcx,%rax
  8004206d0c:	48 8b 00             	mov    (%rax),%rax
  8004206d0f:	48 89 02             	mov    %rax,(%rdx)
	boot_map_region(e->env_pml4e, UENVS, ROUNDUP(sizeof(struct Env) * NENV, PGSIZE), PADDR(envs), PTE_USER);
	boot_map_region(e->env_pml4e, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_USER);
	boot_map_region(e->env_pml4e, KERNBASE, (npages * PGSIZE), 0x0, PTE_USER);
	*/
	
	for (i = PML4(UTOP); i < NPMLENTRIES; i++)
  8004206d12:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004206d16:	81 7d fc ff 01 00 00 	cmpl   $0x1ff,-0x4(%rbp)
  8004206d1d:	7e bb                	jle    8004206cda <env_setup_vm+0xbe>
		e->env_pml4e[i] = boot_pml4e[i];
	
	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pml4e[PML4(UVPT)] = e->env_cr3 | PTE_P | PTE_U;
  8004206d1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004206d23:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004206d2a:	48 8d 50 10          	lea    0x10(%rax),%rdx
  8004206d2e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004206d32:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004206d39:	48 83 c8 05          	or     $0x5,%rax
  8004206d3d:	48 89 02             	mov    %rax,(%rdx)
	
	return 0;
  8004206d40:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004206d45:	c9                   	leaveq 
  8004206d46:	c3                   	retq   

0000008004206d47 <env_alloc>:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  8004206d47:	55                   	push   %rbp
  8004206d48:	48 89 e5             	mov    %rsp,%rbp
  8004206d4b:	53                   	push   %rbx
  8004206d4c:	48 83 ec 38          	sub    $0x38,%rsp
  8004206d50:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004206d54:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = env_free_list))
  8004206d57:	48 b8 a0 c6 2b 04 80 	movabs $0x80042bc6a0,%rax
  8004206d5e:	00 00 00 
  8004206d61:	48 8b 00             	mov    (%rax),%rax
  8004206d64:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004206d68:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004206d6d:	75 0a                	jne    8004206d79 <env_alloc+0x32>
		return -E_NO_FREE_ENV;
  8004206d6f:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  8004206d74:	e9 93 01 00 00       	jmpq   8004206f0c <env_alloc+0x1c5>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  8004206d79:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206d7d:	48 89 c7             	mov    %rax,%rdi
  8004206d80:	48 b8 1c 6c 20 04 80 	movabs $0x8004206c1c,%rax
  8004206d87:	00 00 00 
  8004206d8a:	ff d0                	callq  *%rax
  8004206d8c:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004206d8f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004206d93:	79 08                	jns    8004206d9d <env_alloc+0x56>
		return r;
  8004206d95:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004206d98:	e9 6f 01 00 00       	jmpq   8004206f0c <env_alloc+0x1c5>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  8004206d9d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206da1:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004206da7:	05 00 10 00 00       	add    $0x1000,%eax
  8004206dac:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  8004206db1:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004206db4:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004206db8:	7f 07                	jg     8004206dc1 <env_alloc+0x7a>
		generation = 1 << ENVGENSHIFT;
  8004206dba:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%rbp)
	e->env_id = generation | (e - envs);
  8004206dc1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004206dc5:	48 b8 90 c6 2b 04 80 	movabs $0x80042bc690,%rax
  8004206dcc:	00 00 00 
  8004206dcf:	48 8b 00             	mov    (%rax),%rax
  8004206dd2:	48 29 c2             	sub    %rax,%rdx
  8004206dd5:	48 89 d0             	mov    %rdx,%rax
  8004206dd8:	48 c1 f8 03          	sar    $0x3,%rax
  8004206ddc:	48 89 c2             	mov    %rax,%rdx
  8004206ddf:	48 b8 df 7b ef bd f7 	movabs $0xef7bdef7bdef7bdf,%rax
  8004206de6:	de 7b ef 
  8004206de9:	48 0f af c2          	imul   %rdx,%rax
  8004206ded:	0b 45 ec             	or     -0x14(%rbp),%eax
  8004206df0:	89 c2                	mov    %eax,%edx
  8004206df2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206df6:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  8004206dfc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206e00:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004206e03:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  8004206e09:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206e0d:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  8004206e14:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  8004206e17:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206e1b:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004206e22:	00 00 00 
	e->env_runs = 0;
  8004206e25:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206e29:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  8004206e30:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  8004206e33:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206e37:	ba c0 00 00 00       	mov    $0xc0,%edx
  8004206e3c:	be 00 00 00 00       	mov    $0x0,%esi
  8004206e41:	48 89 c7             	mov    %rax,%rdi
  8004206e44:	48 b8 96 ba 20 04 80 	movabs $0x800420ba96,%rax
  8004206e4b:	00 00 00 
  8004206e4e:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  8004206e50:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206e54:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  8004206e5b:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  8004206e5d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206e61:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  8004206e67:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206e6b:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  8004206e72:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  8004206e74:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206e78:	bb 00 e0 7f ef       	mov    $0xef7fe000,%ebx
  8004206e7d:	48 89 98 b0 00 00 00 	mov    %rbx,0xb0(%rax)
	e->env_tf.tf_cs = GD_UT | 3;
  8004206e84:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206e88:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  8004206e8f:	1b 00 
	// You will set e->env_tf.tf_rip later.

	// commit the allocation
	env_free_list = e->env_link;
  8004206e91:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206e95:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  8004206e9c:	48 b8 a0 c6 2b 04 80 	movabs $0x80042bc6a0,%rax
  8004206ea3:	00 00 00 
  8004206ea6:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  8004206ea9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206ead:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004206eb1:	48 89 10             	mov    %rdx,(%rax)

	cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
  8004206eb4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206eb8:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  8004206ebe:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004206ec5:	00 00 00 
  8004206ec8:	48 8b 00             	mov    (%rax),%rax
  8004206ecb:	48 85 c0             	test   %rax,%rax
  8004206ece:	74 15                	je     8004206ee5 <env_alloc+0x19e>
  8004206ed0:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004206ed7:	00 00 00 
  8004206eda:	48 8b 00             	mov    (%rax),%rax
  8004206edd:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004206ee3:	eb 05                	jmp    8004206eea <env_alloc+0x1a3>
  8004206ee5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206eea:	89 c6                	mov    %eax,%esi
  8004206eec:	48 bf 4b 2e 21 04 80 	movabs $0x8004212e4b,%rdi
  8004206ef3:	00 00 00 
  8004206ef6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206efb:	48 b9 46 7b 20 04 80 	movabs $0x8004207b46,%rcx
  8004206f02:	00 00 00 
  8004206f05:	ff d1                	callq  *%rcx
	return 0;
  8004206f07:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004206f0c:	48 83 c4 38          	add    $0x38,%rsp
  8004206f10:	5b                   	pop    %rbx
  8004206f11:	5d                   	pop    %rbp
  8004206f12:	c3                   	retq   

0000008004206f13 <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  8004206f13:	55                   	push   %rbp
  8004206f14:	48 89 e5             	mov    %rsp,%rbp
  8004206f17:	48 83 ec 70          	sub    $0x70,%rsp
  8004206f1b:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004206f1f:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8004206f23:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
	// LAB 3: Your code here.
	uintptr_t va_aligned = ROUNDDOWN((uintptr_t)va, PGSIZE);
  8004206f27:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004206f2b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004206f2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004206f33:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206f39:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	uintptr_t va_len_aligned = (uintptr_t)ROUNDUP((char*)va + len, PGSIZE);
  8004206f3d:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8004206f44:	00 
  8004206f45:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206f49:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004206f4d:	48 01 d0             	add    %rdx,%rax
  8004206f50:	48 89 c2             	mov    %rax,%rdx
  8004206f53:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206f57:	48 01 d0             	add    %rdx,%rax
  8004206f5a:	48 83 e8 01          	sub    $0x1,%rax
  8004206f5e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004206f62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206f66:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206f6b:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004206f6f:	48 89 d0             	mov    %rdx,%rax
  8004206f72:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004206f76:	48 29 c2             	sub    %rax,%rdx
  8004206f79:	48 89 d0             	mov    %rdx,%rax
  8004206f7c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	int size = (va_len_aligned - va_aligned) / PGSIZE;
  8004206f80:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004206f84:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004206f88:	48 29 c2             	sub    %rax,%rdx
  8004206f8b:	48 89 d0             	mov    %rdx,%rax
  8004206f8e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206f92:	89 45 cc             	mov    %eax,-0x34(%rbp)

	int i;
	for (i=0; i<size; i++) {
  8004206f95:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004206f9c:	e9 ba 00 00 00       	jmpq   800420705b <region_alloc+0x148>
		struct PageInfo* pp = page_alloc(0);
  8004206fa1:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206fa6:	48 b8 39 25 20 04 80 	movabs $0x8004202539,%rax
  8004206fad:	00 00 00 
  8004206fb0:	ff d0                	callq  *%rax
  8004206fb2:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		if (pp == NULL)
  8004206fb6:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004206fbb:	75 32                	jne    8004206fef <region_alloc+0xdc>
			panic("region_alloc(): allocate new page failed! %e", pp);
  8004206fbd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206fc1:	48 89 c1             	mov    %rax,%rcx
  8004206fc4:	48 ba 60 2e 21 04 80 	movabs $0x8004212e60,%rdx
  8004206fcb:	00 00 00 
  8004206fce:	be 48 01 00 00       	mov    $0x148,%esi
  8004206fd3:	48 bf 8d 2e 21 04 80 	movabs $0x8004212e8d,%rdi
  8004206fda:	00 00 00 
  8004206fdd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206fe2:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004206fe9:	00 00 00 
  8004206fec:	41 ff d0             	callq  *%r8
		
		int result = page_insert(e->env_pml4e, pp, (void*)va_aligned, PTE_USER);
  8004206fef:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004206ff3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004206ff7:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004206ffe:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004207002:	b9 07 0e 00 00       	mov    $0xe07,%ecx
  8004207007:	48 89 c7             	mov    %rax,%rdi
  800420700a:	48 b8 3f 2e 20 04 80 	movabs $0x8004202e3f,%rax
  8004207011:	00 00 00 
  8004207014:	ff d0                	callq  *%rax
  8004207016:	89 45 bc             	mov    %eax,-0x44(%rbp)
		if (result < 0)
  8004207019:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  800420701d:	79 30                	jns    800420704f <region_alloc+0x13c>
			panic("region_alloc(): %e", result);
  800420701f:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004207022:	89 c1                	mov    %eax,%ecx
  8004207024:	48 ba 98 2e 21 04 80 	movabs $0x8004212e98,%rdx
  800420702b:	00 00 00 
  800420702e:	be 4c 01 00 00       	mov    $0x14c,%esi
  8004207033:	48 bf 8d 2e 21 04 80 	movabs $0x8004212e8d,%rdi
  800420703a:	00 00 00 
  800420703d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207042:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004207049:	00 00 00 
  800420704c:	41 ff d0             	callq  *%r8

		va_aligned = (uintptr_t)((char*)va_aligned + PGSIZE);
  800420704f:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004207056:	00 
	uintptr_t va_aligned = ROUNDDOWN((uintptr_t)va, PGSIZE);
	uintptr_t va_len_aligned = (uintptr_t)ROUNDUP((char*)va + len, PGSIZE);
	int size = (va_len_aligned - va_aligned) / PGSIZE;

	int i;
	for (i=0; i<size; i++) {
  8004207057:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800420705b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420705e:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  8004207061:	0f 8c 3a ff ff ff    	jl     8004206fa1 <region_alloc+0x8e>
	//
	// Hint: It is easier to use region_alloc if the caller can pass
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
}
  8004207067:	c9                   	leaveq 
  8004207068:	c3                   	retq   

0000008004207069 <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  8004207069:	55                   	push   %rbp
  800420706a:	48 89 e5             	mov    %rsp,%rbp
  800420706d:	48 83 ec 50          	sub    $0x50,%rsp
  8004207071:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004207075:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)

	// LAB 3: Your code here
	
	//lcr3(e->env_cr3);
	
	struct Elf* pbin = (struct Elf*) binary;
  8004207079:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420707d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	struct Proghdr *ph, *eph;
	int i;
	
	if (pbin->e_magic != ELF_MAGIC)
  8004207081:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207085:	8b 00                	mov    (%rax),%eax
  8004207087:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  800420708c:	74 2a                	je     80042070b8 <load_icode+0x4f>
		panic("load_icode(): not elf format!");
  800420708e:	48 ba ab 2e 21 04 80 	movabs $0x8004212eab,%rdx
  8004207095:	00 00 00 
  8004207098:	be 97 01 00 00       	mov    $0x197,%esi
  800420709d:	48 bf 8d 2e 21 04 80 	movabs $0x8004212e8d,%rdi
  80042070a4:	00 00 00 
  80042070a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042070ac:	48 b9 50 01 20 04 80 	movabs $0x8004200150,%rcx
  80042070b3:	00 00 00 
  80042070b6:	ff d1                	callq  *%rcx
	
	ph = (struct Proghdr *) ((char *) pbin + pbin->e_phoff);
  80042070b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042070bc:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042070c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042070c4:	48 01 d0             	add    %rdx,%rax
  80042070c7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	eph = ph + pbin->e_phnum;
  80042070cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042070cf:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  80042070d3:	0f b7 c0             	movzwl %ax,%eax
  80042070d6:	48 c1 e0 03          	shl    $0x3,%rax
  80042070da:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042070e1:	00 
  80042070e2:	48 29 c2             	sub    %rax,%rdx
  80042070e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042070e9:	48 01 d0             	add    %rdx,%rax
  80042070ec:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	
	for (; ph < eph; ph++) {
  80042070f0:	e9 52 01 00 00       	jmpq   8004207247 <load_icode+0x1de>
		if (ph->p_filesz > ph->p_memsz)
  80042070f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042070f9:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042070fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207101:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004207105:	48 39 c2             	cmp    %rax,%rdx
  8004207108:	76 2a                	jbe    8004207134 <load_icode+0xcb>
			panic("load_icode(): wrong program segment size!");
  800420710a:	48 ba d0 2e 21 04 80 	movabs $0x8004212ed0,%rdx
  8004207111:	00 00 00 
  8004207114:	be 9e 01 00 00       	mov    $0x19e,%esi
  8004207119:	48 bf 8d 2e 21 04 80 	movabs $0x8004212e8d,%rdi
  8004207120:	00 00 00 
  8004207123:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207128:	48 b9 50 01 20 04 80 	movabs $0x8004200150,%rcx
  800420712f:	00 00 00 
  8004207132:	ff d1                	callq  *%rcx
		
		if (ph->p_type == ELF_PROG_LOAD) {
  8004207134:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207138:	8b 00                	mov    (%rax),%eax
  800420713a:	83 f8 01             	cmp    $0x1,%eax
  800420713d:	0f 85 ff 00 00 00    	jne    8004207242 <load_icode+0x1d9>
			region_alloc(e, (void*)ph->p_va, ph->p_memsz);
  8004207143:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207147:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420714b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420714f:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004207153:	48 89 c1             	mov    %rax,%rcx
  8004207156:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420715a:	48 89 ce             	mov    %rcx,%rsi
  800420715d:	48 89 c7             	mov    %rax,%rdi
  8004207160:	48 b8 13 6f 20 04 80 	movabs $0x8004206f13,%rax
  8004207167:	00 00 00 
  800420716a:	ff d0                	callq  *%rax

			lcr3(e->env_cr3);
  800420716c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207170:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207177:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420717b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420717f:	0f 22 d8             	mov    %rax,%cr3
			memset((void*)ph->p_va, 0, ph->p_memsz);
  8004207182:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207186:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420718a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420718e:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004207192:	be 00 00 00 00       	mov    $0x0,%esi
  8004207197:	48 89 c7             	mov    %rax,%rdi
  800420719a:	48 b8 96 ba 20 04 80 	movabs $0x800420ba96,%rax
  80042071a1:	00 00 00 
  80042071a4:	ff d0                	callq  *%rax
			
			char *va = (char*)ph->p_va;
  80042071a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042071aa:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042071ae:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
			char *ps = (char*)pbin + ph->p_offset;
  80042071b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042071b6:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042071ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042071be:	48 01 d0             	add    %rdx,%rax
  80042071c1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			cprintf("load_icode: va %x ps %x\n", va, ps);
  80042071c5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042071c9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042071cd:	48 89 c6             	mov    %rax,%rsi
  80042071d0:	48 bf fa 2e 21 04 80 	movabs $0x8004212efa,%rdi
  80042071d7:	00 00 00 
  80042071da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042071df:	48 b9 46 7b 20 04 80 	movabs $0x8004207b46,%rcx
  80042071e6:	00 00 00 
  80042071e9:	ff d1                	callq  *%rcx
			for (i = 0; i < ph->p_filesz; i++)
  80042071eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042071f2:	eb 23                	jmp    8004207217 <load_icode+0x1ae>
				va[i] = ps[i];
  80042071f4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042071f7:	48 63 d0             	movslq %eax,%rdx
  80042071fa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042071fe:	48 01 c2             	add    %rax,%rdx
  8004207201:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004207204:	48 63 c8             	movslq %eax,%rcx
  8004207207:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420720b:	48 01 c8             	add    %rcx,%rax
  800420720e:	0f b6 00             	movzbl (%rax),%eax
  8004207211:	88 02                	mov    %al,(%rdx)
			memset((void*)ph->p_va, 0, ph->p_memsz);
			
			char *va = (char*)ph->p_va;
			char *ps = (char*)pbin + ph->p_offset;
			cprintf("load_icode: va %x ps %x\n", va, ps);
			for (i = 0; i < ph->p_filesz; i++)
  8004207213:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004207217:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420721a:	48 63 d0             	movslq %eax,%rdx
  800420721d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207221:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004207225:	48 39 c2             	cmp    %rax,%rdx
  8004207228:	72 ca                	jb     80042071f4 <load_icode+0x18b>
				va[i] = ps[i];
				
			lcr3(boot_cr3);
  800420722a:	48 b8 d8 db 2b 04 80 	movabs $0x80042bdbd8,%rax
  8004207231:	00 00 00 
  8004207234:	48 8b 00             	mov    (%rax),%rax
  8004207237:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800420723b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420723f:	0f 22 d8             	mov    %rax,%cr3
		panic("load_icode(): not elf format!");
	
	ph = (struct Proghdr *) ((char *) pbin + pbin->e_phoff);
	eph = ph + pbin->e_phnum;
	
	for (; ph < eph; ph++) {
  8004207242:	48 83 45 f8 38       	addq   $0x38,-0x8(%rbp)
  8004207247:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420724b:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420724f:	0f 82 a0 fe ff ff    	jb     80042070f5 <load_icode+0x8c>
	}
	
	// Now map one page for the program's initial stack
	// at virtual address USTACKTOP - PGSIZE.
	// Don't do this: (void*)(USTACKTOP-PGSIZE)
	region_alloc(e, (void*)(USTACKTOP - PGSIZE), PGSIZE);
  8004207255:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207259:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420725e:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  8004207263:	48 89 c7             	mov    %rax,%rdi
  8004207266:	48 b8 13 6f 20 04 80 	movabs $0x8004206f13,%rax
  800420726d:	00 00 00 
  8004207270:	ff d0                	callq  *%rax

	// LAB 3: Your code here.
	e->env_tf.tf_rip = pbin->e_entry;
  8004207272:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207276:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800420727a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420727e:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
   	e->elf = binary;
  8004207285:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207289:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420728d:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)
}
  8004207294:	c9                   	leaveq 
  8004207295:	c3                   	retq   

0000008004207296 <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  8004207296:	55                   	push   %rbp
  8004207297:	48 89 e5             	mov    %rsp,%rbp
  800420729a:	48 83 ec 20          	sub    $0x20,%rsp
  800420729e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042072a2:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// LAB 3: Your code here.
	struct Env *newenv;

	if (env_alloc(&newenv, 0) < 0)
  80042072a5:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  80042072a9:	be 00 00 00 00       	mov    $0x0,%esi
  80042072ae:	48 89 c7             	mov    %rax,%rdi
  80042072b1:	48 b8 47 6d 20 04 80 	movabs $0x8004206d47,%rax
  80042072b8:	00 00 00 
  80042072bb:	ff d0                	callq  *%rax
  80042072bd:	85 c0                	test   %eax,%eax
  80042072bf:	79 2a                	jns    80042072eb <env_create+0x55>
		panic("env_create(): failed to allocate new Env!\n");
  80042072c1:	48 ba 18 2f 21 04 80 	movabs $0x8004212f18,%rdx
  80042072c8:	00 00 00 
  80042072cb:	be c8 01 00 00       	mov    $0x1c8,%esi
  80042072d0:	48 bf 8d 2e 21 04 80 	movabs $0x8004212e8d,%rdi
  80042072d7:	00 00 00 
  80042072da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042072df:	48 b9 50 01 20 04 80 	movabs $0x8004200150,%rcx
  80042072e6:	00 00 00 
  80042072e9:	ff d1                	callq  *%rcx
	
	load_icode(newenv, binary);
  80042072eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042072ef:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042072f3:	48 89 d6             	mov    %rdx,%rsi
  80042072f6:	48 89 c7             	mov    %rax,%rdi
  80042072f9:	48 b8 69 70 20 04 80 	movabs $0x8004207069,%rax
  8004207300:	00 00 00 
  8004207303:	ff d0                	callq  *%rax
	newenv->env_type = type;
  8004207305:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207309:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800420730c:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
	newenv->env_parent_id = 0;
  8004207312:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207316:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  800420731d:	00 00 00 
}
  8004207320:	c9                   	leaveq 
  8004207321:	c3                   	retq   

0000008004207322 <env_free>:
//
// Frees env e and all memory it uses.
//
void
env_free(struct Env *e)
{
  8004207322:	55                   	push   %rbp
  8004207323:	48 89 e5             	mov    %rsp,%rbp
  8004207326:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  800420732d:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)


	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  8004207334:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  800420733b:	00 00 00 
  800420733e:	48 8b 00             	mov    (%rax),%rax
  8004207341:	48 39 85 78 ff ff ff 	cmp    %rax,-0x88(%rbp)
  8004207348:	75 18                	jne    8004207362 <env_free+0x40>
		lcr3(boot_cr3);
  800420734a:	48 b8 d8 db 2b 04 80 	movabs $0x80042bdbd8,%rax
  8004207351:	00 00 00 
  8004207354:	48 8b 00             	mov    (%rax),%rax
  8004207357:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  800420735b:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800420735f:	0f 22 d8             	mov    %rax,%cr3

	// Note the environment's demise.
	cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
  8004207362:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004207369:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420736f:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004207376:	00 00 00 
  8004207379:	48 8b 00             	mov    (%rax),%rax
  800420737c:	48 85 c0             	test   %rax,%rax
  800420737f:	74 15                	je     8004207396 <env_free+0x74>
  8004207381:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004207388:	00 00 00 
  800420738b:	48 8b 00             	mov    (%rax),%rax
  800420738e:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207394:	eb 05                	jmp    800420739b <env_free+0x79>
  8004207396:	b8 00 00 00 00       	mov    $0x0,%eax
  800420739b:	89 c6                	mov    %eax,%esi
  800420739d:	48 bf 43 2f 21 04 80 	movabs $0x8004212f43,%rdi
  80042073a4:	00 00 00 
  80042073a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042073ac:	48 b9 46 7b 20 04 80 	movabs $0x8004207b46,%rcx
  80042073b3:	00 00 00 
  80042073b6:	ff d1                	callq  *%rcx

	// Flush all mapped pages in the user portion of the address space
	if (e->env_pml4e[0] & PTE_P) {
  80042073b8:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042073bf:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042073c6:	48 8b 00             	mov    (%rax),%rax
  80042073c9:	83 e0 01             	and    $0x1,%eax
  80042073cc:	48 85 c0             	test   %rax,%rax
  80042073cf:	0f 84 7a 03 00 00    	je     800420774f <env_free+0x42d>
		pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  80042073d5:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042073dc:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042073e3:	48 8b 00             	mov    (%rax),%rax
  80042073e6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042073ec:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042073f0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042073f4:	48 c1 e8 0c          	shr    $0xc,%rax
  80042073f8:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042073fb:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042073fe:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004207405:	00 00 00 
  8004207408:	48 8b 00             	mov    (%rax),%rax
  800420740b:	48 39 c2             	cmp    %rax,%rdx
  800420740e:	72 32                	jb     8004207442 <env_free+0x120>
  8004207410:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207414:	48 89 c1             	mov    %rax,%rcx
  8004207417:	48 ba 28 2e 21 04 80 	movabs $0x8004212e28,%rdx
  800420741e:	00 00 00 
  8004207421:	be e5 01 00 00       	mov    $0x1e5,%esi
  8004207426:	48 bf 8d 2e 21 04 80 	movabs $0x8004212e8d,%rdi
  800420742d:	00 00 00 
  8004207430:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207435:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420743c:	00 00 00 
  800420743f:	41 ff d0             	callq  *%r8
  8004207442:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207449:	00 00 00 
  800420744c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207450:	48 01 d0             	add    %rdx,%rax
  8004207453:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		int pdeno_limit;
		uint64_t pdpe_index;
		// using 3 instead of NPDPENTRIES as we have only first three indices
		// set for 4GB of address space.
		for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004207457:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420745e:	00 
  800420745f:	e9 ab 02 00 00       	jmpq   800420770f <env_free+0x3ed>
			if(!(env_pdpe[pdpe_index] & PTE_P))
  8004207464:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207468:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420746f:	00 
  8004207470:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207474:	48 01 d0             	add    %rdx,%rax
  8004207477:	48 8b 00             	mov    (%rax),%rax
  800420747a:	83 e0 01             	and    $0x1,%eax
  800420747d:	48 85 c0             	test   %rax,%rax
  8004207480:	75 05                	jne    8004207487 <env_free+0x165>
				continue;
  8004207482:	e9 83 02 00 00       	jmpq   800420770a <env_free+0x3e8>
			pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  8004207487:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420748b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207492:	00 
  8004207493:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207497:	48 01 d0             	add    %rdx,%rax
  800420749a:	48 8b 00             	mov    (%rax),%rax
  800420749d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042074a3:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042074a7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042074ab:	48 c1 e8 0c          	shr    $0xc,%rax
  80042074af:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  80042074b2:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042074b5:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  80042074bc:	00 00 00 
  80042074bf:	48 8b 00             	mov    (%rax),%rax
  80042074c2:	48 39 c2             	cmp    %rax,%rdx
  80042074c5:	72 32                	jb     80042074f9 <env_free+0x1d7>
  80042074c7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042074cb:	48 89 c1             	mov    %rax,%rcx
  80042074ce:	48 ba 28 2e 21 04 80 	movabs $0x8004212e28,%rdx
  80042074d5:	00 00 00 
  80042074d8:	be ed 01 00 00       	mov    $0x1ed,%esi
  80042074dd:	48 bf 8d 2e 21 04 80 	movabs $0x8004212e8d,%rdi
  80042074e4:	00 00 00 
  80042074e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042074ec:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042074f3:	00 00 00 
  80042074f6:	41 ff d0             	callq  *%r8
  80042074f9:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207500:	00 00 00 
  8004207503:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207507:	48 01 d0             	add    %rdx,%rax
  800420750a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  800420750e:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004207513:	75 07                	jne    800420751c <env_free+0x1fa>
  8004207515:	b8 04 00 00 00       	mov    $0x4,%eax
  800420751a:	eb 05                	jmp    8004207521 <env_free+0x1ff>
  800420751c:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  8004207521:	89 45 b4             	mov    %eax,-0x4c(%rbp)
			static_assert(UTOP % PTSIZE == 0);
			for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004207524:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420752b:	00 
  800420752c:	e9 6e 01 00 00       	jmpq   800420769f <env_free+0x37d>

				// only look at mapped page tables
				if (!(env_pgdir[pdeno] & PTE_P))
  8004207531:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207535:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420753c:	00 
  800420753d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207541:	48 01 d0             	add    %rdx,%rax
  8004207544:	48 8b 00             	mov    (%rax),%rax
  8004207547:	83 e0 01             	and    $0x1,%eax
  800420754a:	48 85 c0             	test   %rax,%rax
  800420754d:	75 05                	jne    8004207554 <env_free+0x232>
					continue;
  800420754f:	e9 46 01 00 00       	jmpq   800420769a <env_free+0x378>
				// find the pa and va of the page table
				pa = PTE_ADDR(env_pgdir[pdeno]);
  8004207554:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207558:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420755f:	00 
  8004207560:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207564:	48 01 d0             	add    %rdx,%rax
  8004207567:	48 8b 00             	mov    (%rax),%rax
  800420756a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207570:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
				pt = (pte_t*) KADDR(pa);
  8004207574:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004207578:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  800420757c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004207580:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207584:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004207587:	8b 55 9c             	mov    -0x64(%rbp),%edx
  800420758a:	48 b8 e8 db 2b 04 80 	movabs $0x80042bdbe8,%rax
  8004207591:	00 00 00 
  8004207594:	48 8b 00             	mov    (%rax),%rax
  8004207597:	48 39 c2             	cmp    %rax,%rdx
  800420759a:	72 32                	jb     80042075ce <env_free+0x2ac>
  800420759c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042075a0:	48 89 c1             	mov    %rax,%rcx
  80042075a3:	48 ba 28 2e 21 04 80 	movabs $0x8004212e28,%rdx
  80042075aa:	00 00 00 
  80042075ad:	be f7 01 00 00       	mov    $0x1f7,%esi
  80042075b2:	48 bf 8d 2e 21 04 80 	movabs $0x8004212e8d,%rdi
  80042075b9:	00 00 00 
  80042075bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042075c1:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  80042075c8:	00 00 00 
  80042075cb:	41 ff d0             	callq  *%r8
  80042075ce:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042075d5:	00 00 00 
  80042075d8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042075dc:	48 01 d0             	add    %rdx,%rax
  80042075df:	48 89 45 90          	mov    %rax,-0x70(%rbp)

				// unmap all PTEs in this page table
				for (pteno = 0; pteno < PTX(~0); pteno++) {
  80042075e3:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042075ea:	00 
  80042075eb:	eb 67                	jmp    8004207654 <env_free+0x332>
					if (pt[pteno] & PTE_P){
  80042075ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042075f1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042075f8:	00 
  80042075f9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042075fd:	48 01 d0             	add    %rdx,%rax
  8004207600:	48 8b 00             	mov    (%rax),%rax
  8004207603:	83 e0 01             	and    $0x1,%eax
  8004207606:	48 85 c0             	test   %rax,%rax
  8004207609:	74 44                	je     800420764f <env_free+0x32d>
						page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  800420760b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420760f:	48 c1 e0 1e          	shl    $0x1e,%rax
  8004207613:	48 89 c2             	mov    %rax,%rdx
  8004207616:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420761a:	48 c1 e0 15          	shl    $0x15,%rax
  800420761e:	48 09 c2             	or     %rax,%rdx
  8004207621:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207625:	48 c1 e0 0c          	shl    $0xc,%rax
  8004207629:	48 09 d0             	or     %rdx,%rax
  800420762c:	48 89 c2             	mov    %rax,%rdx
  800420762f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004207636:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420763d:	48 89 d6             	mov    %rdx,%rsi
  8004207640:	48 89 c7             	mov    %rax,%rdi
  8004207643:	48 b8 8c 2f 20 04 80 	movabs $0x8004202f8c,%rax
  800420764a:	00 00 00 
  800420764d:	ff d0                	callq  *%rax
				// find the pa and va of the page table
				pa = PTE_ADDR(env_pgdir[pdeno]);
				pt = (pte_t*) KADDR(pa);

				// unmap all PTEs in this page table
				for (pteno = 0; pteno < PTX(~0); pteno++) {
  800420764f:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004207654:	48 81 7d f0 fe 01 00 	cmpq   $0x1fe,-0x10(%rbp)
  800420765b:	00 
  800420765c:	76 8f                	jbe    80042075ed <env_free+0x2cb>
						page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
					}
				}

				// free the page table itself
				env_pgdir[pdeno] = 0;
  800420765e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207662:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207669:	00 
  800420766a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420766e:	48 01 d0             	add    %rdx,%rax
  8004207671:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
				page_decref(pa2page(pa));
  8004207678:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420767c:	48 89 c7             	mov    %rax,%rdi
  800420767f:	48 b8 a7 67 20 04 80 	movabs $0x80042067a7,%rax
  8004207686:	00 00 00 
  8004207689:	ff d0                	callq  *%rax
  800420768b:	48 89 c7             	mov    %rax,%rdi
  800420768e:	48 b8 68 26 20 04 80 	movabs $0x8004202668,%rax
  8004207695:	00 00 00 
  8004207698:	ff d0                	callq  *%rax
			if(!(env_pdpe[pdpe_index] & PTE_P))
				continue;
			pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
			pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
			static_assert(UTOP % PTSIZE == 0);
			for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  800420769a:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420769f:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80042076a2:	48 98                	cltq   
  80042076a4:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042076a8:	0f 87 83 fe ff ff    	ja     8004207531 <env_free+0x20f>
				// free the page table itself
				env_pgdir[pdeno] = 0;
				page_decref(pa2page(pa));
			}
			// free the page directory
			pa = PTE_ADDR(env_pdpe[pdpe_index]);
  80042076ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042076b2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042076b9:	00 
  80042076ba:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042076be:	48 01 d0             	add    %rdx,%rax
  80042076c1:	48 8b 00             	mov    (%rax),%rax
  80042076c4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042076ca:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			env_pdpe[pdpe_index] = 0;
  80042076ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042076d2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042076d9:	00 
  80042076da:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042076de:	48 01 d0             	add    %rdx,%rax
  80042076e1:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  80042076e8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042076ec:	48 89 c7             	mov    %rax,%rdi
  80042076ef:	48 b8 a7 67 20 04 80 	movabs $0x80042067a7,%rax
  80042076f6:	00 00 00 
  80042076f9:	ff d0                	callq  *%rax
  80042076fb:	48 89 c7             	mov    %rax,%rdi
  80042076fe:	48 b8 68 26 20 04 80 	movabs $0x8004202668,%rax
  8004207705:	00 00 00 
  8004207708:	ff d0                	callq  *%rax
		pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
		int pdeno_limit;
		uint64_t pdpe_index;
		// using 3 instead of NPDPENTRIES as we have only first three indices
		// set for 4GB of address space.
		for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  800420770a:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420770f:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004207714:	0f 86 4a fd ff ff    	jbe    8004207464 <env_free+0x142>
			pa = PTE_ADDR(env_pdpe[pdpe_index]);
			env_pdpe[pdpe_index] = 0;
			page_decref(pa2page(pa));
		}
		// free the page directory pointer
		page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  800420771a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004207721:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207728:	48 8b 00             	mov    (%rax),%rax
  800420772b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207731:	48 89 c7             	mov    %rax,%rdi
  8004207734:	48 b8 a7 67 20 04 80 	movabs $0x80042067a7,%rax
  800420773b:	00 00 00 
  800420773e:	ff d0                	callq  *%rax
  8004207740:	48 89 c7             	mov    %rax,%rdi
  8004207743:	48 b8 68 26 20 04 80 	movabs $0x8004202668,%rax
  800420774a:	00 00 00 
  800420774d:	ff d0                	callq  *%rax
	}
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  800420774f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004207756:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420775d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  8004207764:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420776b:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207772:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	e->env_pml4e = 0;
  8004207776:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420777d:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  8004207784:	00 00 00 00 
	e->env_cr3 = 0;
  8004207788:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420778f:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8004207796:	00 00 00 00 
	page_decref(pa2page(pa));
  800420779a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420779e:	48 89 c7             	mov    %rax,%rdi
  80042077a1:	48 b8 a7 67 20 04 80 	movabs $0x80042067a7,%rax
  80042077a8:	00 00 00 
  80042077ab:	ff d0                	callq  *%rax
  80042077ad:	48 89 c7             	mov    %rax,%rdi
  80042077b0:	48 b8 68 26 20 04 80 	movabs $0x8004202668,%rax
  80042077b7:	00 00 00 
  80042077ba:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  80042077bc:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042077c3:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  80042077ca:	00 00 00 
	e->env_link = env_free_list;
  80042077cd:	48 b8 a0 c6 2b 04 80 	movabs $0x80042bc6a0,%rax
  80042077d4:	00 00 00 
  80042077d7:	48 8b 10             	mov    (%rax),%rdx
  80042077da:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042077e1:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  80042077e8:	48 b8 a0 c6 2b 04 80 	movabs $0x80042bc6a0,%rax
  80042077ef:	00 00 00 
  80042077f2:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  80042077f9:	48 89 10             	mov    %rdx,(%rax)
}
  80042077fc:	c9                   	leaveq 
  80042077fd:	c3                   	retq   

00000080042077fe <env_destroy>:
//
// Frees environment e.
//
void
env_destroy(struct Env *e)
{
  80042077fe:	55                   	push   %rbp
  80042077ff:	48 89 e5             	mov    %rsp,%rbp
  8004207802:	48 83 ec 10          	sub    $0x10,%rsp
  8004207806:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

	env_free(e);
  800420780a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420780e:	48 89 c7             	mov    %rax,%rdi
  8004207811:	48 b8 22 73 20 04 80 	movabs $0x8004207322,%rax
  8004207818:	00 00 00 
  800420781b:	ff d0                	callq  *%rax
	cprintf("Destroyed the only environment - nothing more to do!\n");
  800420781d:	48 bf 60 2f 21 04 80 	movabs $0x8004212f60,%rdi
  8004207824:	00 00 00 
  8004207827:	b8 00 00 00 00       	mov    $0x0,%eax
  800420782c:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004207833:	00 00 00 
  8004207836:	ff d2                	callq  *%rdx
	while (1)
		monitor(NULL);
  8004207838:	bf 00 00 00 00       	mov    $0x0,%edi
  800420783d:	48 b8 ad 12 20 04 80 	movabs $0x80042012ad,%rax
  8004207844:	00 00 00 
  8004207847:	ff d0                	callq  *%rax
  8004207849:	eb ed                	jmp    8004207838 <env_destroy+0x3a>

000000800420784b <env_pop_tf>:
//
// This function does not return.
//
void
env_pop_tf(struct Trapframe *tf)
{
  800420784b:	55                   	push   %rbp
  800420784c:	48 89 e5             	mov    %rsp,%rbp
  800420784f:	48 83 ec 10          	sub    $0x10,%rsp
  8004207853:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	__asm __volatile("movq %0,%%rsp\n"
  8004207857:	48 8b 65 f8          	mov    -0x8(%rbp),%rsp
  800420785b:	4c 8b 3c 24          	mov    (%rsp),%r15
  800420785f:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  8004207864:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  8004207869:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  800420786e:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  8004207873:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  8004207878:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  800420787d:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  8004207882:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  8004207887:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  800420788c:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  8004207891:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  8004207896:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800420789b:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  80042078a0:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  80042078a5:	48 83 c4 78          	add    $0x78,%rsp
  80042078a9:	8e 04 24             	mov    (%rsp),%es
  80042078ac:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  80042078b0:	48 83 c4 10          	add    $0x10,%rsp
  80042078b4:	48 83 c4 10          	add    $0x10,%rsp
  80042078b8:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  80042078ba:	48 ba 96 2f 21 04 80 	movabs $0x8004212f96,%rdx
  80042078c1:	00 00 00 
  80042078c4:	be 38 02 00 00       	mov    $0x238,%esi
  80042078c9:	48 bf 8d 2e 21 04 80 	movabs $0x8004212e8d,%rdi
  80042078d0:	00 00 00 
  80042078d3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042078d8:	48 b9 50 01 20 04 80 	movabs $0x8004200150,%rcx
  80042078df:	00 00 00 
  80042078e2:	ff d1                	callq  *%rcx

00000080042078e4 <env_run>:
//
// This function does not return.
//
void
env_run(struct Env *e)
{
  80042078e4:	55                   	push   %rbp
  80042078e5:	48 89 e5             	mov    %rsp,%rbp
  80042078e8:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  80042078ef:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
	//	e->env_tf.  Go back through the code you wrote above
	//	and make sure you have set the relevant parts of
	//	e->env_tf to sensible values.

	// LAB 3: Your code here.
	if (curenv != NULL && curenv->env_status == ENV_RUNNING)
  80042078f6:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  80042078fd:	00 00 00 
  8004207900:	48 8b 00             	mov    (%rax),%rax
  8004207903:	48 85 c0             	test   %rax,%rax
  8004207906:	74 2f                	je     8004207937 <env_run+0x53>
  8004207908:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  800420790f:	00 00 00 
  8004207912:	48 8b 00             	mov    (%rax),%rax
  8004207915:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420791b:	83 f8 03             	cmp    $0x3,%eax
  800420791e:	75 17                	jne    8004207937 <env_run+0x53>
		curenv->env_status = ENV_RUNNABLE;
  8004207920:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004207927:	00 00 00 
  800420792a:	48 8b 00             	mov    (%rax),%rax
  800420792d:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004207934:	00 00 00 
	
	curenv = e;
  8004207937:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  800420793e:	00 00 00 
  8004207941:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004207948:	48 89 10             	mov    %rdx,(%rax)
	curenv->env_status = ENV_RUNNING;
  800420794b:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004207952:	00 00 00 
  8004207955:	48 8b 00             	mov    (%rax),%rax
  8004207958:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  800420795f:	00 00 00 
	curenv->env_runs++;
  8004207962:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004207969:	00 00 00 
  800420796c:	48 8b 00             	mov    (%rax),%rax
  800420796f:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  8004207975:	83 c2 01             	add    $0x1,%edx
  8004207978:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
	lcr3(curenv->env_cr3);
  800420797e:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004207985:	00 00 00 
  8004207988:	48 8b 00             	mov    (%rax),%rax
  800420798b:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207992:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207996:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420799a:	0f 22 d8             	mov    %rax,%cr3
	
	struct PushRegs regs = curenv->env_tf.tf_regs;
  800420799d:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  80042079a4:	00 00 00 
  80042079a7:	48 8b 00             	mov    (%rax),%rax
  80042079aa:	48 8b 10             	mov    (%rax),%rdx
  80042079ad:	48 89 55 80          	mov    %rdx,-0x80(%rbp)
  80042079b1:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042079b5:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  80042079b9:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042079bd:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
  80042079c1:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042079c5:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  80042079c9:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042079cd:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
  80042079d1:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042079d5:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  80042079d9:	48 8b 50 30          	mov    0x30(%rax),%rdx
  80042079dd:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  80042079e1:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80042079e5:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042079e9:	48 8b 50 40          	mov    0x40(%rax),%rdx
  80042079ed:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  80042079f1:	48 8b 50 48          	mov    0x48(%rax),%rdx
  80042079f5:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80042079f9:	48 8b 50 50          	mov    0x50(%rax),%rdx
  80042079fd:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004207a01:	48 8b 50 58          	mov    0x58(%rax),%rdx
  8004207a05:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004207a09:	48 8b 50 60          	mov    0x60(%rax),%rdx
  8004207a0d:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  8004207a11:	48 8b 50 68          	mov    0x68(%rax),%rdx
  8004207a15:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004207a19:	48 8b 40 70          	mov    0x70(%rax),%rax
  8004207a1d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	env_pop_tf(&(curenv->env_tf));
  8004207a21:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004207a28:	00 00 00 
  8004207a2b:	48 8b 00             	mov    (%rax),%rax
  8004207a2e:	48 89 c7             	mov    %rax,%rdi
  8004207a31:	48 b8 4b 78 20 04 80 	movabs $0x800420784b,%rax
  8004207a38:	00 00 00 
  8004207a3b:	ff d0                	callq  *%rax

0000008004207a3d <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  8004207a3d:	55                   	push   %rbp
  8004207a3e:	48 89 e5             	mov    %rsp,%rbp
  8004207a41:	48 83 ec 14          	sub    $0x14,%rsp
  8004207a45:	89 7d ec             	mov    %edi,-0x14(%rbp)
	outb(IO_RTC, reg);
  8004207a48:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004207a4b:	0f b6 c0             	movzbl %al,%eax
  8004207a4e:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004207a55:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004207a58:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004207a5c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004207a5f:	ee                   	out    %al,(%dx)
  8004207a60:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004207a67:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004207a6a:	89 c2                	mov    %eax,%edx
  8004207a6c:	ec                   	in     (%dx),%al
  8004207a6d:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004207a70:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(IO_RTC+1);
  8004207a74:	0f b6 c0             	movzbl %al,%eax
}
  8004207a77:	c9                   	leaveq 
  8004207a78:	c3                   	retq   

0000008004207a79 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  8004207a79:	55                   	push   %rbp
  8004207a7a:	48 89 e5             	mov    %rsp,%rbp
  8004207a7d:	48 83 ec 18          	sub    $0x18,%rsp
  8004207a81:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004207a84:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  8004207a87:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004207a8a:	0f b6 c0             	movzbl %al,%eax
  8004207a8d:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004207a94:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004207a97:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004207a9b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004207a9e:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  8004207a9f:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004207aa2:	0f b6 c0             	movzbl %al,%eax
  8004207aa5:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)
  8004207aac:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004207aaf:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004207ab3:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004207ab6:	ee                   	out    %al,(%dx)
}
  8004207ab7:	c9                   	leaveq 
  8004207ab8:	c3                   	retq   

0000008004207ab9 <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  8004207ab9:	55                   	push   %rbp
  8004207aba:	48 89 e5             	mov    %rsp,%rbp
  8004207abd:	48 83 ec 10          	sub    $0x10,%rsp
  8004207ac1:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004207ac4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  8004207ac8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004207acb:	89 c7                	mov    %eax,%edi
  8004207acd:	48 b8 0b 0e 20 04 80 	movabs $0x8004200e0b,%rax
  8004207ad4:	00 00 00 
  8004207ad7:	ff d0                	callq  *%rax
	*cnt++;
  8004207ad9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207add:	48 83 c0 04          	add    $0x4,%rax
  8004207ae1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  8004207ae5:	c9                   	leaveq 
  8004207ae6:	c3                   	retq   

0000008004207ae7 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  8004207ae7:	55                   	push   %rbp
  8004207ae8:	48 89 e5             	mov    %rsp,%rbp
  8004207aeb:	48 83 ec 30          	sub    $0x30,%rsp
  8004207aef:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004207af3:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  8004207af7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004207afe:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004207b02:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004207b06:	48 8b 0a             	mov    (%rdx),%rcx
  8004207b09:	48 89 08             	mov    %rcx,(%rax)
  8004207b0c:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004207b10:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004207b14:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004207b18:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  8004207b1c:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  8004207b20:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004207b24:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8004207b28:	48 89 c6             	mov    %rax,%rsi
  8004207b2b:	48 bf b9 7a 20 04 80 	movabs $0x8004207ab9,%rdi
  8004207b32:	00 00 00 
  8004207b35:	48 b8 99 ae 20 04 80 	movabs $0x800420ae99,%rax
  8004207b3c:	00 00 00 
  8004207b3f:	ff d0                	callq  *%rax
	va_end(aq);
	return cnt;
  8004207b41:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  8004207b44:	c9                   	leaveq 
  8004207b45:	c3                   	retq   

0000008004207b46 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  8004207b46:	55                   	push   %rbp
  8004207b47:	48 89 e5             	mov    %rsp,%rbp
  8004207b4a:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  8004207b51:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  8004207b58:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  8004207b5f:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004207b66:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004207b6d:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004207b74:	84 c0                	test   %al,%al
  8004207b76:	74 20                	je     8004207b98 <cprintf+0x52>
  8004207b78:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004207b7c:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004207b80:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004207b84:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004207b88:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004207b8c:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004207b90:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004207b94:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004207b98:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  8004207b9f:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  8004207ba6:	00 00 00 
  8004207ba9:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  8004207bb0:	00 00 00 
  8004207bb3:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004207bb7:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004207bbe:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004207bc5:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004207bcc:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8004207bd3:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8004207bda:	48 8b 0a             	mov    (%rdx),%rcx
  8004207bdd:	48 89 08             	mov    %rcx,(%rax)
  8004207be0:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004207be4:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004207be8:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004207bec:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  8004207bf0:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  8004207bf7:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004207bfe:	48 89 d6             	mov    %rdx,%rsi
  8004207c01:	48 89 c7             	mov    %rax,%rdi
  8004207c04:	48 b8 e7 7a 20 04 80 	movabs $0x8004207ae7,%rax
  8004207c0b:	00 00 00 
  8004207c0e:	ff d0                	callq  *%rax
  8004207c10:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  8004207c16:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8004207c1c:	c9                   	leaveq 
  8004207c1d:	c3                   	retq   

0000008004207c1e <trapname>:
*/
struct Pseudodesc idt_pd = {0,0};


static const char *trapname(int trapno)
{
  8004207c1e:	55                   	push   %rbp
  8004207c1f:	48 89 e5             	mov    %rsp,%rbp
  8004207c22:	48 83 ec 04          	sub    $0x4,%rsp
  8004207c26:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  8004207c29:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004207c2c:	83 f8 13             	cmp    $0x13,%eax
  8004207c2f:	77 16                	ja     8004207c47 <trapname+0x29>
		return excnames[trapno];
  8004207c31:	48 b8 e0 33 21 04 80 	movabs $0x80042133e0,%rax
  8004207c38:	00 00 00 
  8004207c3b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004207c3e:	48 63 d2             	movslq %edx,%rdx
  8004207c41:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004207c45:	eb 1c                	jmp    8004207c63 <trapname+0x45>
	if (trapno == T_SYSCALL)
  8004207c47:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  8004207c4b:	75 0c                	jne    8004207c59 <trapname+0x3b>
		return "System call";
  8004207c4d:	48 b8 c0 2f 21 04 80 	movabs $0x8004212fc0,%rax
  8004207c54:	00 00 00 
  8004207c57:	eb 0a                	jmp    8004207c63 <trapname+0x45>
	return "(unknown trap)";
  8004207c59:	48 b8 cc 2f 21 04 80 	movabs $0x8004212fcc,%rax
  8004207c60:	00 00 00 
}
  8004207c63:	c9                   	leaveq 
  8004207c64:	c3                   	retq   

0000008004207c65 <trap_init>:
extern void handleSystemCall();
extern void handleCatchall();

void
trap_init(void)
{
  8004207c65:	55                   	push   %rbp
  8004207c66:	48 89 e5             	mov    %rsp,%rbp
	extern struct Segdesc gdt[];

	// LAB 3: Your code here.//TODO:check this side 3 after finish
	SETGATE(idt[T_DIVIDE], 0, GD_KT,handleDivideError , 0);
  8004207c69:	48 b8 08 9d 20 04 80 	movabs $0x8004209d08,%rax
  8004207c70:	00 00 00 
  8004207c73:	89 c2                	mov    %eax,%edx
  8004207c75:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207c7c:	00 00 00 
  8004207c7f:	66 89 10             	mov    %dx,(%rax)
  8004207c82:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207c89:	00 00 00 
  8004207c8c:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  8004207c92:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207c99:	00 00 00 
  8004207c9c:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004207ca0:	83 e2 f8             	and    $0xfffffff8,%edx
  8004207ca3:	88 50 04             	mov    %dl,0x4(%rax)
  8004207ca6:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207cad:	00 00 00 
  8004207cb0:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004207cb4:	83 e2 07             	and    $0x7,%edx
  8004207cb7:	88 50 04             	mov    %dl,0x4(%rax)
  8004207cba:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207cc1:	00 00 00 
  8004207cc4:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004207cc8:	83 e2 f0             	and    $0xfffffff0,%edx
  8004207ccb:	83 ca 0e             	or     $0xe,%edx
  8004207cce:	88 50 05             	mov    %dl,0x5(%rax)
  8004207cd1:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207cd8:	00 00 00 
  8004207cdb:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004207cdf:	83 e2 ef             	and    $0xffffffef,%edx
  8004207ce2:	88 50 05             	mov    %dl,0x5(%rax)
  8004207ce5:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207cec:	00 00 00 
  8004207cef:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004207cf3:	83 e2 9f             	and    $0xffffff9f,%edx
  8004207cf6:	88 50 05             	mov    %dl,0x5(%rax)
  8004207cf9:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207d00:	00 00 00 
  8004207d03:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004207d07:	83 ca 80             	or     $0xffffff80,%edx
  8004207d0a:	88 50 05             	mov    %dl,0x5(%rax)
  8004207d0d:	48 b8 08 9d 20 04 80 	movabs $0x8004209d08,%rax
  8004207d14:	00 00 00 
  8004207d17:	48 c1 e8 10          	shr    $0x10,%rax
  8004207d1b:	89 c2                	mov    %eax,%edx
  8004207d1d:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207d24:	00 00 00 
  8004207d27:	66 89 50 06          	mov    %dx,0x6(%rax)
  8004207d2b:	48 b8 08 9d 20 04 80 	movabs $0x8004209d08,%rax
  8004207d32:	00 00 00 
  8004207d35:	48 c1 e8 20          	shr    $0x20,%rax
  8004207d39:	89 c2                	mov    %eax,%edx
  8004207d3b:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207d42:	00 00 00 
  8004207d45:	89 50 08             	mov    %edx,0x8(%rax)
  8004207d48:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207d4f:	00 00 00 
  8004207d52:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
	SETGATE(idt[T_DEBUG], 0, GD_KT, handleDebugException, 0);
  8004207d59:	48 b8 0e 9d 20 04 80 	movabs $0x8004209d0e,%rax
  8004207d60:	00 00 00 
  8004207d63:	89 c2                	mov    %eax,%edx
  8004207d65:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207d6c:	00 00 00 
  8004207d6f:	66 89 50 10          	mov    %dx,0x10(%rax)
  8004207d73:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207d7a:	00 00 00 
  8004207d7d:	66 c7 40 12 08 00    	movw   $0x8,0x12(%rax)
  8004207d83:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207d8a:	00 00 00 
  8004207d8d:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  8004207d91:	83 e2 f8             	and    $0xfffffff8,%edx
  8004207d94:	88 50 14             	mov    %dl,0x14(%rax)
  8004207d97:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207d9e:	00 00 00 
  8004207da1:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  8004207da5:	83 e2 07             	and    $0x7,%edx
  8004207da8:	88 50 14             	mov    %dl,0x14(%rax)
  8004207dab:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207db2:	00 00 00 
  8004207db5:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004207db9:	83 e2 f0             	and    $0xfffffff0,%edx
  8004207dbc:	83 ca 0e             	or     $0xe,%edx
  8004207dbf:	88 50 15             	mov    %dl,0x15(%rax)
  8004207dc2:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207dc9:	00 00 00 
  8004207dcc:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004207dd0:	83 e2 ef             	and    $0xffffffef,%edx
  8004207dd3:	88 50 15             	mov    %dl,0x15(%rax)
  8004207dd6:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207ddd:	00 00 00 
  8004207de0:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004207de4:	83 e2 9f             	and    $0xffffff9f,%edx
  8004207de7:	88 50 15             	mov    %dl,0x15(%rax)
  8004207dea:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207df1:	00 00 00 
  8004207df4:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004207df8:	83 ca 80             	or     $0xffffff80,%edx
  8004207dfb:	88 50 15             	mov    %dl,0x15(%rax)
  8004207dfe:	48 b8 0e 9d 20 04 80 	movabs $0x8004209d0e,%rax
  8004207e05:	00 00 00 
  8004207e08:	48 c1 e8 10          	shr    $0x10,%rax
  8004207e0c:	89 c2                	mov    %eax,%edx
  8004207e0e:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207e15:	00 00 00 
  8004207e18:	66 89 50 16          	mov    %dx,0x16(%rax)
  8004207e1c:	48 b8 0e 9d 20 04 80 	movabs $0x8004209d0e,%rax
  8004207e23:	00 00 00 
  8004207e26:	48 c1 e8 20          	shr    $0x20,%rax
  8004207e2a:	89 c2                	mov    %eax,%edx
  8004207e2c:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207e33:	00 00 00 
  8004207e36:	89 50 18             	mov    %edx,0x18(%rax)
  8004207e39:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207e40:	00 00 00 
  8004207e43:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%rax)
	SETGATE(idt[T_NMI], 0, GD_KT, handleNonMaskableInterrupt, 0);
  8004207e4a:	48 b8 14 9d 20 04 80 	movabs $0x8004209d14,%rax
  8004207e51:	00 00 00 
  8004207e54:	89 c2                	mov    %eax,%edx
  8004207e56:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207e5d:	00 00 00 
  8004207e60:	66 89 50 20          	mov    %dx,0x20(%rax)
  8004207e64:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207e6b:	00 00 00 
  8004207e6e:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  8004207e74:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207e7b:	00 00 00 
  8004207e7e:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004207e82:	83 e2 f8             	and    $0xfffffff8,%edx
  8004207e85:	88 50 24             	mov    %dl,0x24(%rax)
  8004207e88:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207e8f:	00 00 00 
  8004207e92:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004207e96:	83 e2 07             	and    $0x7,%edx
  8004207e99:	88 50 24             	mov    %dl,0x24(%rax)
  8004207e9c:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207ea3:	00 00 00 
  8004207ea6:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004207eaa:	83 e2 f0             	and    $0xfffffff0,%edx
  8004207ead:	83 ca 0e             	or     $0xe,%edx
  8004207eb0:	88 50 25             	mov    %dl,0x25(%rax)
  8004207eb3:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207eba:	00 00 00 
  8004207ebd:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004207ec1:	83 e2 ef             	and    $0xffffffef,%edx
  8004207ec4:	88 50 25             	mov    %dl,0x25(%rax)
  8004207ec7:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207ece:	00 00 00 
  8004207ed1:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004207ed5:	83 e2 9f             	and    $0xffffff9f,%edx
  8004207ed8:	88 50 25             	mov    %dl,0x25(%rax)
  8004207edb:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207ee2:	00 00 00 
  8004207ee5:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004207ee9:	83 ca 80             	or     $0xffffff80,%edx
  8004207eec:	88 50 25             	mov    %dl,0x25(%rax)
  8004207eef:	48 b8 14 9d 20 04 80 	movabs $0x8004209d14,%rax
  8004207ef6:	00 00 00 
  8004207ef9:	48 c1 e8 10          	shr    $0x10,%rax
  8004207efd:	89 c2                	mov    %eax,%edx
  8004207eff:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207f06:	00 00 00 
  8004207f09:	66 89 50 26          	mov    %dx,0x26(%rax)
  8004207f0d:	48 b8 14 9d 20 04 80 	movabs $0x8004209d14,%rax
  8004207f14:	00 00 00 
  8004207f17:	48 c1 e8 20          	shr    $0x20,%rax
  8004207f1b:	89 c2                	mov    %eax,%edx
  8004207f1d:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207f24:	00 00 00 
  8004207f27:	89 50 28             	mov    %edx,0x28(%rax)
  8004207f2a:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207f31:	00 00 00 
  8004207f34:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
	SETGATE(idt[T_BRKPT], 0, GD_KT, handleBreakpoint, 3);
  8004207f3b:	48 b8 1a 9d 20 04 80 	movabs $0x8004209d1a,%rax
  8004207f42:	00 00 00 
  8004207f45:	89 c2                	mov    %eax,%edx
  8004207f47:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207f4e:	00 00 00 
  8004207f51:	66 89 50 30          	mov    %dx,0x30(%rax)
  8004207f55:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207f5c:	00 00 00 
  8004207f5f:	66 c7 40 32 08 00    	movw   $0x8,0x32(%rax)
  8004207f65:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207f6c:	00 00 00 
  8004207f6f:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004207f73:	83 e2 f8             	and    $0xfffffff8,%edx
  8004207f76:	88 50 34             	mov    %dl,0x34(%rax)
  8004207f79:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207f80:	00 00 00 
  8004207f83:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004207f87:	83 e2 07             	and    $0x7,%edx
  8004207f8a:	88 50 34             	mov    %dl,0x34(%rax)
  8004207f8d:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207f94:	00 00 00 
  8004207f97:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004207f9b:	83 e2 f0             	and    $0xfffffff0,%edx
  8004207f9e:	83 ca 0e             	or     $0xe,%edx
  8004207fa1:	88 50 35             	mov    %dl,0x35(%rax)
  8004207fa4:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207fab:	00 00 00 
  8004207fae:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004207fb2:	83 e2 ef             	and    $0xffffffef,%edx
  8004207fb5:	88 50 35             	mov    %dl,0x35(%rax)
  8004207fb8:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207fbf:	00 00 00 
  8004207fc2:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004207fc6:	83 ca 60             	or     $0x60,%edx
  8004207fc9:	88 50 35             	mov    %dl,0x35(%rax)
  8004207fcc:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207fd3:	00 00 00 
  8004207fd6:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004207fda:	83 ca 80             	or     $0xffffff80,%edx
  8004207fdd:	88 50 35             	mov    %dl,0x35(%rax)
  8004207fe0:	48 b8 1a 9d 20 04 80 	movabs $0x8004209d1a,%rax
  8004207fe7:	00 00 00 
  8004207fea:	48 c1 e8 10          	shr    $0x10,%rax
  8004207fee:	89 c2                	mov    %eax,%edx
  8004207ff0:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004207ff7:	00 00 00 
  8004207ffa:	66 89 50 36          	mov    %dx,0x36(%rax)
  8004207ffe:	48 b8 1a 9d 20 04 80 	movabs $0x8004209d1a,%rax
  8004208005:	00 00 00 
  8004208008:	48 c1 e8 20          	shr    $0x20,%rax
  800420800c:	89 c2                	mov    %eax,%edx
  800420800e:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208015:	00 00 00 
  8004208018:	89 50 38             	mov    %edx,0x38(%rax)
  800420801b:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208022:	00 00 00 
  8004208025:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
	SETGATE(idt[T_OFLOW], 0, GD_KT, handleOverflow, 0);
  800420802c:	48 b8 20 9d 20 04 80 	movabs $0x8004209d20,%rax
  8004208033:	00 00 00 
  8004208036:	89 c2                	mov    %eax,%edx
  8004208038:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420803f:	00 00 00 
  8004208042:	66 89 50 40          	mov    %dx,0x40(%rax)
  8004208046:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420804d:	00 00 00 
  8004208050:	66 c7 40 42 08 00    	movw   $0x8,0x42(%rax)
  8004208056:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420805d:	00 00 00 
  8004208060:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004208064:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208067:	88 50 44             	mov    %dl,0x44(%rax)
  800420806a:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208071:	00 00 00 
  8004208074:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004208078:	83 e2 07             	and    $0x7,%edx
  800420807b:	88 50 44             	mov    %dl,0x44(%rax)
  800420807e:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208085:	00 00 00 
  8004208088:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  800420808c:	83 e2 f0             	and    $0xfffffff0,%edx
  800420808f:	83 ca 0e             	or     $0xe,%edx
  8004208092:	88 50 45             	mov    %dl,0x45(%rax)
  8004208095:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420809c:	00 00 00 
  800420809f:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  80042080a3:	83 e2 ef             	and    $0xffffffef,%edx
  80042080a6:	88 50 45             	mov    %dl,0x45(%rax)
  80042080a9:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042080b0:	00 00 00 
  80042080b3:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  80042080b7:	83 e2 9f             	and    $0xffffff9f,%edx
  80042080ba:	88 50 45             	mov    %dl,0x45(%rax)
  80042080bd:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042080c4:	00 00 00 
  80042080c7:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  80042080cb:	83 ca 80             	or     $0xffffff80,%edx
  80042080ce:	88 50 45             	mov    %dl,0x45(%rax)
  80042080d1:	48 b8 20 9d 20 04 80 	movabs $0x8004209d20,%rax
  80042080d8:	00 00 00 
  80042080db:	48 c1 e8 10          	shr    $0x10,%rax
  80042080df:	89 c2                	mov    %eax,%edx
  80042080e1:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042080e8:	00 00 00 
  80042080eb:	66 89 50 46          	mov    %dx,0x46(%rax)
  80042080ef:	48 b8 20 9d 20 04 80 	movabs $0x8004209d20,%rax
  80042080f6:	00 00 00 
  80042080f9:	48 c1 e8 20          	shr    $0x20,%rax
  80042080fd:	89 c2                	mov    %eax,%edx
  80042080ff:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208106:	00 00 00 
  8004208109:	89 50 48             	mov    %edx,0x48(%rax)
  800420810c:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208113:	00 00 00 
  8004208116:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
	SETGATE(idt[T_BOUND], 0, GD_KT, handleBoundsCheck, 0);
  800420811d:	48 b8 26 9d 20 04 80 	movabs $0x8004209d26,%rax
  8004208124:	00 00 00 
  8004208127:	89 c2                	mov    %eax,%edx
  8004208129:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208130:	00 00 00 
  8004208133:	66 89 50 50          	mov    %dx,0x50(%rax)
  8004208137:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420813e:	00 00 00 
  8004208141:	66 c7 40 52 08 00    	movw   $0x8,0x52(%rax)
  8004208147:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420814e:	00 00 00 
  8004208151:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  8004208155:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208158:	88 50 54             	mov    %dl,0x54(%rax)
  800420815b:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208162:	00 00 00 
  8004208165:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  8004208169:	83 e2 07             	and    $0x7,%edx
  800420816c:	88 50 54             	mov    %dl,0x54(%rax)
  800420816f:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208176:	00 00 00 
  8004208179:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  800420817d:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208180:	83 ca 0e             	or     $0xe,%edx
  8004208183:	88 50 55             	mov    %dl,0x55(%rax)
  8004208186:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420818d:	00 00 00 
  8004208190:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004208194:	83 e2 ef             	and    $0xffffffef,%edx
  8004208197:	88 50 55             	mov    %dl,0x55(%rax)
  800420819a:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042081a1:	00 00 00 
  80042081a4:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  80042081a8:	83 e2 9f             	and    $0xffffff9f,%edx
  80042081ab:	88 50 55             	mov    %dl,0x55(%rax)
  80042081ae:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042081b5:	00 00 00 
  80042081b8:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  80042081bc:	83 ca 80             	or     $0xffffff80,%edx
  80042081bf:	88 50 55             	mov    %dl,0x55(%rax)
  80042081c2:	48 b8 26 9d 20 04 80 	movabs $0x8004209d26,%rax
  80042081c9:	00 00 00 
  80042081cc:	48 c1 e8 10          	shr    $0x10,%rax
  80042081d0:	89 c2                	mov    %eax,%edx
  80042081d2:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042081d9:	00 00 00 
  80042081dc:	66 89 50 56          	mov    %dx,0x56(%rax)
  80042081e0:	48 b8 26 9d 20 04 80 	movabs $0x8004209d26,%rax
  80042081e7:	00 00 00 
  80042081ea:	48 c1 e8 20          	shr    $0x20,%rax
  80042081ee:	89 c2                	mov    %eax,%edx
  80042081f0:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042081f7:	00 00 00 
  80042081fa:	89 50 58             	mov    %edx,0x58(%rax)
  80042081fd:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208204:	00 00 00 
  8004208207:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
	SETGATE(idt[T_ILLOP], 0, GD_KT, handleIllegalOpcode, 0);
  800420820e:	48 b8 2c 9d 20 04 80 	movabs $0x8004209d2c,%rax
  8004208215:	00 00 00 
  8004208218:	89 c2                	mov    %eax,%edx
  800420821a:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208221:	00 00 00 
  8004208224:	66 89 50 60          	mov    %dx,0x60(%rax)
  8004208228:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420822f:	00 00 00 
  8004208232:	66 c7 40 62 08 00    	movw   $0x8,0x62(%rax)
  8004208238:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420823f:	00 00 00 
  8004208242:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  8004208246:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208249:	88 50 64             	mov    %dl,0x64(%rax)
  800420824c:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208253:	00 00 00 
  8004208256:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  800420825a:	83 e2 07             	and    $0x7,%edx
  800420825d:	88 50 64             	mov    %dl,0x64(%rax)
  8004208260:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208267:	00 00 00 
  800420826a:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420826e:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208271:	83 ca 0e             	or     $0xe,%edx
  8004208274:	88 50 65             	mov    %dl,0x65(%rax)
  8004208277:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420827e:	00 00 00 
  8004208281:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004208285:	83 e2 ef             	and    $0xffffffef,%edx
  8004208288:	88 50 65             	mov    %dl,0x65(%rax)
  800420828b:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208292:	00 00 00 
  8004208295:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004208299:	83 e2 9f             	and    $0xffffff9f,%edx
  800420829c:	88 50 65             	mov    %dl,0x65(%rax)
  800420829f:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042082a6:	00 00 00 
  80042082a9:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  80042082ad:	83 ca 80             	or     $0xffffff80,%edx
  80042082b0:	88 50 65             	mov    %dl,0x65(%rax)
  80042082b3:	48 b8 2c 9d 20 04 80 	movabs $0x8004209d2c,%rax
  80042082ba:	00 00 00 
  80042082bd:	48 c1 e8 10          	shr    $0x10,%rax
  80042082c1:	89 c2                	mov    %eax,%edx
  80042082c3:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042082ca:	00 00 00 
  80042082cd:	66 89 50 66          	mov    %dx,0x66(%rax)
  80042082d1:	48 b8 2c 9d 20 04 80 	movabs $0x8004209d2c,%rax
  80042082d8:	00 00 00 
  80042082db:	48 c1 e8 20          	shr    $0x20,%rax
  80042082df:	89 c2                	mov    %eax,%edx
  80042082e1:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042082e8:	00 00 00 
  80042082eb:	89 50 68             	mov    %edx,0x68(%rax)
  80042082ee:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042082f5:	00 00 00 
  80042082f8:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%rax)
	SETGATE(idt[T_DEVICE], 0, GD_KT,handleDeviceNotAvailable , 0);
  80042082ff:	48 b8 32 9d 20 04 80 	movabs $0x8004209d32,%rax
  8004208306:	00 00 00 
  8004208309:	89 c2                	mov    %eax,%edx
  800420830b:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208312:	00 00 00 
  8004208315:	66 89 50 70          	mov    %dx,0x70(%rax)
  8004208319:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208320:	00 00 00 
  8004208323:	66 c7 40 72 08 00    	movw   $0x8,0x72(%rax)
  8004208329:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208330:	00 00 00 
  8004208333:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  8004208337:	83 e2 f8             	and    $0xfffffff8,%edx
  800420833a:	88 50 74             	mov    %dl,0x74(%rax)
  800420833d:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208344:	00 00 00 
  8004208347:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  800420834b:	83 e2 07             	and    $0x7,%edx
  800420834e:	88 50 74             	mov    %dl,0x74(%rax)
  8004208351:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208358:	00 00 00 
  800420835b:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420835f:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208362:	83 ca 0e             	or     $0xe,%edx
  8004208365:	88 50 75             	mov    %dl,0x75(%rax)
  8004208368:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420836f:	00 00 00 
  8004208372:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004208376:	83 e2 ef             	and    $0xffffffef,%edx
  8004208379:	88 50 75             	mov    %dl,0x75(%rax)
  800420837c:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208383:	00 00 00 
  8004208386:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420838a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420838d:	88 50 75             	mov    %dl,0x75(%rax)
  8004208390:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208397:	00 00 00 
  800420839a:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420839e:	83 ca 80             	or     $0xffffff80,%edx
  80042083a1:	88 50 75             	mov    %dl,0x75(%rax)
  80042083a4:	48 b8 32 9d 20 04 80 	movabs $0x8004209d32,%rax
  80042083ab:	00 00 00 
  80042083ae:	48 c1 e8 10          	shr    $0x10,%rax
  80042083b2:	89 c2                	mov    %eax,%edx
  80042083b4:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042083bb:	00 00 00 
  80042083be:	66 89 50 76          	mov    %dx,0x76(%rax)
  80042083c2:	48 b8 32 9d 20 04 80 	movabs $0x8004209d32,%rax
  80042083c9:	00 00 00 
  80042083cc:	48 c1 e8 20          	shr    $0x20,%rax
  80042083d0:	89 c2                	mov    %eax,%edx
  80042083d2:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042083d9:	00 00 00 
  80042083dc:	89 50 78             	mov    %edx,0x78(%rax)
  80042083df:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042083e6:	00 00 00 
  80042083e9:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
	SETGATE(idt[T_DBLFLT], 0, GD_KT, handleDoubleFault, 0);
  80042083f0:	48 b8 38 9d 20 04 80 	movabs $0x8004209d38,%rax
  80042083f7:	00 00 00 
  80042083fa:	89 c2                	mov    %eax,%edx
  80042083fc:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208403:	00 00 00 
  8004208406:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
  800420840d:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208414:	00 00 00 
  8004208417:	66 c7 80 82 00 00 00 	movw   $0x8,0x82(%rax)
  800420841e:	08 00 
  8004208420:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208427:	00 00 00 
  800420842a:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  8004208431:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208434:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  800420843a:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208441:	00 00 00 
  8004208444:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  800420844b:	83 e2 07             	and    $0x7,%edx
  800420844e:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  8004208454:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420845b:	00 00 00 
  800420845e:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004208465:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208468:	83 ca 0e             	or     $0xe,%edx
  800420846b:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004208471:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208478:	00 00 00 
  800420847b:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004208482:	83 e2 ef             	and    $0xffffffef,%edx
  8004208485:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420848b:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208492:	00 00 00 
  8004208495:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420849c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420849f:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  80042084a5:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042084ac:	00 00 00 
  80042084af:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  80042084b6:	83 ca 80             	or     $0xffffff80,%edx
  80042084b9:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  80042084bf:	48 b8 38 9d 20 04 80 	movabs $0x8004209d38,%rax
  80042084c6:	00 00 00 
  80042084c9:	48 c1 e8 10          	shr    $0x10,%rax
  80042084cd:	89 c2                	mov    %eax,%edx
  80042084cf:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042084d6:	00 00 00 
  80042084d9:	66 89 90 86 00 00 00 	mov    %dx,0x86(%rax)
  80042084e0:	48 b8 38 9d 20 04 80 	movabs $0x8004209d38,%rax
  80042084e7:	00 00 00 
  80042084ea:	48 c1 e8 20          	shr    $0x20,%rax
  80042084ee:	89 c2                	mov    %eax,%edx
  80042084f0:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042084f7:	00 00 00 
  80042084fa:	89 90 88 00 00 00    	mov    %edx,0x88(%rax)
  8004208500:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208507:	00 00 00 
  800420850a:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%rax)
  8004208511:	00 00 00 
	SETGATE(idt[T_TSS], 0, GD_KT, handleInvalidTaskSwitchSegment, 0);
  8004208514:	48 b8 3c 9d 20 04 80 	movabs $0x8004209d3c,%rax
  800420851b:	00 00 00 
  800420851e:	89 c2                	mov    %eax,%edx
  8004208520:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208527:	00 00 00 
  800420852a:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
  8004208531:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208538:	00 00 00 
  800420853b:	66 c7 80 a2 00 00 00 	movw   $0x8,0xa2(%rax)
  8004208542:	08 00 
  8004208544:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420854b:	00 00 00 
  800420854e:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  8004208555:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208558:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  800420855e:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208565:	00 00 00 
  8004208568:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  800420856f:	83 e2 07             	and    $0x7,%edx
  8004208572:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  8004208578:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420857f:	00 00 00 
  8004208582:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  8004208589:	83 e2 f0             	and    $0xfffffff0,%edx
  800420858c:	83 ca 0e             	or     $0xe,%edx
  800420858f:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004208595:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420859c:	00 00 00 
  800420859f:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042085a6:	83 e2 ef             	and    $0xffffffef,%edx
  80042085a9:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042085af:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042085b6:	00 00 00 
  80042085b9:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042085c0:	83 e2 9f             	and    $0xffffff9f,%edx
  80042085c3:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042085c9:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042085d0:	00 00 00 
  80042085d3:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042085da:	83 ca 80             	or     $0xffffff80,%edx
  80042085dd:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042085e3:	48 b8 3c 9d 20 04 80 	movabs $0x8004209d3c,%rax
  80042085ea:	00 00 00 
  80042085ed:	48 c1 e8 10          	shr    $0x10,%rax
  80042085f1:	89 c2                	mov    %eax,%edx
  80042085f3:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042085fa:	00 00 00 
  80042085fd:	66 89 90 a6 00 00 00 	mov    %dx,0xa6(%rax)
  8004208604:	48 b8 3c 9d 20 04 80 	movabs $0x8004209d3c,%rax
  800420860b:	00 00 00 
  800420860e:	48 c1 e8 20          	shr    $0x20,%rax
  8004208612:	89 c2                	mov    %eax,%edx
  8004208614:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420861b:	00 00 00 
  800420861e:	89 90 a8 00 00 00    	mov    %edx,0xa8(%rax)
  8004208624:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420862b:	00 00 00 
  800420862e:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%rax)
  8004208635:	00 00 00 
	SETGATE(idt[T_SEGNP], 0, GD_KT,handleSegmentNotPresent , 0);
  8004208638:	48 b8 40 9d 20 04 80 	movabs $0x8004209d40,%rax
  800420863f:	00 00 00 
  8004208642:	89 c2                	mov    %eax,%edx
  8004208644:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420864b:	00 00 00 
  800420864e:	66 89 90 b0 00 00 00 	mov    %dx,0xb0(%rax)
  8004208655:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420865c:	00 00 00 
  800420865f:	66 c7 80 b2 00 00 00 	movw   $0x8,0xb2(%rax)
  8004208666:	08 00 
  8004208668:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420866f:	00 00 00 
  8004208672:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  8004208679:	83 e2 f8             	and    $0xfffffff8,%edx
  800420867c:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  8004208682:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208689:	00 00 00 
  800420868c:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  8004208693:	83 e2 07             	and    $0x7,%edx
  8004208696:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  800420869c:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042086a3:	00 00 00 
  80042086a6:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042086ad:	83 e2 f0             	and    $0xfffffff0,%edx
  80042086b0:	83 ca 0e             	or     $0xe,%edx
  80042086b3:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042086b9:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042086c0:	00 00 00 
  80042086c3:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042086ca:	83 e2 ef             	and    $0xffffffef,%edx
  80042086cd:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042086d3:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042086da:	00 00 00 
  80042086dd:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042086e4:	83 e2 9f             	and    $0xffffff9f,%edx
  80042086e7:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042086ed:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042086f4:	00 00 00 
  80042086f7:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042086fe:	83 ca 80             	or     $0xffffff80,%edx
  8004208701:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004208707:	48 b8 40 9d 20 04 80 	movabs $0x8004209d40,%rax
  800420870e:	00 00 00 
  8004208711:	48 c1 e8 10          	shr    $0x10,%rax
  8004208715:	89 c2                	mov    %eax,%edx
  8004208717:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420871e:	00 00 00 
  8004208721:	66 89 90 b6 00 00 00 	mov    %dx,0xb6(%rax)
  8004208728:	48 b8 40 9d 20 04 80 	movabs $0x8004209d40,%rax
  800420872f:	00 00 00 
  8004208732:	48 c1 e8 20          	shr    $0x20,%rax
  8004208736:	89 c2                	mov    %eax,%edx
  8004208738:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420873f:	00 00 00 
  8004208742:	89 90 b8 00 00 00    	mov    %edx,0xb8(%rax)
  8004208748:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420874f:	00 00 00 
  8004208752:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%rax)
  8004208759:	00 00 00 
	SETGATE(idt[T_STACK], 0, GD_KT, handleStackException, 0);
  800420875c:	48 b8 44 9d 20 04 80 	movabs $0x8004209d44,%rax
  8004208763:	00 00 00 
  8004208766:	89 c2                	mov    %eax,%edx
  8004208768:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420876f:	00 00 00 
  8004208772:	66 89 90 c0 00 00 00 	mov    %dx,0xc0(%rax)
  8004208779:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208780:	00 00 00 
  8004208783:	66 c7 80 c2 00 00 00 	movw   $0x8,0xc2(%rax)
  800420878a:	08 00 
  800420878c:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208793:	00 00 00 
  8004208796:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  800420879d:	83 e2 f8             	and    $0xfffffff8,%edx
  80042087a0:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  80042087a6:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042087ad:	00 00 00 
  80042087b0:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  80042087b7:	83 e2 07             	and    $0x7,%edx
  80042087ba:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  80042087c0:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042087c7:	00 00 00 
  80042087ca:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  80042087d1:	83 e2 f0             	and    $0xfffffff0,%edx
  80042087d4:	83 ca 0e             	or     $0xe,%edx
  80042087d7:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  80042087dd:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042087e4:	00 00 00 
  80042087e7:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  80042087ee:	83 e2 ef             	and    $0xffffffef,%edx
  80042087f1:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  80042087f7:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042087fe:	00 00 00 
  8004208801:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004208808:	83 e2 9f             	and    $0xffffff9f,%edx
  800420880b:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004208811:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208818:	00 00 00 
  800420881b:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004208822:	83 ca 80             	or     $0xffffff80,%edx
  8004208825:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420882b:	48 b8 44 9d 20 04 80 	movabs $0x8004209d44,%rax
  8004208832:	00 00 00 
  8004208835:	48 c1 e8 10          	shr    $0x10,%rax
  8004208839:	89 c2                	mov    %eax,%edx
  800420883b:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208842:	00 00 00 
  8004208845:	66 89 90 c6 00 00 00 	mov    %dx,0xc6(%rax)
  800420884c:	48 b8 44 9d 20 04 80 	movabs $0x8004209d44,%rax
  8004208853:	00 00 00 
  8004208856:	48 c1 e8 20          	shr    $0x20,%rax
  800420885a:	89 c2                	mov    %eax,%edx
  800420885c:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208863:	00 00 00 
  8004208866:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
  800420886c:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208873:	00 00 00 
  8004208876:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  800420887d:	00 00 00 
	SETGATE(idt[T_GPFLT], 0, GD_KT, handleGeneralProtectionFault, 0);
  8004208880:	48 b8 48 9d 20 04 80 	movabs $0x8004209d48,%rax
  8004208887:	00 00 00 
  800420888a:	89 c2                	mov    %eax,%edx
  800420888c:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208893:	00 00 00 
  8004208896:	66 89 90 d0 00 00 00 	mov    %dx,0xd0(%rax)
  800420889d:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042088a4:	00 00 00 
  80042088a7:	66 c7 80 d2 00 00 00 	movw   $0x8,0xd2(%rax)
  80042088ae:	08 00 
  80042088b0:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042088b7:	00 00 00 
  80042088ba:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  80042088c1:	83 e2 f8             	and    $0xfffffff8,%edx
  80042088c4:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  80042088ca:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042088d1:	00 00 00 
  80042088d4:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  80042088db:	83 e2 07             	and    $0x7,%edx
  80042088de:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  80042088e4:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042088eb:	00 00 00 
  80042088ee:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  80042088f5:	83 e2 f0             	and    $0xfffffff0,%edx
  80042088f8:	83 ca 0e             	or     $0xe,%edx
  80042088fb:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004208901:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208908:	00 00 00 
  800420890b:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004208912:	83 e2 ef             	and    $0xffffffef,%edx
  8004208915:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420891b:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208922:	00 00 00 
  8004208925:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420892c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420892f:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004208935:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420893c:	00 00 00 
  800420893f:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004208946:	83 ca 80             	or     $0xffffff80,%edx
  8004208949:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420894f:	48 b8 48 9d 20 04 80 	movabs $0x8004209d48,%rax
  8004208956:	00 00 00 
  8004208959:	48 c1 e8 10          	shr    $0x10,%rax
  800420895d:	89 c2                	mov    %eax,%edx
  800420895f:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208966:	00 00 00 
  8004208969:	66 89 90 d6 00 00 00 	mov    %dx,0xd6(%rax)
  8004208970:	48 b8 48 9d 20 04 80 	movabs $0x8004209d48,%rax
  8004208977:	00 00 00 
  800420897a:	48 c1 e8 20          	shr    $0x20,%rax
  800420897e:	89 c2                	mov    %eax,%edx
  8004208980:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208987:	00 00 00 
  800420898a:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
  8004208990:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208997:	00 00 00 
  800420899a:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%rax)
  80042089a1:	00 00 00 
	SETGATE(idt[T_PGFLT], 0, GD_KT, handlePageFault, 0);
  80042089a4:	48 b8 4c 9d 20 04 80 	movabs $0x8004209d4c,%rax
  80042089ab:	00 00 00 
  80042089ae:	89 c2                	mov    %eax,%edx
  80042089b0:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042089b7:	00 00 00 
  80042089ba:	66 89 90 e0 00 00 00 	mov    %dx,0xe0(%rax)
  80042089c1:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042089c8:	00 00 00 
  80042089cb:	66 c7 80 e2 00 00 00 	movw   $0x8,0xe2(%rax)
  80042089d2:	08 00 
  80042089d4:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042089db:	00 00 00 
  80042089de:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  80042089e5:	83 e2 f8             	and    $0xfffffff8,%edx
  80042089e8:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  80042089ee:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042089f5:	00 00 00 
  80042089f8:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  80042089ff:	83 e2 07             	and    $0x7,%edx
  8004208a02:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  8004208a08:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208a0f:	00 00 00 
  8004208a12:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004208a19:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208a1c:	83 ca 0e             	or     $0xe,%edx
  8004208a1f:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004208a25:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208a2c:	00 00 00 
  8004208a2f:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004208a36:	83 e2 ef             	and    $0xffffffef,%edx
  8004208a39:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004208a3f:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208a46:	00 00 00 
  8004208a49:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004208a50:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208a53:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004208a59:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208a60:	00 00 00 
  8004208a63:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004208a6a:	83 ca 80             	or     $0xffffff80,%edx
  8004208a6d:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004208a73:	48 b8 4c 9d 20 04 80 	movabs $0x8004209d4c,%rax
  8004208a7a:	00 00 00 
  8004208a7d:	48 c1 e8 10          	shr    $0x10,%rax
  8004208a81:	89 c2                	mov    %eax,%edx
  8004208a83:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208a8a:	00 00 00 
  8004208a8d:	66 89 90 e6 00 00 00 	mov    %dx,0xe6(%rax)
  8004208a94:	48 b8 4c 9d 20 04 80 	movabs $0x8004209d4c,%rax
  8004208a9b:	00 00 00 
  8004208a9e:	48 c1 e8 20          	shr    $0x20,%rax
  8004208aa2:	89 c2                	mov    %eax,%edx
  8004208aa4:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208aab:	00 00 00 
  8004208aae:	89 90 e8 00 00 00    	mov    %edx,0xe8(%rax)
  8004208ab4:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208abb:	00 00 00 
  8004208abe:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%rax)
  8004208ac5:	00 00 00 
	SETGATE(idt[T_FPERR], 0, GD_KT, handleFloatingPointError, 0);
  8004208ac8:	48 b8 50 9d 20 04 80 	movabs $0x8004209d50,%rax
  8004208acf:	00 00 00 
  8004208ad2:	89 c2                	mov    %eax,%edx
  8004208ad4:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208adb:	00 00 00 
  8004208ade:	66 89 90 00 01 00 00 	mov    %dx,0x100(%rax)
  8004208ae5:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208aec:	00 00 00 
  8004208aef:	66 c7 80 02 01 00 00 	movw   $0x8,0x102(%rax)
  8004208af6:	08 00 
  8004208af8:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208aff:	00 00 00 
  8004208b02:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  8004208b09:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208b0c:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004208b12:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208b19:	00 00 00 
  8004208b1c:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  8004208b23:	83 e2 07             	and    $0x7,%edx
  8004208b26:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004208b2c:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208b33:	00 00 00 
  8004208b36:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004208b3d:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208b40:	83 ca 0e             	or     $0xe,%edx
  8004208b43:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004208b49:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208b50:	00 00 00 
  8004208b53:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004208b5a:	83 e2 ef             	and    $0xffffffef,%edx
  8004208b5d:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004208b63:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208b6a:	00 00 00 
  8004208b6d:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004208b74:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208b77:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004208b7d:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208b84:	00 00 00 
  8004208b87:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004208b8e:	83 ca 80             	or     $0xffffff80,%edx
  8004208b91:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004208b97:	48 b8 50 9d 20 04 80 	movabs $0x8004209d50,%rax
  8004208b9e:	00 00 00 
  8004208ba1:	48 c1 e8 10          	shr    $0x10,%rax
  8004208ba5:	89 c2                	mov    %eax,%edx
  8004208ba7:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208bae:	00 00 00 
  8004208bb1:	66 89 90 06 01 00 00 	mov    %dx,0x106(%rax)
  8004208bb8:	48 b8 50 9d 20 04 80 	movabs $0x8004209d50,%rax
  8004208bbf:	00 00 00 
  8004208bc2:	48 c1 e8 20          	shr    $0x20,%rax
  8004208bc6:	89 c2                	mov    %eax,%edx
  8004208bc8:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208bcf:	00 00 00 
  8004208bd2:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
  8004208bd8:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208bdf:	00 00 00 
  8004208be2:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  8004208be9:	00 00 00 
	SETGATE(idt[T_ALIGN], 0, GD_KT,handleAligmentCheck , 0);
  8004208bec:	48 b8 56 9d 20 04 80 	movabs $0x8004209d56,%rax
  8004208bf3:	00 00 00 
  8004208bf6:	89 c2                	mov    %eax,%edx
  8004208bf8:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208bff:	00 00 00 
  8004208c02:	66 89 90 10 01 00 00 	mov    %dx,0x110(%rax)
  8004208c09:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208c10:	00 00 00 
  8004208c13:	66 c7 80 12 01 00 00 	movw   $0x8,0x112(%rax)
  8004208c1a:	08 00 
  8004208c1c:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208c23:	00 00 00 
  8004208c26:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  8004208c2d:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208c30:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  8004208c36:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208c3d:	00 00 00 
  8004208c40:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  8004208c47:	83 e2 07             	and    $0x7,%edx
  8004208c4a:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  8004208c50:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208c57:	00 00 00 
  8004208c5a:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004208c61:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208c64:	83 ca 0e             	or     $0xe,%edx
  8004208c67:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004208c6d:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208c74:	00 00 00 
  8004208c77:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004208c7e:	83 e2 ef             	and    $0xffffffef,%edx
  8004208c81:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004208c87:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208c8e:	00 00 00 
  8004208c91:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004208c98:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208c9b:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004208ca1:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208ca8:	00 00 00 
  8004208cab:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004208cb2:	83 ca 80             	or     $0xffffff80,%edx
  8004208cb5:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004208cbb:	48 b8 56 9d 20 04 80 	movabs $0x8004209d56,%rax
  8004208cc2:	00 00 00 
  8004208cc5:	48 c1 e8 10          	shr    $0x10,%rax
  8004208cc9:	89 c2                	mov    %eax,%edx
  8004208ccb:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208cd2:	00 00 00 
  8004208cd5:	66 89 90 16 01 00 00 	mov    %dx,0x116(%rax)
  8004208cdc:	48 b8 56 9d 20 04 80 	movabs $0x8004209d56,%rax
  8004208ce3:	00 00 00 
  8004208ce6:	48 c1 e8 20          	shr    $0x20,%rax
  8004208cea:	89 c2                	mov    %eax,%edx
  8004208cec:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208cf3:	00 00 00 
  8004208cf6:	89 90 18 01 00 00    	mov    %edx,0x118(%rax)
  8004208cfc:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208d03:	00 00 00 
  8004208d06:	c7 80 1c 01 00 00 00 	movl   $0x0,0x11c(%rax)
  8004208d0d:	00 00 00 
	SETGATE(idt[T_MCHK], 0, GD_KT,handleMachineCheck , 0);
  8004208d10:	48 b8 5a 9d 20 04 80 	movabs $0x8004209d5a,%rax
  8004208d17:	00 00 00 
  8004208d1a:	89 c2                	mov    %eax,%edx
  8004208d1c:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208d23:	00 00 00 
  8004208d26:	66 89 90 20 01 00 00 	mov    %dx,0x120(%rax)
  8004208d2d:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208d34:	00 00 00 
  8004208d37:	66 c7 80 22 01 00 00 	movw   $0x8,0x122(%rax)
  8004208d3e:	08 00 
  8004208d40:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208d47:	00 00 00 
  8004208d4a:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  8004208d51:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208d54:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  8004208d5a:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208d61:	00 00 00 
  8004208d64:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  8004208d6b:	83 e2 07             	and    $0x7,%edx
  8004208d6e:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  8004208d74:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208d7b:	00 00 00 
  8004208d7e:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  8004208d85:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208d88:	83 ca 0e             	or     $0xe,%edx
  8004208d8b:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  8004208d91:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208d98:	00 00 00 
  8004208d9b:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  8004208da2:	83 e2 ef             	and    $0xffffffef,%edx
  8004208da5:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  8004208dab:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208db2:	00 00 00 
  8004208db5:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  8004208dbc:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208dbf:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  8004208dc5:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208dcc:	00 00 00 
  8004208dcf:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  8004208dd6:	83 ca 80             	or     $0xffffff80,%edx
  8004208dd9:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  8004208ddf:	48 b8 5a 9d 20 04 80 	movabs $0x8004209d5a,%rax
  8004208de6:	00 00 00 
  8004208de9:	48 c1 e8 10          	shr    $0x10,%rax
  8004208ded:	89 c2                	mov    %eax,%edx
  8004208def:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208df6:	00 00 00 
  8004208df9:	66 89 90 26 01 00 00 	mov    %dx,0x126(%rax)
  8004208e00:	48 b8 5a 9d 20 04 80 	movabs $0x8004209d5a,%rax
  8004208e07:	00 00 00 
  8004208e0a:	48 c1 e8 20          	shr    $0x20,%rax
  8004208e0e:	89 c2                	mov    %eax,%edx
  8004208e10:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208e17:	00 00 00 
  8004208e1a:	89 90 28 01 00 00    	mov    %edx,0x128(%rax)
  8004208e20:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208e27:	00 00 00 
  8004208e2a:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%rax)
  8004208e31:	00 00 00 
	SETGATE(idt[T_SIMDERR], 0, GD_KT, handleSIMDFloatingPointError, 0);
  8004208e34:	48 b8 60 9d 20 04 80 	movabs $0x8004209d60,%rax
  8004208e3b:	00 00 00 
  8004208e3e:	89 c2                	mov    %eax,%edx
  8004208e40:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208e47:	00 00 00 
  8004208e4a:	66 89 90 30 01 00 00 	mov    %dx,0x130(%rax)
  8004208e51:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208e58:	00 00 00 
  8004208e5b:	66 c7 80 32 01 00 00 	movw   $0x8,0x132(%rax)
  8004208e62:	08 00 
  8004208e64:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208e6b:	00 00 00 
  8004208e6e:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  8004208e75:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208e78:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  8004208e7e:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208e85:	00 00 00 
  8004208e88:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  8004208e8f:	83 e2 07             	and    $0x7,%edx
  8004208e92:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  8004208e98:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208e9f:	00 00 00 
  8004208ea2:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004208ea9:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208eac:	83 ca 0e             	or     $0xe,%edx
  8004208eaf:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004208eb5:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208ebc:	00 00 00 
  8004208ebf:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004208ec6:	83 e2 ef             	and    $0xffffffef,%edx
  8004208ec9:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004208ecf:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208ed6:	00 00 00 
  8004208ed9:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004208ee0:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208ee3:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004208ee9:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208ef0:	00 00 00 
  8004208ef3:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004208efa:	83 ca 80             	or     $0xffffff80,%edx
  8004208efd:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004208f03:	48 b8 60 9d 20 04 80 	movabs $0x8004209d60,%rax
  8004208f0a:	00 00 00 
  8004208f0d:	48 c1 e8 10          	shr    $0x10,%rax
  8004208f11:	89 c2                	mov    %eax,%edx
  8004208f13:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208f1a:	00 00 00 
  8004208f1d:	66 89 90 36 01 00 00 	mov    %dx,0x136(%rax)
  8004208f24:	48 b8 60 9d 20 04 80 	movabs $0x8004209d60,%rax
  8004208f2b:	00 00 00 
  8004208f2e:	48 c1 e8 20          	shr    $0x20,%rax
  8004208f32:	89 c2                	mov    %eax,%edx
  8004208f34:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208f3b:	00 00 00 
  8004208f3e:	89 90 38 01 00 00    	mov    %edx,0x138(%rax)
  8004208f44:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208f4b:	00 00 00 
  8004208f4e:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%rax)
  8004208f55:	00 00 00 
	SETGATE(idt[T_SYSCALL], 0, GD_KT, handleSystemCall, 3);
  8004208f58:	48 b8 66 9d 20 04 80 	movabs $0x8004209d66,%rax
  8004208f5f:	00 00 00 
  8004208f62:	89 c2                	mov    %eax,%edx
  8004208f64:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208f6b:	00 00 00 
  8004208f6e:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  8004208f75:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208f7c:	00 00 00 
  8004208f7f:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  8004208f86:	08 00 
  8004208f88:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208f8f:	00 00 00 
  8004208f92:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  8004208f99:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208f9c:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  8004208fa2:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208fa9:	00 00 00 
  8004208fac:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  8004208fb3:	83 e2 07             	and    $0x7,%edx
  8004208fb6:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  8004208fbc:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208fc3:	00 00 00 
  8004208fc6:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004208fcd:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208fd0:	83 ca 0e             	or     $0xe,%edx
  8004208fd3:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004208fd9:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208fe0:	00 00 00 
  8004208fe3:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004208fea:	83 e2 ef             	and    $0xffffffef,%edx
  8004208fed:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004208ff3:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004208ffa:	00 00 00 
  8004208ffd:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209004:	83 ca 60             	or     $0x60,%edx
  8004209007:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420900d:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004209014:	00 00 00 
  8004209017:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420901e:	83 ca 80             	or     $0xffffff80,%edx
  8004209021:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209027:	48 b8 66 9d 20 04 80 	movabs $0x8004209d66,%rax
  800420902e:	00 00 00 
  8004209031:	48 c1 e8 10          	shr    $0x10,%rax
  8004209035:	89 c2                	mov    %eax,%edx
  8004209037:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420903e:	00 00 00 
  8004209041:	66 89 90 06 03 00 00 	mov    %dx,0x306(%rax)
  8004209048:	48 b8 66 9d 20 04 80 	movabs $0x8004209d66,%rax
  800420904f:	00 00 00 
  8004209052:	48 c1 e8 20          	shr    $0x20,%rax
  8004209056:	89 c2                	mov    %eax,%edx
  8004209058:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420905f:	00 00 00 
  8004209062:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  8004209068:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420906f:	00 00 00 
  8004209072:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  8004209079:	00 00 00 
	SETGATE(idt[T_DEFAULT], 0, GD_KT,handleCatchall , 0);
  800420907c:	48 b8 6c 9d 20 04 80 	movabs $0x8004209d6c,%rax
  8004209083:	00 00 00 
  8004209086:	89 c2                	mov    %eax,%edx
  8004209088:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420908f:	00 00 00 
  8004209092:	66 89 90 40 1f 00 00 	mov    %dx,0x1f40(%rax)
  8004209099:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042090a0:	00 00 00 
  80042090a3:	66 c7 80 42 1f 00 00 	movw   $0x8,0x1f42(%rax)
  80042090aa:	08 00 
  80042090ac:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042090b3:	00 00 00 
  80042090b6:	0f b6 90 44 1f 00 00 	movzbl 0x1f44(%rax),%edx
  80042090bd:	83 e2 f8             	and    $0xfffffff8,%edx
  80042090c0:	88 90 44 1f 00 00    	mov    %dl,0x1f44(%rax)
  80042090c6:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042090cd:	00 00 00 
  80042090d0:	0f b6 90 44 1f 00 00 	movzbl 0x1f44(%rax),%edx
  80042090d7:	83 e2 07             	and    $0x7,%edx
  80042090da:	88 90 44 1f 00 00    	mov    %dl,0x1f44(%rax)
  80042090e0:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  80042090e7:	00 00 00 
  80042090ea:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  80042090f1:	83 e2 f0             	and    $0xfffffff0,%edx
  80042090f4:	83 ca 0e             	or     $0xe,%edx
  80042090f7:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  80042090fd:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004209104:	00 00 00 
  8004209107:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420910e:	83 e2 ef             	and    $0xffffffef,%edx
  8004209111:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  8004209117:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  800420911e:	00 00 00 
  8004209121:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  8004209128:	83 e2 9f             	and    $0xffffff9f,%edx
  800420912b:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  8004209131:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004209138:	00 00 00 
  800420913b:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  8004209142:	83 ca 80             	or     $0xffffff80,%edx
  8004209145:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420914b:	48 b8 6c 9d 20 04 80 	movabs $0x8004209d6c,%rax
  8004209152:	00 00 00 
  8004209155:	48 c1 e8 10          	shr    $0x10,%rax
  8004209159:	89 c2                	mov    %eax,%edx
  800420915b:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004209162:	00 00 00 
  8004209165:	66 89 90 46 1f 00 00 	mov    %dx,0x1f46(%rax)
  800420916c:	48 b8 6c 9d 20 04 80 	movabs $0x8004209d6c,%rax
  8004209173:	00 00 00 
  8004209176:	48 c1 e8 20          	shr    $0x20,%rax
  800420917a:	89 c2                	mov    %eax,%edx
  800420917c:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004209183:	00 00 00 
  8004209186:	89 90 48 1f 00 00    	mov    %edx,0x1f48(%rax)
  800420918c:	48 b8 c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rax
  8004209193:	00 00 00 
  8004209196:	c7 80 4c 1f 00 00 00 	movl   $0x0,0x1f4c(%rax)
  800420919d:	00 00 00 
	idt_pd.pd_lim = sizeof(idt)-1;
  80042091a0:	48 b8 c0 d6 2b 04 80 	movabs $0x80042bd6c0,%rax
  80042091a7:	00 00 00 
  80042091aa:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)
	idt_pd.pd_base = (uint64_t)idt;
  80042091af:	48 ba c0 c6 2b 04 80 	movabs $0x80042bc6c0,%rdx
  80042091b6:	00 00 00 
  80042091b9:	48 b8 c0 d6 2b 04 80 	movabs $0x80042bd6c0,%rax
  80042091c0:	00 00 00 
  80042091c3:	48 89 50 02          	mov    %rdx,0x2(%rax)
	// Per-CPU setup
	trap_init_percpu();
  80042091c7:	48 b8 d5 91 20 04 80 	movabs $0x80042091d5,%rax
  80042091ce:	00 00 00 
  80042091d1:	ff d0                	callq  *%rax
}
  80042091d3:	5d                   	pop    %rbp
  80042091d4:	c3                   	retq   

00000080042091d5 <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  80042091d5:	55                   	push   %rbp
  80042091d6:	48 89 e5             	mov    %rsp,%rbp
  80042091d9:	48 83 ec 10          	sub    $0x10,%rsp
	// Setup a TSS so that we get the right stack
	// when we trap to the kernel.
	ts.ts_esp0 = KSTACKTOP;
  80042091dd:	48 b8 e0 d6 2b 04 80 	movabs $0x80042bd6e0,%rax
  80042091e4:	00 00 00 
  80042091e7:	48 b9 00 00 00 04 80 	movabs $0x8004000000,%rcx
  80042091ee:	00 00 00 
  80042091f1:	48 89 48 04          	mov    %rcx,0x4(%rax)

	// Initialize the TSS slot of the gdt.
	SETTSS((struct SystemSegdesc64 *)((gdt_pd>>16)+40),STS_T64A, (uint64_t) (&ts),sizeof(struct Taskstate), 0);
  80042091f5:	48 b8 f8 65 22 04 80 	movabs $0x80042265f8,%rax
  80042091fc:	00 00 00 
  80042091ff:	48 8b 00             	mov    (%rax),%rax
  8004209202:	48 c1 f8 10          	sar    $0x10,%rax
  8004209206:	48 83 c0 28          	add    $0x28,%rax
  800420920a:	66 c7 00 68 00       	movw   $0x68,(%rax)
  800420920f:	48 b8 f8 65 22 04 80 	movabs $0x80042265f8,%rax
  8004209216:	00 00 00 
  8004209219:	48 8b 00             	mov    (%rax),%rax
  800420921c:	48 c1 f8 10          	sar    $0x10,%rax
  8004209220:	48 83 c0 28          	add    $0x28,%rax
  8004209224:	48 ba e0 d6 2b 04 80 	movabs $0x80042bd6e0,%rdx
  800420922b:	00 00 00 
  800420922e:	66 89 50 02          	mov    %dx,0x2(%rax)
  8004209232:	48 b8 f8 65 22 04 80 	movabs $0x80042265f8,%rax
  8004209239:	00 00 00 
  800420923c:	48 8b 00             	mov    (%rax),%rax
  800420923f:	48 c1 f8 10          	sar    $0x10,%rax
  8004209243:	48 83 c0 28          	add    $0x28,%rax
  8004209247:	48 ba e0 d6 2b 04 80 	movabs $0x80042bd6e0,%rdx
  800420924e:	00 00 00 
  8004209251:	48 c1 ea 10          	shr    $0x10,%rdx
  8004209255:	88 50 04             	mov    %dl,0x4(%rax)
  8004209258:	48 b8 f8 65 22 04 80 	movabs $0x80042265f8,%rax
  800420925f:	00 00 00 
  8004209262:	48 8b 00             	mov    (%rax),%rax
  8004209265:	48 c1 f8 10          	sar    $0x10,%rax
  8004209269:	48 83 c0 28          	add    $0x28,%rax
  800420926d:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209271:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209274:	83 ca 09             	or     $0x9,%edx
  8004209277:	88 50 05             	mov    %dl,0x5(%rax)
  800420927a:	48 b8 f8 65 22 04 80 	movabs $0x80042265f8,%rax
  8004209281:	00 00 00 
  8004209284:	48 8b 00             	mov    (%rax),%rax
  8004209287:	48 c1 f8 10          	sar    $0x10,%rax
  800420928b:	48 83 c0 28          	add    $0x28,%rax
  800420928f:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209293:	83 e2 ef             	and    $0xffffffef,%edx
  8004209296:	88 50 05             	mov    %dl,0x5(%rax)
  8004209299:	48 b8 f8 65 22 04 80 	movabs $0x80042265f8,%rax
  80042092a0:	00 00 00 
  80042092a3:	48 8b 00             	mov    (%rax),%rax
  80042092a6:	48 c1 f8 10          	sar    $0x10,%rax
  80042092aa:	48 83 c0 28          	add    $0x28,%rax
  80042092ae:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042092b2:	83 e2 9f             	and    $0xffffff9f,%edx
  80042092b5:	88 50 05             	mov    %dl,0x5(%rax)
  80042092b8:	48 b8 f8 65 22 04 80 	movabs $0x80042265f8,%rax
  80042092bf:	00 00 00 
  80042092c2:	48 8b 00             	mov    (%rax),%rax
  80042092c5:	48 c1 f8 10          	sar    $0x10,%rax
  80042092c9:	48 83 c0 28          	add    $0x28,%rax
  80042092cd:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042092d1:	83 ca 80             	or     $0xffffff80,%edx
  80042092d4:	88 50 05             	mov    %dl,0x5(%rax)
  80042092d7:	48 b8 f8 65 22 04 80 	movabs $0x80042265f8,%rax
  80042092de:	00 00 00 
  80042092e1:	48 8b 00             	mov    (%rax),%rax
  80042092e4:	48 c1 f8 10          	sar    $0x10,%rax
  80042092e8:	48 83 c0 28          	add    $0x28,%rax
  80042092ec:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  80042092f0:	83 e2 f0             	and    $0xfffffff0,%edx
  80042092f3:	88 50 06             	mov    %dl,0x6(%rax)
  80042092f6:	48 b8 f8 65 22 04 80 	movabs $0x80042265f8,%rax
  80042092fd:	00 00 00 
  8004209300:	48 8b 00             	mov    (%rax),%rax
  8004209303:	48 c1 f8 10          	sar    $0x10,%rax
  8004209307:	48 83 c0 28          	add    $0x28,%rax
  800420930b:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420930f:	83 e2 ef             	and    $0xffffffef,%edx
  8004209312:	88 50 06             	mov    %dl,0x6(%rax)
  8004209315:	48 b8 f8 65 22 04 80 	movabs $0x80042265f8,%rax
  800420931c:	00 00 00 
  800420931f:	48 8b 00             	mov    (%rax),%rax
  8004209322:	48 c1 f8 10          	sar    $0x10,%rax
  8004209326:	48 83 c0 28          	add    $0x28,%rax
  800420932a:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420932e:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209331:	88 50 06             	mov    %dl,0x6(%rax)
  8004209334:	48 b8 f8 65 22 04 80 	movabs $0x80042265f8,%rax
  800420933b:	00 00 00 
  800420933e:	48 8b 00             	mov    (%rax),%rax
  8004209341:	48 c1 f8 10          	sar    $0x10,%rax
  8004209345:	48 83 c0 28          	add    $0x28,%rax
  8004209349:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420934d:	83 e2 7f             	and    $0x7f,%edx
  8004209350:	88 50 06             	mov    %dl,0x6(%rax)
  8004209353:	48 b8 f8 65 22 04 80 	movabs $0x80042265f8,%rax
  800420935a:	00 00 00 
  800420935d:	48 8b 00             	mov    (%rax),%rax
  8004209360:	48 c1 f8 10          	sar    $0x10,%rax
  8004209364:	48 83 c0 28          	add    $0x28,%rax
  8004209368:	48 ba e0 d6 2b 04 80 	movabs $0x80042bd6e0,%rdx
  800420936f:	00 00 00 
  8004209372:	48 c1 ea 18          	shr    $0x18,%rdx
  8004209376:	88 50 07             	mov    %dl,0x7(%rax)
  8004209379:	48 b8 f8 65 22 04 80 	movabs $0x80042265f8,%rax
  8004209380:	00 00 00 
  8004209383:	48 8b 00             	mov    (%rax),%rax
  8004209386:	48 c1 f8 10          	sar    $0x10,%rax
  800420938a:	48 83 c0 28          	add    $0x28,%rax
  800420938e:	48 ba e0 d6 2b 04 80 	movabs $0x80042bd6e0,%rdx
  8004209395:	00 00 00 
  8004209398:	48 c1 ea 20          	shr    $0x20,%rdx
  800420939c:	89 50 08             	mov    %edx,0x8(%rax)
  800420939f:	48 b8 f8 65 22 04 80 	movabs $0x80042265f8,%rax
  80042093a6:	00 00 00 
  80042093a9:	48 8b 00             	mov    (%rax),%rax
  80042093ac:	48 c1 f8 10          	sar    $0x10,%rax
  80042093b0:	48 83 c0 28          	add    $0x28,%rax
  80042093b4:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  80042093b8:	48 b8 f8 65 22 04 80 	movabs $0x80042265f8,%rax
  80042093bf:	00 00 00 
  80042093c2:	48 8b 00             	mov    (%rax),%rax
  80042093c5:	48 c1 f8 10          	sar    $0x10,%rax
  80042093c9:	48 83 c0 28          	add    $0x28,%rax
  80042093cd:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  80042093d1:	48 b8 f8 65 22 04 80 	movabs $0x80042265f8,%rax
  80042093d8:	00 00 00 
  80042093db:	48 8b 00             	mov    (%rax),%rax
  80042093de:	48 c1 f8 10          	sar    $0x10,%rax
  80042093e2:	48 83 c0 28          	add    $0x28,%rax
  80042093e6:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)
  80042093ec:	66 c7 45 fe 28 00    	movw   $0x28,-0x2(%rbp)
	__asm __volatile("lgdt (%0)" : : "r" (p));
}
static __inline void
ltr(uint16_t sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
  80042093f2:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  80042093f6:	0f 00 d8             	ltr    %ax
  80042093f9:	48 b8 c0 d6 2b 04 80 	movabs $0x80042bd6c0,%rax
  8004209400:	00 00 00 
  8004209403:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}  

static __inline void
lidt(void *p)
{
	__asm __volatile("lidt (%0)" : : "r" (p));
  8004209407:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420940b:	0f 01 18             	lidt   (%rax)
	// bottom three bits are special; we leave them 0)
	ltr(GD_TSS0);

	// Load the IDT
	lidt(&idt_pd);
}
  800420940e:	c9                   	leaveq 
  800420940f:	c3                   	retq   

0000008004209410 <print_trapframe>:

void
print_trapframe(struct Trapframe *tf)
{
  8004209410:	55                   	push   %rbp
  8004209411:	48 89 e5             	mov    %rsp,%rbp
  8004209414:	48 83 ec 20          	sub    $0x20,%rsp
  8004209418:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	cprintf("TRAP frame at %p\n", tf);
  800420941c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209420:	48 89 c6             	mov    %rax,%rsi
  8004209423:	48 bf db 2f 21 04 80 	movabs $0x8004212fdb,%rdi
  800420942a:	00 00 00 
  800420942d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209432:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004209439:	00 00 00 
  800420943c:	ff d2                	callq  *%rdx
	print_regs(&tf->tf_regs);
  800420943e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209442:	48 89 c7             	mov    %rax,%rdi
  8004209445:	48 b8 13 97 20 04 80 	movabs $0x8004209713,%rax
  800420944c:	00 00 00 
  800420944f:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  8004209451:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209455:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  8004209459:	0f b7 c0             	movzwl %ax,%eax
  800420945c:	89 c6                	mov    %eax,%esi
  800420945e:	48 bf ed 2f 21 04 80 	movabs $0x8004212fed,%rdi
  8004209465:	00 00 00 
  8004209468:	b8 00 00 00 00       	mov    $0x0,%eax
  800420946d:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004209474:	00 00 00 
  8004209477:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  8004209479:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420947d:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  8004209484:	0f b7 c0             	movzwl %ax,%eax
  8004209487:	89 c6                	mov    %eax,%esi
  8004209489:	48 bf 00 30 21 04 80 	movabs $0x8004213000,%rdi
  8004209490:	00 00 00 
  8004209493:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209498:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  800420949f:	00 00 00 
  80042094a2:	ff d2                	callq  *%rdx
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  80042094a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042094a8:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80042094af:	89 c7                	mov    %eax,%edi
  80042094b1:	48 b8 1e 7c 20 04 80 	movabs $0x8004207c1e,%rax
  80042094b8:	00 00 00 
  80042094bb:	ff d0                	callq  *%rax
  80042094bd:	48 89 c2             	mov    %rax,%rdx
  80042094c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042094c4:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80042094cb:	48 89 c6             	mov    %rax,%rsi
  80042094ce:	48 bf 13 30 21 04 80 	movabs $0x8004213013,%rdi
  80042094d5:	00 00 00 
  80042094d8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042094dd:	48 b9 46 7b 20 04 80 	movabs $0x8004207b46,%rcx
  80042094e4:	00 00 00 
  80042094e7:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  80042094e9:	48 b8 48 d7 2b 04 80 	movabs $0x80042bd748,%rax
  80042094f0:	00 00 00 
  80042094f3:	48 8b 00             	mov    (%rax),%rax
  80042094f6:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80042094fa:	75 3a                	jne    8004209536 <print_trapframe+0x126>
  80042094fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209500:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004209507:	48 83 f8 0e          	cmp    $0xe,%rax
  800420950b:	75 29                	jne    8004209536 <print_trapframe+0x126>

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420950d:	0f 20 d0             	mov    %cr2,%rax
  8004209510:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return val;
  8004209514:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  8004209518:	48 89 c6             	mov    %rax,%rsi
  800420951b:	48 bf 25 30 21 04 80 	movabs $0x8004213025,%rdi
  8004209522:	00 00 00 
  8004209525:	b8 00 00 00 00       	mov    $0x0,%eax
  800420952a:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004209531:	00 00 00 
  8004209534:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  8004209536:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420953a:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  8004209541:	48 89 c6             	mov    %rax,%rsi
  8004209544:	48 bf 34 30 21 04 80 	movabs $0x8004213034,%rdi
  800420954b:	00 00 00 
  800420954e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209553:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  800420955a:	00 00 00 
  800420955d:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  800420955f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209563:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420956a:	48 83 f8 0e          	cmp    $0xe,%rax
  800420956e:	0f 85 9c 00 00 00    	jne    8004209610 <print_trapframe+0x200>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  8004209574:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209578:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420957f:	83 e0 01             	and    $0x1,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  8004209582:	48 85 c0             	test   %rax,%rax
  8004209585:	74 0c                	je     8004209593 <print_trapframe+0x183>
  8004209587:	48 b9 42 30 21 04 80 	movabs $0x8004213042,%rcx
  800420958e:	00 00 00 
  8004209591:	eb 0a                	jmp    800420959d <print_trapframe+0x18d>
  8004209593:	48 b9 4d 30 21 04 80 	movabs $0x800421304d,%rcx
  800420959a:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
  800420959d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042095a1:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80042095a8:	83 e0 02             	and    $0x2,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  80042095ab:	48 85 c0             	test   %rax,%rax
  80042095ae:	74 0c                	je     80042095bc <print_trapframe+0x1ac>
  80042095b0:	48 ba 59 30 21 04 80 	movabs $0x8004213059,%rdx
  80042095b7:	00 00 00 
  80042095ba:	eb 0a                	jmp    80042095c6 <print_trapframe+0x1b6>
  80042095bc:	48 ba 5f 30 21 04 80 	movabs $0x800421305f,%rdx
  80042095c3:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  80042095c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042095ca:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80042095d1:	83 e0 04             	and    $0x4,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  80042095d4:	48 85 c0             	test   %rax,%rax
  80042095d7:	74 0c                	je     80042095e5 <print_trapframe+0x1d5>
  80042095d9:	48 b8 64 30 21 04 80 	movabs $0x8004213064,%rax
  80042095e0:	00 00 00 
  80042095e3:	eb 0a                	jmp    80042095ef <print_trapframe+0x1df>
  80042095e5:	48 b8 69 30 21 04 80 	movabs $0x8004213069,%rax
  80042095ec:	00 00 00 
  80042095ef:	48 89 c6             	mov    %rax,%rsi
  80042095f2:	48 bf 70 30 21 04 80 	movabs $0x8004213070,%rdi
  80042095f9:	00 00 00 
  80042095fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209601:	49 b8 46 7b 20 04 80 	movabs $0x8004207b46,%r8
  8004209608:	00 00 00 
  800420960b:	41 ff d0             	callq  *%r8
  800420960e:	eb 1b                	jmp    800420962b <print_trapframe+0x21b>
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
	else
		cprintf("\n");
  8004209610:	48 bf 7f 30 21 04 80 	movabs $0x800421307f,%rdi
  8004209617:	00 00 00 
  800420961a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420961f:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004209626:	00 00 00 
  8004209629:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  800420962b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420962f:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  8004209636:	48 89 c6             	mov    %rax,%rsi
  8004209639:	48 bf 81 30 21 04 80 	movabs $0x8004213081,%rdi
  8004209640:	00 00 00 
  8004209643:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209648:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  800420964f:	00 00 00 
  8004209652:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  8004209654:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209658:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420965f:	0f b7 c0             	movzwl %ax,%eax
  8004209662:	89 c6                	mov    %eax,%esi
  8004209664:	48 bf 90 30 21 04 80 	movabs $0x8004213090,%rdi
  800420966b:	00 00 00 
  800420966e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209673:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  800420967a:	00 00 00 
  800420967d:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  800420967f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209683:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420968a:	48 89 c6             	mov    %rax,%rsi
  800420968d:	48 bf a3 30 21 04 80 	movabs $0x80042130a3,%rdi
  8004209694:	00 00 00 
  8004209697:	b8 00 00 00 00       	mov    $0x0,%eax
  800420969c:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  80042096a3:	00 00 00 
  80042096a6:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  80042096a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042096ac:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  80042096b3:	0f b7 c0             	movzwl %ax,%eax
  80042096b6:	83 e0 03             	and    $0x3,%eax
  80042096b9:	85 c0                	test   %eax,%eax
  80042096bb:	74 54                	je     8004209711 <print_trapframe+0x301>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  80042096bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042096c1:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  80042096c8:	48 89 c6             	mov    %rax,%rsi
  80042096cb:	48 bf b2 30 21 04 80 	movabs $0x80042130b2,%rdi
  80042096d2:	00 00 00 
  80042096d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042096da:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  80042096e1:	00 00 00 
  80042096e4:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  80042096e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042096ea:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  80042096f1:	0f b7 c0             	movzwl %ax,%eax
  80042096f4:	89 c6                	mov    %eax,%esi
  80042096f6:	48 bf c1 30 21 04 80 	movabs $0x80042130c1,%rdi
  80042096fd:	00 00 00 
  8004209700:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209705:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  800420970c:	00 00 00 
  800420970f:	ff d2                	callq  *%rdx
	}
}
  8004209711:	c9                   	leaveq 
  8004209712:	c3                   	retq   

0000008004209713 <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  8004209713:	55                   	push   %rbp
  8004209714:	48 89 e5             	mov    %rsp,%rbp
  8004209717:	48 83 ec 10          	sub    $0x10,%rsp
  800420971b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  800420971f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209723:	48 8b 00             	mov    (%rax),%rax
  8004209726:	48 89 c6             	mov    %rax,%rsi
  8004209729:	48 bf d4 30 21 04 80 	movabs $0x80042130d4,%rdi
  8004209730:	00 00 00 
  8004209733:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209738:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  800420973f:	00 00 00 
  8004209742:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  8004209744:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209748:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420974c:	48 89 c6             	mov    %rax,%rsi
  800420974f:	48 bf e3 30 21 04 80 	movabs $0x80042130e3,%rdi
  8004209756:	00 00 00 
  8004209759:	b8 00 00 00 00       	mov    $0x0,%eax
  800420975e:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004209765:	00 00 00 
  8004209768:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  800420976a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420976e:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004209772:	48 89 c6             	mov    %rax,%rsi
  8004209775:	48 bf f2 30 21 04 80 	movabs $0x80042130f2,%rdi
  800420977c:	00 00 00 
  800420977f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209784:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  800420978b:	00 00 00 
  800420978e:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  8004209790:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209794:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004209798:	48 89 c6             	mov    %rax,%rsi
  800420979b:	48 bf 01 31 21 04 80 	movabs $0x8004213101,%rdi
  80042097a2:	00 00 00 
  80042097a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042097aa:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  80042097b1:	00 00 00 
  80042097b4:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  80042097b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042097ba:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042097be:	48 89 c6             	mov    %rax,%rsi
  80042097c1:	48 bf 10 31 21 04 80 	movabs $0x8004213110,%rdi
  80042097c8:	00 00 00 
  80042097cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042097d0:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  80042097d7:	00 00 00 
  80042097da:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  80042097dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042097e0:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042097e4:	48 89 c6             	mov    %rax,%rsi
  80042097e7:	48 bf 1f 31 21 04 80 	movabs $0x800421311f,%rdi
  80042097ee:	00 00 00 
  80042097f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042097f6:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  80042097fd:	00 00 00 
  8004209800:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  8004209802:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209806:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420980a:	48 89 c6             	mov    %rax,%rsi
  800420980d:	48 bf 2e 31 21 04 80 	movabs $0x800421312e,%rdi
  8004209814:	00 00 00 
  8004209817:	b8 00 00 00 00       	mov    $0x0,%eax
  800420981c:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004209823:	00 00 00 
  8004209826:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  8004209828:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420982c:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004209830:	48 89 c6             	mov    %rax,%rsi
  8004209833:	48 bf 3c 31 21 04 80 	movabs $0x800421313c,%rdi
  800420983a:	00 00 00 
  800420983d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209842:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004209849:	00 00 00 
  800420984c:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  800420984e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209852:	48 8b 40 48          	mov    0x48(%rax),%rax
  8004209856:	48 89 c6             	mov    %rax,%rsi
  8004209859:	48 bf 4a 31 21 04 80 	movabs $0x800421314a,%rdi
  8004209860:	00 00 00 
  8004209863:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209868:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  800420986f:	00 00 00 
  8004209872:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  8004209874:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209878:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420987c:	48 89 c6             	mov    %rax,%rsi
  800420987f:	48 bf 59 31 21 04 80 	movabs $0x8004213159,%rdi
  8004209886:	00 00 00 
  8004209889:	b8 00 00 00 00       	mov    $0x0,%eax
  800420988e:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004209895:	00 00 00 
  8004209898:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  800420989a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420989e:	48 8b 40 50          	mov    0x50(%rax),%rax
  80042098a2:	48 89 c6             	mov    %rax,%rsi
  80042098a5:	48 bf 68 31 21 04 80 	movabs $0x8004213168,%rdi
  80042098ac:	00 00 00 
  80042098af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042098b4:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  80042098bb:	00 00 00 
  80042098be:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  80042098c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042098c4:	48 8b 40 68          	mov    0x68(%rax),%rax
  80042098c8:	48 89 c6             	mov    %rax,%rsi
  80042098cb:	48 bf 77 31 21 04 80 	movabs $0x8004213177,%rdi
  80042098d2:	00 00 00 
  80042098d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042098da:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  80042098e1:	00 00 00 
  80042098e4:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  80042098e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042098ea:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042098ee:	48 89 c6             	mov    %rax,%rsi
  80042098f1:	48 bf 86 31 21 04 80 	movabs $0x8004213186,%rdi
  80042098f8:	00 00 00 
  80042098fb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209900:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004209907:	00 00 00 
  800420990a:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  800420990c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209910:	48 8b 40 60          	mov    0x60(%rax),%rax
  8004209914:	48 89 c6             	mov    %rax,%rsi
  8004209917:	48 bf 95 31 21 04 80 	movabs $0x8004213195,%rdi
  800420991e:	00 00 00 
  8004209921:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209926:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  800420992d:	00 00 00 
  8004209930:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  8004209932:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209936:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420993a:	48 89 c6             	mov    %rax,%rsi
  800420993d:	48 bf a4 31 21 04 80 	movabs $0x80042131a4,%rdi
  8004209944:	00 00 00 
  8004209947:	b8 00 00 00 00       	mov    $0x0,%eax
  800420994c:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004209953:	00 00 00 
  8004209956:	ff d2                	callq  *%rdx
}
  8004209958:	c9                   	leaveq 
  8004209959:	c3                   	retq   

000000800420995a <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  800420995a:	55                   	push   %rbp
  800420995b:	48 89 e5             	mov    %rsp,%rbp
  800420995e:	48 83 ec 10          	sub    $0x10,%rsp
  8004209962:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Handle processor exceptions.
	// LAB 3: Your code here.
	if (tf->tf_trapno == T_PGFLT){
  8004209966:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420996a:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004209971:	48 83 f8 0e          	cmp    $0xe,%rax
  8004209975:	75 18                	jne    800420998f <trap_dispatch+0x35>
		page_fault_handler(tf);
  8004209977:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420997b:	48 89 c7             	mov    %rax,%rdi
  800420997e:	48 b8 2f 9c 20 04 80 	movabs $0x8004209c2f,%rax
  8004209985:	00 00 00 
  8004209988:	ff d0                	callq  *%rax
		return;
  800420998a:	e9 f7 00 00 00       	jmpq   8004209a86 <trap_dispatch+0x12c>
	}else if (tf->tf_trapno == T_BRKPT){
  800420998f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209993:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420999a:	48 83 f8 03          	cmp    $0x3,%rax
  800420999e:	75 18                	jne    80042099b8 <trap_dispatch+0x5e>
		monitor(tf);
  80042099a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042099a4:	48 89 c7             	mov    %rax,%rdi
  80042099a7:	48 b8 ad 12 20 04 80 	movabs $0x80042012ad,%rax
  80042099ae:	00 00 00 
  80042099b1:	ff d0                	callq  *%rax
		return;
  80042099b3:	e9 ce 00 00 00       	jmpq   8004209a86 <trap_dispatch+0x12c>
	}else if (tf->tf_trapno == T_SYSCALL){
  80042099b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042099bc:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80042099c3:	48 83 f8 30          	cmp    $0x30,%rax
  80042099c7:	75 52                	jne    8004209a1b <trap_dispatch+0xc1>
		tf->tf_regs.reg_rax = syscall(tf->tf_regs.reg_rax, tf->tf_regs.reg_rdx, tf->tf_regs.reg_rcx,
  80042099c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042099cd:	4c 8b 40 40          	mov    0x40(%rax),%r8
  80042099d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042099d5:	48 8b 78 48          	mov    0x48(%rax),%rdi
  80042099d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042099dd:	48 8b 48 68          	mov    0x68(%rax),%rcx
  80042099e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042099e5:	48 8b 50 60          	mov    0x60(%rax),%rdx
  80042099e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042099ed:	48 8b 70 58          	mov    0x58(%rax),%rsi
  80042099f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042099f5:	48 8b 40 70          	mov    0x70(%rax),%rax
  80042099f9:	4d 89 c1             	mov    %r8,%r9
  80042099fc:	49 89 f8             	mov    %rdi,%r8
  80042099ff:	48 89 c7             	mov    %rax,%rdi
  8004209a02:	48 b8 50 9f 20 04 80 	movabs $0x8004209f50,%rax
  8004209a09:	00 00 00 
  8004209a0c:	ff d0                	callq  *%rax
  8004209a0e:	48 89 c2             	mov    %rax,%rdx
  8004209a11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209a15:	48 89 50 70          	mov    %rdx,0x70(%rax)
			tf->tf_regs.reg_rbx, tf->tf_regs.reg_rdi, tf->tf_regs.reg_rsi);
		return;
  8004209a19:	eb 6b                	jmp    8004209a86 <trap_dispatch+0x12c>
	}
	print_trapframe(tf);
  8004209a1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209a1f:	48 89 c7             	mov    %rax,%rdi
  8004209a22:	48 b8 10 94 20 04 80 	movabs $0x8004209410,%rax
  8004209a29:	00 00 00 
  8004209a2c:	ff d0                	callq  *%rax
	if (tf->tf_cs == GD_KT)
  8004209a2e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209a32:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  8004209a39:	66 83 f8 08          	cmp    $0x8,%ax
  8004209a3d:	75 2a                	jne    8004209a69 <trap_dispatch+0x10f>
		panic("can not handle trap");
  8004209a3f:	48 ba b3 31 21 04 80 	movabs $0x80042131b3,%rdx
  8004209a46:	00 00 00 
  8004209a49:	be dc 00 00 00       	mov    $0xdc,%esi
  8004209a4e:	48 bf c7 31 21 04 80 	movabs $0x80042131c7,%rdi
  8004209a55:	00 00 00 
  8004209a58:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209a5d:	48 b9 50 01 20 04 80 	movabs $0x8004200150,%rcx
  8004209a64:	00 00 00 
  8004209a67:	ff d1                	callq  *%rcx
	else {
		env_destroy(curenv);
  8004209a69:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004209a70:	00 00 00 
  8004209a73:	48 8b 00             	mov    (%rax),%rax
  8004209a76:	48 89 c7             	mov    %rax,%rdi
  8004209a79:	48 b8 fe 77 20 04 80 	movabs $0x80042077fe,%rax
  8004209a80:	00 00 00 
  8004209a83:	ff d0                	callq  *%rax
		return;
  8004209a85:	90                   	nop
	}
}
  8004209a86:	c9                   	leaveq 
  8004209a87:	c3                   	retq   

0000008004209a88 <trap>:

void
trap(struct Trapframe *tf)
{
  8004209a88:	55                   	push   %rbp
  8004209a89:	48 89 e5             	mov    %rsp,%rbp
  8004209a8c:	48 83 ec 20          	sub    $0x20,%rsp
  8004209a90:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    //struct Trapframe *tf = &tf_;
	// The environment may have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  8004209a94:	fc                   	cld    

static __inline uint64_t
read_eflags(void)
{
	uint64_t rflags;
	__asm __volatile("pushfq; popq %0" : "=r" (rflags));
  8004209a95:	9c                   	pushfq 
  8004209a96:	58                   	pop    %rax
  8004209a97:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return rflags;
  8004209a9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  8004209a9f:	25 00 02 00 00       	and    $0x200,%eax
  8004209aa4:	48 85 c0             	test   %rax,%rax
  8004209aa7:	74 35                	je     8004209ade <trap+0x56>
  8004209aa9:	48 b9 d3 31 21 04 80 	movabs $0x80042131d3,%rcx
  8004209ab0:	00 00 00 
  8004209ab3:	48 ba ec 31 21 04 80 	movabs $0x80042131ec,%rdx
  8004209aba:	00 00 00 
  8004209abd:	be ee 00 00 00       	mov    $0xee,%esi
  8004209ac2:	48 bf c7 31 21 04 80 	movabs $0x80042131c7,%rdi
  8004209ac9:	00 00 00 
  8004209acc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209ad1:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004209ad8:	00 00 00 
  8004209adb:	41 ff d0             	callq  *%r8

	cprintf("Incoming TRAP frame at %p\n", tf);
  8004209ade:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209ae2:	48 89 c6             	mov    %rax,%rsi
  8004209ae5:	48 bf 01 32 21 04 80 	movabs $0x8004213201,%rdi
  8004209aec:	00 00 00 
  8004209aef:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209af4:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004209afb:	00 00 00 
  8004209afe:	ff d2                	callq  *%rdx

	if ((tf->tf_cs & 3) == 3) {
  8004209b00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209b04:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  8004209b0b:	0f b7 c0             	movzwl %ax,%eax
  8004209b0e:	83 e0 03             	and    $0x3,%eax
  8004209b11:	83 f8 03             	cmp    $0x3,%eax
  8004209b14:	75 7a                	jne    8004209b90 <trap+0x108>
		// Trapped from user mode.
		assert(curenv);
  8004209b16:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004209b1d:	00 00 00 
  8004209b20:	48 8b 00             	mov    (%rax),%rax
  8004209b23:	48 85 c0             	test   %rax,%rax
  8004209b26:	75 35                	jne    8004209b5d <trap+0xd5>
  8004209b28:	48 b9 1c 32 21 04 80 	movabs $0x800421321c,%rcx
  8004209b2f:	00 00 00 
  8004209b32:	48 ba ec 31 21 04 80 	movabs $0x80042131ec,%rdx
  8004209b39:	00 00 00 
  8004209b3c:	be f4 00 00 00       	mov    $0xf4,%esi
  8004209b41:	48 bf c7 31 21 04 80 	movabs $0x80042131c7,%rdi
  8004209b48:	00 00 00 
  8004209b4b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209b50:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004209b57:	00 00 00 
  8004209b5a:	41 ff d0             	callq  *%r8

		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  8004209b5d:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004209b64:	00 00 00 
  8004209b67:	48 8b 10             	mov    (%rax),%rdx
  8004209b6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209b6e:	48 89 c6             	mov    %rax,%rsi
  8004209b71:	b8 18 00 00 00       	mov    $0x18,%eax
  8004209b76:	48 89 d7             	mov    %rdx,%rdi
  8004209b79:	48 89 c1             	mov    %rax,%rcx
  8004209b7c:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  8004209b7f:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004209b86:	00 00 00 
  8004209b89:	48 8b 00             	mov    (%rax),%rax
  8004209b8c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}

	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  8004209b90:	48 b8 48 d7 2b 04 80 	movabs $0x80042bd748,%rax
  8004209b97:	00 00 00 
  8004209b9a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004209b9e:	48 89 10             	mov    %rdx,(%rax)

	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  8004209ba1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209ba5:	48 89 c7             	mov    %rax,%rdi
  8004209ba8:	48 b8 5a 99 20 04 80 	movabs $0x800420995a,%rax
  8004209baf:	00 00 00 
  8004209bb2:	ff d0                	callq  *%rax

	// Return to the current environment, which should be running.
	assert(curenv && curenv->env_status == ENV_RUNNING);
  8004209bb4:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004209bbb:	00 00 00 
  8004209bbe:	48 8b 00             	mov    (%rax),%rax
  8004209bc1:	48 85 c0             	test   %rax,%rax
  8004209bc4:	74 18                	je     8004209bde <trap+0x156>
  8004209bc6:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004209bcd:	00 00 00 
  8004209bd0:	48 8b 00             	mov    (%rax),%rax
  8004209bd3:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004209bd9:	83 f8 03             	cmp    $0x3,%eax
  8004209bdc:	74 35                	je     8004209c13 <trap+0x18b>
  8004209bde:	48 b9 28 32 21 04 80 	movabs $0x8004213228,%rcx
  8004209be5:	00 00 00 
  8004209be8:	48 ba ec 31 21 04 80 	movabs $0x80042131ec,%rdx
  8004209bef:	00 00 00 
  8004209bf2:	be 06 01 00 00       	mov    $0x106,%esi
  8004209bf7:	48 bf c7 31 21 04 80 	movabs $0x80042131c7,%rdi
  8004209bfe:	00 00 00 
  8004209c01:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209c06:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004209c0d:	00 00 00 
  8004209c10:	41 ff d0             	callq  *%r8
	env_run(curenv);
  8004209c13:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004209c1a:	00 00 00 
  8004209c1d:	48 8b 00             	mov    (%rax),%rax
  8004209c20:	48 89 c7             	mov    %rax,%rdi
  8004209c23:	48 b8 e4 78 20 04 80 	movabs $0x80042078e4,%rax
  8004209c2a:	00 00 00 
  8004209c2d:	ff d0                	callq  *%rax

0000008004209c2f <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  8004209c2f:	55                   	push   %rbp
  8004209c30:	48 89 e5             	mov    %rsp,%rbp
  8004209c33:	48 83 ec 20          	sub    $0x20,%rsp
  8004209c37:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  8004209c3b:	0f 20 d0             	mov    %cr2,%rax
  8004209c3e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	return val;
  8004209c42:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
	uint64_t fault_va;

	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  8004209c46:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	// Handle kernel-mode page faults.
	// LAB 3: Your code here.
	if(tf->tf_cs == GD_KT || tf->tf_cs == GD_KD) {
  8004209c4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209c4e:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  8004209c55:	66 83 f8 08          	cmp    $0x8,%ax
  8004209c59:	74 11                	je     8004209c6c <page_fault_handler+0x3d>
  8004209c5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209c5f:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  8004209c66:	66 83 f8 10          	cmp    $0x10,%ax
  8004209c6a:	75 2a                	jne    8004209c96 <page_fault_handler+0x67>
		panic("Page fault");
  8004209c6c:	48 ba 54 32 21 04 80 	movabs $0x8004213254,%rdx
  8004209c73:	00 00 00 
  8004209c76:	be 16 01 00 00       	mov    $0x116,%esi
  8004209c7b:	48 bf c7 31 21 04 80 	movabs $0x80042131c7,%rdi
  8004209c82:	00 00 00 
  8004209c85:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209c8a:	48 b9 50 01 20 04 80 	movabs $0x8004200150,%rcx
  8004209c91:	00 00 00 
  8004209c94:	ff d1                	callq  *%rcx
	}
	
	// We've already handled kernel-mode exceptions, so if we get here,
	// the page fault happened in user mode.
	// Destroy the environment that caused the fault.
	cprintf("[%08x] user fault va %08x ip %08x\n",
  8004209c96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209c9a:	48 8b 88 98 00 00 00 	mov    0x98(%rax),%rcx
	curenv->env_id, fault_va, tf->tf_rip);
  8004209ca1:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004209ca8:	00 00 00 
  8004209cab:	48 8b 00             	mov    (%rax),%rax
	}
	
	// We've already handled kernel-mode exceptions, so if we get here,
	// the page fault happened in user mode.
	// Destroy the environment that caused the fault.
	cprintf("[%08x] user fault va %08x ip %08x\n",
  8004209cae:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004209cb4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004209cb8:	89 c6                	mov    %eax,%esi
  8004209cba:	48 bf 60 32 21 04 80 	movabs $0x8004213260,%rdi
  8004209cc1:	00 00 00 
  8004209cc4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209cc9:	49 b8 46 7b 20 04 80 	movabs $0x8004207b46,%r8
  8004209cd0:	00 00 00 
  8004209cd3:	41 ff d0             	callq  *%r8
	curenv->env_id, fault_va, tf->tf_rip);
	print_trapframe(tf);
  8004209cd6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209cda:	48 89 c7             	mov    %rax,%rdi
  8004209cdd:	48 b8 10 94 20 04 80 	movabs $0x8004209410,%rax
  8004209ce4:	00 00 00 
  8004209ce7:	ff d0                	callq  *%rax
	env_destroy(curenv);
  8004209ce9:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004209cf0:	00 00 00 
  8004209cf3:	48 8b 00             	mov    (%rax),%rax
  8004209cf6:	48 89 c7             	mov    %rax,%rdi
  8004209cf9:	48 b8 fe 77 20 04 80 	movabs $0x80042077fe,%rax
  8004209d00:	00 00 00 
  8004209d03:	ff d0                	callq  *%rax
}
  8004209d05:	c9                   	leaveq 
  8004209d06:	c3                   	retq   
  8004209d07:	90                   	nop

0000008004209d08 <handleDivideError>:
 */
 
	/* whether or not to use error code found here:
	 * www3.cs.stonybrook.edu/~porter/courses/cse506/f14/ref/i386/s09_10.htm
	 */
        TRAPHANDLER_NOEC(handleDivideError, T_DIVIDE)
  8004209d08:	6a 00                	pushq  $0x0
  8004209d0a:	6a 00                	pushq  $0x0
  8004209d0c:	eb 67                	jmp    8004209d75 <_alltraps>

0000008004209d0e <handleDebugException>:
	TRAPHANDLER_NOEC(handleDebugException, T_DEBUG)
  8004209d0e:	6a 00                	pushq  $0x0
  8004209d10:	6a 01                	pushq  $0x1
  8004209d12:	eb 61                	jmp    8004209d75 <_alltraps>

0000008004209d14 <handleNonMaskableInterrupt>:
	TRAPHANDLER_NOEC(handleNonMaskableInterrupt, T_NMI)
  8004209d14:	6a 00                	pushq  $0x0
  8004209d16:	6a 02                	pushq  $0x2
  8004209d18:	eb 5b                	jmp    8004209d75 <_alltraps>

0000008004209d1a <handleBreakpoint>:
	TRAPHANDLER_NOEC(handleBreakpoint, T_BRKPT)
  8004209d1a:	6a 00                	pushq  $0x0
  8004209d1c:	6a 03                	pushq  $0x3
  8004209d1e:	eb 55                	jmp    8004209d75 <_alltraps>

0000008004209d20 <handleOverflow>:
	TRAPHANDLER_NOEC(handleOverflow, T_OFLOW)
  8004209d20:	6a 00                	pushq  $0x0
  8004209d22:	6a 04                	pushq  $0x4
  8004209d24:	eb 4f                	jmp    8004209d75 <_alltraps>

0000008004209d26 <handleBoundsCheck>:
	TRAPHANDLER_NOEC(handleBoundsCheck, T_BOUND)
  8004209d26:	6a 00                	pushq  $0x0
  8004209d28:	6a 05                	pushq  $0x5
  8004209d2a:	eb 49                	jmp    8004209d75 <_alltraps>

0000008004209d2c <handleIllegalOpcode>:
	TRAPHANDLER_NOEC(handleIllegalOpcode, T_ILLOP)
  8004209d2c:	6a 00                	pushq  $0x0
  8004209d2e:	6a 06                	pushq  $0x6
  8004209d30:	eb 43                	jmp    8004209d75 <_alltraps>

0000008004209d32 <handleDeviceNotAvailable>:
	TRAPHANDLER_NOEC(handleDeviceNotAvailable, T_DEVICE)
  8004209d32:	6a 00                	pushq  $0x0
  8004209d34:	6a 07                	pushq  $0x7
  8004209d36:	eb 3d                	jmp    8004209d75 <_alltraps>

0000008004209d38 <handleDoubleFault>:
	TRAPHANDLER(handleDoubleFault, T_DBLFLT)
  8004209d38:	6a 08                	pushq  $0x8
  8004209d3a:	eb 39                	jmp    8004209d75 <_alltraps>

0000008004209d3c <handleInvalidTaskSwitchSegment>:
	TRAPHANDLER(handleInvalidTaskSwitchSegment, T_TSS)
  8004209d3c:	6a 0a                	pushq  $0xa
  8004209d3e:	eb 35                	jmp    8004209d75 <_alltraps>

0000008004209d40 <handleSegmentNotPresent>:
	TRAPHANDLER(handleSegmentNotPresent, T_SEGNP)
  8004209d40:	6a 0b                	pushq  $0xb
  8004209d42:	eb 31                	jmp    8004209d75 <_alltraps>

0000008004209d44 <handleStackException>:
	TRAPHANDLER(handleStackException, T_STACK)
  8004209d44:	6a 0c                	pushq  $0xc
  8004209d46:	eb 2d                	jmp    8004209d75 <_alltraps>

0000008004209d48 <handleGeneralProtectionFault>:
	TRAPHANDLER(handleGeneralProtectionFault, T_GPFLT)
  8004209d48:	6a 0d                	pushq  $0xd
  8004209d4a:	eb 29                	jmp    8004209d75 <_alltraps>

0000008004209d4c <handlePageFault>:
	TRAPHANDLER(handlePageFault, T_PGFLT)
  8004209d4c:	6a 0e                	pushq  $0xe
  8004209d4e:	eb 25                	jmp    8004209d75 <_alltraps>

0000008004209d50 <handleFloatingPointError>:
	TRAPHANDLER_NOEC(handleFloatingPointError, T_FPERR)
  8004209d50:	6a 00                	pushq  $0x0
  8004209d52:	6a 10                	pushq  $0x10
  8004209d54:	eb 1f                	jmp    8004209d75 <_alltraps>

0000008004209d56 <handleAligmentCheck>:
	TRAPHANDLER(handleAligmentCheck, T_ALIGN)
  8004209d56:	6a 11                	pushq  $0x11
  8004209d58:	eb 1b                	jmp    8004209d75 <_alltraps>

0000008004209d5a <handleMachineCheck>:
	TRAPHANDLER_NOEC(handleMachineCheck, T_MCHK)
  8004209d5a:	6a 00                	pushq  $0x0
  8004209d5c:	6a 12                	pushq  $0x12
  8004209d5e:	eb 15                	jmp    8004209d75 <_alltraps>

0000008004209d60 <handleSIMDFloatingPointError>:
	TRAPHANDLER_NOEC(handleSIMDFloatingPointError, T_SIMDERR)
  8004209d60:	6a 00                	pushq  $0x0
  8004209d62:	6a 13                	pushq  $0x13
  8004209d64:	eb 0f                	jmp    8004209d75 <_alltraps>

0000008004209d66 <handleSystemCall>:
	TRAPHANDLER_NOEC(handleSystemCall, T_SYSCALL)
  8004209d66:	6a 00                	pushq  $0x0
  8004209d68:	6a 30                	pushq  $0x30
  8004209d6a:	eb 09                	jmp    8004209d75 <_alltraps>

0000008004209d6c <handleCatchall>:
	TRAPHANDLER_NOEC(handleCatchall, T_DEFAULT)
  8004209d6c:	6a 00                	pushq  $0x0
  8004209d6e:	68 f4 01 00 00       	pushq  $0x1f4
  8004209d73:	eb 00                	jmp    8004209d75 <_alltraps>

0000008004209d75 <_alltraps>:
 *       for how to pass a pointer to the trapframe.
 */

_alltraps:
		 
	subq $16, %rsp
  8004209d75:	48 83 ec 10          	sub    $0x10,%rsp
	movq $0, 0(%rsp)
  8004209d79:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8004209d80:	00 
	movq $0, 8(%rsp)
  8004209d81:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
  8004209d88:	00 00 
	movw %es, 0(%rsp)
  8004209d8a:	8c 04 24             	mov    %es,(%rsp)
	movw %ds, 8(%rsp)
  8004209d8d:	8c 5c 24 08          	mov    %ds,0x8(%rsp)
	PUSHA
  8004209d91:	48 83 ec 78          	sub    $0x78,%rsp
  8004209d95:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  8004209d9a:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  8004209d9f:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  8004209da4:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  8004209da9:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  8004209dae:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  8004209db3:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  8004209db8:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  8004209dbd:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  8004209dc2:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  8004209dc7:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  8004209dcc:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  8004209dd1:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  8004209dd6:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  8004209ddb:	4c 89 3c 24          	mov    %r15,(%rsp)
	
	movw $GD_KD, %ax
  8004209ddf:	66 b8 10 00          	mov    $0x10,%ax
	movw %ax, %ds
  8004209de3:	8e d8                	mov    %eax,%ds
	movw %ax, %es
  8004209de5:	8e c0                	mov    %eax,%es
	
	movq %rsp, %rdi
  8004209de7:	48 89 e7             	mov    %rsp,%rdi
	call trap
  8004209dea:	e8 99 fc ff ff       	callq  8004209a88 <trap>

0000008004209def <sys_cputs>:
// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  8004209def:	55                   	push   %rbp
  8004209df0:	48 89 e5             	mov    %rsp,%rbp
  8004209df3:	48 83 ec 10          	sub    $0x10,%rsp
  8004209df7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004209dfb:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.
	user_mem_assert(curenv, (char*)s, len, 0);
  8004209dff:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004209e06:	00 00 00 
  8004209e09:	48 8b 00             	mov    (%rax),%rax
  8004209e0c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004209e10:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8004209e14:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004209e19:	48 89 c7             	mov    %rax,%rdi
  8004209e1c:	48 b8 7f 31 20 04 80 	movabs $0x800420317f,%rax
  8004209e23:	00 00 00 
  8004209e26:	ff d0                	callq  *%rax
	// Print the string supplied by the user.
	cprintf("%.*s", len, s);
  8004209e28:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004209e2c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004209e30:	48 89 c6             	mov    %rax,%rsi
  8004209e33:	48 bf 80 34 21 04 80 	movabs $0x8004213480,%rdi
  8004209e3a:	00 00 00 
  8004209e3d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209e42:	48 b9 46 7b 20 04 80 	movabs $0x8004207b46,%rcx
  8004209e49:	00 00 00 
  8004209e4c:	ff d1                	callq  *%rcx
}
  8004209e4e:	c9                   	leaveq 
  8004209e4f:	c3                   	retq   

0000008004209e50 <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  8004209e50:	55                   	push   %rbp
  8004209e51:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  8004209e54:	48 b8 be 0c 20 04 80 	movabs $0x8004200cbe,%rax
  8004209e5b:	00 00 00 
  8004209e5e:	ff d0                	callq  *%rax
}
  8004209e60:	5d                   	pop    %rbp
  8004209e61:	c3                   	retq   

0000008004209e62 <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  8004209e62:	55                   	push   %rbp
  8004209e63:	48 89 e5             	mov    %rsp,%rbp
	return curenv->env_id;
  8004209e66:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004209e6d:	00 00 00 
  8004209e70:	48 8b 00             	mov    (%rax),%rax
  8004209e73:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  8004209e79:	5d                   	pop    %rbp
  8004209e7a:	c3                   	retq   

0000008004209e7b <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  8004209e7b:	55                   	push   %rbp
  8004209e7c:	48 89 e5             	mov    %rsp,%rbp
  8004209e7f:	48 83 ec 20          	sub    $0x20,%rsp
  8004209e83:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  8004209e86:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  8004209e8a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209e8d:	ba 01 00 00 00       	mov    $0x1,%edx
  8004209e92:	48 89 ce             	mov    %rcx,%rsi
  8004209e95:	89 c7                	mov    %eax,%edi
  8004209e97:	48 b8 a0 68 20 04 80 	movabs $0x80042068a0,%rax
  8004209e9e:	00 00 00 
  8004209ea1:	ff d0                	callq  *%rax
  8004209ea3:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004209ea6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004209eaa:	79 08                	jns    8004209eb4 <sys_env_destroy+0x39>
		return r;
  8004209eac:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209eaf:	e9 9a 00 00 00       	jmpq   8004209f4e <sys_env_destroy+0xd3>
	if (e == curenv)
  8004209eb4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004209eb8:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004209ebf:	00 00 00 
  8004209ec2:	48 8b 00             	mov    (%rax),%rax
  8004209ec5:	48 39 c2             	cmp    %rax,%rdx
  8004209ec8:	75 32                	jne    8004209efc <sys_env_destroy+0x81>
		cprintf("[%08x] exiting gracefully\n", curenv->env_id);
  8004209eca:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004209ed1:	00 00 00 
  8004209ed4:	48 8b 00             	mov    (%rax),%rax
  8004209ed7:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004209edd:	89 c6                	mov    %eax,%esi
  8004209edf:	48 bf 85 34 21 04 80 	movabs $0x8004213485,%rdi
  8004209ee6:	00 00 00 
  8004209ee9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209eee:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  8004209ef5:	00 00 00 
  8004209ef8:	ff d2                	callq  *%rdx
  8004209efa:	eb 3a                	jmp    8004209f36 <sys_env_destroy+0xbb>
	else
		cprintf("[%08x] destroying %08x\n", curenv->env_id, e->env_id);
  8004209efc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004209f00:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  8004209f06:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  8004209f0d:	00 00 00 
  8004209f10:	48 8b 00             	mov    (%rax),%rax
  8004209f13:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004209f19:	89 c6                	mov    %eax,%esi
  8004209f1b:	48 bf a0 34 21 04 80 	movabs $0x80042134a0,%rdi
  8004209f22:	00 00 00 
  8004209f25:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209f2a:	48 b9 46 7b 20 04 80 	movabs $0x8004207b46,%rcx
  8004209f31:	00 00 00 
  8004209f34:	ff d1                	callq  *%rcx
	env_destroy(e);
  8004209f36:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004209f3a:	48 89 c7             	mov    %rax,%rdi
  8004209f3d:	48 b8 fe 77 20 04 80 	movabs $0x80042077fe,%rax
  8004209f44:	00 00 00 
  8004209f47:	ff d0                	callq  *%rax
	return 0;
  8004209f49:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004209f4e:	c9                   	leaveq 
  8004209f4f:	c3                   	retq   

0000008004209f50 <syscall>:


// Dispatches to the correct kernel function, passing the arguments.
int64_t
syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  8004209f50:	55                   	push   %rbp
  8004209f51:	48 89 e5             	mov    %rsp,%rbp
  8004209f54:	48 83 ec 40          	sub    $0x40,%rsp
  8004209f58:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004209f5c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004209f60:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004209f64:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004209f68:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
  8004209f6c:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
	//panic("syscall not implemented");

	uint64_t ret;
	
	
	switch (syscallno) {
  8004209f70:	48 83 7d e8 04       	cmpq   $0x4,-0x18(%rbp)
  8004209f75:	0f 87 9e 00 00 00    	ja     800420a019 <syscall+0xc9>
  8004209f7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209f7f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209f86:	00 
  8004209f87:	48 b8 b8 34 21 04 80 	movabs $0x80042134b8,%rax
  8004209f8e:	00 00 00 
  8004209f91:	48 01 d0             	add    %rdx,%rax
  8004209f94:	48 8b 00             	mov    (%rax),%rax
  8004209f97:	ff e0                	jmpq   *%rax
		case SYS_cputs:
			sys_cputs((char*)a1, a2);
  8004209f99:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004209f9d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004209fa1:	48 89 d6             	mov    %rdx,%rsi
  8004209fa4:	48 89 c7             	mov    %rax,%rdi
  8004209fa7:	48 b8 ef 9d 20 04 80 	movabs $0x8004209def,%rax
  8004209fae:	00 00 00 
  8004209fb1:	ff d0                	callq  *%rax
			return 0;
  8004209fb3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209fb8:	eb 66                	jmp    800420a020 <syscall+0xd0>
		case SYS_cgetc:
			ret = sys_cgetc();
  8004209fba:	48 b8 50 9e 20 04 80 	movabs $0x8004209e50,%rax
  8004209fc1:	00 00 00 
  8004209fc4:	ff d0                	callq  *%rax
  8004209fc6:	48 98                	cltq   
  8004209fc8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			return ret;
  8004209fcc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209fd0:	eb 4e                	jmp    800420a020 <syscall+0xd0>
		case SYS_getenvid:
			ret = sys_getenvid();
  8004209fd2:	48 b8 62 9e 20 04 80 	movabs $0x8004209e62,%rax
  8004209fd9:	00 00 00 
  8004209fdc:	ff d0                	callq  *%rax
  8004209fde:	48 98                	cltq   
  8004209fe0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			return ret;
  8004209fe4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209fe8:	eb 36                	jmp    800420a020 <syscall+0xd0>
		case SYS_env_destroy:
			if(sys_env_destroy(a1) == 0)
  8004209fea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004209fee:	89 c7                	mov    %eax,%edi
  8004209ff0:	48 b8 7b 9e 20 04 80 	movabs $0x8004209e7b,%rax
  8004209ff7:	00 00 00 
  8004209ffa:	ff d0                	callq  *%rax
  8004209ffc:	85 c0                	test   %eax,%eax
  8004209ffe:	75 07                	jne    800420a007 <syscall+0xb7>
				return 0;
  800420a000:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a005:	eb 19                	jmp    800420a020 <syscall+0xd0>
			return -E_NO_SYS;
  800420a007:	48 c7 c0 f9 ff ff ff 	mov    $0xfffffffffffffff9,%rax
  800420a00e:	eb 10                	jmp    800420a020 <syscall+0xd0>
		case NSYSCALLS:
			return -E_INVAL;
  800420a010:	48 c7 c0 fd ff ff ff 	mov    $0xfffffffffffffffd,%rax
  800420a017:	eb 07                	jmp    800420a020 <syscall+0xd0>
		default:
			return -E_NO_SYS;
  800420a019:	48 c7 c0 f9 ff ff ff 	mov    $0xfffffffffffffff9,%rax
	}
}
  800420a020:	c9                   	leaveq 
  800420a021:	c3                   	retq   

000000800420a022 <list_func_die>:
	const char *stabstr;
	const char *stabstr_end;
};

int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420a022:	55                   	push   %rbp
  800420a023:	48 89 e5             	mov    %rsp,%rbp
  800420a026:	48 81 ec f0 61 00 00 	sub    $0x61f0,%rsp
  800420a02d:	48 89 bd 58 9e ff ff 	mov    %rdi,-0x61a8(%rbp)
  800420a034:	48 89 b5 50 9e ff ff 	mov    %rsi,-0x61b0(%rbp)
  800420a03b:	48 89 95 48 9e ff ff 	mov    %rdx,-0x61b8(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420a042:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420a049:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420a050:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420a054:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420a05b:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420a062:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420a066:	48 8b 95 50 9e ff ff 	mov    -0x61b0(%rbp),%rdx
  800420a06d:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420a074:	48 89 d1             	mov    %rdx,%rcx
  800420a077:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420a07c:	48 89 ce             	mov    %rcx,%rsi
  800420a07f:	48 89 c7             	mov    %rax,%rdi
  800420a082:	48 b8 38 bc 20 04 80 	movabs $0x800420bc38,%rax
  800420a089:	00 00 00 
  800420a08c:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420a08e:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420a095:	00 
	uint64_t ret_offset=0;
  800420a096:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420a09d:	00 

	if(die->die_tag != DW_TAG_subprogram)
  800420a09e:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420a0a5:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420a0a9:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420a0ad:	74 0a                	je     800420a0b9 <list_func_die+0x97>
		return 0;
  800420a0af:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a0b4:	e9 cd 06 00 00       	jmpq   800420a786 <list_func_die+0x764>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420a0b9:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420a0c0:	ba 38 00 00 00       	mov    $0x38,%edx
  800420a0c5:	be 00 00 00 00       	mov    $0x0,%esi
  800420a0ca:	48 89 c7             	mov    %rax,%rdi
  800420a0cd:	48 b8 96 ba 20 04 80 	movabs $0x800420ba96,%rax
  800420a0d4:	00 00 00 
  800420a0d7:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420a0d9:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420a0e0:	be 11 00 00 00       	mov    $0x11,%esi
  800420a0e5:	48 89 c7             	mov    %rax,%rdi
  800420a0e8:	48 b8 cb d9 20 04 80 	movabs $0x800420d9cb,%rax
  800420a0ef:	00 00 00 
  800420a0f2:	ff d0                	callq  *%rax
  800420a0f4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420a0f8:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420a0ff:	be 12 00 00 00       	mov    $0x12,%esi
  800420a104:	48 89 c7             	mov    %rax,%rdi
  800420a107:	48 b8 cb d9 20 04 80 	movabs $0x800420d9cb,%rax
  800420a10e:	00 00 00 
  800420a111:	ff d0                	callq  *%rax
  800420a113:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420a117:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420a11c:	0f 84 5f 06 00 00    	je     800420a781 <list_func_die+0x75f>
  800420a122:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420a126:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420a12a:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420a131:	0f 83 4a 06 00 00    	jae    800420a781 <list_func_die+0x75f>
  800420a137:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420a13c:	0f 84 3f 06 00 00    	je     800420a781 <list_func_die+0x75f>
  800420a142:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420a146:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420a14a:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420a151:	0f 86 2a 06 00 00    	jbe    800420a781 <list_func_die+0x75f>
	{
		info->rip_file = die->cu_die->die_name;
  800420a157:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420a15e:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420a165:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420a16c:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420a173:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420a176:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420a17d:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420a184:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420a18b:	48 89 50 10          	mov    %rdx,0x10(%rax)
		info->rip_fn_namelen = strlen(die->die_name);
  800420a18f:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420a196:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420a19d:	48 89 c7             	mov    %rax,%rdi
  800420a1a0:	48 b8 91 b7 20 04 80 	movabs $0x800420b791,%rax
  800420a1a7:	00 00 00 
  800420a1aa:	ff d0                	callq  *%rax
  800420a1ac:	48 8b 95 58 9e ff ff 	mov    -0x61a8(%rbp),%rdx
  800420a1b3:	89 42 18             	mov    %eax,0x18(%rdx)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420a1b6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420a1ba:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420a1be:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420a1c5:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420a1c9:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420a1d0:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420a1d7:	48 85 c0             	test   %rax,%rax
  800420a1da:	75 35                	jne    800420a211 <list_func_die+0x1ef>
  800420a1dc:	48 b9 00 38 21 04 80 	movabs $0x8004213800,%rcx
  800420a1e3:	00 00 00 
  800420a1e6:	48 ba 0c 38 21 04 80 	movabs $0x800421380c,%rdx
  800420a1ed:	00 00 00 
  800420a1f0:	be 91 00 00 00       	mov    $0x91,%esi
  800420a1f5:	48 bf 21 38 21 04 80 	movabs $0x8004213821,%rdi
  800420a1fc:	00 00 00 
  800420a1ff:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a204:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420a20b:	00 00 00 
  800420a20e:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420a211:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420a218:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420a21f:	48 8b 95 48 9e ff ff 	mov    -0x61b8(%rbp),%rdx
  800420a226:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
  800420a22d:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420a232:	48 89 c7             	mov    %rax,%rdi
  800420a235:	48 b8 f2 0f 21 04 80 	movabs $0x8004210ff2,%rax
  800420a23c:	00 00 00 
  800420a23f:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420a241:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420a248:	89 c2                	mov    %eax,%edx
  800420a24a:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420a251:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420a254:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420a25b:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420a262:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  800420a269:	00 00 00 
  800420a26c:	48 8b 00             	mov    (%rax),%rax
  800420a26f:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420a276:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420a27d:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420a281:	48 89 c7             	mov    %rax,%rdi
  800420a284:	48 b8 a2 dc 20 04 80 	movabs $0x800420dca2,%rax
  800420a28b:	00 00 00 
  800420a28e:	ff d0                	callq  *%rax
  800420a290:	83 f8 04             	cmp    $0x4,%eax
  800420a293:	0f 84 e1 04 00 00    	je     800420a77a <list_func_die+0x758>
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
  800420a299:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420a2a0:	48 83 f8 05          	cmp    $0x5,%rax
  800420a2a4:	74 05                	je     800420a2ab <list_func_die+0x289>
				goto last;
  800420a2a6:	e9 cf 04 00 00       	jmpq   800420a77a <list_func_die+0x758>

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420a2ab:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420a2b2:	be 49 00 00 00       	mov    $0x49,%esi
  800420a2b7:	48 89 c7             	mov    %rax,%rdi
  800420a2ba:	48 b8 cb d9 20 04 80 	movabs $0x800420d9cb,%rax
  800420a2c1:	00 00 00 
  800420a2c4:	ff d0                	callq  *%rax
  800420a2c6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
		try_again:
			if(attr != NULL)
  800420a2ca:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420a2cf:	0f 84 d7 00 00 00    	je     800420a3ac <list_func_die+0x38a>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420a2d5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420a2d9:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420a2dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a2e1:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420a2e5:	48 01 d0             	add    %rdx,%rax
  800420a2e8:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420a2ec:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  800420a2f3:	00 00 00 
  800420a2f6:	48 8b 08             	mov    (%rax),%rcx
  800420a2f9:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420a300:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420a304:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420a308:	48 8b 38             	mov    (%rax),%rdi
  800420a30b:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420a30f:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420a313:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420a318:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420a31c:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420a321:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420a325:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420a32a:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420a32e:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420a333:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420a337:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420a33c:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420a340:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420a345:	48 89 cf             	mov    %rcx,%rdi
  800420a348:	48 b8 c8 d8 20 04 80 	movabs $0x800420d8c8,%rax
  800420a34f:	00 00 00 
  800420a352:	ff d0                	callq  *%rax
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420a354:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420a35b:	be 0b 00 00 00       	mov    $0xb,%esi
  800420a360:	48 89 c7             	mov    %rax,%rdi
  800420a363:	48 b8 cb d9 20 04 80 	movabs $0x800420d9cb,%rax
  800420a36a:	00 00 00 
  800420a36d:	ff d0                	callq  *%rax
  800420a36f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		
				if(attr != NULL)
  800420a373:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420a378:	74 0e                	je     800420a388 <list_func_die+0x366>
				{
					ret_val = attr->u[0].u64;
  800420a37a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a37e:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420a382:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420a386:	eb 24                	jmp    800420a3ac <list_func_die+0x38a>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420a388:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420a38f:	be 49 00 00 00       	mov    $0x49,%esi
  800420a394:	48 89 c7             	mov    %rax,%rdi
  800420a397:	48 b8 cb d9 20 04 80 	movabs $0x800420d9cb,%rax
  800420a39e:	00 00 00 
  800420a3a1:	ff d0                	callq  *%rax
  800420a3a3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					goto try_again;
  800420a3a7:	e9 1e ff ff ff       	jmpq   800420a2ca <list_func_die+0x2a8>
				}
			}

			ret_offset = 0;
  800420a3ac:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420a3b3:	00 
			attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420a3b4:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420a3bb:	be 02 00 00 00       	mov    $0x2,%esi
  800420a3c0:	48 89 c7             	mov    %rax,%rdi
  800420a3c3:	48 b8 cb d9 20 04 80 	movabs $0x800420d9cb,%rax
  800420a3ca:	00 00 00 
  800420a3cd:	ff d0                	callq  *%rax
  800420a3cf:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if (attr != NULL)
  800420a3d3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420a3d8:	0f 84 a2 00 00 00    	je     800420a480 <list_func_die+0x45e>
			{
				Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420a3de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a3e2:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420a3e6:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
				Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420a3ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a3ee:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420a3f2:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
				Dwarf_Small atom;
				Dwarf_Unsigned op1, op2;

				switch(attr->at_form) {
  800420a3f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a3fa:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420a3fe:	48 83 f8 03          	cmp    $0x3,%rax
  800420a402:	72 7c                	jb     800420a480 <list_func_die+0x45e>
  800420a404:	48 83 f8 04          	cmp    $0x4,%rax
  800420a408:	76 06                	jbe    800420a410 <list_func_die+0x3ee>
  800420a40a:	48 83 f8 0a          	cmp    $0xa,%rax
  800420a40e:	75 70                	jne    800420a480 <list_func_die+0x45e>
					case DW_FORM_block1:
					case DW_FORM_block2:
					case DW_FORM_block4:
						offset = 0;
  800420a410:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420a417:	00 
						atom = *(loc_ptr++);
  800420a418:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420a41c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420a420:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420a424:	0f b6 00             	movzbl (%rax),%eax
  800420a427:	88 45 af             	mov    %al,-0x51(%rbp)
						offset++;
  800420a42a:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
						if (atom == DW_OP_fbreg) {
  800420a42f:	80 7d af 91          	cmpb   $0x91,-0x51(%rbp)
  800420a433:	75 4a                	jne    800420a47f <list_func_die+0x45d>
							uint8_t *p = loc_ptr;
  800420a435:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420a439:	48 89 85 68 9e ff ff 	mov    %rax,-0x6198(%rbp)
							ret_offset = _dwarf_decode_sleb128(&p);
  800420a440:	48 8d 85 68 9e ff ff 	lea    -0x6198(%rbp),%rax
  800420a447:	48 89 c7             	mov    %rax,%rdi
  800420a44a:	48 b8 27 c6 20 04 80 	movabs $0x800420c627,%rax
  800420a451:	00 00 00 
  800420a454:	ff d0                	callq  *%rax
  800420a456:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
							offset += p - loc_ptr;
  800420a45a:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420a461:	48 89 c2             	mov    %rax,%rdx
  800420a464:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420a468:	48 29 c2             	sub    %rax,%rdx
  800420a46b:	48 89 d0             	mov    %rdx,%rax
  800420a46e:	48 01 45 c0          	add    %rax,-0x40(%rbp)
							loc_ptr = p;
  800420a472:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420a479:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
						}
						break;
  800420a47d:	eb 00                	jmp    800420a47f <list_func_die+0x45d>
  800420a47f:	90                   	nop
				}
			}

			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420a480:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420a487:	8b 48 28             	mov    0x28(%rax),%ecx
  800420a48a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a48e:	89 c2                	mov    %eax,%edx
  800420a490:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420a497:	48 63 c9             	movslq %ecx,%rcx
  800420a49a:	48 83 c1 08          	add    $0x8,%rcx
  800420a49e:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
  800420a4a2:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420a4a9:	8b 50 28             	mov    0x28(%rax),%edx
  800420a4ac:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420a4b3:	48 63 d2             	movslq %edx,%rdx
  800420a4b6:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420a4ba:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420a4be:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
			info->rip_fn_narg++;
  800420a4c3:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420a4ca:	8b 40 28             	mov    0x28(%rax),%eax
  800420a4cd:	8d 50 01             	lea    0x1(%rax),%edx
  800420a4d0:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420a4d7:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420a4da:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420a4e1:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420a4e8:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420a4ed:	48 89 ce             	mov    %rcx,%rsi
  800420a4f0:	48 89 c7             	mov    %rax,%rdi
  800420a4f3:	48 b8 38 bc 20 04 80 	movabs $0x800420bc38,%rax
  800420a4fa:	00 00 00 
  800420a4fd:	ff d0                	callq  *%rax

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420a4ff:	e9 40 02 00 00       	jmpq   800420a744 <list_func_die+0x722>
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
  800420a504:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420a50b:	48 83 f8 05          	cmp    $0x5,%rax
  800420a50f:	74 05                	je     800420a516 <list_func_die+0x4f4>
					break;
  800420a511:	e9 64 02 00 00       	jmpq   800420a77a <list_func_die+0x758>

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420a516:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420a51d:	be 49 00 00 00       	mov    $0x49,%esi
  800420a522:	48 89 c7             	mov    %rax,%rdi
  800420a525:	48 b8 cb d9 20 04 80 	movabs $0x800420d9cb,%rax
  800420a52c:	00 00 00 
  800420a52f:	ff d0                	callq  *%rax
  800420a531:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
				if(attr != NULL)
  800420a535:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420a53a:	0f 84 b1 00 00 00    	je     800420a5f1 <list_func_die+0x5cf>
				{	   
					offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420a540:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420a544:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420a548:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a54c:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420a550:	48 01 d0             	add    %rdx,%rax
  800420a553:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
					dwarf_offdie(dbg, offset, &sib, *cu);
  800420a557:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  800420a55e:	00 00 00 
  800420a561:	48 8b 08             	mov    (%rax),%rcx
  800420a564:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420a56b:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420a56f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420a573:	48 8b 38             	mov    (%rax),%rdi
  800420a576:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420a57a:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420a57e:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420a583:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420a587:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420a58c:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420a590:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420a595:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420a599:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420a59e:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420a5a2:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420a5a7:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420a5ab:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420a5b0:	48 89 cf             	mov    %rcx,%rdi
  800420a5b3:	48 b8 c8 d8 20 04 80 	movabs $0x800420d8c8,%rax
  800420a5ba:	00 00 00 
  800420a5bd:	ff d0                	callq  *%rax
					attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420a5bf:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420a5c6:	be 0b 00 00 00       	mov    $0xb,%esi
  800420a5cb:	48 89 c7             	mov    %rax,%rdi
  800420a5ce:	48 b8 cb d9 20 04 80 	movabs $0x800420d9cb,%rax
  800420a5d5:	00 00 00 
  800420a5d8:	ff d0                	callq  *%rax
  800420a5da:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
					if(attr != NULL)
  800420a5de:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420a5e3:	74 0c                	je     800420a5f1 <list_func_die+0x5cf>
					{
						ret_val = attr->u[0].u64;
  800420a5e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a5e9:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420a5ed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
					}
				}
	
				ret_offset = 0;
  800420a5f1:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420a5f8:	00 
				attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420a5f9:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420a600:	be 02 00 00 00       	mov    $0x2,%esi
  800420a605:	48 89 c7             	mov    %rax,%rdi
  800420a608:	48 b8 cb d9 20 04 80 	movabs $0x800420d9cb,%rax
  800420a60f:	00 00 00 
  800420a612:	ff d0                	callq  *%rax
  800420a614:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if (attr != NULL)
  800420a618:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420a61d:	0f 84 a2 00 00 00    	je     800420a6c5 <list_func_die+0x6a3>
				{
					Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420a623:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a627:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420a62b:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
					Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420a62f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a633:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420a637:	48 89 45 98          	mov    %rax,-0x68(%rbp)
					Dwarf_Small atom;
					Dwarf_Unsigned op1, op2;

					switch(attr->at_form) {
  800420a63b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a63f:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420a643:	48 83 f8 03          	cmp    $0x3,%rax
  800420a647:	72 7c                	jb     800420a6c5 <list_func_die+0x6a3>
  800420a649:	48 83 f8 04          	cmp    $0x4,%rax
  800420a64d:	76 06                	jbe    800420a655 <list_func_die+0x633>
  800420a64f:	48 83 f8 0a          	cmp    $0xa,%rax
  800420a653:	75 70                	jne    800420a6c5 <list_func_die+0x6a3>
						case DW_FORM_block1:
						case DW_FORM_block2:
						case DW_FORM_block4:
							offset = 0;
  800420a655:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420a65c:	00 
							atom = *(loc_ptr++);
  800420a65d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420a661:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420a665:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420a669:	0f b6 00             	movzbl (%rax),%eax
  800420a66c:	88 45 97             	mov    %al,-0x69(%rbp)
							offset++;
  800420a66f:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
							if (atom == DW_OP_fbreg) {
  800420a674:	80 7d 97 91          	cmpb   $0x91,-0x69(%rbp)
  800420a678:	75 4a                	jne    800420a6c4 <list_func_die+0x6a2>
								uint8_t *p = loc_ptr;
  800420a67a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420a67e:	48 89 85 60 9e ff ff 	mov    %rax,-0x61a0(%rbp)
								ret_offset = _dwarf_decode_sleb128(&p);
  800420a685:	48 8d 85 60 9e ff ff 	lea    -0x61a0(%rbp),%rax
  800420a68c:	48 89 c7             	mov    %rax,%rdi
  800420a68f:	48 b8 27 c6 20 04 80 	movabs $0x800420c627,%rax
  800420a696:	00 00 00 
  800420a699:	ff d0                	callq  *%rax
  800420a69b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
								offset += p - loc_ptr;
  800420a69f:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420a6a6:	48 89 c2             	mov    %rax,%rdx
  800420a6a9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420a6ad:	48 29 c2             	sub    %rax,%rdx
  800420a6b0:	48 89 d0             	mov    %rdx,%rax
  800420a6b3:	48 01 45 c0          	add    %rax,-0x40(%rbp)
								loc_ptr = p;
  800420a6b7:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420a6be:	48 89 45 98          	mov    %rax,-0x68(%rbp)
							}
							break;
  800420a6c2:	eb 00                	jmp    800420a6c4 <list_func_die+0x6a2>
  800420a6c4:	90                   	nop
					}
				}

				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420a6c5:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420a6cc:	8b 48 28             	mov    0x28(%rax),%ecx
  800420a6cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a6d3:	89 c2                	mov    %eax,%edx
  800420a6d5:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420a6dc:	48 63 c9             	movslq %ecx,%rcx
  800420a6df:	48 83 c1 08          	add    $0x8,%rcx
  800420a6e3:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
				info->offset_fn_arg[info->rip_fn_narg]=ret_offset;
  800420a6e7:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420a6ee:	8b 50 28             	mov    0x28(%rax),%edx
  800420a6f1:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420a6f8:	48 63 d2             	movslq %edx,%rdx
  800420a6fb:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420a6ff:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420a703:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
				info->rip_fn_narg++;
  800420a708:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420a70f:	8b 40 28             	mov    0x28(%rax),%eax
  800420a712:	8d 50 01             	lea    0x1(%rax),%edx
  800420a715:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420a71c:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420a71f:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420a726:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420a72d:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420a732:	48 89 ce             	mov    %rcx,%rsi
  800420a735:	48 89 c7             	mov    %rax,%rdi
  800420a738:	48 b8 38 bc 20 04 80 	movabs $0x800420bc38,%rax
  800420a73f:	00 00 00 
  800420a742:	ff d0                	callq  *%rax
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
			info->rip_fn_narg++;
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420a744:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  800420a74b:	00 00 00 
  800420a74e:	48 8b 00             	mov    (%rax),%rax
  800420a751:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420a755:	48 8d 95 e0 ce ff ff 	lea    -0x3120(%rbp),%rdx
  800420a75c:	48 8d b5 70 9e ff ff 	lea    -0x6190(%rbp),%rsi
  800420a763:	48 89 c7             	mov    %rax,%rdi
  800420a766:	48 b8 5e da 20 04 80 	movabs $0x800420da5e,%rax
  800420a76d:	00 00 00 
  800420a770:	ff d0                	callq  *%rax
  800420a772:	85 c0                	test   %eax,%eax
  800420a774:	0f 84 8a fd ff ff    	je     800420a504 <list_func_die+0x4e2>
				info->rip_fn_narg++;
				sib = ret; 
			}
		}
	last:	
		return 1;
  800420a77a:	b8 01 00 00 00       	mov    $0x1,%eax
  800420a77f:	eb 05                	jmp    800420a786 <list_func_die+0x764>
	}

	return 0;
  800420a781:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420a786:	c9                   	leaveq 
  800420a787:	c3                   	retq   

000000800420a788 <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420a788:	55                   	push   %rbp
  800420a789:	48 89 e5             	mov    %rsp,%rbp
  800420a78c:	53                   	push   %rbx
  800420a78d:	48 81 ec c8 91 00 00 	sub    $0x91c8,%rsp
  800420a794:	48 89 bd 38 6e ff ff 	mov    %rdi,-0x91c8(%rbp)
  800420a79b:	48 89 b5 30 6e ff ff 	mov    %rsi,-0x91d0(%rbp)
	static struct Env* lastenv = NULL;
	void* elf;    
	Dwarf_Section *sect;
	Dwarf_CU cu;
	Dwarf_Die die, cudie, die2;
	Dwarf_Regtable *rt = NULL;
  800420a7a2:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420a7a9:	00 
	//Set up initial pc
	uint64_t pc  = (uintptr_t)addr;
  800420a7aa:	48 8b 85 38 6e ff ff 	mov    -0x91c8(%rbp),%rax
  800420a7b1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    
	// Initialize *info
	info->rip_file = "<unknown>";
  800420a7b5:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420a7bc:	48 bb 2f 38 21 04 80 	movabs $0x800421382f,%rbx
  800420a7c3:	00 00 00 
  800420a7c6:	48 89 18             	mov    %rbx,(%rax)
	info->rip_line = 0;
  800420a7c9:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420a7d0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	info->rip_fn_name = "<unknown>";
  800420a7d7:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420a7de:	48 bb 2f 38 21 04 80 	movabs $0x800421382f,%rbx
  800420a7e5:	00 00 00 
  800420a7e8:	48 89 58 10          	mov    %rbx,0x10(%rax)
	info->rip_fn_namelen = 9;
  800420a7ec:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420a7f3:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
	info->rip_fn_addr = addr;
  800420a7fa:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420a801:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420a808:	48 89 50 20          	mov    %rdx,0x20(%rax)
	info->rip_fn_narg = 0;
  800420a80c:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420a813:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
	// Find the relevant set of stabs
	if (addr >= ULIM) {
  800420a81a:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420a821:	00 00 00 
  800420a824:	48 39 85 38 6e ff ff 	cmp    %rax,-0x91c8(%rbp)
  800420a82b:	76 10                	jbe    800420a83d <debuginfo_rip+0xb5>
		elf = (void *)0x10000 + KERNBASE;
  800420a82d:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800420a834:	00 00 00 
  800420a837:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420a83b:	eb 74                	jmp    800420a8b1 <debuginfo_rip+0x129>
	} else {
		if(curenv != lastenv) {
  800420a83d:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  800420a844:	00 00 00 
  800420a847:	48 8b 10             	mov    (%rax),%rdx
  800420a84a:	48 b8 50 d7 2b 04 80 	movabs $0x80042bd750,%rax
  800420a851:	00 00 00 
  800420a854:	48 8b 00             	mov    (%rax),%rax
  800420a857:	48 39 c2             	cmp    %rax,%rdx
  800420a85a:	74 3d                	je     800420a899 <debuginfo_rip+0x111>
			find_debug_sections((uintptr_t)curenv->elf);
  800420a85c:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  800420a863:	00 00 00 
  800420a866:	48 8b 00             	mov    (%rax),%rax
  800420a869:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420a870:	48 89 c7             	mov    %rax,%rdi
  800420a873:	48 b8 ed 11 21 04 80 	movabs $0x80042111ed,%rax
  800420a87a:	00 00 00 
  800420a87d:	ff d0                	callq  *%rax
			lastenv = curenv;
  800420a87f:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  800420a886:	00 00 00 
  800420a889:	48 8b 10             	mov    (%rax),%rdx
  800420a88c:	48 b8 50 d7 2b 04 80 	movabs $0x80042bd750,%rax
  800420a893:	00 00 00 
  800420a896:	48 89 10             	mov    %rdx,(%rax)
		}
		elf = curenv->elf;
  800420a899:	48 b8 98 c6 2b 04 80 	movabs $0x80042bc698,%rax
  800420a8a0:	00 00 00 
  800420a8a3:	48 8b 00             	mov    (%rax),%rax
  800420a8a6:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420a8ad:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}
	_dwarf_init(dbg, elf);
  800420a8b1:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  800420a8b8:	00 00 00 
  800420a8bb:	48 8b 00             	mov    (%rax),%rax
  800420a8be:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420a8c2:	48 89 d6             	mov    %rdx,%rsi
  800420a8c5:	48 89 c7             	mov    %rax,%rdi
  800420a8c8:	48 b8 d6 c8 20 04 80 	movabs $0x800420c8d6,%rax
  800420a8cf:	00 00 00 
  800420a8d2:	ff d0                	callq  *%rax

	sect = _dwarf_find_section(".debug_info");	
  800420a8d4:	48 bf 39 38 21 04 80 	movabs $0x8004213839,%rdi
  800420a8db:	00 00 00 
  800420a8de:	48 b8 6d 11 21 04 80 	movabs $0x800421116d,%rax
  800420a8e5:	00 00 00 
  800420a8e8:	ff d0                	callq  *%rax
  800420a8ea:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800420a8ee:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  800420a8f5:	00 00 00 
  800420a8f8:	48 8b 00             	mov    (%rax),%rax
  800420a8fb:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420a8ff:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420a903:	48 89 50 08          	mov    %rdx,0x8(%rax)
	dbg->dbg_info_size = sect->ds_size;
  800420a907:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  800420a90e:	00 00 00 
  800420a911:	48 8b 00             	mov    (%rax),%rax
  800420a914:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420a918:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800420a91c:	48 89 50 10          	mov    %rdx,0x10(%rax)

	assert(dbg->dbg_info_size);
  800420a920:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  800420a927:	00 00 00 
  800420a92a:	48 8b 00             	mov    (%rax),%rax
  800420a92d:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420a931:	48 85 c0             	test   %rax,%rax
  800420a934:	75 35                	jne    800420a96b <debuginfo_rip+0x1e3>
  800420a936:	48 b9 45 38 21 04 80 	movabs $0x8004213845,%rcx
  800420a93d:	00 00 00 
  800420a940:	48 ba 0c 38 21 04 80 	movabs $0x800421380c,%rdx
  800420a947:	00 00 00 
  800420a94a:	be 37 01 00 00       	mov    $0x137,%esi
  800420a94f:	48 bf 21 38 21 04 80 	movabs $0x8004213821,%rdi
  800420a956:	00 00 00 
  800420a959:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a95e:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420a965:	00 00 00 
  800420a968:	41 ff d0             	callq  *%r8
	while(_get_next_cu(dbg, &cu) == 0)
  800420a96b:	e9 6f 01 00 00       	jmpq   800420aadf <debuginfo_rip+0x357>
	{
		if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  800420a970:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  800420a977:	00 00 00 
  800420a97a:	48 8b 00             	mov    (%rax),%rax
  800420a97d:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420a981:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420a988:	be 00 00 00 00       	mov    $0x0,%esi
  800420a98d:	48 89 c7             	mov    %rax,%rdi
  800420a990:	48 b8 5e da 20 04 80 	movabs $0x800420da5e,%rax
  800420a997:	00 00 00 
  800420a99a:	ff d0                	callq  *%rax
  800420a99c:	83 f8 04             	cmp    $0x4,%eax
  800420a99f:	75 05                	jne    800420a9a6 <debuginfo_rip+0x21e>
			continue;
  800420a9a1:	e9 39 01 00 00       	jmpq   800420aadf <debuginfo_rip+0x357>

		cudie.cu_header = &cu;
  800420a9a6:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420a9aa:	48 89 85 10 a2 ff ff 	mov    %rax,-0x5df0(%rbp)
		cudie.cu_die = NULL;
  800420a9b1:	48 c7 85 18 a2 ff ff 	movq   $0x0,-0x5de8(%rbp)
  800420a9b8:	00 00 00 00 

		if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  800420a9bc:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  800420a9c3:	00 00 00 
  800420a9c6:	48 8b 00             	mov    (%rax),%rax
  800420a9c9:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420a9d0:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420a9d7:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800420a9db:	48 89 c7             	mov    %rax,%rdi
  800420a9de:	48 b8 a2 dc 20 04 80 	movabs $0x800420dca2,%rax
  800420a9e5:	00 00 00 
  800420a9e8:	ff d0                	callq  *%rax
  800420a9ea:	83 f8 04             	cmp    $0x4,%eax
  800420a9ed:	75 05                	jne    800420a9f4 <debuginfo_rip+0x26c>
			continue;
  800420a9ef:	e9 eb 00 00 00       	jmpq   800420aadf <debuginfo_rip+0x357>

		die.cu_header = &cu;
  800420a9f4:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420a9f8:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
		die.cu_die = &cudie;
  800420a9ff:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420aa06:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		while(1)
		{
			if(list_func_die(info, &die, addr))
  800420aa0d:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420aa14:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420aa1b:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420aa22:	48 89 ce             	mov    %rcx,%rsi
  800420aa25:	48 89 c7             	mov    %rax,%rdi
  800420aa28:	48 b8 22 a0 20 04 80 	movabs $0x800420a022,%rax
  800420aa2f:	00 00 00 
  800420aa32:	ff d0                	callq  *%rax
  800420aa34:	85 c0                	test   %eax,%eax
  800420aa36:	74 30                	je     800420aa68 <debuginfo_rip+0x2e0>
				goto find_done;
  800420aa38:	90                   	nop

	return -1;

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
  800420aa39:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  800420aa40:	00 00 00 
  800420aa43:	48 8b 00             	mov    (%rax),%rax
  800420aa46:	be 00 00 00 00       	mov    $0x0,%esi
  800420aa4b:	48 89 c7             	mov    %rax,%rdi
  800420aa4e:	48 b8 7a 03 21 04 80 	movabs $0x800421037a,%rax
  800420aa55:	00 00 00 
  800420aa58:	ff d0                	callq  *%rax
  800420aa5a:	83 f8 01             	cmp    $0x1,%eax
  800420aa5d:	0f 85 bb 00 00 00    	jne    800420ab1e <debuginfo_rip+0x396>
  800420aa63:	e9 ac 00 00 00       	jmpq   800420ab14 <debuginfo_rip+0x38c>
		die.cu_die = &cudie;
		while(1)
		{
			if(list_func_die(info, &die, addr))
				goto find_done;
			if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  800420aa68:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  800420aa6f:	00 00 00 
  800420aa72:	48 8b 00             	mov    (%rax),%rax
  800420aa75:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420aa79:	48 8d 95 40 6e ff ff 	lea    -0x91c0(%rbp),%rdx
  800420aa80:	48 8d b5 20 cf ff ff 	lea    -0x30e0(%rbp),%rsi
  800420aa87:	48 89 c7             	mov    %rax,%rdi
  800420aa8a:	48 b8 5e da 20 04 80 	movabs $0x800420da5e,%rax
  800420aa91:	00 00 00 
  800420aa94:	ff d0                	callq  *%rax
  800420aa96:	85 c0                	test   %eax,%eax
  800420aa98:	79 02                	jns    800420aa9c <debuginfo_rip+0x314>
				break; 
  800420aa9a:	eb 43                	jmp    800420aadf <debuginfo_rip+0x357>
			die = die2;
  800420aa9c:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420aaa3:	48 8d 8d 40 6e ff ff 	lea    -0x91c0(%rbp),%rcx
  800420aaaa:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420aaaf:	48 89 ce             	mov    %rcx,%rsi
  800420aab2:	48 89 c7             	mov    %rax,%rdi
  800420aab5:	48 b8 38 bc 20 04 80 	movabs $0x800420bc38,%rax
  800420aabc:	00 00 00 
  800420aabf:	ff d0                	callq  *%rax
			die.cu_header = &cu;
  800420aac1:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420aac5:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
			die.cu_die = &cudie;
  800420aacc:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420aad3:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		}
  800420aada:	e9 2e ff ff ff       	jmpq   800420aa0d <debuginfo_rip+0x285>
	sect = _dwarf_find_section(".debug_info");	
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
	dbg->dbg_info_size = sect->ds_size;

	assert(dbg->dbg_info_size);
	while(_get_next_cu(dbg, &cu) == 0)
  800420aadf:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  800420aae6:	00 00 00 
  800420aae9:	48 8b 00             	mov    (%rax),%rax
  800420aaec:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  800420aaf0:	48 89 d6             	mov    %rdx,%rsi
  800420aaf3:	48 89 c7             	mov    %rax,%rdi
  800420aaf6:	48 b8 b8 c9 20 04 80 	movabs $0x800420c9b8,%rax
  800420aafd:	00 00 00 
  800420ab00:	ff d0                	callq  *%rax
  800420ab02:	85 c0                	test   %eax,%eax
  800420ab04:	0f 84 66 fe ff ff    	je     800420a970 <debuginfo_rip+0x1e8>
			die.cu_header = &cu;
			die.cu_die = &cudie;
		}
	}

	return -1;
  800420ab0a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420ab0f:	e9 a0 00 00 00       	jmpq   800420abb4 <debuginfo_rip+0x42c>

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
		return -1;
  800420ab14:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420ab19:	e9 96 00 00 00       	jmpq   800420abb4 <debuginfo_rip+0x42c>

	if (dwarf_get_fde_at_pc(dbg, addr, fde, cie, NULL) == DW_DLV_OK) {
  800420ab1e:	48 b8 10 66 22 04 80 	movabs $0x8004226610,%rax
  800420ab25:	00 00 00 
  800420ab28:	48 8b 08             	mov    (%rax),%rcx
  800420ab2b:	48 b8 08 66 22 04 80 	movabs $0x8004226608,%rax
  800420ab32:	00 00 00 
  800420ab35:	48 8b 10             	mov    (%rax),%rdx
  800420ab38:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  800420ab3f:	00 00 00 
  800420ab42:	48 8b 00             	mov    (%rax),%rax
  800420ab45:	48 8b b5 38 6e ff ff 	mov    -0x91c8(%rbp),%rsi
  800420ab4c:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420ab52:	48 89 c7             	mov    %rax,%rdi
  800420ab55:	48 b8 e3 de 20 04 80 	movabs $0x800420dee3,%rax
  800420ab5c:	00 00 00 
  800420ab5f:	ff d0                	callq  *%rax
  800420ab61:	85 c0                	test   %eax,%eax
  800420ab63:	75 4a                	jne    800420abaf <debuginfo_rip+0x427>
		dwarf_get_fde_info_for_all_regs(dbg, fde, addr,
  800420ab65:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420ab6c:	48 8d 88 a8 00 00 00 	lea    0xa8(%rax),%rcx
  800420ab73:	48 b8 08 66 22 04 80 	movabs $0x8004226608,%rax
  800420ab7a:	00 00 00 
  800420ab7d:	48 8b 30             	mov    (%rax),%rsi
  800420ab80:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  800420ab87:	00 00 00 
  800420ab8a:	48 8b 00             	mov    (%rax),%rax
  800420ab8d:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420ab94:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420ab9a:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420aba0:	48 89 c7             	mov    %rax,%rdi
  800420aba3:	48 b8 ef f1 20 04 80 	movabs $0x800420f1ef,%rax
  800420abaa:	00 00 00 
  800420abad:	ff d0                	callq  *%rax
					break;
			}
		}
#endif
	}
	return 0;
  800420abaf:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420abb4:	48 81 c4 c8 91 00 00 	add    $0x91c8,%rsp
  800420abbb:	5b                   	pop    %rbx
  800420abbc:	5d                   	pop    %rbp
  800420abbd:	c3                   	retq   

000000800420abbe <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800420abbe:	55                   	push   %rbp
  800420abbf:	48 89 e5             	mov    %rsp,%rbp
  800420abc2:	53                   	push   %rbx
  800420abc3:	48 83 ec 38          	sub    $0x38,%rsp
  800420abc7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420abcb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420abcf:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420abd3:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  800420abd6:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
  800420abda:	44 89 4d cc          	mov    %r9d,-0x34(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800420abde:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420abe1:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420abe5:	77 3b                	ja     800420ac22 <printnum+0x64>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800420abe7:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800420abea:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  800420abee:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
  800420abf1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420abf5:	ba 00 00 00 00       	mov    $0x0,%edx
  800420abfa:	48 f7 f3             	div    %rbx
  800420abfd:	48 89 c2             	mov    %rax,%rdx
  800420ac00:	8b 7d cc             	mov    -0x34(%rbp),%edi
  800420ac03:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420ac06:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420ac0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ac0e:	41 89 f9             	mov    %edi,%r9d
  800420ac11:	48 89 c7             	mov    %rax,%rdi
  800420ac14:	48 b8 be ab 20 04 80 	movabs $0x800420abbe,%rax
  800420ac1b:	00 00 00 
  800420ac1e:	ff d0                	callq  *%rax
  800420ac20:	eb 1e                	jmp    800420ac40 <printnum+0x82>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420ac22:	eb 12                	jmp    800420ac36 <printnum+0x78>
			putch(padc, putdat);
  800420ac24:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420ac28:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420ac2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ac2f:	48 89 ce             	mov    %rcx,%rsi
  800420ac32:	89 d7                	mov    %edx,%edi
  800420ac34:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420ac36:	83 6d d0 01          	subl   $0x1,-0x30(%rbp)
  800420ac3a:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  800420ac3e:	7f e4                	jg     800420ac24 <printnum+0x66>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800420ac40:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420ac43:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ac47:	ba 00 00 00 00       	mov    $0x0,%edx
  800420ac4c:	48 f7 f1             	div    %rcx
  800420ac4f:	48 89 d0             	mov    %rdx,%rax
  800420ac52:	48 ba 90 39 21 04 80 	movabs $0x8004213990,%rdx
  800420ac59:	00 00 00 
  800420ac5c:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420ac60:	0f be d0             	movsbl %al,%edx
  800420ac63:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420ac67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ac6b:	48 89 ce             	mov    %rcx,%rsi
  800420ac6e:	89 d7                	mov    %edx,%edi
  800420ac70:	ff d0                	callq  *%rax
}
  800420ac72:	48 83 c4 38          	add    $0x38,%rsp
  800420ac76:	5b                   	pop    %rbx
  800420ac77:	5d                   	pop    %rbp
  800420ac78:	c3                   	retq   

000000800420ac79 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800420ac79:	55                   	push   %rbp
  800420ac7a:	48 89 e5             	mov    %rsp,%rbp
  800420ac7d:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420ac81:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ac85:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  800420ac88:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420ac8c:	7e 52                	jle    800420ace0 <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  800420ac8e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ac92:	8b 00                	mov    (%rax),%eax
  800420ac94:	83 f8 30             	cmp    $0x30,%eax
  800420ac97:	73 24                	jae    800420acbd <getuint+0x44>
  800420ac99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ac9d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420aca1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420aca5:	8b 00                	mov    (%rax),%eax
  800420aca7:	89 c0                	mov    %eax,%eax
  800420aca9:	48 01 d0             	add    %rdx,%rax
  800420acac:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420acb0:	8b 12                	mov    (%rdx),%edx
  800420acb2:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420acb5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420acb9:	89 0a                	mov    %ecx,(%rdx)
  800420acbb:	eb 17                	jmp    800420acd4 <getuint+0x5b>
  800420acbd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420acc1:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420acc5:	48 89 d0             	mov    %rdx,%rax
  800420acc8:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420accc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420acd0:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420acd4:	48 8b 00             	mov    (%rax),%rax
  800420acd7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420acdb:	e9 a3 00 00 00       	jmpq   800420ad83 <getuint+0x10a>
	else if (lflag)
  800420ace0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420ace4:	74 4f                	je     800420ad35 <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  800420ace6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420acea:	8b 00                	mov    (%rax),%eax
  800420acec:	83 f8 30             	cmp    $0x30,%eax
  800420acef:	73 24                	jae    800420ad15 <getuint+0x9c>
  800420acf1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420acf5:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420acf9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420acfd:	8b 00                	mov    (%rax),%eax
  800420acff:	89 c0                	mov    %eax,%eax
  800420ad01:	48 01 d0             	add    %rdx,%rax
  800420ad04:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ad08:	8b 12                	mov    (%rdx),%edx
  800420ad0a:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ad0d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ad11:	89 0a                	mov    %ecx,(%rdx)
  800420ad13:	eb 17                	jmp    800420ad2c <getuint+0xb3>
  800420ad15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ad19:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ad1d:	48 89 d0             	mov    %rdx,%rax
  800420ad20:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ad24:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ad28:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ad2c:	48 8b 00             	mov    (%rax),%rax
  800420ad2f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ad33:	eb 4e                	jmp    800420ad83 <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  800420ad35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ad39:	8b 00                	mov    (%rax),%eax
  800420ad3b:	83 f8 30             	cmp    $0x30,%eax
  800420ad3e:	73 24                	jae    800420ad64 <getuint+0xeb>
  800420ad40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ad44:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ad48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ad4c:	8b 00                	mov    (%rax),%eax
  800420ad4e:	89 c0                	mov    %eax,%eax
  800420ad50:	48 01 d0             	add    %rdx,%rax
  800420ad53:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ad57:	8b 12                	mov    (%rdx),%edx
  800420ad59:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ad5c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ad60:	89 0a                	mov    %ecx,(%rdx)
  800420ad62:	eb 17                	jmp    800420ad7b <getuint+0x102>
  800420ad64:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ad68:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ad6c:	48 89 d0             	mov    %rdx,%rax
  800420ad6f:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ad73:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ad77:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ad7b:	8b 00                	mov    (%rax),%eax
  800420ad7d:	89 c0                	mov    %eax,%eax
  800420ad7f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420ad83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ad87:	c9                   	leaveq 
  800420ad88:	c3                   	retq   

000000800420ad89 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800420ad89:	55                   	push   %rbp
  800420ad8a:	48 89 e5             	mov    %rsp,%rbp
  800420ad8d:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420ad91:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ad95:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  800420ad98:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420ad9c:	7e 52                	jle    800420adf0 <getint+0x67>
		x=va_arg(*ap, long long);
  800420ad9e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ada2:	8b 00                	mov    (%rax),%eax
  800420ada4:	83 f8 30             	cmp    $0x30,%eax
  800420ada7:	73 24                	jae    800420adcd <getint+0x44>
  800420ada9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420adad:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420adb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420adb5:	8b 00                	mov    (%rax),%eax
  800420adb7:	89 c0                	mov    %eax,%eax
  800420adb9:	48 01 d0             	add    %rdx,%rax
  800420adbc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420adc0:	8b 12                	mov    (%rdx),%edx
  800420adc2:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420adc5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420adc9:	89 0a                	mov    %ecx,(%rdx)
  800420adcb:	eb 17                	jmp    800420ade4 <getint+0x5b>
  800420adcd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420add1:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420add5:	48 89 d0             	mov    %rdx,%rax
  800420add8:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420addc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ade0:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ade4:	48 8b 00             	mov    (%rax),%rax
  800420ade7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420adeb:	e9 a3 00 00 00       	jmpq   800420ae93 <getint+0x10a>
	else if (lflag)
  800420adf0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420adf4:	74 4f                	je     800420ae45 <getint+0xbc>
		x=va_arg(*ap, long);
  800420adf6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420adfa:	8b 00                	mov    (%rax),%eax
  800420adfc:	83 f8 30             	cmp    $0x30,%eax
  800420adff:	73 24                	jae    800420ae25 <getint+0x9c>
  800420ae01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ae05:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ae09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ae0d:	8b 00                	mov    (%rax),%eax
  800420ae0f:	89 c0                	mov    %eax,%eax
  800420ae11:	48 01 d0             	add    %rdx,%rax
  800420ae14:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ae18:	8b 12                	mov    (%rdx),%edx
  800420ae1a:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ae1d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ae21:	89 0a                	mov    %ecx,(%rdx)
  800420ae23:	eb 17                	jmp    800420ae3c <getint+0xb3>
  800420ae25:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ae29:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ae2d:	48 89 d0             	mov    %rdx,%rax
  800420ae30:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ae34:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ae38:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ae3c:	48 8b 00             	mov    (%rax),%rax
  800420ae3f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ae43:	eb 4e                	jmp    800420ae93 <getint+0x10a>
	else
		x=va_arg(*ap, int);
  800420ae45:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ae49:	8b 00                	mov    (%rax),%eax
  800420ae4b:	83 f8 30             	cmp    $0x30,%eax
  800420ae4e:	73 24                	jae    800420ae74 <getint+0xeb>
  800420ae50:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ae54:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ae58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ae5c:	8b 00                	mov    (%rax),%eax
  800420ae5e:	89 c0                	mov    %eax,%eax
  800420ae60:	48 01 d0             	add    %rdx,%rax
  800420ae63:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ae67:	8b 12                	mov    (%rdx),%edx
  800420ae69:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ae6c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ae70:	89 0a                	mov    %ecx,(%rdx)
  800420ae72:	eb 17                	jmp    800420ae8b <getint+0x102>
  800420ae74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ae78:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ae7c:	48 89 d0             	mov    %rdx,%rax
  800420ae7f:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ae83:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ae87:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ae8b:	8b 00                	mov    (%rax),%eax
  800420ae8d:	48 98                	cltq   
  800420ae8f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420ae93:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ae97:	c9                   	leaveq 
  800420ae98:	c3                   	retq   

000000800420ae99 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800420ae99:	55                   	push   %rbp
  800420ae9a:	48 89 e5             	mov    %rsp,%rbp
  800420ae9d:	41 54                	push   %r12
  800420ae9f:	53                   	push   %rbx
  800420aea0:	48 83 ec 60          	sub    $0x60,%rsp
  800420aea4:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420aea8:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420aeac:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420aeb0:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  800420aeb4:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420aeb8:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420aebc:	48 8b 0a             	mov    (%rdx),%rcx
  800420aebf:	48 89 08             	mov    %rcx,(%rax)
  800420aec2:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420aec6:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420aeca:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420aece:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420aed2:	eb 17                	jmp    800420aeeb <vprintfmt+0x52>
			if (ch == '\0')
  800420aed4:	85 db                	test   %ebx,%ebx
  800420aed6:	0f 84 df 04 00 00    	je     800420b3bb <vprintfmt+0x522>
				return;
			putch(ch, putdat);
  800420aedc:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420aee0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420aee4:	48 89 d6             	mov    %rdx,%rsi
  800420aee7:	89 df                	mov    %ebx,%edi
  800420aee9:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420aeeb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420aeef:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420aef3:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420aef7:	0f b6 00             	movzbl (%rax),%eax
  800420aefa:	0f b6 d8             	movzbl %al,%ebx
  800420aefd:	83 fb 25             	cmp    $0x25,%ebx
  800420af00:	75 d2                	jne    800420aed4 <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  800420af02:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  800420af06:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  800420af0d:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  800420af14:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  800420af1b:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800420af22:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420af26:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420af2a:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420af2e:	0f b6 00             	movzbl (%rax),%eax
  800420af31:	0f b6 d8             	movzbl %al,%ebx
  800420af34:	8d 43 dd             	lea    -0x23(%rbx),%eax
  800420af37:	83 f8 55             	cmp    $0x55,%eax
  800420af3a:	0f 87 47 04 00 00    	ja     800420b387 <vprintfmt+0x4ee>
  800420af40:	89 c0                	mov    %eax,%eax
  800420af42:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420af49:	00 
  800420af4a:	48 b8 b8 39 21 04 80 	movabs $0x80042139b8,%rax
  800420af51:	00 00 00 
  800420af54:	48 01 d0             	add    %rdx,%rax
  800420af57:	48 8b 00             	mov    (%rax),%rax
  800420af5a:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  800420af5c:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  800420af60:	eb c0                	jmp    800420af22 <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800420af62:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  800420af66:	eb ba                	jmp    800420af22 <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420af68:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  800420af6f:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420af72:	89 d0                	mov    %edx,%eax
  800420af74:	c1 e0 02             	shl    $0x2,%eax
  800420af77:	01 d0                	add    %edx,%eax
  800420af79:	01 c0                	add    %eax,%eax
  800420af7b:	01 d8                	add    %ebx,%eax
  800420af7d:	83 e8 30             	sub    $0x30,%eax
  800420af80:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  800420af83:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420af87:	0f b6 00             	movzbl (%rax),%eax
  800420af8a:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  800420af8d:	83 fb 2f             	cmp    $0x2f,%ebx
  800420af90:	7e 0c                	jle    800420af9e <vprintfmt+0x105>
  800420af92:	83 fb 39             	cmp    $0x39,%ebx
  800420af95:	7f 07                	jg     800420af9e <vprintfmt+0x105>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420af97:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  800420af9c:	eb d1                	jmp    800420af6f <vprintfmt+0xd6>
			goto process_precision;
  800420af9e:	eb 58                	jmp    800420aff8 <vprintfmt+0x15f>

		case '*':
			precision = va_arg(aq, int);
  800420afa0:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420afa3:	83 f8 30             	cmp    $0x30,%eax
  800420afa6:	73 17                	jae    800420afbf <vprintfmt+0x126>
  800420afa8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420afac:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420afaf:	89 c0                	mov    %eax,%eax
  800420afb1:	48 01 d0             	add    %rdx,%rax
  800420afb4:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420afb7:	83 c2 08             	add    $0x8,%edx
  800420afba:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420afbd:	eb 0f                	jmp    800420afce <vprintfmt+0x135>
  800420afbf:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420afc3:	48 89 d0             	mov    %rdx,%rax
  800420afc6:	48 83 c2 08          	add    $0x8,%rdx
  800420afca:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420afce:	8b 00                	mov    (%rax),%eax
  800420afd0:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  800420afd3:	eb 23                	jmp    800420aff8 <vprintfmt+0x15f>

		case '.':
			if (width < 0)
  800420afd5:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420afd9:	79 0c                	jns    800420afe7 <vprintfmt+0x14e>
				width = 0;
  800420afdb:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  800420afe2:	e9 3b ff ff ff       	jmpq   800420af22 <vprintfmt+0x89>
  800420afe7:	e9 36 ff ff ff       	jmpq   800420af22 <vprintfmt+0x89>

		case '#':
			altflag = 1;
  800420afec:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  800420aff3:	e9 2a ff ff ff       	jmpq   800420af22 <vprintfmt+0x89>

		process_precision:
			if (width < 0)
  800420aff8:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420affc:	79 12                	jns    800420b010 <vprintfmt+0x177>
				width = precision, precision = -1;
  800420affe:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420b001:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420b004:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  800420b00b:	e9 12 ff ff ff       	jmpq   800420af22 <vprintfmt+0x89>
  800420b010:	e9 0d ff ff ff       	jmpq   800420af22 <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  800420b015:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  800420b019:	e9 04 ff ff ff       	jmpq   800420af22 <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  800420b01e:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420b021:	83 f8 30             	cmp    $0x30,%eax
  800420b024:	73 17                	jae    800420b03d <vprintfmt+0x1a4>
  800420b026:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420b02a:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420b02d:	89 c0                	mov    %eax,%eax
  800420b02f:	48 01 d0             	add    %rdx,%rax
  800420b032:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420b035:	83 c2 08             	add    $0x8,%edx
  800420b038:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420b03b:	eb 0f                	jmp    800420b04c <vprintfmt+0x1b3>
  800420b03d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420b041:	48 89 d0             	mov    %rdx,%rax
  800420b044:	48 83 c2 08          	add    $0x8,%rdx
  800420b048:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420b04c:	8b 10                	mov    (%rax),%edx
  800420b04e:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420b052:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420b056:	48 89 ce             	mov    %rcx,%rsi
  800420b059:	89 d7                	mov    %edx,%edi
  800420b05b:	ff d0                	callq  *%rax
			break;
  800420b05d:	e9 53 03 00 00       	jmpq   800420b3b5 <vprintfmt+0x51c>

			// error message
		case 'e':
			err = va_arg(aq, int);
  800420b062:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420b065:	83 f8 30             	cmp    $0x30,%eax
  800420b068:	73 17                	jae    800420b081 <vprintfmt+0x1e8>
  800420b06a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420b06e:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420b071:	89 c0                	mov    %eax,%eax
  800420b073:	48 01 d0             	add    %rdx,%rax
  800420b076:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420b079:	83 c2 08             	add    $0x8,%edx
  800420b07c:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420b07f:	eb 0f                	jmp    800420b090 <vprintfmt+0x1f7>
  800420b081:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420b085:	48 89 d0             	mov    %rdx,%rax
  800420b088:	48 83 c2 08          	add    $0x8,%rdx
  800420b08c:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420b090:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  800420b092:	85 db                	test   %ebx,%ebx
  800420b094:	79 02                	jns    800420b098 <vprintfmt+0x1ff>
				err = -err;
  800420b096:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800420b098:	83 fb 15             	cmp    $0x15,%ebx
  800420b09b:	7f 16                	jg     800420b0b3 <vprintfmt+0x21a>
  800420b09d:	48 b8 e0 38 21 04 80 	movabs $0x80042138e0,%rax
  800420b0a4:	00 00 00 
  800420b0a7:	48 63 d3             	movslq %ebx,%rdx
  800420b0aa:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  800420b0ae:	4d 85 e4             	test   %r12,%r12
  800420b0b1:	75 2e                	jne    800420b0e1 <vprintfmt+0x248>
				printfmt(putch, putdat, "error %d", err);
  800420b0b3:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420b0b7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420b0bb:	89 d9                	mov    %ebx,%ecx
  800420b0bd:	48 ba a1 39 21 04 80 	movabs $0x80042139a1,%rdx
  800420b0c4:	00 00 00 
  800420b0c7:	48 89 c7             	mov    %rax,%rdi
  800420b0ca:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b0cf:	49 b8 c4 b3 20 04 80 	movabs $0x800420b3c4,%r8
  800420b0d6:	00 00 00 
  800420b0d9:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  800420b0dc:	e9 d4 02 00 00       	jmpq   800420b3b5 <vprintfmt+0x51c>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800420b0e1:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420b0e5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420b0e9:	4c 89 e1             	mov    %r12,%rcx
  800420b0ec:	48 ba aa 39 21 04 80 	movabs $0x80042139aa,%rdx
  800420b0f3:	00 00 00 
  800420b0f6:	48 89 c7             	mov    %rax,%rdi
  800420b0f9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b0fe:	49 b8 c4 b3 20 04 80 	movabs $0x800420b3c4,%r8
  800420b105:	00 00 00 
  800420b108:	41 ff d0             	callq  *%r8
			break;
  800420b10b:	e9 a5 02 00 00       	jmpq   800420b3b5 <vprintfmt+0x51c>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  800420b110:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420b113:	83 f8 30             	cmp    $0x30,%eax
  800420b116:	73 17                	jae    800420b12f <vprintfmt+0x296>
  800420b118:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420b11c:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420b11f:	89 c0                	mov    %eax,%eax
  800420b121:	48 01 d0             	add    %rdx,%rax
  800420b124:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420b127:	83 c2 08             	add    $0x8,%edx
  800420b12a:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420b12d:	eb 0f                	jmp    800420b13e <vprintfmt+0x2a5>
  800420b12f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420b133:	48 89 d0             	mov    %rdx,%rax
  800420b136:	48 83 c2 08          	add    $0x8,%rdx
  800420b13a:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420b13e:	4c 8b 20             	mov    (%rax),%r12
  800420b141:	4d 85 e4             	test   %r12,%r12
  800420b144:	75 0a                	jne    800420b150 <vprintfmt+0x2b7>
				p = "(null)";
  800420b146:	49 bc ad 39 21 04 80 	movabs $0x80042139ad,%r12
  800420b14d:	00 00 00 
			if (width > 0 && padc != '-')
  800420b150:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420b154:	7e 3f                	jle    800420b195 <vprintfmt+0x2fc>
  800420b156:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  800420b15a:	74 39                	je     800420b195 <vprintfmt+0x2fc>
				for (width -= strnlen(p, precision); width > 0; width--)
  800420b15c:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420b15f:	48 98                	cltq   
  800420b161:	48 89 c6             	mov    %rax,%rsi
  800420b164:	4c 89 e7             	mov    %r12,%rdi
  800420b167:	48 b8 bf b7 20 04 80 	movabs $0x800420b7bf,%rax
  800420b16e:	00 00 00 
  800420b171:	ff d0                	callq  *%rax
  800420b173:	29 45 dc             	sub    %eax,-0x24(%rbp)
  800420b176:	eb 17                	jmp    800420b18f <vprintfmt+0x2f6>
					putch(padc, putdat);
  800420b178:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  800420b17c:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420b180:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420b184:	48 89 ce             	mov    %rcx,%rsi
  800420b187:	89 d7                	mov    %edx,%edi
  800420b189:	ff d0                	callq  *%rax
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800420b18b:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420b18f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420b193:	7f e3                	jg     800420b178 <vprintfmt+0x2df>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420b195:	eb 37                	jmp    800420b1ce <vprintfmt+0x335>
				if (altflag && (ch < ' ' || ch > '~'))
  800420b197:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  800420b19b:	74 1e                	je     800420b1bb <vprintfmt+0x322>
  800420b19d:	83 fb 1f             	cmp    $0x1f,%ebx
  800420b1a0:	7e 05                	jle    800420b1a7 <vprintfmt+0x30e>
  800420b1a2:	83 fb 7e             	cmp    $0x7e,%ebx
  800420b1a5:	7e 14                	jle    800420b1bb <vprintfmt+0x322>
					putch('?', putdat);
  800420b1a7:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420b1ab:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420b1af:	48 89 d6             	mov    %rdx,%rsi
  800420b1b2:	bf 3f 00 00 00       	mov    $0x3f,%edi
  800420b1b7:	ff d0                	callq  *%rax
  800420b1b9:	eb 0f                	jmp    800420b1ca <vprintfmt+0x331>
				else
					putch(ch, putdat);
  800420b1bb:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420b1bf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420b1c3:	48 89 d6             	mov    %rdx,%rsi
  800420b1c6:	89 df                	mov    %ebx,%edi
  800420b1c8:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420b1ca:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420b1ce:	4c 89 e0             	mov    %r12,%rax
  800420b1d1:	4c 8d 60 01          	lea    0x1(%rax),%r12
  800420b1d5:	0f b6 00             	movzbl (%rax),%eax
  800420b1d8:	0f be d8             	movsbl %al,%ebx
  800420b1db:	85 db                	test   %ebx,%ebx
  800420b1dd:	74 10                	je     800420b1ef <vprintfmt+0x356>
  800420b1df:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420b1e3:	78 b2                	js     800420b197 <vprintfmt+0x2fe>
  800420b1e5:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  800420b1e9:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420b1ed:	79 a8                	jns    800420b197 <vprintfmt+0x2fe>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420b1ef:	eb 16                	jmp    800420b207 <vprintfmt+0x36e>
				putch(' ', putdat);
  800420b1f1:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420b1f5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420b1f9:	48 89 d6             	mov    %rdx,%rsi
  800420b1fc:	bf 20 00 00 00       	mov    $0x20,%edi
  800420b201:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420b203:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420b207:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420b20b:	7f e4                	jg     800420b1f1 <vprintfmt+0x358>
				putch(' ', putdat);
			break;
  800420b20d:	e9 a3 01 00 00       	jmpq   800420b3b5 <vprintfmt+0x51c>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  800420b212:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420b216:	be 03 00 00 00       	mov    $0x3,%esi
  800420b21b:	48 89 c7             	mov    %rax,%rdi
  800420b21e:	48 b8 89 ad 20 04 80 	movabs $0x800420ad89,%rax
  800420b225:	00 00 00 
  800420b228:	ff d0                	callq  *%rax
  800420b22a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800420b22e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b232:	48 85 c0             	test   %rax,%rax
  800420b235:	79 1d                	jns    800420b254 <vprintfmt+0x3bb>
				putch('-', putdat);
  800420b237:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420b23b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420b23f:	48 89 d6             	mov    %rdx,%rsi
  800420b242:	bf 2d 00 00 00       	mov    $0x2d,%edi
  800420b247:	ff d0                	callq  *%rax
				num = -(long long) num;
  800420b249:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b24d:	48 f7 d8             	neg    %rax
  800420b250:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  800420b254:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420b25b:	e9 e8 00 00 00       	jmpq   800420b348 <vprintfmt+0x4af>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  800420b260:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420b264:	be 03 00 00 00       	mov    $0x3,%esi
  800420b269:	48 89 c7             	mov    %rax,%rdi
  800420b26c:	48 b8 79 ac 20 04 80 	movabs $0x800420ac79,%rax
  800420b273:	00 00 00 
  800420b276:	ff d0                	callq  *%rax
  800420b278:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  800420b27c:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420b283:	e9 c0 00 00 00       	jmpq   800420b348 <vprintfmt+0x4af>

			// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
  800420b288:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420b28c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420b290:	48 89 d6             	mov    %rdx,%rsi
  800420b293:	bf 58 00 00 00       	mov    $0x58,%edi
  800420b298:	ff d0                	callq  *%rax
			putch('X', putdat);
  800420b29a:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420b29e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420b2a2:	48 89 d6             	mov    %rdx,%rsi
  800420b2a5:	bf 58 00 00 00       	mov    $0x58,%edi
  800420b2aa:	ff d0                	callq  *%rax
			putch('X', putdat);
  800420b2ac:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420b2b0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420b2b4:	48 89 d6             	mov    %rdx,%rsi
  800420b2b7:	bf 58 00 00 00       	mov    $0x58,%edi
  800420b2bc:	ff d0                	callq  *%rax
			break;
  800420b2be:	e9 f2 00 00 00       	jmpq   800420b3b5 <vprintfmt+0x51c>

			// pointer
		case 'p':
			putch('0', putdat);
  800420b2c3:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420b2c7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420b2cb:	48 89 d6             	mov    %rdx,%rsi
  800420b2ce:	bf 30 00 00 00       	mov    $0x30,%edi
  800420b2d3:	ff d0                	callq  *%rax
			putch('x', putdat);
  800420b2d5:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420b2d9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420b2dd:	48 89 d6             	mov    %rdx,%rsi
  800420b2e0:	bf 78 00 00 00       	mov    $0x78,%edi
  800420b2e5:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  800420b2e7:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420b2ea:	83 f8 30             	cmp    $0x30,%eax
  800420b2ed:	73 17                	jae    800420b306 <vprintfmt+0x46d>
  800420b2ef:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420b2f3:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420b2f6:	89 c0                	mov    %eax,%eax
  800420b2f8:	48 01 d0             	add    %rdx,%rax
  800420b2fb:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420b2fe:	83 c2 08             	add    $0x8,%edx
  800420b301:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420b304:	eb 0f                	jmp    800420b315 <vprintfmt+0x47c>
				(uintptr_t) va_arg(aq, void *);
  800420b306:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420b30a:	48 89 d0             	mov    %rdx,%rax
  800420b30d:	48 83 c2 08          	add    $0x8,%rdx
  800420b311:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420b315:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420b318:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  800420b31c:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  800420b323:	eb 23                	jmp    800420b348 <vprintfmt+0x4af>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  800420b325:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420b329:	be 03 00 00 00       	mov    $0x3,%esi
  800420b32e:	48 89 c7             	mov    %rax,%rdi
  800420b331:	48 b8 79 ac 20 04 80 	movabs $0x800420ac79,%rax
  800420b338:	00 00 00 
  800420b33b:	ff d0                	callq  *%rax
  800420b33d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  800420b341:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  800420b348:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  800420b34d:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420b350:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800420b353:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b357:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420b35b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420b35f:	45 89 c1             	mov    %r8d,%r9d
  800420b362:	41 89 f8             	mov    %edi,%r8d
  800420b365:	48 89 c7             	mov    %rax,%rdi
  800420b368:	48 b8 be ab 20 04 80 	movabs $0x800420abbe,%rax
  800420b36f:	00 00 00 
  800420b372:	ff d0                	callq  *%rax
			break;
  800420b374:	eb 3f                	jmp    800420b3b5 <vprintfmt+0x51c>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  800420b376:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420b37a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420b37e:	48 89 d6             	mov    %rdx,%rsi
  800420b381:	89 df                	mov    %ebx,%edi
  800420b383:	ff d0                	callq  *%rax
			break;
  800420b385:	eb 2e                	jmp    800420b3b5 <vprintfmt+0x51c>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800420b387:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420b38b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420b38f:	48 89 d6             	mov    %rdx,%rsi
  800420b392:	bf 25 00 00 00       	mov    $0x25,%edi
  800420b397:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  800420b399:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420b39e:	eb 05                	jmp    800420b3a5 <vprintfmt+0x50c>
  800420b3a0:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420b3a5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420b3a9:	48 83 e8 01          	sub    $0x1,%rax
  800420b3ad:	0f b6 00             	movzbl (%rax),%eax
  800420b3b0:	3c 25                	cmp    $0x25,%al
  800420b3b2:	75 ec                	jne    800420b3a0 <vprintfmt+0x507>
				/* do nothing */;
			break;
  800420b3b4:	90                   	nop
		}
	}
  800420b3b5:	90                   	nop
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420b3b6:	e9 30 fb ff ff       	jmpq   800420aeeb <vprintfmt+0x52>
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  800420b3bb:	48 83 c4 60          	add    $0x60,%rsp
  800420b3bf:	5b                   	pop    %rbx
  800420b3c0:	41 5c                	pop    %r12
  800420b3c2:	5d                   	pop    %rbp
  800420b3c3:	c3                   	retq   

000000800420b3c4 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800420b3c4:	55                   	push   %rbp
  800420b3c5:	48 89 e5             	mov    %rsp,%rbp
  800420b3c8:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420b3cf:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420b3d6:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  800420b3dd:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420b3e4:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420b3eb:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420b3f2:	84 c0                	test   %al,%al
  800420b3f4:	74 20                	je     800420b416 <printfmt+0x52>
  800420b3f6:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420b3fa:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420b3fe:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420b402:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420b406:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420b40a:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420b40e:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420b412:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420b416:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420b41d:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420b424:	00 00 00 
  800420b427:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420b42e:	00 00 00 
  800420b431:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420b435:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420b43c:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420b443:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  800420b44a:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  800420b451:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420b458:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420b45f:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420b466:	48 89 c7             	mov    %rax,%rdi
  800420b469:	48 b8 99 ae 20 04 80 	movabs $0x800420ae99,%rax
  800420b470:	00 00 00 
  800420b473:	ff d0                	callq  *%rax
	va_end(ap);
}
  800420b475:	c9                   	leaveq 
  800420b476:	c3                   	retq   

000000800420b477 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800420b477:	55                   	push   %rbp
  800420b478:	48 89 e5             	mov    %rsp,%rbp
  800420b47b:	48 83 ec 10          	sub    $0x10,%rsp
  800420b47f:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420b482:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  800420b486:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b48a:	8b 40 10             	mov    0x10(%rax),%eax
  800420b48d:	8d 50 01             	lea    0x1(%rax),%edx
  800420b490:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b494:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  800420b497:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b49b:	48 8b 10             	mov    (%rax),%rdx
  800420b49e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b4a2:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b4a6:	48 39 c2             	cmp    %rax,%rdx
  800420b4a9:	73 17                	jae    800420b4c2 <sprintputch+0x4b>
		*b->buf++ = ch;
  800420b4ab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b4af:	48 8b 00             	mov    (%rax),%rax
  800420b4b2:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800420b4b6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420b4ba:	48 89 0a             	mov    %rcx,(%rdx)
  800420b4bd:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420b4c0:	88 10                	mov    %dl,(%rax)
}
  800420b4c2:	c9                   	leaveq 
  800420b4c3:	c3                   	retq   

000000800420b4c4 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  800420b4c4:	55                   	push   %rbp
  800420b4c5:	48 89 e5             	mov    %rsp,%rbp
  800420b4c8:	48 83 ec 50          	sub    $0x50,%rsp
  800420b4cc:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420b4d0:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800420b4d3:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420b4d7:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  800420b4db:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420b4df:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420b4e3:	48 8b 0a             	mov    (%rdx),%rcx
  800420b4e6:	48 89 08             	mov    %rcx,(%rax)
  800420b4e9:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420b4ed:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420b4f1:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420b4f5:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  800420b4f9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b4fd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420b501:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420b504:	48 98                	cltq   
  800420b506:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420b50a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b50e:	48 01 d0             	add    %rdx,%rax
  800420b511:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420b515:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  800420b51c:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420b521:	74 06                	je     800420b529 <vsnprintf+0x65>
  800420b523:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800420b527:	7f 07                	jg     800420b530 <vsnprintf+0x6c>
		return -E_INVAL;
  800420b529:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420b52e:	eb 2f                	jmp    800420b55f <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  800420b530:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420b534:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420b538:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800420b53c:	48 89 c6             	mov    %rax,%rsi
  800420b53f:	48 bf 77 b4 20 04 80 	movabs $0x800420b477,%rdi
  800420b546:	00 00 00 
  800420b549:	48 b8 99 ae 20 04 80 	movabs $0x800420ae99,%rax
  800420b550:	00 00 00 
  800420b553:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  800420b555:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420b559:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  800420b55c:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  800420b55f:	c9                   	leaveq 
  800420b560:	c3                   	retq   

000000800420b561 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  800420b561:	55                   	push   %rbp
  800420b562:	48 89 e5             	mov    %rsp,%rbp
  800420b565:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800420b56c:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  800420b573:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  800420b579:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420b580:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420b587:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420b58e:	84 c0                	test   %al,%al
  800420b590:	74 20                	je     800420b5b2 <snprintf+0x51>
  800420b592:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420b596:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420b59a:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420b59e:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420b5a2:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420b5a6:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420b5aa:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420b5ae:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420b5b2:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  800420b5b9:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  800420b5c0:	00 00 00 
  800420b5c3:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  800420b5ca:	00 00 00 
  800420b5cd:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420b5d1:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  800420b5d8:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420b5df:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  800420b5e6:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420b5ed:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420b5f4:	48 8b 0a             	mov    (%rdx),%rcx
  800420b5f7:	48 89 08             	mov    %rcx,(%rax)
  800420b5fa:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420b5fe:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420b602:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420b606:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  800420b60a:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  800420b611:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  800420b618:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  800420b61e:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420b625:	48 89 c7             	mov    %rax,%rdi
  800420b628:	48 b8 c4 b4 20 04 80 	movabs $0x800420b4c4,%rax
  800420b62f:	00 00 00 
  800420b632:	ff d0                	callq  *%rax
  800420b634:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  800420b63a:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  800420b640:	c9                   	leaveq 
  800420b641:	c3                   	retq   

000000800420b642 <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  800420b642:	55                   	push   %rbp
  800420b643:	48 89 e5             	mov    %rsp,%rbp
  800420b646:	48 83 ec 20          	sub    $0x20,%rsp
  800420b64a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;

	if (prompt != NULL)
  800420b64e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420b653:	74 22                	je     800420b677 <readline+0x35>
		cprintf("%s", prompt);
  800420b655:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b659:	48 89 c6             	mov    %rax,%rsi
  800420b65c:	48 bf 68 3c 21 04 80 	movabs $0x8004213c68,%rdi
  800420b663:	00 00 00 
  800420b666:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b66b:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  800420b672:	00 00 00 
  800420b675:	ff d2                	callq  *%rdx

	i = 0;
  800420b677:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  800420b67e:	bf 00 00 00 00       	mov    $0x0,%edi
  800420b683:	48 b8 4b 0e 20 04 80 	movabs $0x8004200e4b,%rax
  800420b68a:	00 00 00 
  800420b68d:	ff d0                	callq  *%rax
  800420b68f:	89 45 f8             	mov    %eax,-0x8(%rbp)
	while (1) {
		c = getchar();
  800420b692:	48 b8 29 0e 20 04 80 	movabs $0x8004200e29,%rax
  800420b699:	00 00 00 
  800420b69c:	ff d0                	callq  *%rax
  800420b69e:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  800420b6a1:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420b6a5:	79 2a                	jns    800420b6d1 <readline+0x8f>
			cprintf("read error: %e\n", c);
  800420b6a7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420b6aa:	89 c6                	mov    %eax,%esi
  800420b6ac:	48 bf 6b 3c 21 04 80 	movabs $0x8004213c6b,%rdi
  800420b6b3:	00 00 00 
  800420b6b6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b6bb:	48 ba 46 7b 20 04 80 	movabs $0x8004207b46,%rdx
  800420b6c2:	00 00 00 
  800420b6c5:	ff d2                	callq  *%rdx
			return NULL;
  800420b6c7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b6cc:	e9 be 00 00 00       	jmpq   800420b78f <readline+0x14d>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  800420b6d1:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  800420b6d5:	74 06                	je     800420b6dd <readline+0x9b>
  800420b6d7:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  800420b6db:	75 26                	jne    800420b703 <readline+0xc1>
  800420b6dd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420b6e1:	7e 20                	jle    800420b703 <readline+0xc1>
			if (echoing)
  800420b6e3:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420b6e7:	74 11                	je     800420b6fa <readline+0xb8>
				cputchar('\b');
  800420b6e9:	bf 08 00 00 00       	mov    $0x8,%edi
  800420b6ee:	48 b8 0b 0e 20 04 80 	movabs $0x8004200e0b,%rax
  800420b6f5:	00 00 00 
  800420b6f8:	ff d0                	callq  *%rax
			i--;
  800420b6fa:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  800420b6fe:	e9 87 00 00 00       	jmpq   800420b78a <readline+0x148>
		} else if (c >= ' ' && i < BUFLEN-1) {
  800420b703:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420b707:	7e 3f                	jle    800420b748 <readline+0x106>
  800420b709:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  800420b710:	7f 36                	jg     800420b748 <readline+0x106>
			if (echoing)
  800420b712:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420b716:	74 11                	je     800420b729 <readline+0xe7>
				cputchar(c);
  800420b718:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420b71b:	89 c7                	mov    %eax,%edi
  800420b71d:	48 b8 0b 0e 20 04 80 	movabs $0x8004200e0b,%rax
  800420b724:	00 00 00 
  800420b727:	ff d0                	callq  *%rax
			buf[i++] = c;
  800420b729:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420b72c:	8d 50 01             	lea    0x1(%rax),%edx
  800420b72f:	89 55 fc             	mov    %edx,-0x4(%rbp)
  800420b732:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420b735:	89 d1                	mov    %edx,%ecx
  800420b737:	48 ba 60 d7 2b 04 80 	movabs $0x80042bd760,%rdx
  800420b73e:	00 00 00 
  800420b741:	48 98                	cltq   
  800420b743:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  800420b746:	eb 42                	jmp    800420b78a <readline+0x148>
		} else if (c == '\n' || c == '\r') {
  800420b748:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  800420b74c:	74 06                	je     800420b754 <readline+0x112>
  800420b74e:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  800420b752:	75 36                	jne    800420b78a <readline+0x148>
			if (echoing)
  800420b754:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420b758:	74 11                	je     800420b76b <readline+0x129>
				cputchar('\n');
  800420b75a:	bf 0a 00 00 00       	mov    $0xa,%edi
  800420b75f:	48 b8 0b 0e 20 04 80 	movabs $0x8004200e0b,%rax
  800420b766:	00 00 00 
  800420b769:	ff d0                	callq  *%rax
			buf[i] = 0;
  800420b76b:	48 ba 60 d7 2b 04 80 	movabs $0x80042bd760,%rdx
  800420b772:	00 00 00 
  800420b775:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420b778:	48 98                	cltq   
  800420b77a:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  800420b77e:	48 b8 60 d7 2b 04 80 	movabs $0x80042bd760,%rax
  800420b785:	00 00 00 
  800420b788:	eb 05                	jmp    800420b78f <readline+0x14d>
		}
	}
  800420b78a:	e9 03 ff ff ff       	jmpq   800420b692 <readline+0x50>
}
  800420b78f:	c9                   	leaveq 
  800420b790:	c3                   	retq   

000000800420b791 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  800420b791:	55                   	push   %rbp
  800420b792:	48 89 e5             	mov    %rsp,%rbp
  800420b795:	48 83 ec 18          	sub    $0x18,%rsp
  800420b799:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  800420b79d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420b7a4:	eb 09                	jmp    800420b7af <strlen+0x1e>
		n++;
  800420b7a6:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  800420b7aa:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420b7af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b7b3:	0f b6 00             	movzbl (%rax),%eax
  800420b7b6:	84 c0                	test   %al,%al
  800420b7b8:	75 ec                	jne    800420b7a6 <strlen+0x15>
		n++;
	return n;
  800420b7ba:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420b7bd:	c9                   	leaveq 
  800420b7be:	c3                   	retq   

000000800420b7bf <strnlen>:

int
strnlen(const char *s, size_t size)
{
  800420b7bf:	55                   	push   %rbp
  800420b7c0:	48 89 e5             	mov    %rsp,%rbp
  800420b7c3:	48 83 ec 20          	sub    $0x20,%rsp
  800420b7c7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420b7cb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420b7cf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420b7d6:	eb 0e                	jmp    800420b7e6 <strnlen+0x27>
		n++;
  800420b7d8:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420b7dc:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420b7e1:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  800420b7e6:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420b7eb:	74 0b                	je     800420b7f8 <strnlen+0x39>
  800420b7ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b7f1:	0f b6 00             	movzbl (%rax),%eax
  800420b7f4:	84 c0                	test   %al,%al
  800420b7f6:	75 e0                	jne    800420b7d8 <strnlen+0x19>
		n++;
	return n;
  800420b7f8:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420b7fb:	c9                   	leaveq 
  800420b7fc:	c3                   	retq   

000000800420b7fd <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  800420b7fd:	55                   	push   %rbp
  800420b7fe:	48 89 e5             	mov    %rsp,%rbp
  800420b801:	48 83 ec 20          	sub    $0x20,%rsp
  800420b805:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420b809:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  800420b80d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b811:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  800420b815:	90                   	nop
  800420b816:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b81a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420b81e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420b822:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420b826:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420b82a:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420b82e:	0f b6 12             	movzbl (%rdx),%edx
  800420b831:	88 10                	mov    %dl,(%rax)
  800420b833:	0f b6 00             	movzbl (%rax),%eax
  800420b836:	84 c0                	test   %al,%al
  800420b838:	75 dc                	jne    800420b816 <strcpy+0x19>
		/* do nothing */;
	return ret;
  800420b83a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420b83e:	c9                   	leaveq 
  800420b83f:	c3                   	retq   

000000800420b840 <strcat>:

char *
strcat(char *dst, const char *src)
{
  800420b840:	55                   	push   %rbp
  800420b841:	48 89 e5             	mov    %rsp,%rbp
  800420b844:	48 83 ec 20          	sub    $0x20,%rsp
  800420b848:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420b84c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  800420b850:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b854:	48 89 c7             	mov    %rax,%rdi
  800420b857:	48 b8 91 b7 20 04 80 	movabs $0x800420b791,%rax
  800420b85e:	00 00 00 
  800420b861:	ff d0                	callq  *%rax
  800420b863:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  800420b866:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420b869:	48 63 d0             	movslq %eax,%rdx
  800420b86c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b870:	48 01 c2             	add    %rax,%rdx
  800420b873:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420b877:	48 89 c6             	mov    %rax,%rsi
  800420b87a:	48 89 d7             	mov    %rdx,%rdi
  800420b87d:	48 b8 fd b7 20 04 80 	movabs $0x800420b7fd,%rax
  800420b884:	00 00 00 
  800420b887:	ff d0                	callq  *%rax
	return dst;
  800420b889:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420b88d:	c9                   	leaveq 
  800420b88e:	c3                   	retq   

000000800420b88f <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  800420b88f:	55                   	push   %rbp
  800420b890:	48 89 e5             	mov    %rsp,%rbp
  800420b893:	48 83 ec 28          	sub    $0x28,%rsp
  800420b897:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420b89b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420b89f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  800420b8a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b8a7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  800420b8ab:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420b8b2:	00 
  800420b8b3:	eb 2a                	jmp    800420b8df <strncpy+0x50>
		*dst++ = *src;
  800420b8b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b8b9:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420b8bd:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420b8c1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420b8c5:	0f b6 12             	movzbl (%rdx),%edx
  800420b8c8:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  800420b8ca:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420b8ce:	0f b6 00             	movzbl (%rax),%eax
  800420b8d1:	84 c0                	test   %al,%al
  800420b8d3:	74 05                	je     800420b8da <strncpy+0x4b>
			src++;
  800420b8d5:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  800420b8da:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420b8df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b8e3:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420b8e7:	72 cc                	jb     800420b8b5 <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  800420b8e9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420b8ed:	c9                   	leaveq 
  800420b8ee:	c3                   	retq   

000000800420b8ef <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  800420b8ef:	55                   	push   %rbp
  800420b8f0:	48 89 e5             	mov    %rsp,%rbp
  800420b8f3:	48 83 ec 28          	sub    $0x28,%rsp
  800420b8f7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420b8fb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420b8ff:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  800420b903:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b907:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  800420b90b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420b910:	74 3d                	je     800420b94f <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  800420b912:	eb 1d                	jmp    800420b931 <strlcpy+0x42>
			*dst++ = *src++;
  800420b914:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b918:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420b91c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420b920:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420b924:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420b928:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420b92c:	0f b6 12             	movzbl (%rdx),%edx
  800420b92f:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  800420b931:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  800420b936:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420b93b:	74 0b                	je     800420b948 <strlcpy+0x59>
  800420b93d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420b941:	0f b6 00             	movzbl (%rax),%eax
  800420b944:	84 c0                	test   %al,%al
  800420b946:	75 cc                	jne    800420b914 <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  800420b948:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b94c:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  800420b94f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b953:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b957:	48 29 c2             	sub    %rax,%rdx
  800420b95a:	48 89 d0             	mov    %rdx,%rax
}
  800420b95d:	c9                   	leaveq 
  800420b95e:	c3                   	retq   

000000800420b95f <strcmp>:

int
strcmp(const char *p, const char *q)
{
  800420b95f:	55                   	push   %rbp
  800420b960:	48 89 e5             	mov    %rsp,%rbp
  800420b963:	48 83 ec 10          	sub    $0x10,%rsp
  800420b967:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420b96b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  800420b96f:	eb 0a                	jmp    800420b97b <strcmp+0x1c>
		p++, q++;
  800420b971:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420b976:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  800420b97b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b97f:	0f b6 00             	movzbl (%rax),%eax
  800420b982:	84 c0                	test   %al,%al
  800420b984:	74 12                	je     800420b998 <strcmp+0x39>
  800420b986:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b98a:	0f b6 10             	movzbl (%rax),%edx
  800420b98d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b991:	0f b6 00             	movzbl (%rax),%eax
  800420b994:	38 c2                	cmp    %al,%dl
  800420b996:	74 d9                	je     800420b971 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  800420b998:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b99c:	0f b6 00             	movzbl (%rax),%eax
  800420b99f:	0f b6 d0             	movzbl %al,%edx
  800420b9a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b9a6:	0f b6 00             	movzbl (%rax),%eax
  800420b9a9:	0f b6 c0             	movzbl %al,%eax
  800420b9ac:	29 c2                	sub    %eax,%edx
  800420b9ae:	89 d0                	mov    %edx,%eax
}
  800420b9b0:	c9                   	leaveq 
  800420b9b1:	c3                   	retq   

000000800420b9b2 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  800420b9b2:	55                   	push   %rbp
  800420b9b3:	48 89 e5             	mov    %rsp,%rbp
  800420b9b6:	48 83 ec 18          	sub    $0x18,%rsp
  800420b9ba:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420b9be:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420b9c2:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  800420b9c6:	eb 0f                	jmp    800420b9d7 <strncmp+0x25>
		n--, p++, q++;
  800420b9c8:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  800420b9cd:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420b9d2:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  800420b9d7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420b9dc:	74 1d                	je     800420b9fb <strncmp+0x49>
  800420b9de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b9e2:	0f b6 00             	movzbl (%rax),%eax
  800420b9e5:	84 c0                	test   %al,%al
  800420b9e7:	74 12                	je     800420b9fb <strncmp+0x49>
  800420b9e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b9ed:	0f b6 10             	movzbl (%rax),%edx
  800420b9f0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b9f4:	0f b6 00             	movzbl (%rax),%eax
  800420b9f7:	38 c2                	cmp    %al,%dl
  800420b9f9:	74 cd                	je     800420b9c8 <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  800420b9fb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ba00:	75 07                	jne    800420ba09 <strncmp+0x57>
		return 0;
  800420ba02:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ba07:	eb 18                	jmp    800420ba21 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  800420ba09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ba0d:	0f b6 00             	movzbl (%rax),%eax
  800420ba10:	0f b6 d0             	movzbl %al,%edx
  800420ba13:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ba17:	0f b6 00             	movzbl (%rax),%eax
  800420ba1a:	0f b6 c0             	movzbl %al,%eax
  800420ba1d:	29 c2                	sub    %eax,%edx
  800420ba1f:	89 d0                	mov    %edx,%eax
}
  800420ba21:	c9                   	leaveq 
  800420ba22:	c3                   	retq   

000000800420ba23 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  800420ba23:	55                   	push   %rbp
  800420ba24:	48 89 e5             	mov    %rsp,%rbp
  800420ba27:	48 83 ec 0c          	sub    $0xc,%rsp
  800420ba2b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ba2f:	89 f0                	mov    %esi,%eax
  800420ba31:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420ba34:	eb 17                	jmp    800420ba4d <strchr+0x2a>
		if (*s == c)
  800420ba36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ba3a:	0f b6 00             	movzbl (%rax),%eax
  800420ba3d:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420ba40:	75 06                	jne    800420ba48 <strchr+0x25>
			return (char *) s;
  800420ba42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ba46:	eb 15                	jmp    800420ba5d <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  800420ba48:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420ba4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ba51:	0f b6 00             	movzbl (%rax),%eax
  800420ba54:	84 c0                	test   %al,%al
  800420ba56:	75 de                	jne    800420ba36 <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  800420ba58:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420ba5d:	c9                   	leaveq 
  800420ba5e:	c3                   	retq   

000000800420ba5f <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  800420ba5f:	55                   	push   %rbp
  800420ba60:	48 89 e5             	mov    %rsp,%rbp
  800420ba63:	48 83 ec 0c          	sub    $0xc,%rsp
  800420ba67:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ba6b:	89 f0                	mov    %esi,%eax
  800420ba6d:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420ba70:	eb 13                	jmp    800420ba85 <strfind+0x26>
		if (*s == c)
  800420ba72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ba76:	0f b6 00             	movzbl (%rax),%eax
  800420ba79:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420ba7c:	75 02                	jne    800420ba80 <strfind+0x21>
			break;
  800420ba7e:	eb 10                	jmp    800420ba90 <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  800420ba80:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420ba85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ba89:	0f b6 00             	movzbl (%rax),%eax
  800420ba8c:	84 c0                	test   %al,%al
  800420ba8e:	75 e2                	jne    800420ba72 <strfind+0x13>
		if (*s == c)
			break;
	return (char *) s;
  800420ba90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ba94:	c9                   	leaveq 
  800420ba95:	c3                   	retq   

000000800420ba96 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  800420ba96:	55                   	push   %rbp
  800420ba97:	48 89 e5             	mov    %rsp,%rbp
  800420ba9a:	48 83 ec 18          	sub    $0x18,%rsp
  800420ba9e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420baa2:	89 75 f4             	mov    %esi,-0xc(%rbp)
  800420baa5:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  800420baa9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420baae:	75 06                	jne    800420bab6 <memset+0x20>
		return v;
  800420bab0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420bab4:	eb 69                	jmp    800420bb1f <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  800420bab6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420baba:	83 e0 03             	and    $0x3,%eax
  800420babd:	48 85 c0             	test   %rax,%rax
  800420bac0:	75 48                	jne    800420bb0a <memset+0x74>
  800420bac2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bac6:	83 e0 03             	and    $0x3,%eax
  800420bac9:	48 85 c0             	test   %rax,%rax
  800420bacc:	75 3c                	jne    800420bb0a <memset+0x74>
		c &= 0xFF;
  800420bace:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  800420bad5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420bad8:	c1 e0 18             	shl    $0x18,%eax
  800420badb:	89 c2                	mov    %eax,%edx
  800420badd:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420bae0:	c1 e0 10             	shl    $0x10,%eax
  800420bae3:	09 c2                	or     %eax,%edx
  800420bae5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420bae8:	c1 e0 08             	shl    $0x8,%eax
  800420baeb:	09 d0                	or     %edx,%eax
  800420baed:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  800420baf0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420baf4:	48 c1 e8 02          	shr    $0x2,%rax
  800420baf8:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  800420bafb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420baff:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420bb02:	48 89 d7             	mov    %rdx,%rdi
  800420bb05:	fc                   	cld    
  800420bb06:	f3 ab                	rep stos %eax,%es:(%rdi)
  800420bb08:	eb 11                	jmp    800420bb1b <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  800420bb0a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420bb0e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420bb11:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420bb15:	48 89 d7             	mov    %rdx,%rdi
  800420bb18:	fc                   	cld    
  800420bb19:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  800420bb1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420bb1f:	c9                   	leaveq 
  800420bb20:	c3                   	retq   

000000800420bb21 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  800420bb21:	55                   	push   %rbp
  800420bb22:	48 89 e5             	mov    %rsp,%rbp
  800420bb25:	48 83 ec 28          	sub    $0x28,%rsp
  800420bb29:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420bb2d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420bb31:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  800420bb35:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420bb39:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  800420bb3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bb41:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  800420bb45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420bb49:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420bb4d:	0f 83 88 00 00 00    	jae    800420bbdb <memmove+0xba>
  800420bb53:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bb57:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420bb5b:	48 01 d0             	add    %rdx,%rax
  800420bb5e:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420bb62:	76 77                	jbe    800420bbdb <memmove+0xba>
		s += n;
  800420bb64:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bb68:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  800420bb6c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bb70:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420bb74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420bb78:	83 e0 03             	and    $0x3,%eax
  800420bb7b:	48 85 c0             	test   %rax,%rax
  800420bb7e:	75 3b                	jne    800420bbbb <memmove+0x9a>
  800420bb80:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bb84:	83 e0 03             	and    $0x3,%eax
  800420bb87:	48 85 c0             	test   %rax,%rax
  800420bb8a:	75 2f                	jne    800420bbbb <memmove+0x9a>
  800420bb8c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bb90:	83 e0 03             	and    $0x3,%eax
  800420bb93:	48 85 c0             	test   %rax,%rax
  800420bb96:	75 23                	jne    800420bbbb <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  800420bb98:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bb9c:	48 83 e8 04          	sub    $0x4,%rax
  800420bba0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420bba4:	48 83 ea 04          	sub    $0x4,%rdx
  800420bba8:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420bbac:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  800420bbb0:	48 89 c7             	mov    %rax,%rdi
  800420bbb3:	48 89 d6             	mov    %rdx,%rsi
  800420bbb6:	fd                   	std    
  800420bbb7:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420bbb9:	eb 1d                	jmp    800420bbd8 <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  800420bbbb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bbbf:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420bbc3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420bbc7:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  800420bbcb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bbcf:	48 89 d7             	mov    %rdx,%rdi
  800420bbd2:	48 89 c1             	mov    %rax,%rcx
  800420bbd5:	fd                   	std    
  800420bbd6:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  800420bbd8:	fc                   	cld    
  800420bbd9:	eb 57                	jmp    800420bc32 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420bbdb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420bbdf:	83 e0 03             	and    $0x3,%eax
  800420bbe2:	48 85 c0             	test   %rax,%rax
  800420bbe5:	75 36                	jne    800420bc1d <memmove+0xfc>
  800420bbe7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bbeb:	83 e0 03             	and    $0x3,%eax
  800420bbee:	48 85 c0             	test   %rax,%rax
  800420bbf1:	75 2a                	jne    800420bc1d <memmove+0xfc>
  800420bbf3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bbf7:	83 e0 03             	and    $0x3,%eax
  800420bbfa:	48 85 c0             	test   %rax,%rax
  800420bbfd:	75 1e                	jne    800420bc1d <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  800420bbff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bc03:	48 c1 e8 02          	shr    $0x2,%rax
  800420bc07:	48 89 c1             	mov    %rax,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  800420bc0a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bc0e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420bc12:	48 89 c7             	mov    %rax,%rdi
  800420bc15:	48 89 d6             	mov    %rdx,%rsi
  800420bc18:	fc                   	cld    
  800420bc19:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420bc1b:	eb 15                	jmp    800420bc32 <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  800420bc1d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bc21:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420bc25:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420bc29:	48 89 c7             	mov    %rax,%rdi
  800420bc2c:	48 89 d6             	mov    %rdx,%rsi
  800420bc2f:	fc                   	cld    
  800420bc30:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  800420bc32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420bc36:	c9                   	leaveq 
  800420bc37:	c3                   	retq   

000000800420bc38 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  800420bc38:	55                   	push   %rbp
  800420bc39:	48 89 e5             	mov    %rsp,%rbp
  800420bc3c:	48 83 ec 18          	sub    $0x18,%rsp
  800420bc40:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420bc44:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420bc48:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  800420bc4c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420bc50:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420bc54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420bc58:	48 89 ce             	mov    %rcx,%rsi
  800420bc5b:	48 89 c7             	mov    %rax,%rdi
  800420bc5e:	48 b8 21 bb 20 04 80 	movabs $0x800420bb21,%rax
  800420bc65:	00 00 00 
  800420bc68:	ff d0                	callq  *%rax
}
  800420bc6a:	c9                   	leaveq 
  800420bc6b:	c3                   	retq   

000000800420bc6c <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  800420bc6c:	55                   	push   %rbp
  800420bc6d:	48 89 e5             	mov    %rsp,%rbp
  800420bc70:	48 83 ec 28          	sub    $0x28,%rsp
  800420bc74:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420bc78:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420bc7c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  800420bc80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bc84:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  800420bc88:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420bc8c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  800420bc90:	eb 36                	jmp    800420bcc8 <memcmp+0x5c>
		if (*s1 != *s2)
  800420bc92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420bc96:	0f b6 10             	movzbl (%rax),%edx
  800420bc99:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bc9d:	0f b6 00             	movzbl (%rax),%eax
  800420bca0:	38 c2                	cmp    %al,%dl
  800420bca2:	74 1a                	je     800420bcbe <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  800420bca4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420bca8:	0f b6 00             	movzbl (%rax),%eax
  800420bcab:	0f b6 d0             	movzbl %al,%edx
  800420bcae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bcb2:	0f b6 00             	movzbl (%rax),%eax
  800420bcb5:	0f b6 c0             	movzbl %al,%eax
  800420bcb8:	29 c2                	sub    %eax,%edx
  800420bcba:	89 d0                	mov    %edx,%eax
  800420bcbc:	eb 20                	jmp    800420bcde <memcmp+0x72>
		s1++, s2++;
  800420bcbe:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420bcc3:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  800420bcc8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bccc:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420bcd0:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420bcd4:	48 85 c0             	test   %rax,%rax
  800420bcd7:	75 b9                	jne    800420bc92 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  800420bcd9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420bcde:	c9                   	leaveq 
  800420bcdf:	c3                   	retq   

000000800420bce0 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  800420bce0:	55                   	push   %rbp
  800420bce1:	48 89 e5             	mov    %rsp,%rbp
  800420bce4:	48 83 ec 28          	sub    $0x28,%rsp
  800420bce8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420bcec:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  800420bcef:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  800420bcf3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bcf7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420bcfb:	48 01 d0             	add    %rdx,%rax
  800420bcfe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  800420bd02:	eb 15                	jmp    800420bd19 <memfind+0x39>
		if (*(const unsigned char *) s == (unsigned char) c)
  800420bd04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bd08:	0f b6 10             	movzbl (%rax),%edx
  800420bd0b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420bd0e:	38 c2                	cmp    %al,%dl
  800420bd10:	75 02                	jne    800420bd14 <memfind+0x34>
			break;
  800420bd12:	eb 0f                	jmp    800420bd23 <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  800420bd14:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420bd19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bd1d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420bd21:	72 e1                	jb     800420bd04 <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
  800420bd23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420bd27:	c9                   	leaveq 
  800420bd28:	c3                   	retq   

000000800420bd29 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  800420bd29:	55                   	push   %rbp
  800420bd2a:	48 89 e5             	mov    %rsp,%rbp
  800420bd2d:	48 83 ec 34          	sub    $0x34,%rsp
  800420bd31:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420bd35:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420bd39:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  800420bd3c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  800420bd43:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420bd4a:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420bd4b:	eb 05                	jmp    800420bd52 <strtol+0x29>
		s++;
  800420bd4d:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420bd52:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bd56:	0f b6 00             	movzbl (%rax),%eax
  800420bd59:	3c 20                	cmp    $0x20,%al
  800420bd5b:	74 f0                	je     800420bd4d <strtol+0x24>
  800420bd5d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bd61:	0f b6 00             	movzbl (%rax),%eax
  800420bd64:	3c 09                	cmp    $0x9,%al
  800420bd66:	74 e5                	je     800420bd4d <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  800420bd68:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bd6c:	0f b6 00             	movzbl (%rax),%eax
  800420bd6f:	3c 2b                	cmp    $0x2b,%al
  800420bd71:	75 07                	jne    800420bd7a <strtol+0x51>
		s++;
  800420bd73:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420bd78:	eb 17                	jmp    800420bd91 <strtol+0x68>
	else if (*s == '-')
  800420bd7a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bd7e:	0f b6 00             	movzbl (%rax),%eax
  800420bd81:	3c 2d                	cmp    $0x2d,%al
  800420bd83:	75 0c                	jne    800420bd91 <strtol+0x68>
		s++, neg = 1;
  800420bd85:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420bd8a:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  800420bd91:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420bd95:	74 06                	je     800420bd9d <strtol+0x74>
  800420bd97:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  800420bd9b:	75 28                	jne    800420bdc5 <strtol+0x9c>
  800420bd9d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bda1:	0f b6 00             	movzbl (%rax),%eax
  800420bda4:	3c 30                	cmp    $0x30,%al
  800420bda6:	75 1d                	jne    800420bdc5 <strtol+0x9c>
  800420bda8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bdac:	48 83 c0 01          	add    $0x1,%rax
  800420bdb0:	0f b6 00             	movzbl (%rax),%eax
  800420bdb3:	3c 78                	cmp    $0x78,%al
  800420bdb5:	75 0e                	jne    800420bdc5 <strtol+0x9c>
		s += 2, base = 16;
  800420bdb7:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  800420bdbc:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  800420bdc3:	eb 2c                	jmp    800420bdf1 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  800420bdc5:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420bdc9:	75 19                	jne    800420bde4 <strtol+0xbb>
  800420bdcb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bdcf:	0f b6 00             	movzbl (%rax),%eax
  800420bdd2:	3c 30                	cmp    $0x30,%al
  800420bdd4:	75 0e                	jne    800420bde4 <strtol+0xbb>
		s++, base = 8;
  800420bdd6:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420bddb:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  800420bde2:	eb 0d                	jmp    800420bdf1 <strtol+0xc8>
	else if (base == 0)
  800420bde4:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420bde8:	75 07                	jne    800420bdf1 <strtol+0xc8>
		base = 10;
  800420bdea:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  800420bdf1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bdf5:	0f b6 00             	movzbl (%rax),%eax
  800420bdf8:	3c 2f                	cmp    $0x2f,%al
  800420bdfa:	7e 1d                	jle    800420be19 <strtol+0xf0>
  800420bdfc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420be00:	0f b6 00             	movzbl (%rax),%eax
  800420be03:	3c 39                	cmp    $0x39,%al
  800420be05:	7f 12                	jg     800420be19 <strtol+0xf0>
			dig = *s - '0';
  800420be07:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420be0b:	0f b6 00             	movzbl (%rax),%eax
  800420be0e:	0f be c0             	movsbl %al,%eax
  800420be11:	83 e8 30             	sub    $0x30,%eax
  800420be14:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420be17:	eb 4e                	jmp    800420be67 <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  800420be19:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420be1d:	0f b6 00             	movzbl (%rax),%eax
  800420be20:	3c 60                	cmp    $0x60,%al
  800420be22:	7e 1d                	jle    800420be41 <strtol+0x118>
  800420be24:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420be28:	0f b6 00             	movzbl (%rax),%eax
  800420be2b:	3c 7a                	cmp    $0x7a,%al
  800420be2d:	7f 12                	jg     800420be41 <strtol+0x118>
			dig = *s - 'a' + 10;
  800420be2f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420be33:	0f b6 00             	movzbl (%rax),%eax
  800420be36:	0f be c0             	movsbl %al,%eax
  800420be39:	83 e8 57             	sub    $0x57,%eax
  800420be3c:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420be3f:	eb 26                	jmp    800420be67 <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  800420be41:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420be45:	0f b6 00             	movzbl (%rax),%eax
  800420be48:	3c 40                	cmp    $0x40,%al
  800420be4a:	7e 48                	jle    800420be94 <strtol+0x16b>
  800420be4c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420be50:	0f b6 00             	movzbl (%rax),%eax
  800420be53:	3c 5a                	cmp    $0x5a,%al
  800420be55:	7f 3d                	jg     800420be94 <strtol+0x16b>
			dig = *s - 'A' + 10;
  800420be57:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420be5b:	0f b6 00             	movzbl (%rax),%eax
  800420be5e:	0f be c0             	movsbl %al,%eax
  800420be61:	83 e8 37             	sub    $0x37,%eax
  800420be64:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  800420be67:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420be6a:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  800420be6d:	7c 02                	jl     800420be71 <strtol+0x148>
			break;
  800420be6f:	eb 23                	jmp    800420be94 <strtol+0x16b>
		s++, val = (val * base) + dig;
  800420be71:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420be76:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420be79:	48 98                	cltq   
  800420be7b:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  800420be80:	48 89 c2             	mov    %rax,%rdx
  800420be83:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420be86:	48 98                	cltq   
  800420be88:	48 01 d0             	add    %rdx,%rax
  800420be8b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  800420be8f:	e9 5d ff ff ff       	jmpq   800420bdf1 <strtol+0xc8>

	if (endptr)
  800420be94:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420be99:	74 0b                	je     800420bea6 <strtol+0x17d>
		*endptr = (char *) s;
  800420be9b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420be9f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420bea3:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  800420bea6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420beaa:	74 09                	je     800420beb5 <strtol+0x18c>
  800420beac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420beb0:	48 f7 d8             	neg    %rax
  800420beb3:	eb 04                	jmp    800420beb9 <strtol+0x190>
  800420beb5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420beb9:	c9                   	leaveq 
  800420beba:	c3                   	retq   

000000800420bebb <strstr>:

char * strstr(const char *in, const char *str)
{
  800420bebb:	55                   	push   %rbp
  800420bebc:	48 89 e5             	mov    %rsp,%rbp
  800420bebf:	48 83 ec 30          	sub    $0x30,%rsp
  800420bec3:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420bec7:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  800420becb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420becf:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420bed3:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420bed7:	0f b6 00             	movzbl (%rax),%eax
  800420beda:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  800420bedd:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800420bee1:	75 06                	jne    800420bee9 <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  800420bee3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bee7:	eb 6b                	jmp    800420bf54 <strstr+0x99>

	len = strlen(str);
  800420bee9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420beed:	48 89 c7             	mov    %rax,%rdi
  800420bef0:	48 b8 91 b7 20 04 80 	movabs $0x800420b791,%rax
  800420bef7:	00 00 00 
  800420befa:	ff d0                	callq  *%rax
  800420befc:	48 98                	cltq   
  800420befe:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  800420bf02:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bf06:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420bf0a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420bf0e:	0f b6 00             	movzbl (%rax),%eax
  800420bf11:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  800420bf14:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800420bf18:	75 07                	jne    800420bf21 <strstr+0x66>
				return (char *) 0;
  800420bf1a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bf1f:	eb 33                	jmp    800420bf54 <strstr+0x99>
		} while (sc != c);
  800420bf21:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800420bf25:	3a 45 ff             	cmp    -0x1(%rbp),%al
  800420bf28:	75 d8                	jne    800420bf02 <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  800420bf2a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420bf2e:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420bf32:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bf36:	48 89 ce             	mov    %rcx,%rsi
  800420bf39:	48 89 c7             	mov    %rax,%rdi
  800420bf3c:	48 b8 b2 b9 20 04 80 	movabs $0x800420b9b2,%rax
  800420bf43:	00 00 00 
  800420bf46:	ff d0                	callq  *%rax
  800420bf48:	85 c0                	test   %eax,%eax
  800420bf4a:	75 b6                	jne    800420bf02 <strstr+0x47>

	return (char *) (in - 1);
  800420bf4c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bf50:	48 83 e8 01          	sub    $0x1,%rax
}
  800420bf54:	c9                   	leaveq 
  800420bf55:	c3                   	retq   

000000800420bf56 <_dwarf_read_lsb>:
Dwarf_Section *
_dwarf_find_section(const char *name);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420bf56:	55                   	push   %rbp
  800420bf57:	48 89 e5             	mov    %rsp,%rbp
  800420bf5a:	48 83 ec 24          	sub    $0x24,%rsp
  800420bf5e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420bf62:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420bf66:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420bf69:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420bf6d:	48 8b 10             	mov    (%rax),%rdx
  800420bf70:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf74:	48 01 d0             	add    %rdx,%rax
  800420bf77:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420bf7b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420bf82:	00 
	switch (bytes_to_read) {
  800420bf83:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420bf86:	83 f8 02             	cmp    $0x2,%eax
  800420bf89:	0f 84 ab 00 00 00    	je     800420c03a <_dwarf_read_lsb+0xe4>
  800420bf8f:	83 f8 02             	cmp    $0x2,%eax
  800420bf92:	7f 0e                	jg     800420bfa2 <_dwarf_read_lsb+0x4c>
  800420bf94:	83 f8 01             	cmp    $0x1,%eax
  800420bf97:	0f 84 b3 00 00 00    	je     800420c050 <_dwarf_read_lsb+0xfa>
  800420bf9d:	e9 d9 00 00 00       	jmpq   800420c07b <_dwarf_read_lsb+0x125>
  800420bfa2:	83 f8 04             	cmp    $0x4,%eax
  800420bfa5:	74 65                	je     800420c00c <_dwarf_read_lsb+0xb6>
  800420bfa7:	83 f8 08             	cmp    $0x8,%eax
  800420bfaa:	0f 85 cb 00 00 00    	jne    800420c07b <_dwarf_read_lsb+0x125>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420bfb0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bfb4:	48 83 c0 04          	add    $0x4,%rax
  800420bfb8:	0f b6 00             	movzbl (%rax),%eax
  800420bfbb:	0f b6 c0             	movzbl %al,%eax
  800420bfbe:	48 c1 e0 20          	shl    $0x20,%rax
  800420bfc2:	48 89 c2             	mov    %rax,%rdx
  800420bfc5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bfc9:	48 83 c0 05          	add    $0x5,%rax
  800420bfcd:	0f b6 00             	movzbl (%rax),%eax
  800420bfd0:	0f b6 c0             	movzbl %al,%eax
  800420bfd3:	48 c1 e0 28          	shl    $0x28,%rax
  800420bfd7:	48 09 d0             	or     %rdx,%rax
  800420bfda:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420bfde:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bfe2:	48 83 c0 06          	add    $0x6,%rax
  800420bfe6:	0f b6 00             	movzbl (%rax),%eax
  800420bfe9:	0f b6 c0             	movzbl %al,%eax
  800420bfec:	48 c1 e0 30          	shl    $0x30,%rax
  800420bff0:	48 89 c2             	mov    %rax,%rdx
  800420bff3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bff7:	48 83 c0 07          	add    $0x7,%rax
  800420bffb:	0f b6 00             	movzbl (%rax),%eax
  800420bffe:	0f b6 c0             	movzbl %al,%eax
  800420c001:	48 c1 e0 38          	shl    $0x38,%rax
  800420c005:	48 09 d0             	or     %rdx,%rax
  800420c008:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420c00c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c010:	48 83 c0 02          	add    $0x2,%rax
  800420c014:	0f b6 00             	movzbl (%rax),%eax
  800420c017:	0f b6 c0             	movzbl %al,%eax
  800420c01a:	48 c1 e0 10          	shl    $0x10,%rax
  800420c01e:	48 89 c2             	mov    %rax,%rdx
  800420c021:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c025:	48 83 c0 03          	add    $0x3,%rax
  800420c029:	0f b6 00             	movzbl (%rax),%eax
  800420c02c:	0f b6 c0             	movzbl %al,%eax
  800420c02f:	48 c1 e0 18          	shl    $0x18,%rax
  800420c033:	48 09 d0             	or     %rdx,%rax
  800420c036:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420c03a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c03e:	48 83 c0 01          	add    $0x1,%rax
  800420c042:	0f b6 00             	movzbl (%rax),%eax
  800420c045:	0f b6 c0             	movzbl %al,%eax
  800420c048:	48 c1 e0 08          	shl    $0x8,%rax
  800420c04c:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420c050:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c054:	0f b6 00             	movzbl (%rax),%eax
  800420c057:	0f b6 c0             	movzbl %al,%eax
  800420c05a:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420c05e:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  800420c05f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c063:	48 8b 10             	mov    (%rax),%rdx
  800420c066:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420c069:	48 98                	cltq   
  800420c06b:	48 01 c2             	add    %rax,%rdx
  800420c06e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c072:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420c075:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c079:	eb 05                	jmp    800420c080 <_dwarf_read_lsb+0x12a>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420c07b:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*offsetp += bytes_to_read;

	return (ret);
}
  800420c080:	c9                   	leaveq 
  800420c081:	c3                   	retq   

000000800420c082 <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  800420c082:	55                   	push   %rbp
  800420c083:	48 89 e5             	mov    %rsp,%rbp
  800420c086:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420c08a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c08e:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420c091:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c095:	48 8b 00             	mov    (%rax),%rax
  800420c098:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420c09c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420c0a3:	00 
	switch (bytes_to_read) {
  800420c0a4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420c0a7:	83 f8 02             	cmp    $0x2,%eax
  800420c0aa:	0f 84 ab 00 00 00    	je     800420c15b <_dwarf_decode_lsb+0xd9>
  800420c0b0:	83 f8 02             	cmp    $0x2,%eax
  800420c0b3:	7f 0e                	jg     800420c0c3 <_dwarf_decode_lsb+0x41>
  800420c0b5:	83 f8 01             	cmp    $0x1,%eax
  800420c0b8:	0f 84 b3 00 00 00    	je     800420c171 <_dwarf_decode_lsb+0xef>
  800420c0be:	e9 d9 00 00 00       	jmpq   800420c19c <_dwarf_decode_lsb+0x11a>
  800420c0c3:	83 f8 04             	cmp    $0x4,%eax
  800420c0c6:	74 65                	je     800420c12d <_dwarf_decode_lsb+0xab>
  800420c0c8:	83 f8 08             	cmp    $0x8,%eax
  800420c0cb:	0f 85 cb 00 00 00    	jne    800420c19c <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420c0d1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c0d5:	48 83 c0 04          	add    $0x4,%rax
  800420c0d9:	0f b6 00             	movzbl (%rax),%eax
  800420c0dc:	0f b6 c0             	movzbl %al,%eax
  800420c0df:	48 c1 e0 20          	shl    $0x20,%rax
  800420c0e3:	48 89 c2             	mov    %rax,%rdx
  800420c0e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c0ea:	48 83 c0 05          	add    $0x5,%rax
  800420c0ee:	0f b6 00             	movzbl (%rax),%eax
  800420c0f1:	0f b6 c0             	movzbl %al,%eax
  800420c0f4:	48 c1 e0 28          	shl    $0x28,%rax
  800420c0f8:	48 09 d0             	or     %rdx,%rax
  800420c0fb:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420c0ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c103:	48 83 c0 06          	add    $0x6,%rax
  800420c107:	0f b6 00             	movzbl (%rax),%eax
  800420c10a:	0f b6 c0             	movzbl %al,%eax
  800420c10d:	48 c1 e0 30          	shl    $0x30,%rax
  800420c111:	48 89 c2             	mov    %rax,%rdx
  800420c114:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c118:	48 83 c0 07          	add    $0x7,%rax
  800420c11c:	0f b6 00             	movzbl (%rax),%eax
  800420c11f:	0f b6 c0             	movzbl %al,%eax
  800420c122:	48 c1 e0 38          	shl    $0x38,%rax
  800420c126:	48 09 d0             	or     %rdx,%rax
  800420c129:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420c12d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c131:	48 83 c0 02          	add    $0x2,%rax
  800420c135:	0f b6 00             	movzbl (%rax),%eax
  800420c138:	0f b6 c0             	movzbl %al,%eax
  800420c13b:	48 c1 e0 10          	shl    $0x10,%rax
  800420c13f:	48 89 c2             	mov    %rax,%rdx
  800420c142:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c146:	48 83 c0 03          	add    $0x3,%rax
  800420c14a:	0f b6 00             	movzbl (%rax),%eax
  800420c14d:	0f b6 c0             	movzbl %al,%eax
  800420c150:	48 c1 e0 18          	shl    $0x18,%rax
  800420c154:	48 09 d0             	or     %rdx,%rax
  800420c157:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420c15b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c15f:	48 83 c0 01          	add    $0x1,%rax
  800420c163:	0f b6 00             	movzbl (%rax),%eax
  800420c166:	0f b6 c0             	movzbl %al,%eax
  800420c169:	48 c1 e0 08          	shl    $0x8,%rax
  800420c16d:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420c171:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c175:	0f b6 00             	movzbl (%rax),%eax
  800420c178:	0f b6 c0             	movzbl %al,%eax
  800420c17b:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420c17f:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  800420c180:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c184:	48 8b 10             	mov    (%rax),%rdx
  800420c187:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420c18a:	48 98                	cltq   
  800420c18c:	48 01 c2             	add    %rax,%rdx
  800420c18f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c193:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420c196:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c19a:	eb 05                	jmp    800420c1a1 <_dwarf_decode_lsb+0x11f>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420c19c:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*data += bytes_to_read;

	return (ret);
}
  800420c1a1:	c9                   	leaveq 
  800420c1a2:	c3                   	retq   

000000800420c1a3 <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420c1a3:	55                   	push   %rbp
  800420c1a4:	48 89 e5             	mov    %rsp,%rbp
  800420c1a7:	48 83 ec 24          	sub    $0x24,%rsp
  800420c1ab:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c1af:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420c1b3:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420c1b6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c1ba:	48 8b 10             	mov    (%rax),%rdx
  800420c1bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c1c1:	48 01 d0             	add    %rdx,%rax
  800420c1c4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  800420c1c8:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420c1cb:	83 f8 02             	cmp    $0x2,%eax
  800420c1ce:	74 35                	je     800420c205 <_dwarf_read_msb+0x62>
  800420c1d0:	83 f8 02             	cmp    $0x2,%eax
  800420c1d3:	7f 0a                	jg     800420c1df <_dwarf_read_msb+0x3c>
  800420c1d5:	83 f8 01             	cmp    $0x1,%eax
  800420c1d8:	74 18                	je     800420c1f2 <_dwarf_read_msb+0x4f>
  800420c1da:	e9 53 01 00 00       	jmpq   800420c332 <_dwarf_read_msb+0x18f>
  800420c1df:	83 f8 04             	cmp    $0x4,%eax
  800420c1e2:	74 49                	je     800420c22d <_dwarf_read_msb+0x8a>
  800420c1e4:	83 f8 08             	cmp    $0x8,%eax
  800420c1e7:	0f 84 96 00 00 00    	je     800420c283 <_dwarf_read_msb+0xe0>
  800420c1ed:	e9 40 01 00 00       	jmpq   800420c332 <_dwarf_read_msb+0x18f>
	case 1:
		ret = src[0];
  800420c1f2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c1f6:	0f b6 00             	movzbl (%rax),%eax
  800420c1f9:	0f b6 c0             	movzbl %al,%eax
  800420c1fc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420c200:	e9 34 01 00 00       	jmpq   800420c339 <_dwarf_read_msb+0x196>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800420c205:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c209:	48 83 c0 01          	add    $0x1,%rax
  800420c20d:	0f b6 00             	movzbl (%rax),%eax
  800420c210:	0f b6 d0             	movzbl %al,%edx
  800420c213:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c217:	0f b6 00             	movzbl (%rax),%eax
  800420c21a:	0f b6 c0             	movzbl %al,%eax
  800420c21d:	48 c1 e0 08          	shl    $0x8,%rax
  800420c221:	48 09 d0             	or     %rdx,%rax
  800420c224:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420c228:	e9 0c 01 00 00       	jmpq   800420c339 <_dwarf_read_msb+0x196>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800420c22d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c231:	48 83 c0 03          	add    $0x3,%rax
  800420c235:	0f b6 00             	movzbl (%rax),%eax
  800420c238:	0f b6 c0             	movzbl %al,%eax
  800420c23b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c23f:	48 83 c2 02          	add    $0x2,%rdx
  800420c243:	0f b6 12             	movzbl (%rdx),%edx
  800420c246:	0f b6 d2             	movzbl %dl,%edx
  800420c249:	48 c1 e2 08          	shl    $0x8,%rdx
  800420c24d:	48 09 d0             	or     %rdx,%rax
  800420c250:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800420c254:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c258:	48 83 c0 01          	add    $0x1,%rax
  800420c25c:	0f b6 00             	movzbl (%rax),%eax
  800420c25f:	0f b6 c0             	movzbl %al,%eax
  800420c262:	48 c1 e0 10          	shl    $0x10,%rax
  800420c266:	48 89 c2             	mov    %rax,%rdx
  800420c269:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c26d:	0f b6 00             	movzbl (%rax),%eax
  800420c270:	0f b6 c0             	movzbl %al,%eax
  800420c273:	48 c1 e0 18          	shl    $0x18,%rax
  800420c277:	48 09 d0             	or     %rdx,%rax
  800420c27a:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420c27e:	e9 b6 00 00 00       	jmpq   800420c339 <_dwarf_read_msb+0x196>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800420c283:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c287:	48 83 c0 07          	add    $0x7,%rax
  800420c28b:	0f b6 00             	movzbl (%rax),%eax
  800420c28e:	0f b6 c0             	movzbl %al,%eax
  800420c291:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c295:	48 83 c2 06          	add    $0x6,%rdx
  800420c299:	0f b6 12             	movzbl (%rdx),%edx
  800420c29c:	0f b6 d2             	movzbl %dl,%edx
  800420c29f:	48 c1 e2 08          	shl    $0x8,%rdx
  800420c2a3:	48 09 d0             	or     %rdx,%rax
  800420c2a6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800420c2aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c2ae:	48 83 c0 05          	add    $0x5,%rax
  800420c2b2:	0f b6 00             	movzbl (%rax),%eax
  800420c2b5:	0f b6 c0             	movzbl %al,%eax
  800420c2b8:	48 c1 e0 10          	shl    $0x10,%rax
  800420c2bc:	48 89 c2             	mov    %rax,%rdx
  800420c2bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c2c3:	48 83 c0 04          	add    $0x4,%rax
  800420c2c7:	0f b6 00             	movzbl (%rax),%eax
  800420c2ca:	0f b6 c0             	movzbl %al,%eax
  800420c2cd:	48 c1 e0 18          	shl    $0x18,%rax
  800420c2d1:	48 09 d0             	or     %rdx,%rax
  800420c2d4:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800420c2d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c2dc:	48 83 c0 03          	add    $0x3,%rax
  800420c2e0:	0f b6 00             	movzbl (%rax),%eax
  800420c2e3:	0f b6 c0             	movzbl %al,%eax
  800420c2e6:	48 c1 e0 20          	shl    $0x20,%rax
  800420c2ea:	48 89 c2             	mov    %rax,%rdx
  800420c2ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c2f1:	48 83 c0 02          	add    $0x2,%rax
  800420c2f5:	0f b6 00             	movzbl (%rax),%eax
  800420c2f8:	0f b6 c0             	movzbl %al,%eax
  800420c2fb:	48 c1 e0 28          	shl    $0x28,%rax
  800420c2ff:	48 09 d0             	or     %rdx,%rax
  800420c302:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800420c306:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c30a:	48 83 c0 01          	add    $0x1,%rax
  800420c30e:	0f b6 00             	movzbl (%rax),%eax
  800420c311:	0f b6 c0             	movzbl %al,%eax
  800420c314:	48 c1 e0 30          	shl    $0x30,%rax
  800420c318:	48 89 c2             	mov    %rax,%rdx
  800420c31b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c31f:	0f b6 00             	movzbl (%rax),%eax
  800420c322:	0f b6 c0             	movzbl %al,%eax
  800420c325:	48 c1 e0 38          	shl    $0x38,%rax
  800420c329:	48 09 d0             	or     %rdx,%rax
  800420c32c:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420c330:	eb 07                	jmp    800420c339 <_dwarf_read_msb+0x196>
	default:
		return (0);
  800420c332:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c337:	eb 1a                	jmp    800420c353 <_dwarf_read_msb+0x1b0>
	}

	*offsetp += bytes_to_read;
  800420c339:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c33d:	48 8b 10             	mov    (%rax),%rdx
  800420c340:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420c343:	48 98                	cltq   
  800420c345:	48 01 c2             	add    %rax,%rdx
  800420c348:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c34c:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420c34f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420c353:	c9                   	leaveq 
  800420c354:	c3                   	retq   

000000800420c355 <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  800420c355:	55                   	push   %rbp
  800420c356:	48 89 e5             	mov    %rsp,%rbp
  800420c359:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420c35d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c361:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420c364:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c368:	48 8b 00             	mov    (%rax),%rax
  800420c36b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420c36f:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420c376:	00 
	switch (bytes_to_read) {
  800420c377:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420c37a:	83 f8 02             	cmp    $0x2,%eax
  800420c37d:	74 35                	je     800420c3b4 <_dwarf_decode_msb+0x5f>
  800420c37f:	83 f8 02             	cmp    $0x2,%eax
  800420c382:	7f 0a                	jg     800420c38e <_dwarf_decode_msb+0x39>
  800420c384:	83 f8 01             	cmp    $0x1,%eax
  800420c387:	74 18                	je     800420c3a1 <_dwarf_decode_msb+0x4c>
  800420c389:	e9 53 01 00 00       	jmpq   800420c4e1 <_dwarf_decode_msb+0x18c>
  800420c38e:	83 f8 04             	cmp    $0x4,%eax
  800420c391:	74 49                	je     800420c3dc <_dwarf_decode_msb+0x87>
  800420c393:	83 f8 08             	cmp    $0x8,%eax
  800420c396:	0f 84 96 00 00 00    	je     800420c432 <_dwarf_decode_msb+0xdd>
  800420c39c:	e9 40 01 00 00       	jmpq   800420c4e1 <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  800420c3a1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c3a5:	0f b6 00             	movzbl (%rax),%eax
  800420c3a8:	0f b6 c0             	movzbl %al,%eax
  800420c3ab:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420c3af:	e9 34 01 00 00       	jmpq   800420c4e8 <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800420c3b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c3b8:	48 83 c0 01          	add    $0x1,%rax
  800420c3bc:	0f b6 00             	movzbl (%rax),%eax
  800420c3bf:	0f b6 d0             	movzbl %al,%edx
  800420c3c2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c3c6:	0f b6 00             	movzbl (%rax),%eax
  800420c3c9:	0f b6 c0             	movzbl %al,%eax
  800420c3cc:	48 c1 e0 08          	shl    $0x8,%rax
  800420c3d0:	48 09 d0             	or     %rdx,%rax
  800420c3d3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420c3d7:	e9 0c 01 00 00       	jmpq   800420c4e8 <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800420c3dc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c3e0:	48 83 c0 03          	add    $0x3,%rax
  800420c3e4:	0f b6 00             	movzbl (%rax),%eax
  800420c3e7:	0f b6 c0             	movzbl %al,%eax
  800420c3ea:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c3ee:	48 83 c2 02          	add    $0x2,%rdx
  800420c3f2:	0f b6 12             	movzbl (%rdx),%edx
  800420c3f5:	0f b6 d2             	movzbl %dl,%edx
  800420c3f8:	48 c1 e2 08          	shl    $0x8,%rdx
  800420c3fc:	48 09 d0             	or     %rdx,%rax
  800420c3ff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800420c403:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c407:	48 83 c0 01          	add    $0x1,%rax
  800420c40b:	0f b6 00             	movzbl (%rax),%eax
  800420c40e:	0f b6 c0             	movzbl %al,%eax
  800420c411:	48 c1 e0 10          	shl    $0x10,%rax
  800420c415:	48 89 c2             	mov    %rax,%rdx
  800420c418:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c41c:	0f b6 00             	movzbl (%rax),%eax
  800420c41f:	0f b6 c0             	movzbl %al,%eax
  800420c422:	48 c1 e0 18          	shl    $0x18,%rax
  800420c426:	48 09 d0             	or     %rdx,%rax
  800420c429:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420c42d:	e9 b6 00 00 00       	jmpq   800420c4e8 <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800420c432:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c436:	48 83 c0 07          	add    $0x7,%rax
  800420c43a:	0f b6 00             	movzbl (%rax),%eax
  800420c43d:	0f b6 c0             	movzbl %al,%eax
  800420c440:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c444:	48 83 c2 06          	add    $0x6,%rdx
  800420c448:	0f b6 12             	movzbl (%rdx),%edx
  800420c44b:	0f b6 d2             	movzbl %dl,%edx
  800420c44e:	48 c1 e2 08          	shl    $0x8,%rdx
  800420c452:	48 09 d0             	or     %rdx,%rax
  800420c455:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800420c459:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c45d:	48 83 c0 05          	add    $0x5,%rax
  800420c461:	0f b6 00             	movzbl (%rax),%eax
  800420c464:	0f b6 c0             	movzbl %al,%eax
  800420c467:	48 c1 e0 10          	shl    $0x10,%rax
  800420c46b:	48 89 c2             	mov    %rax,%rdx
  800420c46e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c472:	48 83 c0 04          	add    $0x4,%rax
  800420c476:	0f b6 00             	movzbl (%rax),%eax
  800420c479:	0f b6 c0             	movzbl %al,%eax
  800420c47c:	48 c1 e0 18          	shl    $0x18,%rax
  800420c480:	48 09 d0             	or     %rdx,%rax
  800420c483:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800420c487:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c48b:	48 83 c0 03          	add    $0x3,%rax
  800420c48f:	0f b6 00             	movzbl (%rax),%eax
  800420c492:	0f b6 c0             	movzbl %al,%eax
  800420c495:	48 c1 e0 20          	shl    $0x20,%rax
  800420c499:	48 89 c2             	mov    %rax,%rdx
  800420c49c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c4a0:	48 83 c0 02          	add    $0x2,%rax
  800420c4a4:	0f b6 00             	movzbl (%rax),%eax
  800420c4a7:	0f b6 c0             	movzbl %al,%eax
  800420c4aa:	48 c1 e0 28          	shl    $0x28,%rax
  800420c4ae:	48 09 d0             	or     %rdx,%rax
  800420c4b1:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800420c4b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c4b9:	48 83 c0 01          	add    $0x1,%rax
  800420c4bd:	0f b6 00             	movzbl (%rax),%eax
  800420c4c0:	0f b6 c0             	movzbl %al,%eax
  800420c4c3:	48 c1 e0 30          	shl    $0x30,%rax
  800420c4c7:	48 89 c2             	mov    %rax,%rdx
  800420c4ca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c4ce:	0f b6 00             	movzbl (%rax),%eax
  800420c4d1:	0f b6 c0             	movzbl %al,%eax
  800420c4d4:	48 c1 e0 38          	shl    $0x38,%rax
  800420c4d8:	48 09 d0             	or     %rdx,%rax
  800420c4db:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420c4df:	eb 07                	jmp    800420c4e8 <_dwarf_decode_msb+0x193>
	default:
		return (0);
  800420c4e1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c4e6:	eb 1a                	jmp    800420c502 <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  800420c4e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c4ec:	48 8b 10             	mov    (%rax),%rdx
  800420c4ef:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420c4f2:	48 98                	cltq   
  800420c4f4:	48 01 c2             	add    %rax,%rdx
  800420c4f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c4fb:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420c4fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420c502:	c9                   	leaveq 
  800420c503:	c3                   	retq   

000000800420c504 <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  800420c504:	55                   	push   %rbp
  800420c505:	48 89 e5             	mov    %rsp,%rbp
  800420c508:	48 83 ec 30          	sub    $0x30,%rsp
  800420c50c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420c510:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int64_t ret = 0;
  800420c514:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420c51b:	00 
	uint8_t b;
	int shift = 0;
  800420c51c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800420c523:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c527:	48 8b 10             	mov    (%rax),%rdx
  800420c52a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c52e:	48 01 d0             	add    %rdx,%rax
  800420c531:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420c535:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c539:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420c53d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420c541:	0f b6 00             	movzbl (%rax),%eax
  800420c544:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420c547:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420c54b:	83 e0 7f             	and    $0x7f,%eax
  800420c54e:	89 c2                	mov    %eax,%edx
  800420c550:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420c553:	89 c1                	mov    %eax,%ecx
  800420c555:	d3 e2                	shl    %cl,%edx
  800420c557:	89 d0                	mov    %edx,%eax
  800420c559:	48 98                	cltq   
  800420c55b:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800420c55f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c563:	48 8b 00             	mov    (%rax),%rax
  800420c566:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420c56a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c56e:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800420c571:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420c575:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420c579:	84 c0                	test   %al,%al
  800420c57b:	78 b8                	js     800420c535 <_dwarf_read_sleb128+0x31>

	if (shift < 32 && (b & 0x40) != 0)
  800420c57d:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420c581:	7f 1f                	jg     800420c5a2 <_dwarf_read_sleb128+0x9e>
  800420c583:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420c587:	83 e0 40             	and    $0x40,%eax
  800420c58a:	85 c0                	test   %eax,%eax
  800420c58c:	74 14                	je     800420c5a2 <_dwarf_read_sleb128+0x9e>
		ret |= (-1 << shift);
  800420c58e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420c591:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800420c596:	89 c1                	mov    %eax,%ecx
  800420c598:	d3 e2                	shl    %cl,%edx
  800420c59a:	89 d0                	mov    %edx,%eax
  800420c59c:	48 98                	cltq   
  800420c59e:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	return (ret);
  800420c5a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420c5a6:	c9                   	leaveq 
  800420c5a7:	c3                   	retq   

000000800420c5a8 <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  800420c5a8:	55                   	push   %rbp
  800420c5a9:	48 89 e5             	mov    %rsp,%rbp
  800420c5ac:	48 83 ec 30          	sub    $0x30,%rsp
  800420c5b0:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420c5b4:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t ret = 0;
  800420c5b8:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420c5bf:	00 
	uint8_t b;
	int shift = 0;
  800420c5c0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800420c5c7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c5cb:	48 8b 10             	mov    (%rax),%rdx
  800420c5ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c5d2:	48 01 d0             	add    %rdx,%rax
  800420c5d5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420c5d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c5dd:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420c5e1:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420c5e5:	0f b6 00             	movzbl (%rax),%eax
  800420c5e8:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420c5eb:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420c5ef:	83 e0 7f             	and    $0x7f,%eax
  800420c5f2:	89 c2                	mov    %eax,%edx
  800420c5f4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420c5f7:	89 c1                	mov    %eax,%ecx
  800420c5f9:	d3 e2                	shl    %cl,%edx
  800420c5fb:	89 d0                	mov    %edx,%eax
  800420c5fd:	48 98                	cltq   
  800420c5ff:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800420c603:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c607:	48 8b 00             	mov    (%rax),%rax
  800420c60a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420c60e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c612:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800420c615:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420c619:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420c61d:	84 c0                	test   %al,%al
  800420c61f:	78 b8                	js     800420c5d9 <_dwarf_read_uleb128+0x31>

	return (ret);
  800420c621:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420c625:	c9                   	leaveq 
  800420c626:	c3                   	retq   

000000800420c627 <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  800420c627:	55                   	push   %rbp
  800420c628:	48 89 e5             	mov    %rsp,%rbp
  800420c62b:	48 83 ec 28          	sub    $0x28,%rsp
  800420c62f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int64_t ret = 0;
  800420c633:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420c63a:	00 
	uint8_t b;
	int shift = 0;
  800420c63b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  800420c642:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c646:	48 8b 00             	mov    (%rax),%rax
  800420c649:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420c64d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c651:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420c655:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420c659:	0f b6 00             	movzbl (%rax),%eax
  800420c65c:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420c65f:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420c663:	83 e0 7f             	and    $0x7f,%eax
  800420c666:	89 c2                	mov    %eax,%edx
  800420c668:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420c66b:	89 c1                	mov    %eax,%ecx
  800420c66d:	d3 e2                	shl    %cl,%edx
  800420c66f:	89 d0                	mov    %edx,%eax
  800420c671:	48 98                	cltq   
  800420c673:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  800420c677:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420c67b:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420c67f:	84 c0                	test   %al,%al
  800420c681:	78 ca                	js     800420c64d <_dwarf_decode_sleb128+0x26>

	if (shift < 32 && (b & 0x40) != 0)
  800420c683:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420c687:	7f 1f                	jg     800420c6a8 <_dwarf_decode_sleb128+0x81>
  800420c689:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420c68d:	83 e0 40             	and    $0x40,%eax
  800420c690:	85 c0                	test   %eax,%eax
  800420c692:	74 14                	je     800420c6a8 <_dwarf_decode_sleb128+0x81>
		ret |= (-1 << shift);
  800420c694:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420c697:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800420c69c:	89 c1                	mov    %eax,%ecx
  800420c69e:	d3 e2                	shl    %cl,%edx
  800420c6a0:	89 d0                	mov    %edx,%eax
  800420c6a2:	48 98                	cltq   
  800420c6a4:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	*dp = src;
  800420c6a8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c6ac:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420c6b0:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420c6b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420c6b7:	c9                   	leaveq 
  800420c6b8:	c3                   	retq   

000000800420c6b9 <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  800420c6b9:	55                   	push   %rbp
  800420c6ba:	48 89 e5             	mov    %rsp,%rbp
  800420c6bd:	48 83 ec 28          	sub    $0x28,%rsp
  800420c6c1:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint64_t ret = 0;
  800420c6c5:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420c6cc:	00 
	uint8_t b;
	int shift = 0;
  800420c6cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  800420c6d4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c6d8:	48 8b 00             	mov    (%rax),%rax
  800420c6db:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420c6df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c6e3:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420c6e7:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420c6eb:	0f b6 00             	movzbl (%rax),%eax
  800420c6ee:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420c6f1:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420c6f5:	83 e0 7f             	and    $0x7f,%eax
  800420c6f8:	89 c2                	mov    %eax,%edx
  800420c6fa:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420c6fd:	89 c1                	mov    %eax,%ecx
  800420c6ff:	d3 e2                	shl    %cl,%edx
  800420c701:	89 d0                	mov    %edx,%eax
  800420c703:	48 98                	cltq   
  800420c705:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  800420c709:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420c70d:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420c711:	84 c0                	test   %al,%al
  800420c713:	78 ca                	js     800420c6df <_dwarf_decode_uleb128+0x26>

	*dp = src;
  800420c715:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c719:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420c71d:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420c720:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420c724:	c9                   	leaveq 
  800420c725:	c3                   	retq   

000000800420c726 <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  800420c726:	55                   	push   %rbp
  800420c727:	48 89 e5             	mov    %rsp,%rbp
  800420c72a:	48 83 ec 28          	sub    $0x28,%rsp
  800420c72e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c732:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420c736:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  800420c73a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c73e:	48 8b 10             	mov    (%rax),%rdx
  800420c741:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c745:	48 01 d0             	add    %rdx,%rax
  800420c748:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420c74c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c750:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  800420c754:	eb 17                	jmp    800420c76d <_dwarf_read_string+0x47>
		src++;
  800420c756:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  800420c75b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c75f:	48 8b 00             	mov    (%rax),%rax
  800420c762:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420c766:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c76a:	48 89 10             	mov    %rdx,(%rax)
{
	char *ret, *src;

	ret = src = (char *) data + *offsetp;

	while (*src != '\0' && *offsetp < size) {
  800420c76d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c771:	0f b6 00             	movzbl (%rax),%eax
  800420c774:	84 c0                	test   %al,%al
  800420c776:	74 0d                	je     800420c785 <_dwarf_read_string+0x5f>
  800420c778:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c77c:	48 8b 00             	mov    (%rax),%rax
  800420c77f:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420c783:	72 d1                	jb     800420c756 <_dwarf_read_string+0x30>
		src++;
		(*offsetp)++;
	}

	if (*src == '\0' && *offsetp < size)
  800420c785:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c789:	0f b6 00             	movzbl (%rax),%eax
  800420c78c:	84 c0                	test   %al,%al
  800420c78e:	75 1f                	jne    800420c7af <_dwarf_read_string+0x89>
  800420c790:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c794:	48 8b 00             	mov    (%rax),%rax
  800420c797:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420c79b:	73 12                	jae    800420c7af <_dwarf_read_string+0x89>
		(*offsetp)++;
  800420c79d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c7a1:	48 8b 00             	mov    (%rax),%rax
  800420c7a4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420c7a8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c7ac:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420c7af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420c7b3:	c9                   	leaveq 
  800420c7b4:	c3                   	retq   

000000800420c7b5 <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  800420c7b5:	55                   	push   %rbp
  800420c7b6:	48 89 e5             	mov    %rsp,%rbp
  800420c7b9:	48 83 ec 28          	sub    $0x28,%rsp
  800420c7bd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c7c1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420c7c5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  800420c7c9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c7cd:	48 8b 10             	mov    (%rax),%rdx
  800420c7d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c7d4:	48 01 d0             	add    %rdx,%rax
  800420c7d7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420c7db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c7df:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  800420c7e3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c7e7:	48 8b 10             	mov    (%rax),%rdx
  800420c7ea:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c7ee:	48 01 c2             	add    %rax,%rdx
  800420c7f1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c7f5:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420c7f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420c7fc:	c9                   	leaveq 
  800420c7fd:	c3                   	retq   

000000800420c7fe <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  800420c7fe:	55                   	push   %rbp
  800420c7ff:	48 89 e5             	mov    %rsp,%rbp
  800420c802:	48 83 ec 20          	sub    $0x20,%rsp
  800420c806:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *)obj;
  800420c80a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c80e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  800420c812:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420c817:	75 35                	jne    800420c84e <_dwarf_elf_get_byte_order+0x50>
  800420c819:	48 b9 80 3c 21 04 80 	movabs $0x8004213c80,%rcx
  800420c820:	00 00 00 
  800420c823:	48 ba 8a 3c 21 04 80 	movabs $0x8004213c8a,%rdx
  800420c82a:	00 00 00 
  800420c82d:	be 29 01 00 00       	mov    $0x129,%esi
  800420c832:	48 bf 9f 3c 21 04 80 	movabs $0x8004213c9f,%rdi
  800420c839:	00 00 00 
  800420c83c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c841:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420c848:	00 00 00 
  800420c84b:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
	switch (e->e_ident[EI_DATA]) {
  800420c84e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c852:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  800420c856:	0f b6 c0             	movzbl %al,%eax
  800420c859:	83 f8 02             	cmp    $0x2,%eax
  800420c85c:	75 07                	jne    800420c865 <_dwarf_elf_get_byte_order+0x67>
	case ELFDATA2MSB:
		return (DW_OBJECT_MSB);
  800420c85e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c863:	eb 05                	jmp    800420c86a <_dwarf_elf_get_byte_order+0x6c>

	case ELFDATA2LSB:
	case ELFDATANONE:
	default:
		return (DW_OBJECT_LSB);
  800420c865:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
  800420c86a:	c9                   	leaveq 
  800420c86b:	c3                   	retq   

000000800420c86c <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  800420c86c:	55                   	push   %rbp
  800420c86d:	48 89 e5             	mov    %rsp,%rbp
  800420c870:	48 83 ec 20          	sub    $0x20,%rsp
  800420c874:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *) obj;
  800420c878:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c87c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  800420c880:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420c885:	75 35                	jne    800420c8bc <_dwarf_elf_get_pointer_size+0x50>
  800420c887:	48 b9 80 3c 21 04 80 	movabs $0x8004213c80,%rcx
  800420c88e:	00 00 00 
  800420c891:	48 ba 8a 3c 21 04 80 	movabs $0x8004213c8a,%rdx
  800420c898:	00 00 00 
  800420c89b:	be 3f 01 00 00       	mov    $0x13f,%esi
  800420c8a0:	48 bf 9f 3c 21 04 80 	movabs $0x8004213c9f,%rdi
  800420c8a7:	00 00 00 
  800420c8aa:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c8af:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420c8b6:	00 00 00 
  800420c8b9:	41 ff d0             	callq  *%r8

	if (e->e_ident[4] == ELFCLASS32)
  800420c8bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c8c0:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  800420c8c4:	3c 01                	cmp    $0x1,%al
  800420c8c6:	75 07                	jne    800420c8cf <_dwarf_elf_get_pointer_size+0x63>
		return (4);
  800420c8c8:	b8 04 00 00 00       	mov    $0x4,%eax
  800420c8cd:	eb 05                	jmp    800420c8d4 <_dwarf_elf_get_pointer_size+0x68>
	else
		return (8);
  800420c8cf:	b8 08 00 00 00       	mov    $0x8,%eax
}
  800420c8d4:	c9                   	leaveq 
  800420c8d5:	c3                   	retq   

000000800420c8d6 <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  800420c8d6:	55                   	push   %rbp
  800420c8d7:	48 89 e5             	mov    %rsp,%rbp
  800420c8da:	53                   	push   %rbx
  800420c8db:	48 83 ec 18          	sub    $0x18,%rsp
  800420c8df:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c8e3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  800420c8e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c8eb:	ba 60 00 00 00       	mov    $0x60,%edx
  800420c8f0:	be 00 00 00 00       	mov    $0x0,%esi
  800420c8f5:	48 89 c7             	mov    %rax,%rdi
  800420c8f8:	48 b8 96 ba 20 04 80 	movabs $0x800420ba96,%rax
  800420c8ff:	00 00 00 
  800420c902:	ff d0                	callq  *%rax
	dbg->curr_off_dbginfo = 0;
  800420c904:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c908:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	dbg->dbg_info_size = 0;
  800420c90f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c913:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800420c91a:	00 
	dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  800420c91b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c91f:	48 89 c7             	mov    %rax,%rdi
  800420c922:	48 b8 6c c8 20 04 80 	movabs $0x800420c86c,%rax
  800420c929:	00 00 00 
  800420c92c:	ff d0                	callq  *%rax
  800420c92e:	0f b6 d0             	movzbl %al,%edx
  800420c931:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c935:	89 50 28             	mov    %edx,0x28(%rax)

	if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  800420c938:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c93c:	48 89 c7             	mov    %rax,%rdi
  800420c93f:	48 b8 fe c7 20 04 80 	movabs $0x800420c7fe,%rax
  800420c946:	00 00 00 
  800420c949:	ff d0                	callq  *%rax
  800420c94b:	85 c0                	test   %eax,%eax
  800420c94d:	75 26                	jne    800420c975 <_dwarf_init+0x9f>
		dbg->read = _dwarf_read_msb;
  800420c94f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c953:	48 b9 a3 c1 20 04 80 	movabs $0x800420c1a3,%rcx
  800420c95a:	00 00 00 
  800420c95d:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_msb;
  800420c961:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c965:	48 bb 55 c3 20 04 80 	movabs $0x800420c355,%rbx
  800420c96c:	00 00 00 
  800420c96f:	48 89 58 20          	mov    %rbx,0x20(%rax)
  800420c973:	eb 24                	jmp    800420c999 <_dwarf_init+0xc3>
	} else {
		dbg->read = _dwarf_read_lsb;
  800420c975:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c979:	48 b9 56 bf 20 04 80 	movabs $0x800420bf56,%rcx
  800420c980:	00 00 00 
  800420c983:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_lsb;
  800420c987:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c98b:	48 be 82 c0 20 04 80 	movabs $0x800420c082,%rsi
  800420c992:	00 00 00 
  800420c995:	48 89 70 20          	mov    %rsi,0x20(%rax)
	}
	_dwarf_frame_params_init(dbg);
  800420c999:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c99d:	48 89 c7             	mov    %rax,%rdi
  800420c9a0:	48 b8 a3 de 20 04 80 	movabs $0x800420dea3,%rax
  800420c9a7:	00 00 00 
  800420c9aa:	ff d0                	callq  *%rax
	return 0;
  800420c9ac:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420c9b1:	48 83 c4 18          	add    $0x18,%rsp
  800420c9b5:	5b                   	pop    %rbx
  800420c9b6:	5d                   	pop    %rbp
  800420c9b7:	c3                   	retq   

000000800420c9b8 <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  800420c9b8:	55                   	push   %rbp
  800420c9b9:	48 89 e5             	mov    %rsp,%rbp
  800420c9bc:	48 83 ec 20          	sub    $0x20,%rsp
  800420c9c0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c9c4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t length;
	uint64_t offset;
	uint8_t dwarf_size;

	if(dbg->curr_off_dbginfo > dbg->dbg_info_size)
  800420c9c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c9cc:	48 8b 10             	mov    (%rax),%rdx
  800420c9cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c9d3:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420c9d7:	48 39 c2             	cmp    %rax,%rdx
  800420c9da:	76 0a                	jbe    800420c9e6 <_get_next_cu+0x2e>
		return -1;
  800420c9dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420c9e1:	e9 6b 01 00 00       	jmpq   800420cb51 <_get_next_cu+0x199>

	offset = dbg->curr_off_dbginfo;
  800420c9e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c9ea:	48 8b 00             	mov    (%rax),%rax
  800420c9ed:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  800420c9f1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c9f5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c9f9:	48 89 50 30          	mov    %rdx,0x30(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  800420c9fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca01:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ca05:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ca09:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420ca0d:	48 89 d1             	mov    %rdx,%rcx
  800420ca10:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420ca14:	ba 04 00 00 00       	mov    $0x4,%edx
  800420ca19:	48 89 cf             	mov    %rcx,%rdi
  800420ca1c:	ff d0                	callq  *%rax
  800420ca1e:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (length == 0xffffffff) {
  800420ca21:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800420ca25:	75 2a                	jne    800420ca51 <_get_next_cu+0x99>
		length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  800420ca27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca2b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ca2f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ca33:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420ca37:	48 89 d1             	mov    %rdx,%rcx
  800420ca3a:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420ca3e:	ba 08 00 00 00       	mov    $0x8,%edx
  800420ca43:	48 89 cf             	mov    %rcx,%rdi
  800420ca46:	ff d0                	callq  *%rax
  800420ca48:	89 45 fc             	mov    %eax,-0x4(%rbp)
		dwarf_size = 8;
  800420ca4b:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  800420ca4f:	eb 04                	jmp    800420ca55 <_get_next_cu+0x9d>
	} else {
		dwarf_size = 4;
  800420ca51:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
	}

	cu->cu_dwarf_size = dwarf_size;
  800420ca55:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ca59:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800420ca5d:	88 50 19             	mov    %dl,0x19(%rax)
	 if (length > ds->ds_size - offset) {
	 return (DW_DLE_CU_LENGTH_ERROR);
	 }*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  800420ca60:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420ca63:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ca67:	48 01 c2             	add    %rax,%rdx
  800420ca6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca6e:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  800420ca71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca75:	48 8b 10             	mov    (%rax),%rdx
  800420ca78:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ca7c:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  800420ca80:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420ca83:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ca87:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  800420ca8a:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  800420ca8e:	75 07                	jne    800420ca97 <_get_next_cu+0xdf>
  800420ca90:	b8 04 00 00 00       	mov    $0x4,%eax
  800420ca95:	eb 05                	jmp    800420ca9c <_get_next_cu+0xe4>
  800420ca97:	b8 0c 00 00 00       	mov    $0xc,%eax
  800420ca9c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420caa0:	88 42 18             	mov    %al,0x18(%rdx)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  800420caa3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420caa7:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420caab:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420caaf:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420cab3:	48 89 d1             	mov    %rdx,%rcx
  800420cab6:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420caba:	ba 02 00 00 00       	mov    $0x2,%edx
  800420cabf:	48 89 cf             	mov    %rcx,%rdi
  800420cac2:	ff d0                	callq  *%rax
  800420cac4:	89 c2                	mov    %eax,%edx
  800420cac6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420caca:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  800420cace:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cad2:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420cad6:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800420cada:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420cade:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  800420cae2:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420cae6:	48 89 cf             	mov    %rcx,%rdi
  800420cae9:	ff d0                	callq  *%rax
  800420caeb:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420caef:	48 89 42 10          	mov    %rax,0x10(%rdx)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  800420caf3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420caf7:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420cafb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420caff:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420cb03:	48 89 d1             	mov    %rdx,%rcx
  800420cb06:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420cb0a:	ba 01 00 00 00       	mov    $0x1,%edx
  800420cb0f:	48 89 cf             	mov    %rcx,%rdi
  800420cb12:	ff d0                	callq  *%rax
  800420cb14:	89 c2                	mov    %eax,%edx
  800420cb16:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cb1a:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  800420cb1d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cb21:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420cb25:	66 83 f8 01          	cmp    $0x1,%ax
  800420cb29:	76 0e                	jbe    800420cb39 <_get_next_cu+0x181>
  800420cb2b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cb2f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420cb33:	66 83 f8 04          	cmp    $0x4,%ax
  800420cb37:	76 07                	jbe    800420cb40 <_get_next_cu+0x188>
		return -1;
  800420cb39:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420cb3e:	eb 11                	jmp    800420cb51 <_get_next_cu+0x199>
	}

	cu->cu_die_offset = offset;
  800420cb40:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420cb44:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cb48:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  800420cb4c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420cb51:	c9                   	leaveq 
  800420cb52:	c3                   	retq   

000000800420cb53 <print_cu>:

void print_cu(Dwarf_CU cu)
{
  800420cb53:	55                   	push   %rbp
  800420cb54:	48 89 e5             	mov    %rsp,%rbp
	cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  800420cb57:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  800420cb5b:	0f b6 c8             	movzbl %al,%ecx
  800420cb5e:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  800420cb62:	0f b7 d0             	movzwl %ax,%edx
  800420cb65:	48 8b 45 10          	mov    0x10(%rbp),%rax
  800420cb69:	48 89 c6             	mov    %rax,%rsi
  800420cb6c:	48 bf b2 3c 21 04 80 	movabs $0x8004213cb2,%rdi
  800420cb73:	00 00 00 
  800420cb76:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cb7b:	49 b8 46 7b 20 04 80 	movabs $0x8004207b46,%r8
  800420cb82:	00 00 00 
  800420cb85:	41 ff d0             	callq  *%r8
}
  800420cb88:	5d                   	pop    %rbp
  800420cb89:	c3                   	retq   

000000800420cb8a <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
		    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  800420cb8a:	55                   	push   %rbp
  800420cb8b:	48 89 e5             	mov    %rsp,%rbp
  800420cb8e:	48 83 ec 60          	sub    $0x60,%rsp
  800420cb92:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800420cb96:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800420cb9a:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  800420cb9e:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
	uint64_t tag;
	uint8_t children;
	uint64_t abbr_addr;
	int ret;

	assert(abp != NULL);
  800420cba2:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  800420cba7:	75 35                	jne    800420cbde <_dwarf_abbrev_parse+0x54>
  800420cba9:	48 b9 c1 3c 21 04 80 	movabs $0x8004213cc1,%rcx
  800420cbb0:	00 00 00 
  800420cbb3:	48 ba 8a 3c 21 04 80 	movabs $0x8004213c8a,%rdx
  800420cbba:	00 00 00 
  800420cbbd:	be a4 01 00 00       	mov    $0x1a4,%esi
  800420cbc2:	48 bf 9f 3c 21 04 80 	movabs $0x8004213c9f,%rdi
  800420cbc9:	00 00 00 
  800420cbcc:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cbd1:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420cbd8:	00 00 00 
  800420cbdb:	41 ff d0             	callq  *%r8
	assert(ds != NULL);
  800420cbde:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  800420cbe3:	75 35                	jne    800420cc1a <_dwarf_abbrev_parse+0x90>
  800420cbe5:	48 b9 cd 3c 21 04 80 	movabs $0x8004213ccd,%rcx
  800420cbec:	00 00 00 
  800420cbef:	48 ba 8a 3c 21 04 80 	movabs $0x8004213c8a,%rdx
  800420cbf6:	00 00 00 
  800420cbf9:	be a5 01 00 00       	mov    $0x1a5,%esi
  800420cbfe:	48 bf 9f 3c 21 04 80 	movabs $0x8004213c9f,%rdi
  800420cc05:	00 00 00 
  800420cc08:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cc0d:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420cc14:	00 00 00 
  800420cc17:	41 ff d0             	callq  *%r8

	if (*offset >= ds->ds_size)
  800420cc1a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420cc1e:	48 8b 10             	mov    (%rax),%rdx
  800420cc21:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420cc25:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420cc29:	48 39 c2             	cmp    %rax,%rdx
  800420cc2c:	72 0a                	jb     800420cc38 <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  800420cc2e:	b8 04 00 00 00       	mov    $0x4,%eax
  800420cc33:	e9 d3 01 00 00       	jmpq   800420ce0b <_dwarf_abbrev_parse+0x281>

	aboff = *offset;
  800420cc38:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420cc3c:	48 8b 00             	mov    (%rax),%rax
  800420cc3f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  800420cc43:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420cc47:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420cc4b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420cc4f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cc53:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420cc57:	48 89 d6             	mov    %rdx,%rsi
  800420cc5a:	48 89 c7             	mov    %rax,%rdi
  800420cc5d:	48 b8 a8 c5 20 04 80 	movabs $0x800420c5a8,%rax
  800420cc64:	00 00 00 
  800420cc67:	ff d0                	callq  *%rax
  800420cc69:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if (entry == 0) {
  800420cc6d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420cc72:	75 15                	jne    800420cc89 <_dwarf_abbrev_parse+0xff>
		/* Last entry. */
		//Need to make connection from below function
		abp->ab_entry = 0;
  800420cc74:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420cc78:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return DW_DLE_NONE;
  800420cc7f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cc84:	e9 82 01 00 00       	jmpq   800420ce0b <_dwarf_abbrev_parse+0x281>
	}

	tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420cc89:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cc8d:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420cc91:	48 89 d6             	mov    %rdx,%rsi
  800420cc94:	48 89 c7             	mov    %rax,%rdi
  800420cc97:	48 b8 a8 c5 20 04 80 	movabs $0x800420c5a8,%rax
  800420cc9e:	00 00 00 
  800420cca1:	ff d0                	callq  *%rax
  800420cca3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  800420cca7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420ccab:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ccaf:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420ccb3:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800420ccb7:	ba 01 00 00 00       	mov    $0x1,%edx
  800420ccbc:	48 89 cf             	mov    %rcx,%rdi
  800420ccbf:	ff d0                	callq  *%rax
  800420ccc1:	88 45 df             	mov    %al,-0x21(%rbp)

	abp->ab_entry    = entry;
  800420ccc4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ccc8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cccc:	48 89 10             	mov    %rdx,(%rax)
	abp->ab_tag      = tag;
  800420cccf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ccd3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420ccd7:	48 89 50 08          	mov    %rdx,0x8(%rax)
	abp->ab_children = children;
  800420ccdb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ccdf:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  800420cce3:	88 50 10             	mov    %dl,0x10(%rax)
	abp->ab_offset   = aboff;
  800420cce6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ccea:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ccee:	48 89 50 18          	mov    %rdx,0x18(%rax)
	abp->ab_length   = 0;    /* fill in later. */
  800420ccf2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ccf6:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  800420ccfd:	00 
	abp->ab_atnum    = 0;
  800420ccfe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420cd02:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  800420cd09:	00 

	/* Parse attribute definitions. */
	do {
		adoff = *offset;
  800420cd0a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420cd0e:	48 8b 00             	mov    (%rax),%rax
  800420cd11:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420cd15:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cd19:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420cd1d:	48 89 d6             	mov    %rdx,%rsi
  800420cd20:	48 89 c7             	mov    %rax,%rdi
  800420cd23:	48 b8 a8 c5 20 04 80 	movabs $0x800420c5a8,%rax
  800420cd2a:	00 00 00 
  800420cd2d:	ff d0                	callq  *%rax
  800420cd2f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420cd33:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cd37:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420cd3b:	48 89 d6             	mov    %rdx,%rsi
  800420cd3e:	48 89 c7             	mov    %rax,%rdi
  800420cd41:	48 b8 a8 c5 20 04 80 	movabs $0x800420c5a8,%rax
  800420cd48:	00 00 00 
  800420cd4b:	ff d0                	callq  *%rax
  800420cd4d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		if (attr != 0)
  800420cd51:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420cd56:	0f 84 89 00 00 00    	je     800420cde5 <_dwarf_abbrev_parse+0x25b>
		{
			/* Initialise the attribute definition structure. */
			abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  800420cd5c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420cd60:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420cd64:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420cd68:	48 89 d0             	mov    %rdx,%rax
  800420cd6b:	48 01 c0             	add    %rax,%rax
  800420cd6e:	48 01 d0             	add    %rdx,%rax
  800420cd71:	48 c1 e0 03          	shl    $0x3,%rax
  800420cd75:	48 01 c8             	add    %rcx,%rax
  800420cd78:	48 8d 50 30          	lea    0x30(%rax),%rdx
  800420cd7c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cd80:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  800420cd83:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420cd87:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420cd8b:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420cd8f:	48 89 d0             	mov    %rdx,%rax
  800420cd92:	48 01 c0             	add    %rax,%rax
  800420cd95:	48 01 d0             	add    %rdx,%rax
  800420cd98:	48 c1 e0 03          	shl    $0x3,%rax
  800420cd9c:	48 01 c8             	add    %rcx,%rax
  800420cd9f:	48 8d 50 38          	lea    0x38(%rax),%rdx
  800420cda3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420cda7:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  800420cdaa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420cdae:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420cdb2:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420cdb6:	48 89 d0             	mov    %rdx,%rax
  800420cdb9:	48 01 c0             	add    %rax,%rax
  800420cdbc:	48 01 d0             	add    %rdx,%rax
  800420cdbf:	48 c1 e0 03          	shl    $0x3,%rax
  800420cdc3:	48 01 c8             	add    %rcx,%rax
  800420cdc6:	48 8d 50 40          	lea    0x40(%rax),%rdx
  800420cdca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420cdce:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_atnum++;
  800420cdd1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420cdd5:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420cdd9:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420cddd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420cde1:	48 89 50 28          	mov    %rdx,0x28(%rax)
		}
	} while (attr != 0);
  800420cde5:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420cdea:	0f 85 1a ff ff ff    	jne    800420cd0a <_dwarf_abbrev_parse+0x180>

	//(*abp)->ab_length = *offset - aboff;
	abp->ab_length = (uint64_t)(*offset - aboff);
  800420cdf0:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420cdf4:	48 8b 00             	mov    (%rax),%rax
  800420cdf7:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  800420cdfb:	48 89 c2             	mov    %rax,%rdx
  800420cdfe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ce02:	48 89 50 20          	mov    %rdx,0x20(%rax)

	return DW_DLV_OK;
  800420ce06:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420ce0b:	c9                   	leaveq 
  800420ce0c:	c3                   	retq   

000000800420ce0d <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  800420ce0d:	55                   	push   %rbp
  800420ce0e:	48 89 e5             	mov    %rsp,%rbp
  800420ce11:	48 83 ec 70          	sub    $0x70,%rsp
  800420ce15:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420ce19:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420ce1d:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	Dwarf_Section *ds;
	uint64_t offset;
	int ret;

	if (entry == 0)
  800420ce21:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420ce26:	75 0a                	jne    800420ce32 <_dwarf_abbrev_find+0x25>
	{
		return (DW_DLE_NO_ENTRY);
  800420ce28:	b8 04 00 00 00       	mov    $0x4,%eax
  800420ce2d:	e9 0a 01 00 00       	jmpq   800420cf3c <_dwarf_abbrev_find+0x12f>
	}

	/* Load and search the abbrev table. */
	ds = _dwarf_find_section(".debug_abbrev");
  800420ce32:	48 bf d8 3c 21 04 80 	movabs $0x8004213cd8,%rdi
  800420ce39:	00 00 00 
  800420ce3c:	48 b8 6d 11 21 04 80 	movabs $0x800421116d,%rax
  800420ce43:	00 00 00 
  800420ce46:	ff d0                	callq  *%rax
  800420ce48:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(ds != NULL);
  800420ce4c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420ce51:	75 35                	jne    800420ce88 <_dwarf_abbrev_find+0x7b>
  800420ce53:	48 b9 cd 3c 21 04 80 	movabs $0x8004213ccd,%rcx
  800420ce5a:	00 00 00 
  800420ce5d:	48 ba 8a 3c 21 04 80 	movabs $0x8004213c8a,%rdx
  800420ce64:	00 00 00 
  800420ce67:	be e5 01 00 00       	mov    $0x1e5,%esi
  800420ce6c:	48 bf 9f 3c 21 04 80 	movabs $0x8004213c9f,%rdi
  800420ce73:	00 00 00 
  800420ce76:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ce7b:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420ce82:	00 00 00 
  800420ce85:	41 ff d0             	callq  *%r8

	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  800420ce88:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420ce8c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	while (offset < ds->ds_size) {
  800420ce90:	e9 8d 00 00 00       	jmpq   800420cf22 <_dwarf_abbrev_find+0x115>
		ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  800420ce95:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420ce99:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420ce9d:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  800420cea1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cea5:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  800420cea9:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420cead:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
  800420ceb1:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420ceb6:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  800420ceba:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420cebf:	48 8b 7d 28          	mov    0x28(%rbp),%rdi
  800420cec3:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420cec8:	48 8b 7d 30          	mov    0x30(%rbp),%rdi
  800420cecc:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420ced1:	48 8b 7d 38          	mov    0x38(%rbp),%rdi
  800420ced5:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420ceda:	48 8b 7d 40          	mov    0x40(%rbp),%rdi
  800420cede:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
  800420cee3:	48 89 c7             	mov    %rax,%rdi
  800420cee6:	48 b8 8a cb 20 04 80 	movabs $0x800420cb8a,%rax
  800420ceed:	00 00 00 
  800420cef0:	ff d0                	callq  *%rax
  800420cef2:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (ret != DW_DLE_NONE)
  800420cef5:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420cef9:	74 05                	je     800420cf00 <_dwarf_abbrev_find+0xf3>
			return (ret);
  800420cefb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420cefe:	eb 3c                	jmp    800420cf3c <_dwarf_abbrev_find+0x12f>
		if (abp->ab_entry == entry) {
  800420cf00:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cf04:	48 8b 00             	mov    (%rax),%rax
  800420cf07:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420cf0b:	75 07                	jne    800420cf14 <_dwarf_abbrev_find+0x107>
			//cu->cu_abbrev_offset_cur = offset;
			return DW_DLE_NONE;
  800420cf0d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cf12:	eb 28                	jmp    800420cf3c <_dwarf_abbrev_find+0x12f>
		}
		if (abp->ab_entry == 0) {
  800420cf14:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cf18:	48 8b 00             	mov    (%rax),%rax
  800420cf1b:	48 85 c0             	test   %rax,%rax
  800420cf1e:	75 02                	jne    800420cf22 <_dwarf_abbrev_find+0x115>
			//cu->cu_abbrev_offset_cur = offset;
			//cu->cu_abbrev_loaded = 1;
			break;
  800420cf20:	eb 15                	jmp    800420cf37 <_dwarf_abbrev_find+0x12a>
	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
	while (offset < ds->ds_size) {
  800420cf22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cf26:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800420cf2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cf2e:	48 39 c2             	cmp    %rax,%rdx
  800420cf31:	0f 87 5e ff ff ff    	ja     800420ce95 <_dwarf_abbrev_find+0x88>
			//cu->cu_abbrev_loaded = 1;
			break;
		}
	}

	return DW_DLE_NO_ENTRY;
  800420cf37:	b8 04 00 00 00       	mov    $0x4,%eax
}
  800420cf3c:	c9                   	leaveq 
  800420cf3d:	c3                   	retq   

000000800420cf3e <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
		 uint64_t form, int indirect)
{
  800420cf3e:	55                   	push   %rbp
  800420cf3f:	48 89 e5             	mov    %rsp,%rbp
  800420cf42:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  800420cf49:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  800420cf50:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  800420cf57:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  800420cf5e:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  800420cf65:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  800420cf6c:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
	struct _Dwarf_Attribute atref;
	Dwarf_Section *str;
	int ret;
	Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  800420cf73:	48 bf e6 3c 21 04 80 	movabs $0x8004213ce6,%rdi
  800420cf7a:	00 00 00 
  800420cf7d:	48 b8 6d 11 21 04 80 	movabs $0x800421116d,%rax
  800420cf84:	00 00 00 
  800420cf87:	ff d0                	callq  *%rax
  800420cf89:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  800420cf8d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cf91:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420cf95:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint8_t dwarf_size = cu->cu_dwarf_size;
  800420cf99:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420cfa0:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  800420cfa4:	88 45 e7             	mov    %al,-0x19(%rbp)

	ret = DW_DLE_NONE;
  800420cfa7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	memset(&atref, 0, sizeof(atref));
  800420cfae:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  800420cfb5:	ba 60 00 00 00       	mov    $0x60,%edx
  800420cfba:	be 00 00 00 00       	mov    $0x0,%esi
  800420cfbf:	48 89 c7             	mov    %rax,%rdi
  800420cfc2:	48 b8 96 ba 20 04 80 	movabs $0x800420ba96,%rax
  800420cfc9:	00 00 00 
  800420cfcc:	ff d0                	callq  *%rax
	atref.at_die = ret_die;
  800420cfce:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420cfd5:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	atref.at_attrib = ad->ad_attrib;
  800420cfdc:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420cfe3:	48 8b 00             	mov    (%rax),%rax
  800420cfe6:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	atref.at_form = ad->ad_form;
  800420cfea:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420cff1:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420cff5:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	atref.at_indirect = indirect;
  800420cff9:	8b 45 10             	mov    0x10(%rbp),%eax
  800420cffc:	89 45 90             	mov    %eax,-0x70(%rbp)
	atref.at_ld = NULL;
  800420cfff:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  800420d006:	00 

	switch (form) {
  800420d007:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  800420d00e:	20 
  800420d00f:	0f 87 82 04 00 00    	ja     800420d497 <_dwarf_attr_init+0x559>
  800420d015:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  800420d01c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420d023:	00 
  800420d024:	48 b8 10 3d 21 04 80 	movabs $0x8004213d10,%rax
  800420d02b:	00 00 00 
  800420d02e:	48 01 d0             	add    %rdx,%rax
  800420d031:	48 8b 00             	mov    (%rax),%rax
  800420d034:	ff e0                	jmpq   *%rax
	case DW_FORM_addr:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  800420d036:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420d03d:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d041:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800420d048:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  800420d04c:	0f b6 d2             	movzbl %dl,%edx
  800420d04f:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420d056:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d05a:	48 89 cf             	mov    %rcx,%rdi
  800420d05d:	ff d0                	callq  *%rax
  800420d05f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420d063:	e9 37 04 00 00       	jmpq   800420d49f <_dwarf_attr_init+0x561>
	case DW_FORM_block:
	case DW_FORM_exprloc:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  800420d068:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420d06f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d073:	48 89 d6             	mov    %rdx,%rsi
  800420d076:	48 89 c7             	mov    %rax,%rdi
  800420d079:	48 b8 a8 c5 20 04 80 	movabs $0x800420c5a8,%rax
  800420d080:	00 00 00 
  800420d083:	ff d0                	callq  *%rax
  800420d085:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420d089:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420d08d:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420d094:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d098:	48 89 ce             	mov    %rcx,%rsi
  800420d09b:	48 89 c7             	mov    %rax,%rdi
  800420d09e:	48 b8 b5 c7 20 04 80 	movabs $0x800420c7b5,%rax
  800420d0a5:	00 00 00 
  800420d0a8:	ff d0                	callq  *%rax
  800420d0aa:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800420d0ae:	e9 ec 03 00 00       	jmpq   800420d49f <_dwarf_attr_init+0x561>
	case DW_FORM_block1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  800420d0b3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420d0ba:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d0be:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420d0c5:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d0c9:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d0ce:	48 89 cf             	mov    %rcx,%rdi
  800420d0d1:	ff d0                	callq  *%rax
  800420d0d3:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420d0d7:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420d0db:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420d0e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d0e6:	48 89 ce             	mov    %rcx,%rsi
  800420d0e9:	48 89 c7             	mov    %rax,%rdi
  800420d0ec:	48 b8 b5 c7 20 04 80 	movabs $0x800420c7b5,%rax
  800420d0f3:	00 00 00 
  800420d0f6:	ff d0                	callq  *%rax
  800420d0f8:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800420d0fc:	e9 9e 03 00 00       	jmpq   800420d49f <_dwarf_attr_init+0x561>
	case DW_FORM_block2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  800420d101:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420d108:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d10c:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420d113:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d117:	ba 02 00 00 00       	mov    $0x2,%edx
  800420d11c:	48 89 cf             	mov    %rcx,%rdi
  800420d11f:	ff d0                	callq  *%rax
  800420d121:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420d125:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420d129:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420d130:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d134:	48 89 ce             	mov    %rcx,%rsi
  800420d137:	48 89 c7             	mov    %rax,%rdi
  800420d13a:	48 b8 b5 c7 20 04 80 	movabs $0x800420c7b5,%rax
  800420d141:	00 00 00 
  800420d144:	ff d0                	callq  *%rax
  800420d146:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800420d14a:	e9 50 03 00 00       	jmpq   800420d49f <_dwarf_attr_init+0x561>
	case DW_FORM_block4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  800420d14f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420d156:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d15a:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420d161:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d165:	ba 04 00 00 00       	mov    $0x4,%edx
  800420d16a:	48 89 cf             	mov    %rcx,%rdi
  800420d16d:	ff d0                	callq  *%rax
  800420d16f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420d173:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420d177:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420d17e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d182:	48 89 ce             	mov    %rcx,%rsi
  800420d185:	48 89 c7             	mov    %rax,%rdi
  800420d188:	48 b8 b5 c7 20 04 80 	movabs $0x800420c7b5,%rax
  800420d18f:	00 00 00 
  800420d192:	ff d0                	callq  *%rax
  800420d194:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800420d198:	e9 02 03 00 00       	jmpq   800420d49f <_dwarf_attr_init+0x561>
	case DW_FORM_data1:
	case DW_FORM_flag:
	case DW_FORM_ref1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  800420d19d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420d1a4:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d1a8:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420d1af:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d1b3:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d1b8:	48 89 cf             	mov    %rcx,%rdi
  800420d1bb:	ff d0                	callq  *%rax
  800420d1bd:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420d1c1:	e9 d9 02 00 00       	jmpq   800420d49f <_dwarf_attr_init+0x561>
	case DW_FORM_data2:
	case DW_FORM_ref2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  800420d1c6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420d1cd:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d1d1:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420d1d8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d1dc:	ba 02 00 00 00       	mov    $0x2,%edx
  800420d1e1:	48 89 cf             	mov    %rcx,%rdi
  800420d1e4:	ff d0                	callq  *%rax
  800420d1e6:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420d1ea:	e9 b0 02 00 00       	jmpq   800420d49f <_dwarf_attr_init+0x561>
	case DW_FORM_data4:
	case DW_FORM_ref4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  800420d1ef:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420d1f6:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d1fa:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420d201:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d205:	ba 04 00 00 00       	mov    $0x4,%edx
  800420d20a:	48 89 cf             	mov    %rcx,%rdi
  800420d20d:	ff d0                	callq  *%rax
  800420d20f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420d213:	e9 87 02 00 00       	jmpq   800420d49f <_dwarf_attr_init+0x561>
	case DW_FORM_data8:
	case DW_FORM_ref8:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  800420d218:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420d21f:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d223:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420d22a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d22e:	ba 08 00 00 00       	mov    $0x8,%edx
  800420d233:	48 89 cf             	mov    %rcx,%rdi
  800420d236:	ff d0                	callq  *%rax
  800420d238:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420d23c:	e9 5e 02 00 00       	jmpq   800420d49f <_dwarf_attr_init+0x561>
	case DW_FORM_indirect:
		form = _dwarf_read_uleb128(ds_data, offsetp);
  800420d241:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420d248:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d24c:	48 89 d6             	mov    %rdx,%rsi
  800420d24f:	48 89 c7             	mov    %rax,%rdi
  800420d252:	48 b8 a8 c5 20 04 80 	movabs $0x800420c5a8,%rax
  800420d259:	00 00 00 
  800420d25c:	ff d0                	callq  *%rax
  800420d25e:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  800420d265:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  800420d26c:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  800420d273:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  800420d27a:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800420d281:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420d288:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420d28f:	c7 04 24 01 00 00 00 	movl   $0x1,(%rsp)
  800420d296:	4d 89 c1             	mov    %r8,%r9
  800420d299:	49 89 f8             	mov    %rdi,%r8
  800420d29c:	48 89 c7             	mov    %rax,%rdi
  800420d29f:	48 b8 3e cf 20 04 80 	movabs $0x800420cf3e,%rax
  800420d2a6:	00 00 00 
  800420d2a9:	ff d0                	callq  *%rax
  800420d2ab:	e9 1d 03 00 00       	jmpq   800420d5cd <_dwarf_attr_init+0x68f>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
  800420d2b0:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420d2b7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420d2bb:	66 83 f8 02          	cmp    $0x2,%ax
  800420d2bf:	75 2f                	jne    800420d2f0 <_dwarf_attr_init+0x3b2>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  800420d2c1:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420d2c8:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d2cc:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800420d2d3:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  800420d2d7:	0f b6 d2             	movzbl %dl,%edx
  800420d2da:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420d2e1:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d2e5:	48 89 cf             	mov    %rcx,%rdi
  800420d2e8:	ff d0                	callq  *%rax
  800420d2ea:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  800420d2ee:	eb 39                	jmp    800420d329 <_dwarf_attr_init+0x3eb>
		else if (cu->version == 3)
  800420d2f0:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420d2f7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420d2fb:	66 83 f8 03          	cmp    $0x3,%ax
  800420d2ff:	75 28                	jne    800420d329 <_dwarf_attr_init+0x3eb>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  800420d301:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420d308:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d30c:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  800420d310:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420d317:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d31b:	48 89 cf             	mov    %rcx,%rdi
  800420d31e:	ff d0                	callq  *%rax
  800420d320:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420d324:	e9 76 01 00 00       	jmpq   800420d49f <_dwarf_attr_init+0x561>
  800420d329:	e9 71 01 00 00       	jmpq   800420d49f <_dwarf_attr_init+0x561>
	case DW_FORM_ref_udata:
	case DW_FORM_udata:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  800420d32e:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420d335:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d339:	48 89 d6             	mov    %rdx,%rsi
  800420d33c:	48 89 c7             	mov    %rax,%rdi
  800420d33f:	48 b8 a8 c5 20 04 80 	movabs $0x800420c5a8,%rax
  800420d346:	00 00 00 
  800420d349:	ff d0                	callq  *%rax
  800420d34b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420d34f:	e9 4b 01 00 00       	jmpq   800420d49f <_dwarf_attr_init+0x561>
	case DW_FORM_sdata:
		atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  800420d354:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420d35b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d35f:	48 89 d6             	mov    %rdx,%rsi
  800420d362:	48 89 c7             	mov    %rax,%rdi
  800420d365:	48 b8 04 c5 20 04 80 	movabs $0x800420c504,%rax
  800420d36c:	00 00 00 
  800420d36f:	ff d0                	callq  *%rax
  800420d371:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420d375:	e9 25 01 00 00       	jmpq   800420d49f <_dwarf_attr_init+0x561>
	case DW_FORM_sec_offset:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  800420d37a:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420d381:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d385:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  800420d389:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420d390:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d394:	48 89 cf             	mov    %rcx,%rdi
  800420d397:	ff d0                	callq  *%rax
  800420d399:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420d39d:	e9 fd 00 00 00       	jmpq   800420d49f <_dwarf_attr_init+0x561>
	case DW_FORM_string:
		atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  800420d3a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d3a6:	48 8b 48 18          	mov    0x18(%rax),%rcx
  800420d3aa:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420d3b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d3b5:	48 89 ce             	mov    %rcx,%rsi
  800420d3b8:	48 89 c7             	mov    %rax,%rdi
  800420d3bb:	48 b8 26 c7 20 04 80 	movabs $0x800420c726,%rax
  800420d3c2:	00 00 00 
  800420d3c5:	ff d0                	callq  *%rax
  800420d3c7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420d3cb:	e9 cf 00 00 00       	jmpq   800420d49f <_dwarf_attr_init+0x561>
	case DW_FORM_strp:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  800420d3d0:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420d3d7:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d3db:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  800420d3df:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420d3e6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d3ea:	48 89 cf             	mov    %rcx,%rdi
  800420d3ed:	ff d0                	callq  *%rax
  800420d3ef:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		str = _dwarf_find_section(".debug_str");
  800420d3f3:	48 bf f2 3c 21 04 80 	movabs $0x8004213cf2,%rdi
  800420d3fa:	00 00 00 
  800420d3fd:	48 b8 6d 11 21 04 80 	movabs $0x800421116d,%rax
  800420d404:	00 00 00 
  800420d407:	ff d0                	callq  *%rax
  800420d409:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		assert(str != NULL);
  800420d40d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420d412:	75 35                	jne    800420d449 <_dwarf_attr_init+0x50b>
  800420d414:	48 b9 fd 3c 21 04 80 	movabs $0x8004213cfd,%rcx
  800420d41b:	00 00 00 
  800420d41e:	48 ba 8a 3c 21 04 80 	movabs $0x8004213c8a,%rdx
  800420d425:	00 00 00 
  800420d428:	be 51 02 00 00       	mov    $0x251,%esi
  800420d42d:	48 bf 9f 3c 21 04 80 	movabs $0x8004213c9f,%rdi
  800420d434:	00 00 00 
  800420d437:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d43c:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420d443:	00 00 00 
  800420d446:	41 ff d0             	callq  *%r8
		//atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
		atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  800420d449:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d44d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420d451:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420d455:	48 01 d0             	add    %rdx,%rax
  800420d458:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800420d45c:	eb 41                	jmp    800420d49f <_dwarf_attr_init+0x561>
	case DW_FORM_ref_sig8:
		atref.u[0].u64 = 8;
  800420d45e:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  800420d465:	00 
		atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  800420d466:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420d46a:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420d471:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d475:	48 89 ce             	mov    %rcx,%rsi
  800420d478:	48 89 c7             	mov    %rax,%rdi
  800420d47b:	48 b8 b5 c7 20 04 80 	movabs $0x800420c7b5,%rax
  800420d482:	00 00 00 
  800420d485:	ff d0                	callq  *%rax
  800420d487:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800420d48b:	eb 12                	jmp    800420d49f <_dwarf_attr_init+0x561>
	case DW_FORM_flag_present:
		/* This form has no value encoded in the DIE. */
		atref.u[0].u64 = 1;
  800420d48d:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  800420d494:	00 
		break;
  800420d495:	eb 08                	jmp    800420d49f <_dwarf_attr_init+0x561>
	default:
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
  800420d497:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
		break;
  800420d49e:	90                   	nop
	}

	if (ret == DW_DLE_NONE) {
  800420d49f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d4a3:	0f 85 21 01 00 00    	jne    800420d5ca <_dwarf_attr_init+0x68c>
		if (form == DW_FORM_block || form == DW_FORM_block1 ||
  800420d4a9:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  800420d4b0:	09 
  800420d4b1:	74 1e                	je     800420d4d1 <_dwarf_attr_init+0x593>
  800420d4b3:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  800420d4ba:	0a 
  800420d4bb:	74 14                	je     800420d4d1 <_dwarf_attr_init+0x593>
  800420d4bd:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  800420d4c4:	03 
  800420d4c5:	74 0a                	je     800420d4d1 <_dwarf_attr_init+0x593>
		    form == DW_FORM_block2 || form == DW_FORM_block4) {
  800420d4c7:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  800420d4ce:	04 
  800420d4cf:	75 10                	jne    800420d4e1 <_dwarf_attr_init+0x5a3>
			atref.at_block.bl_len = atref.u[0].u64;
  800420d4d1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420d4d5:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			atref.at_block.bl_data = atref.u[1].u8p;
  800420d4d9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420d4dd:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
  800420d4e1:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800420d4e5:	48 83 f8 03          	cmp    $0x3,%rax
  800420d4e9:	75 39                	jne    800420d524 <_dwarf_attr_init+0x5e6>
			switch (atref.at_form) {
  800420d4eb:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800420d4ef:	48 83 f8 08          	cmp    $0x8,%rax
  800420d4f3:	74 1c                	je     800420d511 <_dwarf_attr_init+0x5d3>
  800420d4f5:	48 83 f8 0e          	cmp    $0xe,%rax
  800420d4f9:	74 02                	je     800420d4fd <_dwarf_attr_init+0x5bf>
				break;
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
				break;
			default:
				break;
  800420d4fb:	eb 27                	jmp    800420d524 <_dwarf_attr_init+0x5e6>
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
			switch (atref.at_form) {
			case DW_FORM_strp:
				ret_die->die_name = atref.u[1].s;
  800420d4fd:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420d501:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420d508:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  800420d50f:	eb 13                	jmp    800420d524 <_dwarf_attr_init+0x5e6>
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
  800420d511:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420d515:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420d51c:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  800420d523:	90                   	nop
			default:
				break;
			}
		}
		ret_die->die_attr[ret_die->die_attr_count++] = atref;
  800420d524:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420d52b:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  800420d532:	8d 48 01             	lea    0x1(%rax),%ecx
  800420d535:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  800420d53c:	88 8a 58 03 00 00    	mov    %cl,0x358(%rdx)
  800420d542:	0f b6 c0             	movzbl %al,%eax
  800420d545:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  800420d54c:	48 63 d0             	movslq %eax,%rdx
  800420d54f:	48 89 d0             	mov    %rdx,%rax
  800420d552:	48 01 c0             	add    %rax,%rax
  800420d555:	48 01 d0             	add    %rdx,%rax
  800420d558:	48 c1 e0 05          	shl    $0x5,%rax
  800420d55c:	48 01 c8             	add    %rcx,%rax
  800420d55f:	48 05 70 03 00 00    	add    $0x370,%rax
  800420d565:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800420d56c:	48 89 10             	mov    %rdx,(%rax)
  800420d56f:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  800420d576:	48 89 50 08          	mov    %rdx,0x8(%rax)
  800420d57a:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  800420d57e:	48 89 50 10          	mov    %rdx,0x10(%rax)
  800420d582:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  800420d586:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800420d58a:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420d58e:	48 89 50 20          	mov    %rdx,0x20(%rax)
  800420d592:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420d596:	48 89 50 28          	mov    %rdx,0x28(%rax)
  800420d59a:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420d59e:	48 89 50 30          	mov    %rdx,0x30(%rax)
  800420d5a2:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420d5a6:	48 89 50 38          	mov    %rdx,0x38(%rax)
  800420d5aa:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420d5ae:	48 89 50 40          	mov    %rdx,0x40(%rax)
  800420d5b2:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420d5b6:	48 89 50 48          	mov    %rdx,0x48(%rax)
  800420d5ba:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420d5be:	48 89 50 50          	mov    %rdx,0x50(%rax)
  800420d5c2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420d5c6:	48 89 50 58          	mov    %rdx,0x58(%rax)
	}

	return (ret);
  800420d5ca:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420d5cd:	c9                   	leaveq 
  800420d5ce:	c3                   	retq   

000000800420d5cf <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  800420d5cf:	55                   	push   %rbp
  800420d5d0:	48 89 e5             	mov    %rsp,%rbp
  800420d5d3:	48 81 ec d0 03 00 00 	sub    $0x3d0,%rsp
  800420d5da:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  800420d5e1:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  800420d5e8:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  800420d5ef:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
	uint64_t abnum;
	uint64_t die_offset;
	int ret, level;
	int i;

	assert(dbg);
  800420d5f5:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  800420d5fc:	00 
  800420d5fd:	75 35                	jne    800420d634 <dwarf_search_die_within_cu+0x65>
  800420d5ff:	48 b9 18 3e 21 04 80 	movabs $0x8004213e18,%rcx
  800420d606:	00 00 00 
  800420d609:	48 ba 8a 3c 21 04 80 	movabs $0x8004213c8a,%rdx
  800420d610:	00 00 00 
  800420d613:	be 86 02 00 00       	mov    $0x286,%esi
  800420d618:	48 bf 9f 3c 21 04 80 	movabs $0x8004213c9f,%rdi
  800420d61f:	00 00 00 
  800420d622:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d627:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420d62e:	00 00 00 
  800420d631:	41 ff d0             	callq  *%r8
	//assert(cu);
	assert(ret_die);
  800420d634:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  800420d63b:	00 
  800420d63c:	75 35                	jne    800420d673 <dwarf_search_die_within_cu+0xa4>
  800420d63e:	48 b9 1c 3e 21 04 80 	movabs $0x8004213e1c,%rcx
  800420d645:	00 00 00 
  800420d648:	48 ba 8a 3c 21 04 80 	movabs $0x8004213c8a,%rdx
  800420d64f:	00 00 00 
  800420d652:	be 88 02 00 00       	mov    $0x288,%esi
  800420d657:	48 bf 9f 3c 21 04 80 	movabs $0x8004213c9f,%rdi
  800420d65e:	00 00 00 
  800420d661:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d666:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420d66d:	00 00 00 
  800420d670:	41 ff d0             	callq  *%r8

	level = 1;
  800420d673:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  800420d67a:	e9 17 02 00 00       	jmpq   800420d896 <dwarf_search_die_within_cu+0x2c7>

		die_offset = offset;
  800420d67f:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  800420d686:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  800420d68a:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800420d691:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420d695:	48 8d 95 80 fc ff ff 	lea    -0x380(%rbp),%rdx
  800420d69c:	48 89 d6             	mov    %rdx,%rsi
  800420d69f:	48 89 c7             	mov    %rax,%rdi
  800420d6a2:	48 b8 a8 c5 20 04 80 	movabs $0x800420c5a8,%rax
  800420d6a9:	00 00 00 
  800420d6ac:	ff d0                	callq  *%rax
  800420d6ae:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		if (abnum == 0) {
  800420d6b2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d6b7:	75 22                	jne    800420d6db <dwarf_search_die_within_cu+0x10c>
			if (level == 0 || !search_sibling) {
  800420d6b9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d6bd:	74 09                	je     800420d6c8 <dwarf_search_die_within_cu+0xf9>
  800420d6bf:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  800420d6c6:	75 0a                	jne    800420d6d2 <dwarf_search_die_within_cu+0x103>
				//No more entry
				return (DW_DLE_NO_ENTRY);
  800420d6c8:	b8 04 00 00 00       	mov    $0x4,%eax
  800420d6cd:	e9 f4 01 00 00       	jmpq   800420d8c6 <dwarf_search_die_within_cu+0x2f7>
			}
			/*
			 * Return to previous DIE level.
			 */
			level--;
  800420d6d2:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
			continue;
  800420d6d6:	e9 bb 01 00 00       	jmpq   800420d896 <dwarf_search_die_within_cu+0x2c7>
		}

		if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  800420d6db:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  800420d6e2:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d6e6:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800420d6ed:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  800420d6f1:	48 89 34 24          	mov    %rsi,(%rsp)
  800420d6f5:	48 8b 75 18          	mov    0x18(%rbp),%rsi
  800420d6f9:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  800420d6fe:	48 8b 75 20          	mov    0x20(%rbp),%rsi
  800420d702:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  800420d707:	48 8b 75 28          	mov    0x28(%rbp),%rsi
  800420d70b:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  800420d710:	48 8b 75 30          	mov    0x30(%rbp),%rsi
  800420d714:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
  800420d719:	48 8b 75 38          	mov    0x38(%rbp),%rsi
  800420d71d:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  800420d722:	48 8b 75 40          	mov    0x40(%rbp),%rsi
  800420d726:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
  800420d72b:	48 89 ce             	mov    %rcx,%rsi
  800420d72e:	48 89 c7             	mov    %rax,%rdi
  800420d731:	48 b8 0d ce 20 04 80 	movabs $0x800420ce0d,%rax
  800420d738:	00 00 00 
  800420d73b:	ff d0                	callq  *%rax
  800420d73d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  800420d740:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420d744:	74 08                	je     800420d74e <dwarf_search_die_within_cu+0x17f>
			return (ret);
  800420d746:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420d749:	e9 78 01 00 00       	jmpq   800420d8c6 <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_offset = die_offset;
  800420d74e:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800420d755:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d759:	48 89 10             	mov    %rdx,(%rax)
		ret_die->die_abnum  = abnum;
  800420d75c:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800420d763:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d767:	48 89 50 10          	mov    %rdx,0x10(%rax)
		ret_die->die_ab  = ab;
  800420d76b:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800420d772:	48 8d 78 20          	lea    0x20(%rax),%rdi
  800420d776:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  800420d77d:	b8 66 00 00 00       	mov    $0x66,%eax
  800420d782:	48 89 d6             	mov    %rdx,%rsi
  800420d785:	48 89 c1             	mov    %rax,%rcx
  800420d788:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		ret_die->die_attr_count = 0;
  800420d78b:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800420d792:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
		ret_die->die_tag = ab.ab_tag;
  800420d799:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  800420d7a0:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800420d7a7:	48 89 50 18          	mov    %rdx,0x18(%rax)
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  800420d7ab:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  800420d7b2:	e9 8e 00 00 00       	jmpq   800420d845 <dwarf_search_die_within_cu+0x276>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  800420d7b7:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420d7ba:	48 63 d0             	movslq %eax,%rdx
  800420d7bd:	48 89 d0             	mov    %rdx,%rax
  800420d7c0:	48 01 c0             	add    %rax,%rax
  800420d7c3:	48 01 d0             	add    %rdx,%rax
  800420d7c6:	48 c1 e0 03          	shl    $0x3,%rax
  800420d7ca:	48 01 e8             	add    %rbp,%rax
  800420d7cd:	48 2d 18 03 00 00    	sub    $0x318,%rax
  800420d7d3:	48 8b 08             	mov    (%rax),%rcx
  800420d7d6:	48 8d b5 b0 fc ff ff 	lea    -0x350(%rbp),%rsi
  800420d7dd:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420d7e0:	48 63 d0             	movslq %eax,%rdx
  800420d7e3:	48 89 d0             	mov    %rdx,%rax
  800420d7e6:	48 01 c0             	add    %rax,%rax
  800420d7e9:	48 01 d0             	add    %rdx,%rax
  800420d7ec:	48 c1 e0 03          	shl    $0x3,%rax
  800420d7f0:	48 83 c0 30          	add    $0x30,%rax
  800420d7f4:	48 8d 3c 06          	lea    (%rsi,%rax,1),%rdi
  800420d7f8:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  800420d7ff:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  800420d806:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800420d80d:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  800420d814:	49 89 c9             	mov    %rcx,%r9
  800420d817:	49 89 f8             	mov    %rdi,%r8
  800420d81a:	48 89 d1             	mov    %rdx,%rcx
  800420d81d:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  800420d821:	48 89 c7             	mov    %rax,%rdi
  800420d824:	48 b8 3e cf 20 04 80 	movabs $0x800420cf3e,%rax
  800420d82b:	00 00 00 
  800420d82e:	ff d0                	callq  *%rax
  800420d830:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  800420d833:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420d837:	74 08                	je     800420d841 <dwarf_search_die_within_cu+0x272>
				return (ret);
  800420d839:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420d83c:	e9 85 00 00 00       	jmpq   800420d8c6 <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_attr_count = 0;
		ret_die->die_tag = ab.ab_tag;
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  800420d841:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  800420d845:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420d848:	48 63 d0             	movslq %eax,%rdx
  800420d84b:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  800420d852:	48 39 c2             	cmp    %rax,%rdx
  800420d855:	0f 82 5c ff ff ff    	jb     800420d7b7 <dwarf_search_die_within_cu+0x1e8>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
				return (ret);
		}

		ret_die->die_next_off = offset;
  800420d85b:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  800420d862:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800420d869:	48 89 50 08          	mov    %rdx,0x8(%rax)
		if (search_sibling && level > 0) {
  800420d86d:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  800420d874:	74 19                	je     800420d88f <dwarf_search_die_within_cu+0x2c0>
  800420d876:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d87a:	7e 13                	jle    800420d88f <dwarf_search_die_within_cu+0x2c0>
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  800420d87c:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  800420d883:	3c 01                	cmp    $0x1,%al
  800420d885:	75 06                	jne    800420d88d <dwarf_search_die_within_cu+0x2be>
				/* Advance to next DIE level. */
				level++;
  800420d887:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
		}

		ret_die->die_next_off = offset;
		if (search_sibling && level > 0) {
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  800420d88b:	eb 09                	jmp    800420d896 <dwarf_search_die_within_cu+0x2c7>
  800420d88d:	eb 07                	jmp    800420d896 <dwarf_search_die_within_cu+0x2c7>
				/* Advance to next DIE level. */
				level++;
			}
		} else {
			//*ret_die = die;
			return (DW_DLE_NONE);
  800420d88f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d894:	eb 30                	jmp    800420d8c6 <dwarf_search_die_within_cu+0x2f7>
	//assert(cu);
	assert(ret_die);

	level = 1;

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  800420d896:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  800420d89a:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  800420d8a1:	48 39 c2             	cmp    %rax,%rdx
  800420d8a4:	76 1b                	jbe    800420d8c1 <dwarf_search_die_within_cu+0x2f2>
  800420d8a6:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800420d8ad:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420d8b1:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  800420d8b8:	48 39 c2             	cmp    %rax,%rdx
  800420d8bb:	0f 87 be fd ff ff    	ja     800420d67f <dwarf_search_die_within_cu+0xb0>
			//*ret_die = die;
			return (DW_DLE_NONE);
		}
	}

	return (DW_DLE_NO_ENTRY);
  800420d8c1:	b8 04 00 00 00       	mov    $0x4,%eax
}
  800420d8c6:	c9                   	leaveq 
  800420d8c7:	c3                   	retq   

000000800420d8c8 <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  800420d8c8:	55                   	push   %rbp
  800420d8c9:	48 89 e5             	mov    %rsp,%rbp
  800420d8cc:	48 83 ec 60          	sub    $0x60,%rsp
  800420d8d0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d8d4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420d8d8:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int ret;

	assert(dbg);
  800420d8dc:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d8e1:	75 35                	jne    800420d918 <dwarf_offdie+0x50>
  800420d8e3:	48 b9 18 3e 21 04 80 	movabs $0x8004213e18,%rcx
  800420d8ea:	00 00 00 
  800420d8ed:	48 ba 8a 3c 21 04 80 	movabs $0x8004213c8a,%rdx
  800420d8f4:	00 00 00 
  800420d8f7:	be c4 02 00 00       	mov    $0x2c4,%esi
  800420d8fc:	48 bf 9f 3c 21 04 80 	movabs $0x8004213c9f,%rdi
  800420d903:	00 00 00 
  800420d906:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d90b:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420d912:	00 00 00 
  800420d915:	41 ff d0             	callq  *%r8
	assert(ret_die);
  800420d918:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420d91d:	75 35                	jne    800420d954 <dwarf_offdie+0x8c>
  800420d91f:	48 b9 1c 3e 21 04 80 	movabs $0x8004213e1c,%rcx
  800420d926:	00 00 00 
  800420d929:	48 ba 8a 3c 21 04 80 	movabs $0x8004213c8a,%rdx
  800420d930:	00 00 00 
  800420d933:	be c5 02 00 00       	mov    $0x2c5,%esi
  800420d938:	48 bf 9f 3c 21 04 80 	movabs $0x8004213c9f,%rdi
  800420d93f:	00 00 00 
  800420d942:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d947:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420d94e:	00 00 00 
  800420d951:	41 ff d0             	callq  *%r8

	/* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  800420d954:	48 8b 45 30          	mov    0x30(%rbp),%rax
  800420d958:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420d95c:	76 66                	jbe    800420d9c4 <dwarf_offdie+0xfc>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  800420d95e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420d962:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420d966:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d96a:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  800420d96e:	48 89 0c 24          	mov    %rcx,(%rsp)
  800420d972:	48 8b 4d 18          	mov    0x18(%rbp),%rcx
  800420d976:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  800420d97b:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
  800420d97f:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  800420d984:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800420d988:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  800420d98d:	48 8b 4d 30          	mov    0x30(%rbp),%rcx
  800420d991:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  800420d996:	48 8b 4d 38          	mov    0x38(%rbp),%rcx
  800420d99a:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  800420d99f:	48 8b 4d 40          	mov    0x40(%rbp),%rcx
  800420d9a3:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
  800420d9a8:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420d9ad:	48 89 c7             	mov    %rax,%rdi
  800420d9b0:	48 b8 cf d5 20 04 80 	movabs $0x800420d5cf,%rax
  800420d9b7:	00 00 00 
  800420d9ba:	ff d0                	callq  *%rax
  800420d9bc:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  800420d9bf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d9c2:	eb 05                	jmp    800420d9c9 <dwarf_offdie+0x101>
	}

	/*TODO: Search other CU*/
	return DW_DLV_OK;
  800420d9c4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420d9c9:	c9                   	leaveq 
  800420d9ca:	c3                   	retq   

000000800420d9cb <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  800420d9cb:	55                   	push   %rbp
  800420d9cc:	48 89 e5             	mov    %rsp,%rbp
  800420d9cf:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420d9d3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d9d7:	89 f0                	mov    %esi,%eax
  800420d9d9:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Attribute *myat = NULL;
  800420d9dd:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420d9e4:	00 
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  800420d9e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  800420d9ec:	eb 57                	jmp    800420da45 <_dwarf_attr_find+0x7a>
	{
		if (die->die_attr[i].at_attrib == attr)
  800420d9ee:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d9f2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420d9f5:	48 63 d0             	movslq %eax,%rdx
  800420d9f8:	48 89 d0             	mov    %rdx,%rax
  800420d9fb:	48 01 c0             	add    %rax,%rax
  800420d9fe:	48 01 d0             	add    %rdx,%rax
  800420da01:	48 c1 e0 05          	shl    $0x5,%rax
  800420da05:	48 01 c8             	add    %rcx,%rax
  800420da08:	48 05 80 03 00 00    	add    $0x380,%rax
  800420da0e:	48 8b 10             	mov    (%rax),%rdx
  800420da11:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  800420da15:	48 39 c2             	cmp    %rax,%rdx
  800420da18:	75 27                	jne    800420da41 <_dwarf_attr_find+0x76>
		{
			myat = &(die->die_attr[i]);
  800420da1a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420da1d:	48 63 d0             	movslq %eax,%rdx
  800420da20:	48 89 d0             	mov    %rdx,%rax
  800420da23:	48 01 c0             	add    %rax,%rax
  800420da26:	48 01 d0             	add    %rdx,%rax
  800420da29:	48 c1 e0 05          	shl    $0x5,%rax
  800420da2d:	48 8d 90 70 03 00 00 	lea    0x370(%rax),%rdx
  800420da34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420da38:	48 01 d0             	add    %rdx,%rax
  800420da3b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800420da3f:	eb 17                	jmp    800420da58 <_dwarf_attr_find+0x8d>
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
	Dwarf_Attribute *myat = NULL;
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  800420da41:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800420da45:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420da49:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  800420da50:	0f b6 c0             	movzbl %al,%eax
  800420da53:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  800420da56:	7f 96                	jg     800420d9ee <_dwarf_attr_find+0x23>
			myat = &(die->die_attr[i]);
			break;
		}
	}

	return myat;
  800420da58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420da5c:	c9                   	leaveq 
  800420da5d:	c3                   	retq   

000000800420da5e <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
		Dwarf_CU *cu)
{
  800420da5e:	55                   	push   %rbp
  800420da5f:	48 89 e5             	mov    %rsp,%rbp
  800420da62:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  800420da66:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420da6a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420da6e:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800420da72:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	Dwarf_Attribute *at;
	uint64_t offset;
	int ret, search_sibling;

	assert(dbg);
  800420da76:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420da7b:	75 35                	jne    800420dab2 <dwarf_siblingof+0x54>
  800420da7d:	48 b9 18 3e 21 04 80 	movabs $0x8004213e18,%rcx
  800420da84:	00 00 00 
  800420da87:	48 ba 8a 3c 21 04 80 	movabs $0x8004213c8a,%rdx
  800420da8e:	00 00 00 
  800420da91:	be ec 02 00 00       	mov    $0x2ec,%esi
  800420da96:	48 bf 9f 3c 21 04 80 	movabs $0x8004213c9f,%rdi
  800420da9d:	00 00 00 
  800420daa0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420daa5:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420daac:	00 00 00 
  800420daaf:	41 ff d0             	callq  *%r8
	assert(ret_die);
  800420dab2:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420dab7:	75 35                	jne    800420daee <dwarf_siblingof+0x90>
  800420dab9:	48 b9 1c 3e 21 04 80 	movabs $0x8004213e1c,%rcx
  800420dac0:	00 00 00 
  800420dac3:	48 ba 8a 3c 21 04 80 	movabs $0x8004213c8a,%rdx
  800420daca:	00 00 00 
  800420dacd:	be ed 02 00 00       	mov    $0x2ed,%esi
  800420dad2:	48 bf 9f 3c 21 04 80 	movabs $0x8004213c9f,%rdi
  800420dad9:	00 00 00 
  800420dadc:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dae1:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420dae8:	00 00 00 
  800420daeb:	41 ff d0             	callq  *%r8
	assert(cu);
  800420daee:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800420daf3:	75 35                	jne    800420db2a <dwarf_siblingof+0xcc>
  800420daf5:	48 b9 24 3e 21 04 80 	movabs $0x8004213e24,%rcx
  800420dafc:	00 00 00 
  800420daff:	48 ba 8a 3c 21 04 80 	movabs $0x8004213c8a,%rdx
  800420db06:	00 00 00 
  800420db09:	be ee 02 00 00       	mov    $0x2ee,%esi
  800420db0e:	48 bf 9f 3c 21 04 80 	movabs $0x8004213c9f,%rdi
  800420db15:	00 00 00 
  800420db18:	b8 00 00 00 00       	mov    $0x0,%eax
  800420db1d:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420db24:	00 00 00 
  800420db27:	41 ff d0             	callq  *%r8

	/* Application requests the first DIE in this CU. */
	if (die == NULL)
  800420db2a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420db2f:	75 65                	jne    800420db96 <dwarf_siblingof+0x138>
		return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  800420db31:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420db35:	48 8b 70 28          	mov    0x28(%rax),%rsi
  800420db39:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420db3d:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420db41:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420db45:	48 8b 38             	mov    (%rax),%rdi
  800420db48:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420db4c:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420db50:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420db55:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420db59:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420db5e:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420db62:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420db67:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420db6b:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420db70:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420db74:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420db79:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420db7d:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420db82:	48 89 cf             	mov    %rcx,%rdi
  800420db85:	48 b8 c8 d8 20 04 80 	movabs $0x800420d8c8,%rax
  800420db8c:	00 00 00 
  800420db8f:	ff d0                	callq  *%rax
  800420db91:	e9 0a 01 00 00       	jmpq   800420dca0 <dwarf_siblingof+0x242>

	/*
	 * If the DIE doesn't have any children, its sibling sits next
	 * right to it.
	 */
	search_sibling = 0;
  800420db96:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	if (die->die_ab.ab_children == DW_CHILDREN_no)
  800420db9d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420dba1:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  800420dba5:	84 c0                	test   %al,%al
  800420dba7:	75 0e                	jne    800420dbb7 <dwarf_siblingof+0x159>
		offset = die->die_next_off;
  800420dba9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420dbad:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420dbb1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420dbb5:	eb 6b                	jmp    800420dc22 <dwarf_siblingof+0x1c4>
	else {
		/*
		 * Look for DW_AT_sibling attribute for the offset of
		 * its sibling.
		 */
		if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  800420dbb7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420dbbb:	be 01 00 00 00       	mov    $0x1,%esi
  800420dbc0:	48 89 c7             	mov    %rax,%rdi
  800420dbc3:	48 b8 cb d9 20 04 80 	movabs $0x800420d9cb,%rax
  800420dbca:	00 00 00 
  800420dbcd:	ff d0                	callq  *%rax
  800420dbcf:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420dbd3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420dbd8:	74 35                	je     800420dc0f <dwarf_siblingof+0x1b1>
			if (at->at_form != DW_FORM_ref_addr)
  800420dbda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dbde:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420dbe2:	48 83 f8 10          	cmp    $0x10,%rax
  800420dbe6:	74 19                	je     800420dc01 <dwarf_siblingof+0x1a3>
				offset = at->u[0].u64 + cu->cu_offset;
  800420dbe8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dbec:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420dbf0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420dbf4:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420dbf8:	48 01 d0             	add    %rdx,%rax
  800420dbfb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420dbff:	eb 21                	jmp    800420dc22 <dwarf_siblingof+0x1c4>
			else
				offset = at->u[0].u64;
  800420dc01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dc05:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420dc09:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420dc0d:	eb 13                	jmp    800420dc22 <dwarf_siblingof+0x1c4>
		} else {
			offset = die->die_next_off;
  800420dc0f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420dc13:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420dc17:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			search_sibling = 1;
  800420dc1b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
		}
	}

	ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  800420dc22:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  800420dc25:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420dc29:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420dc2d:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  800420dc31:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420dc35:	4c 8b 00             	mov    (%rax),%r8
  800420dc38:	4c 89 04 24          	mov    %r8,(%rsp)
  800420dc3c:	4c 8b 40 08          	mov    0x8(%rax),%r8
  800420dc40:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  800420dc45:	4c 8b 40 10          	mov    0x10(%rax),%r8
  800420dc49:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  800420dc4e:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420dc52:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  800420dc57:	4c 8b 40 20          	mov    0x20(%rax),%r8
  800420dc5b:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
  800420dc60:	4c 8b 40 28          	mov    0x28(%rax),%r8
  800420dc64:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
  800420dc69:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420dc6d:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420dc72:	48 b8 cf d5 20 04 80 	movabs $0x800420d5cf,%rax
  800420dc79:	00 00 00 
  800420dc7c:	ff d0                	callq  *%rax
  800420dc7e:	89 45 e4             	mov    %eax,-0x1c(%rbp)


	if (ret == DW_DLE_NO_ENTRY) {
  800420dc81:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  800420dc85:	75 07                	jne    800420dc8e <dwarf_siblingof+0x230>
		return (DW_DLV_NO_ENTRY);
  800420dc87:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420dc8c:	eb 12                	jmp    800420dca0 <dwarf_siblingof+0x242>
	} else if (ret != DW_DLE_NONE)
  800420dc8e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420dc92:	74 07                	je     800420dc9b <dwarf_siblingof+0x23d>
		return (DW_DLV_ERROR);
  800420dc94:	b8 01 00 00 00       	mov    $0x1,%eax
  800420dc99:	eb 05                	jmp    800420dca0 <dwarf_siblingof+0x242>


	return (DW_DLV_OK);
  800420dc9b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420dca0:	c9                   	leaveq 
  800420dca1:	c3                   	retq   

000000800420dca2 <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  800420dca2:	55                   	push   %rbp
  800420dca3:	48 89 e5             	mov    %rsp,%rbp
  800420dca6:	48 83 ec 70          	sub    $0x70,%rsp
  800420dcaa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420dcae:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420dcb2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420dcb6:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int ret;

	assert(die);
  800420dcba:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420dcbf:	75 35                	jne    800420dcf6 <dwarf_child+0x54>
  800420dcc1:	48 b9 27 3e 21 04 80 	movabs $0x8004213e27,%rcx
  800420dcc8:	00 00 00 
  800420dccb:	48 ba 8a 3c 21 04 80 	movabs $0x8004213c8a,%rdx
  800420dcd2:	00 00 00 
  800420dcd5:	be 1c 03 00 00       	mov    $0x31c,%esi
  800420dcda:	48 bf 9f 3c 21 04 80 	movabs $0x8004213c9f,%rdi
  800420dce1:	00 00 00 
  800420dce4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dce9:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420dcf0:	00 00 00 
  800420dcf3:	41 ff d0             	callq  *%r8
	assert(ret_die);
  800420dcf6:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420dcfb:	75 35                	jne    800420dd32 <dwarf_child+0x90>
  800420dcfd:	48 b9 1c 3e 21 04 80 	movabs $0x8004213e1c,%rcx
  800420dd04:	00 00 00 
  800420dd07:	48 ba 8a 3c 21 04 80 	movabs $0x8004213c8a,%rdx
  800420dd0e:	00 00 00 
  800420dd11:	be 1d 03 00 00       	mov    $0x31d,%esi
  800420dd16:	48 bf 9f 3c 21 04 80 	movabs $0x8004213c9f,%rdi
  800420dd1d:	00 00 00 
  800420dd20:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dd25:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420dd2c:	00 00 00 
  800420dd2f:	41 ff d0             	callq  *%r8
	assert(dbg);
  800420dd32:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420dd37:	75 35                	jne    800420dd6e <dwarf_child+0xcc>
  800420dd39:	48 b9 18 3e 21 04 80 	movabs $0x8004213e18,%rcx
  800420dd40:	00 00 00 
  800420dd43:	48 ba 8a 3c 21 04 80 	movabs $0x8004213c8a,%rdx
  800420dd4a:	00 00 00 
  800420dd4d:	be 1e 03 00 00       	mov    $0x31e,%esi
  800420dd52:	48 bf 9f 3c 21 04 80 	movabs $0x8004213c9f,%rdi
  800420dd59:	00 00 00 
  800420dd5c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dd61:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420dd68:	00 00 00 
  800420dd6b:	41 ff d0             	callq  *%r8
	assert(cu);
  800420dd6e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420dd73:	75 35                	jne    800420ddaa <dwarf_child+0x108>
  800420dd75:	48 b9 24 3e 21 04 80 	movabs $0x8004213e24,%rcx
  800420dd7c:	00 00 00 
  800420dd7f:	48 ba 8a 3c 21 04 80 	movabs $0x8004213c8a,%rdx
  800420dd86:	00 00 00 
  800420dd89:	be 1f 03 00 00       	mov    $0x31f,%esi
  800420dd8e:	48 bf 9f 3c 21 04 80 	movabs $0x8004213c9f,%rdi
  800420dd95:	00 00 00 
  800420dd98:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dd9d:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420dda4:	00 00 00 
  800420dda7:	41 ff d0             	callq  *%r8

	if (die->die_ab.ab_children == DW_CHILDREN_no)
  800420ddaa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ddae:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  800420ddb2:	84 c0                	test   %al,%al
  800420ddb4:	75 0a                	jne    800420ddc0 <dwarf_child+0x11e>
		return (DW_DLE_NO_ENTRY);
  800420ddb6:	b8 04 00 00 00       	mov    $0x4,%eax
  800420ddbb:	e9 84 00 00 00       	jmpq   800420de44 <dwarf_child+0x1a2>

	ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  800420ddc0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ddc4:	48 8b 70 08          	mov    0x8(%rax),%rsi
  800420ddc8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ddcc:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  800420ddd0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ddd4:	48 8b 08             	mov    (%rax),%rcx
  800420ddd7:	48 89 0c 24          	mov    %rcx,(%rsp)
  800420dddb:	48 8b 48 08          	mov    0x8(%rax),%rcx
  800420dddf:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  800420dde4:	48 8b 48 10          	mov    0x10(%rax),%rcx
  800420dde8:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  800420dded:	48 8b 48 18          	mov    0x18(%rax),%rcx
  800420ddf1:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  800420ddf6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ddfa:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  800420ddff:	48 8b 48 28          	mov    0x28(%rax),%rcx
  800420de03:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  800420de08:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420de0c:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420de11:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420de16:	48 b8 cf d5 20 04 80 	movabs $0x800420d5cf,%rax
  800420de1d:	00 00 00 
  800420de20:	ff d0                	callq  *%rax
  800420de22:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if (ret == DW_DLE_NO_ENTRY) {
  800420de25:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  800420de29:	75 07                	jne    800420de32 <dwarf_child+0x190>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  800420de2b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420de30:	eb 12                	jmp    800420de44 <dwarf_child+0x1a2>
	} else if (ret != DW_DLE_NONE)
  800420de32:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420de36:	74 07                	je     800420de3f <dwarf_child+0x19d>
		return (DW_DLV_ERROR);
  800420de38:	b8 01 00 00 00       	mov    $0x1,%eax
  800420de3d:	eb 05                	jmp    800420de44 <dwarf_child+0x1a2>

	return (DW_DLV_OK);
  800420de3f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420de44:	c9                   	leaveq 
  800420de45:	c3                   	retq   

000000800420de46 <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  800420de46:	55                   	push   %rbp
  800420de47:	48 89 e5             	mov    %rsp,%rbp
  800420de4a:	48 83 ec 20          	sub    $0x20,%rsp
  800420de4e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  800420de52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420de56:	48 8b 00             	mov    (%rax),%rax
  800420de59:	48 89 c7             	mov    %rax,%rdi
  800420de5c:	48 b8 6d 11 21 04 80 	movabs $0x800421116d,%rax
  800420de63:	00 00 00 
  800420de66:	ff d0                	callq  *%rax
  800420de68:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  800420de6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420de70:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420de74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420de78:	48 89 50 08          	mov    %rdx,0x8(%rax)
	ds->ds_addr = secthdr->ds_addr;
  800420de7c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420de80:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420de84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420de88:	48 89 50 10          	mov    %rdx,0x10(%rax)
	ds->ds_size = secthdr->ds_size;
  800420de8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420de90:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800420de94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420de98:	48 89 50 18          	mov    %rdx,0x18(%rax)
	return 0;
  800420de9c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420dea1:	c9                   	leaveq 
  800420dea2:	c3                   	retq   

000000800420dea3 <_dwarf_frame_params_init>:

extern int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  800420dea3:	55                   	push   %rbp
  800420dea4:	48 89 e5             	mov    %rsp,%rbp
  800420dea7:	48 83 ec 08          	sub    $0x8,%rsp
  800420deab:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	/* Initialise call frame related parameters. */
	dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  800420deaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420deb3:	66 c7 40 48 42 00    	movw   $0x42,0x48(%rax)
	dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  800420deb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420debd:	66 c7 40 4a 0b 04    	movw   $0x40b,0x4a(%rax)
	dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  800420dec3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dec7:	66 c7 40 4c 9c 05    	movw   $0x59c,0x4c(%rax)
	dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  800420decd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ded1:	66 c7 40 4e 0b 04    	movw   $0x40b,0x4e(%rax)
	dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  800420ded7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dedb:	66 c7 40 50 0a 04    	movw   $0x40a,0x50(%rax)
}
  800420dee1:	c9                   	leaveq 
  800420dee2:	c3                   	retq   

000000800420dee3 <dwarf_get_fde_at_pc>:

int
dwarf_get_fde_at_pc(Dwarf_Debug dbg, Dwarf_Addr pc,
		    struct _Dwarf_Fde *ret_fde, Dwarf_Cie cie,
		    Dwarf_Error *error)
{
  800420dee3:	55                   	push   %rbp
  800420dee4:	48 89 e5             	mov    %rsp,%rbp
  800420dee7:	48 83 ec 40          	sub    $0x40,%rsp
  800420deeb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420deef:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420def3:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420def7:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  800420defb:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
	Dwarf_Fde fde = ret_fde;
  800420deff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420df03:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(fde, 0, sizeof(struct _Dwarf_Fde));
  800420df07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420df0b:	ba 80 00 00 00       	mov    $0x80,%edx
  800420df10:	be 00 00 00 00       	mov    $0x0,%esi
  800420df15:	48 89 c7             	mov    %rax,%rdi
  800420df18:	48 b8 96 ba 20 04 80 	movabs $0x800420ba96,%rax
  800420df1f:	00 00 00 
  800420df22:	ff d0                	callq  *%rax
	fde->fde_cie = cie;
  800420df24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420df28:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420df2c:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
	if (ret_fde == NULL)
  800420df30:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420df35:	75 07                	jne    800420df3e <dwarf_get_fde_at_pc+0x5b>
		return (DW_DLV_ERROR);
  800420df37:	b8 01 00 00 00       	mov    $0x1,%eax
  800420df3c:	eb 75                	jmp    800420dfb3 <dwarf_get_fde_at_pc+0xd0>

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  800420df3e:	eb 59                	jmp    800420df99 <dwarf_get_fde_at_pc+0xb6>
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
  800420df40:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420df44:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420df48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420df4c:	be 01 00 00 00       	mov    $0x1,%esi
  800420df51:	48 89 c7             	mov    %rax,%rdi
  800420df54:	48 b8 f8 00 21 04 80 	movabs $0x80042100f8,%rax
  800420df5b:	00 00 00 
  800420df5e:	ff d0                	callq  *%rax
  800420df60:	85 c0                	test   %eax,%eax
  800420df62:	79 07                	jns    800420df6b <dwarf_get_fde_at_pc+0x88>
		{
			return DW_DLV_NO_ENTRY;
  800420df64:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420df69:	eb 48                	jmp    800420dfb3 <dwarf_get_fde_at_pc+0xd0>
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  800420df6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420df6f:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420df73:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420df77:	77 20                	ja     800420df99 <dwarf_get_fde_at_pc+0xb6>
  800420df79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420df7d:	48 8b 50 30          	mov    0x30(%rax),%rdx
		    fde->fde_adrange)
  800420df81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420df85:	48 8b 40 38          	mov    0x38(%rax),%rax
	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
		{
			return DW_DLV_NO_ENTRY;
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  800420df89:	48 01 d0             	add    %rdx,%rax
  800420df8c:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420df90:	76 07                	jbe    800420df99 <dwarf_get_fde_at_pc+0xb6>
		    fde->fde_adrange)
			return (DW_DLV_OK);
  800420df92:	b8 00 00 00 00       	mov    $0x0,%eax
  800420df97:	eb 1a                	jmp    800420dfb3 <dwarf_get_fde_at_pc+0xd0>
	fde->fde_cie = cie;
	
	if (ret_fde == NULL)
		return (DW_DLV_ERROR);

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  800420df99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420df9d:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420dfa1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dfa5:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420dfa9:	48 39 c2             	cmp    %rax,%rdx
  800420dfac:	72 92                	jb     800420df40 <dwarf_get_fde_at_pc+0x5d>
		    fde->fde_adrange)
			return (DW_DLV_OK);
	}

	DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
	return (DW_DLV_NO_ENTRY);
  800420dfae:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  800420dfb3:	c9                   	leaveq 
  800420dfb4:	c3                   	retq   

000000800420dfb5 <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
			   Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  800420dfb5:	55                   	push   %rbp
  800420dfb6:	48 89 e5             	mov    %rsp,%rbp
  800420dfb9:	53                   	push   %rbx
  800420dfba:	48 83 ec 38          	sub    $0x38,%rsp
  800420dfbe:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420dfc2:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420dfc6:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800420dfca:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	int i;

	assert(dest != NULL);
  800420dfce:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420dfd3:	75 35                	jne    800420e00a <_dwarf_frame_regtable_copy+0x55>
  800420dfd5:	48 b9 3a 3e 21 04 80 	movabs $0x8004213e3a,%rcx
  800420dfdc:	00 00 00 
  800420dfdf:	48 ba 47 3e 21 04 80 	movabs $0x8004213e47,%rdx
  800420dfe6:	00 00 00 
  800420dfe9:	be 57 00 00 00       	mov    $0x57,%esi
  800420dfee:	48 bf 5c 3e 21 04 80 	movabs $0x8004213e5c,%rdi
  800420dff5:	00 00 00 
  800420dff8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dffd:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420e004:	00 00 00 
  800420e007:	41 ff d0             	callq  *%r8
	assert(src != NULL);
  800420e00a:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420e00f:	75 35                	jne    800420e046 <_dwarf_frame_regtable_copy+0x91>
  800420e011:	48 b9 72 3e 21 04 80 	movabs $0x8004213e72,%rcx
  800420e018:	00 00 00 
  800420e01b:	48 ba 47 3e 21 04 80 	movabs $0x8004213e47,%rdx
  800420e022:	00 00 00 
  800420e025:	be 58 00 00 00       	mov    $0x58,%esi
  800420e02a:	48 bf 5c 3e 21 04 80 	movabs $0x8004213e5c,%rdi
  800420e031:	00 00 00 
  800420e034:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e039:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420e040:	00 00 00 
  800420e043:	41 ff d0             	callq  *%r8

	if (*dest == NULL) {
  800420e046:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e04a:	48 8b 00             	mov    (%rax),%rax
  800420e04d:	48 85 c0             	test   %rax,%rax
  800420e050:	75 39                	jne    800420e08b <_dwarf_frame_regtable_copy+0xd6>
		*dest = &global_rt_table_shadow;
  800420e052:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e056:	48 bb a0 db 2b 04 80 	movabs $0x80042bdba0,%rbx
  800420e05d:	00 00 00 
  800420e060:	48 89 18             	mov    %rbx,(%rax)
		(*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  800420e063:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e067:	48 8b 00             	mov    (%rax),%rax
  800420e06a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e06e:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  800420e072:	66 89 50 18          	mov    %dx,0x18(%rax)
		(*dest)->rt3_rules = global_rules_shadow;
  800420e076:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e07a:	48 8b 00             	mov    (%rax),%rax
  800420e07d:	48 bb 60 dd 2b 04 80 	movabs $0x80042bdd60,%rbx
  800420e084:	00 00 00 
  800420e087:	48 89 58 20          	mov    %rbx,0x20(%rax)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  800420e08b:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800420e08f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e093:	48 8b 00             	mov    (%rax),%rax
  800420e096:	ba 18 00 00 00       	mov    $0x18,%edx
  800420e09b:	48 89 ce             	mov    %rcx,%rsi
  800420e09e:	48 89 c7             	mov    %rax,%rdi
  800420e0a1:	48 b8 38 bc 20 04 80 	movabs $0x800420bc38,%rax
  800420e0a8:	00 00 00 
  800420e0ab:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  800420e0ad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  800420e0b4:	eb 5a                	jmp    800420e110 <_dwarf_frame_regtable_copy+0x15b>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  800420e0b6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e0ba:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e0be:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e0c1:	48 63 d0             	movslq %eax,%rdx
  800420e0c4:	48 89 d0             	mov    %rdx,%rax
  800420e0c7:	48 01 c0             	add    %rax,%rax
  800420e0ca:	48 01 d0             	add    %rdx,%rax
  800420e0cd:	48 c1 e0 03          	shl    $0x3,%rax
  800420e0d1:	48 01 c1             	add    %rax,%rcx
  800420e0d4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e0d8:	48 8b 00             	mov    (%rax),%rax
  800420e0db:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800420e0df:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e0e2:	48 63 d0             	movslq %eax,%rdx
  800420e0e5:	48 89 d0             	mov    %rdx,%rax
  800420e0e8:	48 01 c0             	add    %rax,%rax
  800420e0eb:	48 01 d0             	add    %rdx,%rax
  800420e0ee:	48 c1 e0 03          	shl    $0x3,%rax
  800420e0f2:	48 01 f0             	add    %rsi,%rax
  800420e0f5:	ba 18 00 00 00       	mov    $0x18,%edx
  800420e0fa:	48 89 ce             	mov    %rcx,%rsi
  800420e0fd:	48 89 c7             	mov    %rax,%rdi
  800420e100:	48 b8 38 bc 20 04 80 	movabs $0x800420bc38,%rax
  800420e107:	00 00 00 
  800420e10a:	ff d0                	callq  *%rax

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
  800420e10c:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  800420e110:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e114:	48 8b 00             	mov    (%rax),%rax
  800420e117:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420e11b:	0f b7 c0             	movzwl %ax,%eax
  800420e11e:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800420e121:	7e 10                	jle    800420e133 <_dwarf_frame_regtable_copy+0x17e>
		     i < src->rt3_reg_table_size; i++)
  800420e123:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e127:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420e12b:	0f b7 c0             	movzwl %ax,%eax
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  800420e12e:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800420e131:	7f 83                	jg     800420e0b6 <_dwarf_frame_regtable_copy+0x101>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  800420e133:	eb 32                	jmp    800420e167 <_dwarf_frame_regtable_copy+0x1b2>
		(*dest)->rt3_rules[i].dw_regnum =
  800420e135:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e139:	48 8b 00             	mov    (%rax),%rax
  800420e13c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e140:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e143:	48 63 d0             	movslq %eax,%rdx
  800420e146:	48 89 d0             	mov    %rdx,%rax
  800420e149:	48 01 c0             	add    %rax,%rax
  800420e14c:	48 01 d0             	add    %rdx,%rax
  800420e14f:	48 c1 e0 03          	shl    $0x3,%rax
  800420e153:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
			dbg->dbg_frame_undefined_value;
  800420e157:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e15b:	0f b7 40 50          	movzwl 0x50(%rax),%eax
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
		(*dest)->rt3_rules[i].dw_regnum =
  800420e15f:	66 89 42 02          	mov    %ax,0x2(%rdx)
	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  800420e163:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  800420e167:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e16b:	48 8b 00             	mov    (%rax),%rax
  800420e16e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420e172:	0f b7 c0             	movzwl %ax,%eax
  800420e175:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800420e178:	7f bb                	jg     800420e135 <_dwarf_frame_regtable_copy+0x180>
		(*dest)->rt3_rules[i].dw_regnum =
			dbg->dbg_frame_undefined_value;

	return (DW_DLE_NONE);
  800420e17a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420e17f:	48 83 c4 38          	add    $0x38,%rsp
  800420e183:	5b                   	pop    %rbx
  800420e184:	5d                   	pop    %rbp
  800420e185:	c3                   	retq   

000000800420e186 <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
		      Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
		      Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  800420e186:	55                   	push   %rbp
  800420e187:	48 89 e5             	mov    %rsp,%rbp
  800420e18a:	53                   	push   %rbx
  800420e18b:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  800420e192:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  800420e196:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  800420e19a:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  800420e19e:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  800420e1a2:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  800420e1a9:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
			ret = DW_DLE_DF_REG_NUM_TOO_HIGH;               \
			goto program_done;                              \
		}                                                       \
	} while(0)

	ret = DW_DLE_NONE;
  800420e1b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	init_rt = saved_rt = NULL;
  800420e1b7:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  800420e1be:	00 
  800420e1bf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e1c3:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	*row_pc = pc;
  800420e1c7:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420e1cb:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420e1cf:	48 89 10             	mov    %rdx,(%rax)

	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  800420e1d2:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420e1d6:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800420e1da:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  800420e1de:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e1e2:	48 89 c7             	mov    %rax,%rdi
  800420e1e5:	48 b8 b5 df 20 04 80 	movabs $0x800420dfb5,%rax
  800420e1ec:	00 00 00 
  800420e1ef:	ff d0                	callq  *%rax
	p = insts;
  800420e1f1:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800420e1f5:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	pe = p + len;
  800420e1f9:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e1fd:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800420e201:	48 01 d0             	add    %rdx,%rax
  800420e204:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	while (p < pe) {
  800420e208:	e9 3a 0d 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		if (*p == DW_CFA_nop) {
  800420e20d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420e211:	0f b6 00             	movzbl (%rax),%eax
  800420e214:	84 c0                	test   %al,%al
  800420e216:	75 11                	jne    800420e229 <_dwarf_frame_run_inst+0xa3>
			p++;
  800420e218:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420e21c:	48 83 c0 01          	add    $0x1,%rax
  800420e220:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			continue;
  800420e224:	e9 1e 0d 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		}

		high2 = *p & 0xc0;
  800420e229:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420e22d:	0f b6 00             	movzbl (%rax),%eax
  800420e230:	83 e0 c0             	and    $0xffffffc0,%eax
  800420e233:	88 45 df             	mov    %al,-0x21(%rbp)
		low6 = *p & 0x3f;
  800420e236:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420e23a:	0f b6 00             	movzbl (%rax),%eax
  800420e23d:	83 e0 3f             	and    $0x3f,%eax
  800420e240:	88 45 de             	mov    %al,-0x22(%rbp)
		p++;
  800420e243:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420e247:	48 83 c0 01          	add    $0x1,%rax
  800420e24b:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

		if (high2 > 0) {
  800420e24f:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  800420e253:	0f 84 a1 01 00 00    	je     800420e3fa <_dwarf_frame_run_inst+0x274>
			switch (high2) {
  800420e259:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800420e25d:	3d 80 00 00 00       	cmp    $0x80,%eax
  800420e262:	74 38                	je     800420e29c <_dwarf_frame_run_inst+0x116>
  800420e264:	3d c0 00 00 00       	cmp    $0xc0,%eax
  800420e269:	0f 84 01 01 00 00    	je     800420e370 <_dwarf_frame_run_inst+0x1ea>
  800420e26f:	83 f8 40             	cmp    $0x40,%eax
  800420e272:	0f 85 71 01 00 00    	jne    800420e3e9 <_dwarf_frame_run_inst+0x263>
			case DW_CFA_advance_loc:
			        pc += low6 * caf;
  800420e278:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  800420e27c:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800420e283:	ff 
  800420e284:	48 01 45 10          	add    %rax,0x10(%rbp)
			        if (pc_req < pc)
  800420e288:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800420e28c:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800420e290:	73 05                	jae    800420e297 <_dwarf_frame_run_inst+0x111>
			                goto program_done;
  800420e292:	e9 be 0c 00 00       	jmpq   800420ef55 <_dwarf_frame_run_inst+0xdcf>
			        break;
  800420e297:	e9 59 01 00 00       	jmpq   800420e3f5 <_dwarf_frame_run_inst+0x26f>
			case DW_CFA_offset:
			        *row_pc = pc;
  800420e29c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420e2a0:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420e2a4:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  800420e2a7:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800420e2ab:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e2af:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420e2b3:	66 39 c2             	cmp    %ax,%dx
  800420e2b6:	72 0c                	jb     800420e2c4 <_dwarf_frame_run_inst+0x13e>
  800420e2b8:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420e2bf:	e9 91 0c 00 00       	jmpq   800420ef55 <_dwarf_frame_run_inst+0xdcf>
			        RL[low6].dw_offset_relevant = 1;
  800420e2c4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e2c8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e2cc:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800420e2d0:	48 89 d0             	mov    %rdx,%rax
  800420e2d3:	48 01 c0             	add    %rax,%rax
  800420e2d6:	48 01 d0             	add    %rdx,%rax
  800420e2d9:	48 c1 e0 03          	shl    $0x3,%rax
  800420e2dd:	48 01 c8             	add    %rcx,%rax
  800420e2e0:	c6 00 01             	movb   $0x1,(%rax)
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
  800420e2e3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e2e7:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e2eb:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800420e2ef:	48 89 d0             	mov    %rdx,%rax
  800420e2f2:	48 01 c0             	add    %rax,%rax
  800420e2f5:	48 01 d0             	add    %rdx,%rax
  800420e2f8:	48 c1 e0 03          	shl    $0x3,%rax
  800420e2fc:	48 01 c8             	add    %rcx,%rax
  800420e2ff:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  800420e303:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e307:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e30b:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800420e30f:	48 89 d0             	mov    %rdx,%rax
  800420e312:	48 01 c0             	add    %rax,%rax
  800420e315:	48 01 d0             	add    %rdx,%rax
  800420e318:	48 c1 e0 03          	shl    $0x3,%rax
  800420e31c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420e320:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e324:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800420e328:	66 89 42 02          	mov    %ax,0x2(%rdx)
			        RL[low6].dw_offset_or_block_len =
  800420e32c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e330:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e334:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800420e338:	48 89 d0             	mov    %rdx,%rax
  800420e33b:	48 01 c0             	add    %rax,%rax
  800420e33e:	48 01 d0             	add    %rdx,%rax
  800420e341:	48 c1 e0 03          	shl    $0x3,%rax
  800420e345:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
					_dwarf_decode_uleb128(&p) * daf;
  800420e349:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420e34d:	48 89 c7             	mov    %rax,%rdi
  800420e350:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420e357:	00 00 00 
  800420e35a:	ff d0                	callq  *%rax
  800420e35c:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800420e363:	48 0f af c2          	imul   %rdx,%rax
			        *row_pc = pc;
			        CHECK_TABLE_SIZE(low6);
			        RL[low6].dw_offset_relevant = 1;
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
			        RL[low6].dw_offset_or_block_len =
  800420e367:	48 89 43 08          	mov    %rax,0x8(%rbx)
					_dwarf_decode_uleb128(&p) * daf;
			        break;
  800420e36b:	e9 85 00 00 00       	jmpq   800420e3f5 <_dwarf_frame_run_inst+0x26f>
			case DW_CFA_restore:
			        *row_pc = pc;
  800420e370:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420e374:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420e378:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  800420e37b:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800420e37f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e383:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420e387:	66 39 c2             	cmp    %ax,%dx
  800420e38a:	72 0c                	jb     800420e398 <_dwarf_frame_run_inst+0x212>
  800420e38c:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420e393:	e9 bd 0b 00 00       	jmpq   800420ef55 <_dwarf_frame_run_inst+0xdcf>
			        memcpy(&RL[low6], &INITRL[low6],
  800420e398:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420e39c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e3a0:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800420e3a4:	48 89 d0             	mov    %rdx,%rax
  800420e3a7:	48 01 c0             	add    %rax,%rax
  800420e3aa:	48 01 d0             	add    %rdx,%rax
  800420e3ad:	48 c1 e0 03          	shl    $0x3,%rax
  800420e3b1:	48 01 c1             	add    %rax,%rcx
  800420e3b4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e3b8:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800420e3bc:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800420e3c0:	48 89 d0             	mov    %rdx,%rax
  800420e3c3:	48 01 c0             	add    %rax,%rax
  800420e3c6:	48 01 d0             	add    %rdx,%rax
  800420e3c9:	48 c1 e0 03          	shl    $0x3,%rax
  800420e3cd:	48 01 f0             	add    %rsi,%rax
  800420e3d0:	ba 18 00 00 00       	mov    $0x18,%edx
  800420e3d5:	48 89 ce             	mov    %rcx,%rsi
  800420e3d8:	48 89 c7             	mov    %rax,%rdi
  800420e3db:	48 b8 38 bc 20 04 80 	movabs $0x800420bc38,%rax
  800420e3e2:	00 00 00 
  800420e3e5:	ff d0                	callq  *%rax
				       sizeof(Dwarf_Regtable_Entry3));
			        break;
  800420e3e7:	eb 0c                	jmp    800420e3f5 <_dwarf_frame_run_inst+0x26f>
			default:
			        DWARF_SET_ERROR(dbg, error,
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
			        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  800420e3e9:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			        goto program_done;
  800420e3f0:	e9 60 0b 00 00       	jmpq   800420ef55 <_dwarf_frame_run_inst+0xdcf>
			}

			continue;
  800420e3f5:	e9 4d 0b 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		}

		switch (low6) {
  800420e3fa:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  800420e3fe:	83 f8 16             	cmp    $0x16,%eax
  800420e401:	0f 87 37 0b 00 00    	ja     800420ef3e <_dwarf_frame_run_inst+0xdb8>
  800420e407:	89 c0                	mov    %eax,%eax
  800420e409:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420e410:	00 
  800420e411:	48 b8 80 3e 21 04 80 	movabs $0x8004213e80,%rax
  800420e418:	00 00 00 
  800420e41b:	48 01 d0             	add    %rdx,%rax
  800420e41e:	48 8b 00             	mov    (%rax),%rax
  800420e421:	ff e0                	jmpq   *%rax
		case DW_CFA_set_loc:
			pc = dbg->decode(&p, dbg->dbg_pointer_size);
  800420e423:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e427:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420e42b:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420e42f:	8b 4a 28             	mov    0x28(%rdx),%ecx
  800420e432:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800420e436:	89 ce                	mov    %ecx,%esi
  800420e438:	48 89 d7             	mov    %rdx,%rdi
  800420e43b:	ff d0                	callq  *%rax
  800420e43d:	48 89 45 10          	mov    %rax,0x10(%rbp)
			if (pc_req < pc)
  800420e441:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800420e445:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800420e449:	73 05                	jae    800420e450 <_dwarf_frame_run_inst+0x2ca>
			        goto program_done;
  800420e44b:	e9 05 0b 00 00       	jmpq   800420ef55 <_dwarf_frame_run_inst+0xdcf>
			break;
  800420e450:	e9 f2 0a 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc1:
			pc += dbg->decode(&p, 1) * caf;
  800420e455:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e459:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420e45d:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800420e461:	be 01 00 00 00       	mov    $0x1,%esi
  800420e466:	48 89 d7             	mov    %rdx,%rdi
  800420e469:	ff d0                	callq  *%rax
  800420e46b:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800420e472:	ff 
  800420e473:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  800420e477:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800420e47b:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800420e47f:	73 05                	jae    800420e486 <_dwarf_frame_run_inst+0x300>
			        goto program_done;
  800420e481:	e9 cf 0a 00 00       	jmpq   800420ef55 <_dwarf_frame_run_inst+0xdcf>
			break;
  800420e486:	e9 bc 0a 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc2:
			pc += dbg->decode(&p, 2) * caf;
  800420e48b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e48f:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420e493:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800420e497:	be 02 00 00 00       	mov    $0x2,%esi
  800420e49c:	48 89 d7             	mov    %rdx,%rdi
  800420e49f:	ff d0                	callq  *%rax
  800420e4a1:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800420e4a8:	ff 
  800420e4a9:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  800420e4ad:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800420e4b1:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800420e4b5:	73 05                	jae    800420e4bc <_dwarf_frame_run_inst+0x336>
			        goto program_done;
  800420e4b7:	e9 99 0a 00 00       	jmpq   800420ef55 <_dwarf_frame_run_inst+0xdcf>
			break;
  800420e4bc:	e9 86 0a 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc4:
			pc += dbg->decode(&p, 4) * caf;
  800420e4c1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e4c5:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420e4c9:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800420e4cd:	be 04 00 00 00       	mov    $0x4,%esi
  800420e4d2:	48 89 d7             	mov    %rdx,%rdi
  800420e4d5:	ff d0                	callq  *%rax
  800420e4d7:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800420e4de:	ff 
  800420e4df:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  800420e4e3:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800420e4e7:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800420e4eb:	73 05                	jae    800420e4f2 <_dwarf_frame_run_inst+0x36c>
			        goto program_done;
  800420e4ed:	e9 63 0a 00 00       	jmpq   800420ef55 <_dwarf_frame_run_inst+0xdcf>
			break;
  800420e4f2:	e9 50 0a 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_offset_extended:
			*row_pc = pc;
  800420e4f7:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420e4fb:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420e4ff:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420e502:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420e506:	48 89 c7             	mov    %rax,%rdi
  800420e509:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420e510:	00 00 00 
  800420e513:	ff d0                	callq  *%rax
  800420e515:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  800420e519:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420e51d:	48 89 c7             	mov    %rax,%rdi
  800420e520:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420e527:	00 00 00 
  800420e52a:	ff d0                	callq  *%rax
  800420e52c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420e530:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e534:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420e538:	0f b7 c0             	movzwl %ax,%eax
  800420e53b:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420e53f:	77 0c                	ja     800420e54d <_dwarf_frame_run_inst+0x3c7>
  800420e541:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420e548:	e9 08 0a 00 00       	jmpq   800420ef55 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  800420e54d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e551:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e555:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e559:	48 89 d0             	mov    %rdx,%rax
  800420e55c:	48 01 c0             	add    %rax,%rax
  800420e55f:	48 01 d0             	add    %rdx,%rax
  800420e562:	48 c1 e0 03          	shl    $0x3,%rax
  800420e566:	48 01 c8             	add    %rcx,%rax
  800420e569:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  800420e56c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e570:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e574:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e578:	48 89 d0             	mov    %rdx,%rax
  800420e57b:	48 01 c0             	add    %rax,%rax
  800420e57e:	48 01 d0             	add    %rdx,%rax
  800420e581:	48 c1 e0 03          	shl    $0x3,%rax
  800420e585:	48 01 c8             	add    %rcx,%rax
  800420e588:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800420e58c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e590:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e594:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e598:	48 89 d0             	mov    %rdx,%rax
  800420e59b:	48 01 c0             	add    %rax,%rax
  800420e59e:	48 01 d0             	add    %rdx,%rax
  800420e5a1:	48 c1 e0 03          	shl    $0x3,%rax
  800420e5a5:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420e5a9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e5ad:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800420e5b1:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  800420e5b5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e5b9:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e5bd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e5c1:	48 89 d0             	mov    %rdx,%rax
  800420e5c4:	48 01 c0             	add    %rax,%rax
  800420e5c7:	48 01 d0             	add    %rdx,%rax
  800420e5ca:	48 c1 e0 03          	shl    $0x3,%rax
  800420e5ce:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420e5d2:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420e5d9:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  800420e5de:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  800420e5e2:	e9 60 09 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_restore_extended:
			*row_pc = pc;
  800420e5e7:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420e5eb:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420e5ef:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420e5f2:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420e5f6:	48 89 c7             	mov    %rax,%rdi
  800420e5f9:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420e600:	00 00 00 
  800420e603:	ff d0                	callq  *%rax
  800420e605:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420e609:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e60d:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420e611:	0f b7 c0             	movzwl %ax,%eax
  800420e614:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420e618:	77 0c                	ja     800420e626 <_dwarf_frame_run_inst+0x4a0>
  800420e61a:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420e621:	e9 2f 09 00 00       	jmpq   800420ef55 <_dwarf_frame_run_inst+0xdcf>
			memcpy(&RL[reg], &INITRL[reg],
  800420e626:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420e62a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e62e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e632:	48 89 d0             	mov    %rdx,%rax
  800420e635:	48 01 c0             	add    %rax,%rax
  800420e638:	48 01 d0             	add    %rdx,%rax
  800420e63b:	48 c1 e0 03          	shl    $0x3,%rax
  800420e63f:	48 01 c1             	add    %rax,%rcx
  800420e642:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e646:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800420e64a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e64e:	48 89 d0             	mov    %rdx,%rax
  800420e651:	48 01 c0             	add    %rax,%rax
  800420e654:	48 01 d0             	add    %rdx,%rax
  800420e657:	48 c1 e0 03          	shl    $0x3,%rax
  800420e65b:	48 01 f0             	add    %rsi,%rax
  800420e65e:	ba 18 00 00 00       	mov    $0x18,%edx
  800420e663:	48 89 ce             	mov    %rcx,%rsi
  800420e666:	48 89 c7             	mov    %rax,%rdi
  800420e669:	48 b8 38 bc 20 04 80 	movabs $0x800420bc38,%rax
  800420e670:	00 00 00 
  800420e673:	ff d0                	callq  *%rax
			       sizeof(Dwarf_Regtable_Entry3));
			break;
  800420e675:	e9 cd 08 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_undefined:
			*row_pc = pc;
  800420e67a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420e67e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420e682:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420e685:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420e689:	48 89 c7             	mov    %rax,%rdi
  800420e68c:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420e693:	00 00 00 
  800420e696:	ff d0                	callq  *%rax
  800420e698:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420e69c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e6a0:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420e6a4:	0f b7 c0             	movzwl %ax,%eax
  800420e6a7:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420e6ab:	77 0c                	ja     800420e6b9 <_dwarf_frame_run_inst+0x533>
  800420e6ad:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420e6b4:	e9 9c 08 00 00       	jmpq   800420ef55 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  800420e6b9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e6bd:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e6c1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e6c5:	48 89 d0             	mov    %rdx,%rax
  800420e6c8:	48 01 c0             	add    %rax,%rax
  800420e6cb:	48 01 d0             	add    %rdx,%rax
  800420e6ce:	48 c1 e0 03          	shl    $0x3,%rax
  800420e6d2:	48 01 c8             	add    %rcx,%rax
  800420e6d5:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  800420e6d8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e6dc:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e6e0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e6e4:	48 89 d0             	mov    %rdx,%rax
  800420e6e7:	48 01 c0             	add    %rax,%rax
  800420e6ea:	48 01 d0             	add    %rdx,%rax
  800420e6ed:	48 c1 e0 03          	shl    $0x3,%rax
  800420e6f1:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420e6f5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e6f9:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  800420e6fd:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  800420e701:	e9 41 08 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_same_value:
			reg = _dwarf_decode_uleb128(&p);
  800420e706:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420e70a:	48 89 c7             	mov    %rax,%rdi
  800420e70d:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420e714:	00 00 00 
  800420e717:	ff d0                	callq  *%rax
  800420e719:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420e71d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e721:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420e725:	0f b7 c0             	movzwl %ax,%eax
  800420e728:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420e72c:	77 0c                	ja     800420e73a <_dwarf_frame_run_inst+0x5b4>
  800420e72e:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420e735:	e9 1b 08 00 00       	jmpq   800420ef55 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  800420e73a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e73e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e742:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e746:	48 89 d0             	mov    %rdx,%rax
  800420e749:	48 01 c0             	add    %rax,%rax
  800420e74c:	48 01 d0             	add    %rdx,%rax
  800420e74f:	48 c1 e0 03          	shl    $0x3,%rax
  800420e753:	48 01 c8             	add    %rcx,%rax
  800420e756:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  800420e759:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e75d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e761:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e765:	48 89 d0             	mov    %rdx,%rax
  800420e768:	48 01 c0             	add    %rax,%rax
  800420e76b:	48 01 d0             	add    %rdx,%rax
  800420e76e:	48 c1 e0 03          	shl    $0x3,%rax
  800420e772:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420e776:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e77a:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  800420e77e:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  800420e782:	e9 c0 07 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_register:
			*row_pc = pc;
  800420e787:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420e78b:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420e78f:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420e792:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420e796:	48 89 c7             	mov    %rax,%rdi
  800420e799:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420e7a0:	00 00 00 
  800420e7a3:	ff d0                	callq  *%rax
  800420e7a5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			reg2 = _dwarf_decode_uleb128(&p);
  800420e7a9:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420e7ad:	48 89 c7             	mov    %rax,%rdi
  800420e7b0:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420e7b7:	00 00 00 
  800420e7ba:	ff d0                	callq  *%rax
  800420e7bc:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420e7c0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e7c4:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420e7c8:	0f b7 c0             	movzwl %ax,%eax
  800420e7cb:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420e7cf:	77 0c                	ja     800420e7dd <_dwarf_frame_run_inst+0x657>
  800420e7d1:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420e7d8:	e9 78 07 00 00       	jmpq   800420ef55 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  800420e7dd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e7e1:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e7e5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e7e9:	48 89 d0             	mov    %rdx,%rax
  800420e7ec:	48 01 c0             	add    %rax,%rax
  800420e7ef:	48 01 d0             	add    %rdx,%rax
  800420e7f2:	48 c1 e0 03          	shl    $0x3,%rax
  800420e7f6:	48 01 c8             	add    %rcx,%rax
  800420e7f9:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = reg2;
  800420e7fc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e800:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e804:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e808:	48 89 d0             	mov    %rdx,%rax
  800420e80b:	48 01 c0             	add    %rax,%rax
  800420e80e:	48 01 d0             	add    %rdx,%rax
  800420e811:	48 c1 e0 03          	shl    $0x3,%rax
  800420e815:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420e819:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420e81d:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  800420e821:	e9 21 07 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_remember_state:
			_dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  800420e826:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420e82a:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800420e82e:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  800420e832:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e836:	48 89 c7             	mov    %rax,%rdi
  800420e839:	48 b8 b5 df 20 04 80 	movabs $0x800420dfb5,%rax
  800420e840:	00 00 00 
  800420e843:	ff d0                	callq  *%rax
			break;
  800420e845:	e9 fd 06 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_restore_state:
			*row_pc = pc;
  800420e84a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420e84e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420e852:	48 89 10             	mov    %rdx,(%rax)
			_dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  800420e855:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420e859:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800420e85d:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800420e861:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e865:	48 89 c7             	mov    %rax,%rdi
  800420e868:	48 b8 b5 df 20 04 80 	movabs $0x800420dfb5,%rax
  800420e86f:	00 00 00 
  800420e872:	ff d0                	callq  *%rax
			break;
  800420e874:	e9 ce 06 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa:
			*row_pc = pc;
  800420e879:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420e87d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420e881:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420e884:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420e888:	48 89 c7             	mov    %rax,%rdi
  800420e88b:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420e892:	00 00 00 
  800420e895:	ff d0                	callq  *%rax
  800420e897:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  800420e89b:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420e89f:	48 89 c7             	mov    %rax,%rdi
  800420e8a2:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420e8a9:	00 00 00 
  800420e8ac:	ff d0                	callq  *%rax
  800420e8ae:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  800420e8b2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e8b6:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  800420e8b9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e8bd:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  800420e8c1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e8c5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e8c9:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = uoff;
  800420e8cd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e8d1:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e8d5:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  800420e8d9:	e9 69 06 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_register:
			*row_pc = pc;
  800420e8de:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420e8e2:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420e8e6:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420e8e9:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420e8ed:	48 89 c7             	mov    %rax,%rdi
  800420e8f0:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420e8f7:	00 00 00 
  800420e8fa:	ff d0                	callq  *%rax
  800420e8fc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CFA.dw_regnum = reg;
  800420e900:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e904:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e908:	66 89 50 02          	mov    %dx,0x2(%rax)
			 * Note that DW_CFA_def_cfa_register change the CFA
			 * rule register while keep the old offset. So we
			 * should not touch the CFA.dw_offset_relevant flag
			 * here.
			 */
			break;
  800420e90c:	e9 36 06 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_offset:
			*row_pc = pc;
  800420e911:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420e915:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420e919:	48 89 10             	mov    %rdx,(%rax)
			uoff = _dwarf_decode_uleb128(&p);
  800420e91c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420e920:	48 89 c7             	mov    %rax,%rdi
  800420e923:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420e92a:	00 00 00 
  800420e92d:	ff d0                	callq  *%rax
  800420e92f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  800420e933:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e937:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  800420e93a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e93e:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = uoff;
  800420e942:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e946:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e94a:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  800420e94e:	e9 f4 05 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_expression:
			*row_pc = pc;
  800420e953:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420e957:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420e95b:	48 89 10             	mov    %rdx,(%rax)
			CFA.dw_offset_relevant = 0;
  800420e95e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e962:	c6 00 00             	movb   $0x0,(%rax)
			CFA.dw_value_type = DW_EXPR_EXPRESSION;
  800420e965:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e969:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  800420e96d:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  800420e971:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420e975:	48 89 c7             	mov    %rax,%rdi
  800420e978:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420e97f:	00 00 00 
  800420e982:	ff d0                	callq  *%rax
  800420e984:	48 89 43 08          	mov    %rax,0x8(%rbx)
			CFA.dw_block_ptr = p;
  800420e988:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e98c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e990:	48 89 50 10          	mov    %rdx,0x10(%rax)
			p += CFA.dw_offset_or_block_len;
  800420e994:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e998:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e99c:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e9a0:	48 01 d0             	add    %rdx,%rax
  800420e9a3:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  800420e9a7:	e9 9b 05 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_expression:
			*row_pc = pc;
  800420e9ac:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420e9b0:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420e9b4:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420e9b7:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420e9bb:	48 89 c7             	mov    %rax,%rdi
  800420e9be:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420e9c5:	00 00 00 
  800420e9c8:	ff d0                	callq  *%rax
  800420e9ca:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420e9ce:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e9d2:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420e9d6:	0f b7 c0             	movzwl %ax,%eax
  800420e9d9:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420e9dd:	77 0c                	ja     800420e9eb <_dwarf_frame_run_inst+0x865>
  800420e9df:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420e9e6:	e9 6a 05 00 00       	jmpq   800420ef55 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  800420e9eb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420e9ef:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420e9f3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e9f7:	48 89 d0             	mov    %rdx,%rax
  800420e9fa:	48 01 c0             	add    %rax,%rax
  800420e9fd:	48 01 d0             	add    %rdx,%rax
  800420ea00:	48 c1 e0 03          	shl    $0x3,%rax
  800420ea04:	48 01 c8             	add    %rcx,%rax
  800420ea07:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  800420ea0a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ea0e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ea12:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ea16:	48 89 d0             	mov    %rdx,%rax
  800420ea19:	48 01 c0             	add    %rax,%rax
  800420ea1c:	48 01 d0             	add    %rdx,%rax
  800420ea1f:	48 c1 e0 03          	shl    $0x3,%rax
  800420ea23:	48 01 c8             	add    %rcx,%rax
  800420ea26:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  800420ea2a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ea2e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ea32:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ea36:	48 89 d0             	mov    %rdx,%rax
  800420ea39:	48 01 c0             	add    %rax,%rax
  800420ea3c:	48 01 d0             	add    %rdx,%rax
  800420ea3f:	48 c1 e0 03          	shl    $0x3,%rax
  800420ea43:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  800420ea47:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420ea4b:	48 89 c7             	mov    %rax,%rdi
  800420ea4e:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420ea55:	00 00 00 
  800420ea58:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  800420ea5a:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  800420ea5e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ea62:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ea66:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ea6a:	48 89 d0             	mov    %rdx,%rax
  800420ea6d:	48 01 c0             	add    %rax,%rax
  800420ea70:	48 01 d0             	add    %rdx,%rax
  800420ea73:	48 c1 e0 03          	shl    $0x3,%rax
  800420ea77:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420ea7b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420ea7f:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  800420ea83:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420ea87:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ea8b:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800420ea8f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ea93:	48 89 d0             	mov    %rdx,%rax
  800420ea96:	48 01 c0             	add    %rax,%rax
  800420ea99:	48 01 d0             	add    %rdx,%rax
  800420ea9c:	48 c1 e0 03          	shl    $0x3,%rax
  800420eaa0:	48 01 f0             	add    %rsi,%rax
  800420eaa3:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420eaa7:	48 01 c8             	add    %rcx,%rax
  800420eaaa:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  800420eaae:	e9 94 04 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_offset_extended_sf:
			*row_pc = pc;
  800420eab3:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420eab7:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420eabb:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420eabe:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420eac2:	48 89 c7             	mov    %rax,%rdi
  800420eac5:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420eacc:	00 00 00 
  800420eacf:	ff d0                	callq  *%rax
  800420ead1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  800420ead5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420ead9:	48 89 c7             	mov    %rax,%rdi
  800420eadc:	48 b8 27 c6 20 04 80 	movabs $0x800420c627,%rax
  800420eae3:	00 00 00 
  800420eae6:	ff d0                	callq  *%rax
  800420eae8:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420eaec:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420eaf0:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420eaf4:	0f b7 c0             	movzwl %ax,%eax
  800420eaf7:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420eafb:	77 0c                	ja     800420eb09 <_dwarf_frame_run_inst+0x983>
  800420eafd:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420eb04:	e9 4c 04 00 00       	jmpq   800420ef55 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  800420eb09:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420eb0d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420eb11:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420eb15:	48 89 d0             	mov    %rdx,%rax
  800420eb18:	48 01 c0             	add    %rax,%rax
  800420eb1b:	48 01 d0             	add    %rdx,%rax
  800420eb1e:	48 c1 e0 03          	shl    $0x3,%rax
  800420eb22:	48 01 c8             	add    %rcx,%rax
  800420eb25:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  800420eb28:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420eb2c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420eb30:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420eb34:	48 89 d0             	mov    %rdx,%rax
  800420eb37:	48 01 c0             	add    %rax,%rax
  800420eb3a:	48 01 d0             	add    %rdx,%rax
  800420eb3d:	48 c1 e0 03          	shl    $0x3,%rax
  800420eb41:	48 01 c8             	add    %rcx,%rax
  800420eb44:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800420eb48:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420eb4c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420eb50:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420eb54:	48 89 d0             	mov    %rdx,%rax
  800420eb57:	48 01 c0             	add    %rax,%rax
  800420eb5a:	48 01 d0             	add    %rdx,%rax
  800420eb5d:	48 c1 e0 03          	shl    $0x3,%rax
  800420eb61:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420eb65:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420eb69:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800420eb6d:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  800420eb71:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420eb75:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420eb79:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420eb7d:	48 89 d0             	mov    %rdx,%rax
  800420eb80:	48 01 c0             	add    %rax,%rax
  800420eb83:	48 01 d0             	add    %rdx,%rax
  800420eb86:	48 c1 e0 03          	shl    $0x3,%rax
  800420eb8a:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420eb8e:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420eb95:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  800420eb9a:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  800420eb9e:	e9 a4 03 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_sf:
			*row_pc = pc;
  800420eba3:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420eba7:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420ebab:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420ebae:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420ebb2:	48 89 c7             	mov    %rax,%rdi
  800420ebb5:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420ebbc:	00 00 00 
  800420ebbf:	ff d0                	callq  *%rax
  800420ebc1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  800420ebc5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420ebc9:	48 89 c7             	mov    %rax,%rdi
  800420ebcc:	48 b8 27 c6 20 04 80 	movabs $0x800420c627,%rax
  800420ebd3:	00 00 00 
  800420ebd6:	ff d0                	callq  *%rax
  800420ebd8:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  800420ebdc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ebe0:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  800420ebe3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ebe7:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  800420ebeb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ebef:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ebf3:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  800420ebf7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ebfb:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800420ec02:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  800420ec07:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  800420ec0b:	e9 37 03 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_offset_sf:
			*row_pc = pc;
  800420ec10:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420ec14:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420ec18:	48 89 10             	mov    %rdx,(%rax)
			soff = _dwarf_decode_sleb128(&p);
  800420ec1b:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420ec1f:	48 89 c7             	mov    %rax,%rdi
  800420ec22:	48 b8 27 c6 20 04 80 	movabs $0x800420c627,%rax
  800420ec29:	00 00 00 
  800420ec2c:	ff d0                	callq  *%rax
  800420ec2e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  800420ec32:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ec36:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  800420ec39:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ec3d:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  800420ec41:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ec45:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800420ec4c:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  800420ec51:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  800420ec55:	e9 ed 02 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_offset:
			*row_pc = pc;
  800420ec5a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420ec5e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420ec62:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420ec65:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420ec69:	48 89 c7             	mov    %rax,%rdi
  800420ec6c:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420ec73:	00 00 00 
  800420ec76:	ff d0                	callq  *%rax
  800420ec78:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  800420ec7c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420ec80:	48 89 c7             	mov    %rax,%rdi
  800420ec83:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420ec8a:	00 00 00 
  800420ec8d:	ff d0                	callq  *%rax
  800420ec8f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420ec93:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ec97:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420ec9b:	0f b7 c0             	movzwl %ax,%eax
  800420ec9e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420eca2:	77 0c                	ja     800420ecb0 <_dwarf_frame_run_inst+0xb2a>
  800420eca4:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420ecab:	e9 a5 02 00 00       	jmpq   800420ef55 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  800420ecb0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ecb4:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ecb8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ecbc:	48 89 d0             	mov    %rdx,%rax
  800420ecbf:	48 01 c0             	add    %rax,%rax
  800420ecc2:	48 01 d0             	add    %rdx,%rax
  800420ecc5:	48 c1 e0 03          	shl    $0x3,%rax
  800420ecc9:	48 01 c8             	add    %rcx,%rax
  800420eccc:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  800420eccf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ecd3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ecd7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ecdb:	48 89 d0             	mov    %rdx,%rax
  800420ecde:	48 01 c0             	add    %rax,%rax
  800420ece1:	48 01 d0             	add    %rdx,%rax
  800420ece4:	48 c1 e0 03          	shl    $0x3,%rax
  800420ece8:	48 01 c8             	add    %rcx,%rax
  800420eceb:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800420ecef:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ecf3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ecf7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ecfb:	48 89 d0             	mov    %rdx,%rax
  800420ecfe:	48 01 c0             	add    %rax,%rax
  800420ed01:	48 01 d0             	add    %rdx,%rax
  800420ed04:	48 c1 e0 03          	shl    $0x3,%rax
  800420ed08:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420ed0c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420ed10:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800420ed14:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  800420ed18:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ed1c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ed20:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ed24:	48 89 d0             	mov    %rdx,%rax
  800420ed27:	48 01 c0             	add    %rax,%rax
  800420ed2a:	48 01 d0             	add    %rdx,%rax
  800420ed2d:	48 c1 e0 03          	shl    $0x3,%rax
  800420ed31:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420ed35:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420ed3c:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  800420ed41:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  800420ed45:	e9 fd 01 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_offset_sf:
			*row_pc = pc;
  800420ed4a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420ed4e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420ed52:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420ed55:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420ed59:	48 89 c7             	mov    %rax,%rdi
  800420ed5c:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420ed63:	00 00 00 
  800420ed66:	ff d0                	callq  *%rax
  800420ed68:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  800420ed6c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420ed70:	48 89 c7             	mov    %rax,%rdi
  800420ed73:	48 b8 27 c6 20 04 80 	movabs $0x800420c627,%rax
  800420ed7a:	00 00 00 
  800420ed7d:	ff d0                	callq  *%rax
  800420ed7f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420ed83:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ed87:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420ed8b:	0f b7 c0             	movzwl %ax,%eax
  800420ed8e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420ed92:	77 0c                	ja     800420eda0 <_dwarf_frame_run_inst+0xc1a>
  800420ed94:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420ed9b:	e9 b5 01 00 00       	jmpq   800420ef55 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  800420eda0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420eda4:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420eda8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420edac:	48 89 d0             	mov    %rdx,%rax
  800420edaf:	48 01 c0             	add    %rax,%rax
  800420edb2:	48 01 d0             	add    %rdx,%rax
  800420edb5:	48 c1 e0 03          	shl    $0x3,%rax
  800420edb9:	48 01 c8             	add    %rcx,%rax
  800420edbc:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  800420edbf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420edc3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420edc7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420edcb:	48 89 d0             	mov    %rdx,%rax
  800420edce:	48 01 c0             	add    %rax,%rax
  800420edd1:	48 01 d0             	add    %rdx,%rax
  800420edd4:	48 c1 e0 03          	shl    $0x3,%rax
  800420edd8:	48 01 c8             	add    %rcx,%rax
  800420eddb:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800420eddf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ede3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ede7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420edeb:	48 89 d0             	mov    %rdx,%rax
  800420edee:	48 01 c0             	add    %rax,%rax
  800420edf1:	48 01 d0             	add    %rdx,%rax
  800420edf4:	48 c1 e0 03          	shl    $0x3,%rax
  800420edf8:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420edfc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420ee00:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800420ee04:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  800420ee08:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ee0c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ee10:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ee14:	48 89 d0             	mov    %rdx,%rax
  800420ee17:	48 01 c0             	add    %rax,%rax
  800420ee1a:	48 01 d0             	add    %rdx,%rax
  800420ee1d:	48 c1 e0 03          	shl    $0x3,%rax
  800420ee21:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420ee25:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420ee2c:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  800420ee31:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  800420ee35:	e9 0d 01 00 00       	jmpq   800420ef47 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_expression:
			*row_pc = pc;
  800420ee3a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420ee3e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800420ee42:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800420ee45:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420ee49:	48 89 c7             	mov    %rax,%rdi
  800420ee4c:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420ee53:	00 00 00 
  800420ee56:	ff d0                	callq  *%rax
  800420ee58:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800420ee5c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ee60:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420ee64:	0f b7 c0             	movzwl %ax,%eax
  800420ee67:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420ee6b:	77 0c                	ja     800420ee79 <_dwarf_frame_run_inst+0xcf3>
  800420ee6d:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800420ee74:	e9 dc 00 00 00       	jmpq   800420ef55 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  800420ee79:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ee7d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420ee81:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ee85:	48 89 d0             	mov    %rdx,%rax
  800420ee88:	48 01 c0             	add    %rax,%rax
  800420ee8b:	48 01 d0             	add    %rdx,%rax
  800420ee8e:	48 c1 e0 03          	shl    $0x3,%rax
  800420ee92:	48 01 c8             	add    %rcx,%rax
  800420ee95:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  800420ee98:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ee9c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420eea0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420eea4:	48 89 d0             	mov    %rdx,%rax
  800420eea7:	48 01 c0             	add    %rax,%rax
  800420eeaa:	48 01 d0             	add    %rdx,%rax
  800420eead:	48 c1 e0 03          	shl    $0x3,%rax
  800420eeb1:	48 01 c8             	add    %rcx,%rax
  800420eeb4:	c6 40 01 03          	movb   $0x3,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  800420eeb8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420eebc:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420eec0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420eec4:	48 89 d0             	mov    %rdx,%rax
  800420eec7:	48 01 c0             	add    %rax,%rax
  800420eeca:	48 01 d0             	add    %rdx,%rax
  800420eecd:	48 c1 e0 03          	shl    $0x3,%rax
  800420eed1:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  800420eed5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420eed9:	48 89 c7             	mov    %rax,%rdi
  800420eedc:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  800420eee3:	00 00 00 
  800420eee6:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  800420eee8:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  800420eeec:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420eef0:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420eef4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420eef8:	48 89 d0             	mov    %rdx,%rax
  800420eefb:	48 01 c0             	add    %rax,%rax
  800420eefe:	48 01 d0             	add    %rdx,%rax
  800420ef01:	48 c1 e0 03          	shl    $0x3,%rax
  800420ef05:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420ef09:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420ef0d:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  800420ef11:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420ef15:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420ef19:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800420ef1d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ef21:	48 89 d0             	mov    %rdx,%rax
  800420ef24:	48 01 c0             	add    %rax,%rax
  800420ef27:	48 01 d0             	add    %rdx,%rax
  800420ef2a:	48 c1 e0 03          	shl    $0x3,%rax
  800420ef2e:	48 01 f0             	add    %rsi,%rax
  800420ef31:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420ef35:	48 01 c8             	add    %rcx,%rax
  800420ef38:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  800420ef3c:	eb 09                	jmp    800420ef47 <_dwarf_frame_run_inst+0xdc1>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_INSTR_EXEC_ERROR);
			ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  800420ef3e:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			goto program_done;
  800420ef45:	eb 0e                	jmp    800420ef55 <_dwarf_frame_run_inst+0xdcf>
	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
	p = insts;
	pe = p + len;

	while (p < pe) {
  800420ef47:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420ef4b:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420ef4f:	0f 82 b8 f2 ff ff    	jb     800420e20d <_dwarf_frame_run_inst+0x87>
			goto program_done;
		}
	}

program_done:
	return (ret);
  800420ef55:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  800420ef58:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  800420ef5f:	5b                   	pop    %rbx
  800420ef60:	5d                   	pop    %rbp
  800420ef61:	c3                   	retq   

000000800420ef62 <_dwarf_frame_get_internal_table>:
int
_dwarf_frame_get_internal_table(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_req, Dwarf_Regtable3 **ret_rt,
				Dwarf_Addr *ret_row_pc,
				Dwarf_Error *error)
{
  800420ef62:	55                   	push   %rbp
  800420ef63:	48 89 e5             	mov    %rsp,%rbp
  800420ef66:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  800420ef6a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420ef6e:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420ef72:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420ef76:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  800420ef7a:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  800420ef7e:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Cie cie;
	Dwarf_Regtable3 *rt;
	Dwarf_Addr row_pc;
	int i, ret;

	assert(ret_rt != NULL);
  800420ef82:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  800420ef87:	75 35                	jne    800420efbe <_dwarf_frame_get_internal_table+0x5c>
  800420ef89:	48 b9 38 3f 21 04 80 	movabs $0x8004213f38,%rcx
  800420ef90:	00 00 00 
  800420ef93:	48 ba 47 3e 21 04 80 	movabs $0x8004213e47,%rdx
  800420ef9a:	00 00 00 
  800420ef9d:	be 83 01 00 00       	mov    $0x183,%esi
  800420efa2:	48 bf 5c 3e 21 04 80 	movabs $0x8004213e5c,%rdi
  800420efa9:	00 00 00 
  800420efac:	b8 00 00 00 00       	mov    $0x0,%eax
  800420efb1:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420efb8:	00 00 00 
  800420efbb:	41 ff d0             	callq  *%r8

	//dbg = fde->fde_dbg;
	assert(dbg != NULL);
  800420efbe:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420efc3:	75 35                	jne    800420effa <_dwarf_frame_get_internal_table+0x98>
  800420efc5:	48 b9 47 3f 21 04 80 	movabs $0x8004213f47,%rcx
  800420efcc:	00 00 00 
  800420efcf:	48 ba 47 3e 21 04 80 	movabs $0x8004213e47,%rdx
  800420efd6:	00 00 00 
  800420efd9:	be 86 01 00 00       	mov    $0x186,%esi
  800420efde:	48 bf 5c 3e 21 04 80 	movabs $0x8004213e5c,%rdi
  800420efe5:	00 00 00 
  800420efe8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420efed:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420eff4:	00 00 00 
  800420eff7:	41 ff d0             	callq  *%r8

	rt = dbg->dbg_internal_reg_table;
  800420effa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420effe:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420f002:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	/* Clear the content of regtable from previous run. */
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  800420f006:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f00a:	ba 18 00 00 00       	mov    $0x18,%edx
  800420f00f:	be 00 00 00 00       	mov    $0x0,%esi
  800420f014:	48 89 c7             	mov    %rax,%rdi
  800420f017:	48 b8 96 ba 20 04 80 	movabs $0x800420ba96,%rax
  800420f01e:	00 00 00 
  800420f021:	ff d0                	callq  *%rax
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  800420f023:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f027:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420f02b:	0f b7 d0             	movzwl %ax,%edx
  800420f02e:	48 89 d0             	mov    %rdx,%rax
  800420f031:	48 01 c0             	add    %rax,%rax
  800420f034:	48 01 d0             	add    %rdx,%rax
  800420f037:	48 c1 e0 03          	shl    $0x3,%rax
  800420f03b:	48 89 c2             	mov    %rax,%rdx
  800420f03e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f042:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420f046:	be 00 00 00 00       	mov    $0x0,%esi
  800420f04b:	48 89 c7             	mov    %rax,%rdi
  800420f04e:	48 b8 96 ba 20 04 80 	movabs $0x800420ba96,%rax
  800420f055:	00 00 00 
  800420f058:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  800420f05a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420f061:	eb 2f                	jmp    800420f092 <_dwarf_frame_get_internal_table+0x130>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  800420f063:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f067:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f06b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f06e:	48 63 d0             	movslq %eax,%rdx
  800420f071:	48 89 d0             	mov    %rdx,%rax
  800420f074:	48 01 c0             	add    %rax,%rax
  800420f077:	48 01 d0             	add    %rdx,%rax
  800420f07a:	48 c1 e0 03          	shl    $0x3,%rax
  800420f07e:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800420f082:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f086:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  800420f08a:	66 89 42 02          	mov    %ax,0x2(%rdx)
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  800420f08e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420f092:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f096:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800420f09a:	0f b7 c0             	movzwl %ax,%eax
  800420f09d:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800420f0a0:	7f c1                	jg     800420f063 <_dwarf_frame_get_internal_table+0x101>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

	/* Run initial instructions in CIE. */
	cie = fde->fde_cie;
  800420f0a2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f0a6:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f0aa:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	assert(cie != NULL);
  800420f0ae:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f0b3:	75 35                	jne    800420f0ea <_dwarf_frame_get_internal_table+0x188>
  800420f0b5:	48 b9 53 3f 21 04 80 	movabs $0x8004213f53,%rcx
  800420f0bc:	00 00 00 
  800420f0bf:	48 ba 47 3e 21 04 80 	movabs $0x8004213e47,%rdx
  800420f0c6:	00 00 00 
  800420f0c9:	be 95 01 00 00       	mov    $0x195,%esi
  800420f0ce:	48 bf 5c 3e 21 04 80 	movabs $0x8004213e5c,%rdi
  800420f0d5:	00 00 00 
  800420f0d8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f0dd:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420f0e4:	00 00 00 
  800420f0e7:	41 ff d0             	callq  *%r8
	ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  800420f0ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f0ee:	4c 8b 48 40          	mov    0x40(%rax),%r9
  800420f0f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f0f6:	4c 8b 40 38          	mov    0x38(%rax),%r8
  800420f0fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f0fe:	48 8b 48 70          	mov    0x70(%rax),%rcx
  800420f102:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f106:	48 8b 50 68          	mov    0x68(%rax),%rdx
  800420f10a:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420f10e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f112:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  800420f116:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420f11b:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  800420f11f:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420f124:	48 c7 44 24 08 ff ff 	movq   $0xffffffffffffffff,0x8(%rsp)
  800420f12b:	ff ff 
  800420f12d:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  800420f134:	00 
  800420f135:	48 89 c7             	mov    %rax,%rdi
  800420f138:	48 b8 86 e1 20 04 80 	movabs $0x800420e186,%rax
  800420f13f:	00 00 00 
  800420f142:	ff d0                	callq  *%rax
  800420f144:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    cie->cie_instlen, cie->cie_caf,
				    cie->cie_daf, 0, ~0ULL,
				    &row_pc, error);
	if (ret != DW_DLE_NONE)
  800420f147:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420f14b:	74 08                	je     800420f155 <_dwarf_frame_get_internal_table+0x1f3>
		return (ret);
  800420f14d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f150:	e9 98 00 00 00       	jmpq   800420f1ed <_dwarf_frame_get_internal_table+0x28b>
	/* Run instructions in FDE. */
	if (pc_req >= fde->fde_initloc) {
  800420f155:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f159:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420f15d:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800420f161:	77 6f                	ja     800420f1d2 <_dwarf_frame_get_internal_table+0x270>
		ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  800420f163:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f167:	48 8b 78 30          	mov    0x30(%rax),%rdi
  800420f16b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f16f:	4c 8b 48 40          	mov    0x40(%rax),%r9
  800420f173:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f177:	4c 8b 50 38          	mov    0x38(%rax),%r10
  800420f17b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f17f:	48 8b 48 58          	mov    0x58(%rax),%rcx
  800420f183:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f187:	48 8b 50 50          	mov    0x50(%rax),%rdx
  800420f18b:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420f18f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f193:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
  800420f197:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  800420f19c:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  800420f1a0:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  800420f1a5:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  800420f1a9:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  800420f1ae:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420f1b2:	4d 89 d0             	mov    %r10,%r8
  800420f1b5:	48 89 c7             	mov    %rax,%rdi
  800420f1b8:	48 b8 86 e1 20 04 80 	movabs $0x800420e186,%rax
  800420f1bf:	00 00 00 
  800420f1c2:	ff d0                	callq  *%rax
  800420f1c4:	89 45 e4             	mov    %eax,-0x1c(%rbp)
					    fde->fde_instlen, cie->cie_caf,
					    cie->cie_daf,
					    fde->fde_initloc, pc_req,
					    &row_pc, error);
		if (ret != DW_DLE_NONE)
  800420f1c7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420f1cb:	74 05                	je     800420f1d2 <_dwarf_frame_get_internal_table+0x270>
			return (ret);
  800420f1cd:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f1d0:	eb 1b                	jmp    800420f1ed <_dwarf_frame_get_internal_table+0x28b>
	}

	*ret_rt = rt;
  800420f1d2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420f1d6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f1da:	48 89 10             	mov    %rdx,(%rax)
	*ret_row_pc = row_pc;
  800420f1dd:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420f1e1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f1e5:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  800420f1e8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f1ed:	c9                   	leaveq 
  800420f1ee:	c3                   	retq   

000000800420f1ef <dwarf_get_fde_info_for_all_regs>:
int
dwarf_get_fde_info_for_all_regs(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_requested,
				Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc,
				Dwarf_Error *error)
{
  800420f1ef:	55                   	push   %rbp
  800420f1f0:	48 89 e5             	mov    %rsp,%rbp
  800420f1f3:	48 83 ec 50          	sub    $0x50,%rsp
  800420f1f7:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420f1fb:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420f1ff:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800420f203:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  800420f207:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  800420f20b:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
	Dwarf_Regtable3 *rt;
	Dwarf_Addr pc;
	Dwarf_Half cfa;
	int i, ret;

	if (fde == NULL || reg_table == NULL) {
  800420f20f:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420f214:	74 07                	je     800420f21d <dwarf_get_fde_info_for_all_regs+0x2e>
  800420f216:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800420f21b:	75 0a                	jne    800420f227 <dwarf_get_fde_info_for_all_regs+0x38>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  800420f21d:	b8 01 00 00 00       	mov    $0x1,%eax
  800420f222:	e9 eb 02 00 00       	jmpq   800420f512 <dwarf_get_fde_info_for_all_regs+0x323>
	}

	assert(dbg != NULL);
  800420f227:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420f22c:	75 35                	jne    800420f263 <dwarf_get_fde_info_for_all_regs+0x74>
  800420f22e:	48 b9 47 3f 21 04 80 	movabs $0x8004213f47,%rcx
  800420f235:	00 00 00 
  800420f238:	48 ba 47 3e 21 04 80 	movabs $0x8004213e47,%rdx
  800420f23f:	00 00 00 
  800420f242:	be bf 01 00 00       	mov    $0x1bf,%esi
  800420f247:	48 bf 5c 3e 21 04 80 	movabs $0x8004213e5c,%rdi
  800420f24e:	00 00 00 
  800420f251:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f256:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420f25d:	00 00 00 
  800420f260:	41 ff d0             	callq  *%r8

	if (pc_requested < fde->fde_initloc ||
  800420f263:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f267:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420f26b:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  800420f26f:	77 19                	ja     800420f28a <dwarf_get_fde_info_for_all_regs+0x9b>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  800420f271:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f275:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420f279:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f27d:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420f281:	48 01 d0             	add    %rdx,%rax
		return (DW_DLV_ERROR);
	}

	assert(dbg != NULL);

	if (pc_requested < fde->fde_initloc ||
  800420f284:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  800420f288:	77 0a                	ja     800420f294 <dwarf_get_fde_info_for_all_regs+0xa5>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
		return (DW_DLV_ERROR);
  800420f28a:	b8 01 00 00 00       	mov    $0x1,%eax
  800420f28f:	e9 7e 02 00 00       	jmpq   800420f512 <dwarf_get_fde_info_for_all_regs+0x323>
	}

	ret = _dwarf_frame_get_internal_table(dbg, fde, pc_requested, &rt, &pc,
  800420f294:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
  800420f298:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  800420f29c:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420f2a0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f2a4:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420f2a8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f2ac:	4d 89 c1             	mov    %r8,%r9
  800420f2af:	49 89 f8             	mov    %rdi,%r8
  800420f2b2:	48 89 c7             	mov    %rax,%rdi
  800420f2b5:	48 b8 62 ef 20 04 80 	movabs $0x800420ef62,%rax
  800420f2bc:	00 00 00 
  800420f2bf:	ff d0                	callq  *%rax
  800420f2c1:	89 45 f8             	mov    %eax,-0x8(%rbp)
					      error);
	if (ret != DW_DLE_NONE)
  800420f2c4:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420f2c8:	74 0a                	je     800420f2d4 <dwarf_get_fde_info_for_all_regs+0xe5>
		return (DW_DLV_ERROR);
  800420f2ca:	b8 01 00 00 00       	mov    $0x1,%eax
  800420f2cf:	e9 3e 02 00 00       	jmpq   800420f512 <dwarf_get_fde_info_for_all_regs+0x323>
	/*
	 * Copy the CFA rule to the column intended for holding the CFA,
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
  800420f2d4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f2d8:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800420f2dc:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	if (cfa < DW_REG_TABLE_SIZE) {
  800420f2e0:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  800420f2e5:	0f 87 b1 00 00 00    	ja     800420f39c <dwarf_get_fde_info_for_all_regs+0x1ad>
		reg_table->rules[cfa].dw_offset_relevant =
  800420f2eb:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
			CFA.dw_offset_relevant;
  800420f2ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f2f3:	0f b6 00             	movzbl (%rax),%eax
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
	if (cfa < DW_REG_TABLE_SIZE) {
		reg_table->rules[cfa].dw_offset_relevant =
  800420f2f6:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f2fa:	48 63 c9             	movslq %ecx,%rcx
  800420f2fd:	48 83 c1 01          	add    $0x1,%rcx
  800420f301:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f305:	48 01 ca             	add    %rcx,%rdx
  800420f308:	88 02                	mov    %al,(%rdx)
			CFA.dw_offset_relevant;
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
  800420f30a:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800420f30e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f312:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  800420f316:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f31a:	48 63 c9             	movslq %ecx,%rcx
  800420f31d:	48 83 c1 01          	add    $0x1,%rcx
  800420f321:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f325:	48 01 ca             	add    %rcx,%rdx
  800420f328:	88 42 01             	mov    %al,0x1(%rdx)
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  800420f32b:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800420f32f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f333:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  800420f337:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f33b:	48 63 c9             	movslq %ecx,%rcx
  800420f33e:	48 83 c1 01          	add    $0x1,%rcx
  800420f342:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f346:	48 01 ca             	add    %rcx,%rdx
  800420f349:	66 89 42 02          	mov    %ax,0x2(%rdx)
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  800420f34d:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800420f351:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f355:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f359:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f35d:	48 63 c9             	movslq %ecx,%rcx
  800420f360:	48 83 c1 01          	add    $0x1,%rcx
  800420f364:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f368:	48 01 ca             	add    %rcx,%rdx
  800420f36b:	48 83 c2 08          	add    $0x8,%rdx
  800420f36f:	48 89 02             	mov    %rax,(%rdx)
		reg_table->cfa_rule = reg_table->rules[cfa];
  800420f372:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  800420f376:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420f37a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f37e:	48 63 d2             	movslq %edx,%rdx
  800420f381:	48 83 c2 01          	add    $0x1,%rdx
  800420f385:	48 c1 e2 04          	shl    $0x4,%rdx
  800420f389:	48 01 d0             	add    %rdx,%rax
  800420f38c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420f390:	48 8b 00             	mov    (%rax),%rax
  800420f393:	48 89 01             	mov    %rax,(%rcx)
  800420f396:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  800420f39a:	eb 3c                	jmp    800420f3d8 <dwarf_get_fde_info_for_all_regs+0x1e9>
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
		    CFA.dw_offset_relevant;
  800420f39c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f3a0:	0f b6 10             	movzbl (%rax),%edx
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
		reg_table->cfa_rule = reg_table->rules[cfa];
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
  800420f3a3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f3a7:	88 10                	mov    %dl,(%rax)
		    CFA.dw_offset_relevant;
		reg_table->cfa_rule.dw_value_type = CFA.dw_value_type;
  800420f3a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f3ad:	0f b6 50 01          	movzbl 0x1(%rax),%edx
  800420f3b1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f3b5:	88 50 01             	mov    %dl,0x1(%rax)
		reg_table->cfa_rule.dw_regnum = CFA.dw_regnum;
  800420f3b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f3bc:	0f b7 50 02          	movzwl 0x2(%rax),%edx
  800420f3c0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f3c4:	66 89 50 02          	mov    %dx,0x2(%rax)
		reg_table->cfa_rule.dw_offset = CFA.dw_offset_or_block_len;
  800420f3c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f3cc:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420f3d0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f3d4:	48 89 50 08          	mov    %rdx,0x8(%rax)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  800420f3d8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420f3df:	e9 fd 00 00 00       	jmpq   800420f4e1 <dwarf_get_fde_info_for_all_regs+0x2f2>
	     i++) {

		/* Do not overwrite CFA column */
		if (i == cfa)
  800420f3e4:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  800420f3e8:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800420f3eb:	75 05                	jne    800420f3f2 <dwarf_get_fde_info_for_all_regs+0x203>
			continue;
  800420f3ed:	e9 eb 00 00 00       	jmpq   800420f4dd <dwarf_get_fde_info_for_all_regs+0x2ee>

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
  800420f3f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f3f6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f3fa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f3fd:	48 63 d0             	movslq %eax,%rdx
  800420f400:	48 89 d0             	mov    %rdx,%rax
  800420f403:	48 01 c0             	add    %rax,%rax
  800420f406:	48 01 d0             	add    %rdx,%rax
  800420f409:	48 c1 e0 03          	shl    $0x3,%rax
  800420f40d:	48 01 c8             	add    %rcx,%rax
  800420f410:	0f b6 00             	movzbl (%rax),%eax

		/* Do not overwrite CFA column */
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
  800420f413:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f417:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800420f41a:	48 63 c9             	movslq %ecx,%rcx
  800420f41d:	48 83 c1 01          	add    $0x1,%rcx
  800420f421:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f425:	48 01 ca             	add    %rcx,%rdx
  800420f428:	88 02                	mov    %al,(%rdx)
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
  800420f42a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f42e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f432:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f435:	48 63 d0             	movslq %eax,%rdx
  800420f438:	48 89 d0             	mov    %rdx,%rax
  800420f43b:	48 01 c0             	add    %rax,%rax
  800420f43e:	48 01 d0             	add    %rdx,%rax
  800420f441:	48 c1 e0 03          	shl    $0x3,%rax
  800420f445:	48 01 c8             	add    %rcx,%rax
  800420f448:	0f b6 40 01          	movzbl 0x1(%rax),%eax
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
  800420f44c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f450:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800420f453:	48 63 c9             	movslq %ecx,%rcx
  800420f456:	48 83 c1 01          	add    $0x1,%rcx
  800420f45a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f45e:	48 01 ca             	add    %rcx,%rdx
  800420f461:	88 42 01             	mov    %al,0x1(%rdx)
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  800420f464:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f468:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f46c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f46f:	48 63 d0             	movslq %eax,%rdx
  800420f472:	48 89 d0             	mov    %rdx,%rax
  800420f475:	48 01 c0             	add    %rax,%rax
  800420f478:	48 01 d0             	add    %rdx,%rax
  800420f47b:	48 c1 e0 03          	shl    $0x3,%rax
  800420f47f:	48 01 c8             	add    %rcx,%rax
  800420f482:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  800420f486:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f48a:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800420f48d:	48 63 c9             	movslq %ecx,%rcx
  800420f490:	48 83 c1 01          	add    $0x1,%rcx
  800420f494:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f498:	48 01 ca             	add    %rcx,%rdx
  800420f49b:	66 89 42 02          	mov    %ax,0x2(%rdx)
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
  800420f49f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f4a3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420f4a7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f4aa:	48 63 d0             	movslq %eax,%rdx
  800420f4ad:	48 89 d0             	mov    %rdx,%rax
  800420f4b0:	48 01 c0             	add    %rax,%rax
  800420f4b3:	48 01 d0             	add    %rdx,%rax
  800420f4b6:	48 c1 e0 03          	shl    $0x3,%rax
  800420f4ba:	48 01 c8             	add    %rcx,%rax
  800420f4bd:	48 8b 40 08          	mov    0x8(%rax),%rax
		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
  800420f4c1:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f4c5:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800420f4c8:	48 63 c9             	movslq %ecx,%rcx
  800420f4cb:	48 83 c1 01          	add    $0x1,%rcx
  800420f4cf:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f4d3:	48 01 ca             	add    %rcx,%rdx
  800420f4d6:	48 83 c2 08          	add    $0x8,%rdx
  800420f4da:	48 89 02             	mov    %rax,(%rdx)

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
	     i++) {
  800420f4dd:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  800420f4e1:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  800420f4e5:	7f 14                	jg     800420f4fb <dwarf_get_fde_info_for_all_regs+0x30c>
  800420f4e7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f4eb:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  800420f4ef:	0f b7 c0             	movzwl %ax,%eax
  800420f4f2:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800420f4f5:	0f 8f e9 fe ff ff    	jg     800420f3e4 <dwarf_get_fde_info_for_all_regs+0x1f5>
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
	}

	if (row_pc) *row_pc = pc;
  800420f4fb:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  800420f500:	74 0b                	je     800420f50d <dwarf_get_fde_info_for_all_regs+0x31e>
  800420f502:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f506:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420f50a:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLV_OK);
  800420f50d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f512:	c9                   	leaveq 
  800420f513:	c3                   	retq   

000000800420f514 <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
			      uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  800420f514:	55                   	push   %rbp
  800420f515:	48 89 e5             	mov    %rsp,%rbp
  800420f518:	48 83 ec 40          	sub    $0x40,%rsp
  800420f51c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f520:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f524:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420f528:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  800420f52c:	44 89 c0             	mov    %r8d,%eax
  800420f52f:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  800420f533:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  800420f536:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  800420f53a:	75 0a                	jne    800420f546 <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  800420f53c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f541:	e9 e6 01 00 00       	jmpq   800420f72c <_dwarf_frame_read_lsb_encoded+0x218>

	application = encode & 0xf0;
  800420f546:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800420f54a:	83 e0 f0             	and    $0xfffffff0,%eax
  800420f54d:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  800420f550:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  800420f554:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800420f558:	83 f8 0c             	cmp    $0xc,%eax
  800420f55b:	0f 87 72 01 00 00    	ja     800420f6d3 <_dwarf_frame_read_lsb_encoded+0x1bf>
  800420f561:	89 c0                	mov    %eax,%eax
  800420f563:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420f56a:	00 
  800420f56b:	48 b8 60 3f 21 04 80 	movabs $0x8004213f60,%rax
  800420f572:	00 00 00 
  800420f575:	48 01 d0             	add    %rdx,%rax
  800420f578:	48 8b 00             	mov    (%rax),%rax
  800420f57b:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  800420f57d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f581:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f585:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f589:	8b 52 28             	mov    0x28(%rdx),%edx
  800420f58c:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420f590:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420f594:	48 89 cf             	mov    %rcx,%rdi
  800420f597:	ff d0                	callq  *%rax
  800420f599:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f59d:	48 89 02             	mov    %rax,(%rdx)
		break;
  800420f5a0:	e9 35 01 00 00       	jmpq   800420f6da <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  800420f5a5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f5a9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f5ad:	48 89 d6             	mov    %rdx,%rsi
  800420f5b0:	48 89 c7             	mov    %rax,%rdi
  800420f5b3:	48 b8 a8 c5 20 04 80 	movabs $0x800420c5a8,%rax
  800420f5ba:	00 00 00 
  800420f5bd:	ff d0                	callq  *%rax
  800420f5bf:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f5c3:	48 89 02             	mov    %rax,(%rdx)
		break;
  800420f5c6:	e9 0f 01 00 00       	jmpq   800420f6da <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  800420f5cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f5cf:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f5d3:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420f5d7:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420f5db:	ba 02 00 00 00       	mov    $0x2,%edx
  800420f5e0:	48 89 cf             	mov    %rcx,%rdi
  800420f5e3:	ff d0                	callq  *%rax
  800420f5e5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f5e9:	48 89 02             	mov    %rax,(%rdx)
		break;
  800420f5ec:	e9 e9 00 00 00       	jmpq   800420f6da <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  800420f5f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f5f5:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f5f9:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420f5fd:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420f601:	ba 04 00 00 00       	mov    $0x4,%edx
  800420f606:	48 89 cf             	mov    %rcx,%rdi
  800420f609:	ff d0                	callq  *%rax
  800420f60b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f60f:	48 89 02             	mov    %rax,(%rdx)
		break;
  800420f612:	e9 c3 00 00 00       	jmpq   800420f6da <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  800420f617:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f61b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f61f:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420f623:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420f627:	ba 08 00 00 00       	mov    $0x8,%edx
  800420f62c:	48 89 cf             	mov    %rcx,%rdi
  800420f62f:	ff d0                	callq  *%rax
  800420f631:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f635:	48 89 02             	mov    %rax,(%rdx)
		break;
  800420f638:	e9 9d 00 00 00       	jmpq   800420f6da <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  800420f63d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420f641:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f645:	48 89 d6             	mov    %rdx,%rsi
  800420f648:	48 89 c7             	mov    %rax,%rdi
  800420f64b:	48 b8 04 c5 20 04 80 	movabs $0x800420c504,%rax
  800420f652:	00 00 00 
  800420f655:	ff d0                	callq  *%rax
  800420f657:	48 89 c2             	mov    %rax,%rdx
  800420f65a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f65e:	48 89 10             	mov    %rdx,(%rax)
		break;
  800420f661:	eb 77                	jmp    800420f6da <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  800420f663:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f667:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f66b:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420f66f:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420f673:	ba 02 00 00 00       	mov    $0x2,%edx
  800420f678:	48 89 cf             	mov    %rcx,%rdi
  800420f67b:	ff d0                	callq  *%rax
  800420f67d:	48 0f bf d0          	movswq %ax,%rdx
  800420f681:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f685:	48 89 10             	mov    %rdx,(%rax)
		break;
  800420f688:	eb 50                	jmp    800420f6da <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  800420f68a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f68e:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f692:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420f696:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420f69a:	ba 04 00 00 00       	mov    $0x4,%edx
  800420f69f:	48 89 cf             	mov    %rcx,%rdi
  800420f6a2:	ff d0                	callq  *%rax
  800420f6a4:	48 63 d0             	movslq %eax,%rdx
  800420f6a7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f6ab:	48 89 10             	mov    %rdx,(%rax)
		break;
  800420f6ae:	eb 2a                	jmp    800420f6da <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  800420f6b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6b4:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f6b8:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420f6bc:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420f6c0:	ba 08 00 00 00       	mov    $0x8,%edx
  800420f6c5:	48 89 cf             	mov    %rcx,%rdi
  800420f6c8:	ff d0                	callq  *%rax
  800420f6ca:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f6ce:	48 89 02             	mov    %rax,(%rdx)
		break;
  800420f6d1:	eb 07                	jmp    800420f6da <_dwarf_frame_read_lsb_encoded+0x1c6>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  800420f6d3:	b8 14 00 00 00       	mov    $0x14,%eax
  800420f6d8:	eb 52                	jmp    800420f72c <_dwarf_frame_read_lsb_encoded+0x218>
	}

	if (application == DW_EH_PE_pcrel) {
  800420f6da:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  800420f6de:	75 47                	jne    800420f727 <_dwarf_frame_read_lsb_encoded+0x213>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  800420f6e0:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800420f6e4:	83 f8 01             	cmp    $0x1,%eax
  800420f6e7:	7c 3d                	jl     800420f726 <_dwarf_frame_read_lsb_encoded+0x212>
  800420f6e9:	83 f8 04             	cmp    $0x4,%eax
  800420f6ec:	7e 0a                	jle    800420f6f8 <_dwarf_frame_read_lsb_encoded+0x1e4>
  800420f6ee:	83 e8 09             	sub    $0x9,%eax
  800420f6f1:	83 f8 03             	cmp    $0x3,%eax
  800420f6f4:	77 30                	ja     800420f726 <_dwarf_frame_read_lsb_encoded+0x212>
  800420f6f6:	eb 17                	jmp    800420f70f <_dwarf_frame_read_lsb_encoded+0x1fb>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  800420f6f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f6fc:	48 8b 10             	mov    (%rax),%rdx
  800420f6ff:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f703:	48 01 c2             	add    %rax,%rdx
  800420f706:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f70a:	48 89 10             	mov    %rdx,(%rax)
			break;
  800420f70d:	eb 18                	jmp    800420f727 <_dwarf_frame_read_lsb_encoded+0x213>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  800420f70f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f713:	48 8b 10             	mov    (%rax),%rdx
  800420f716:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f71a:	48 01 c2             	add    %rax,%rdx
  800420f71d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f721:	48 89 10             	mov    %rdx,(%rax)
			break;
  800420f724:	eb 01                	jmp    800420f727 <_dwarf_frame_read_lsb_encoded+0x213>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  800420f726:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  800420f727:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f72c:	c9                   	leaveq 
  800420f72d:	c3                   	retq   

000000800420f72e <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
				   Dwarf_Error *error)
{
  800420f72e:	55                   	push   %rbp
  800420f72f:	48 89 e5             	mov    %rsp,%rbp
  800420f732:	48 83 ec 50          	sub    $0x50,%rsp
  800420f736:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420f73a:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420f73e:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  800420f742:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f746:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420f74a:	48 85 c0             	test   %rax,%rax
  800420f74d:	74 0f                	je     800420f75e <_dwarf_frame_parse_lsb_cie_augment+0x30>
  800420f74f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f753:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420f757:	0f b6 00             	movzbl (%rax),%eax
  800420f75a:	3c 7a                	cmp    $0x7a,%al
  800420f75c:	74 35                	je     800420f793 <_dwarf_frame_parse_lsb_cie_augment+0x65>
  800420f75e:	48 b9 c8 3f 21 04 80 	movabs $0x8004213fc8,%rcx
  800420f765:	00 00 00 
  800420f768:	48 ba 47 3e 21 04 80 	movabs $0x8004213e47,%rdx
  800420f76f:	00 00 00 
  800420f772:	be 4a 02 00 00       	mov    $0x24a,%esi
  800420f777:	48 bf 5c 3e 21 04 80 	movabs $0x8004213e5c,%rdi
  800420f77e:	00 00 00 
  800420f781:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f786:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420f78d:	00 00 00 
  800420f790:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  800420f793:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f797:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420f79b:	48 83 c0 01          	add    $0x1,%rax
  800420f79f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  800420f7a3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f7a7:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420f7ab:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  800420f7af:	e9 af 00 00 00       	jmpq   800420f863 <_dwarf_frame_parse_lsb_cie_augment+0x135>
		switch (*aug_p) {
  800420f7b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f7b8:	0f b6 00             	movzbl (%rax),%eax
  800420f7bb:	0f b6 c0             	movzbl %al,%eax
  800420f7be:	83 f8 50             	cmp    $0x50,%eax
  800420f7c1:	74 18                	je     800420f7db <_dwarf_frame_parse_lsb_cie_augment+0xad>
  800420f7c3:	83 f8 52             	cmp    $0x52,%eax
  800420f7c6:	74 77                	je     800420f83f <_dwarf_frame_parse_lsb_cie_augment+0x111>
  800420f7c8:	83 f8 4c             	cmp    $0x4c,%eax
  800420f7cb:	0f 85 86 00 00 00    	jne    800420f857 <_dwarf_frame_parse_lsb_cie_augment+0x129>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  800420f7d1:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  800420f7d6:	e9 83 00 00 00       	jmpq   800420f85e <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  800420f7db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f7df:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f7e3:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  800420f7e7:	0f b6 00             	movzbl (%rax),%eax
  800420f7ea:	88 45 ef             	mov    %al,-0x11(%rbp)
			offset = 0;
  800420f7ed:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  800420f7f4:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  800420f7f5:	44 0f b6 45 ef       	movzbl -0x11(%rbp),%r8d
  800420f7fa:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800420f7fe:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f802:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  800420f806:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f80a:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  800420f80e:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420f812:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420f818:	48 89 c7             	mov    %rax,%rdi
  800420f81b:	48 b8 14 f5 20 04 80 	movabs $0x800420f514,%rax
  800420f822:	00 00 00 
  800420f825:	ff d0                	callq  *%rax
  800420f827:	89 45 e8             	mov    %eax,-0x18(%rbp)
							    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  800420f82a:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800420f82e:	74 05                	je     800420f835 <_dwarf_frame_parse_lsb_cie_augment+0x107>
				return (ret);
  800420f830:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420f833:	eb 42                	jmp    800420f877 <_dwarf_frame_parse_lsb_cie_augment+0x149>
			augdata_p += offset;
  800420f835:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f839:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  800420f83d:	eb 1f                	jmp    800420f85e <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  800420f83f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f843:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f847:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  800420f84b:	0f b6 10             	movzbl (%rax),%edx
  800420f84e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f852:	88 50 60             	mov    %dl,0x60(%rax)
			break;
  800420f855:	eb 07                	jmp    800420f85e <_dwarf_frame_parse_lsb_cie_augment+0x130>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  800420f857:	b8 14 00 00 00       	mov    $0x14,%eax
  800420f85c:	eb 19                	jmp    800420f877 <_dwarf_frame_parse_lsb_cie_augment+0x149>
		}
		aug_p++;
  800420f85e:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
	augdata_p = cie->cie_augdata;
	while (*aug_p != '\0') {
  800420f863:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f867:	0f b6 00             	movzbl (%rax),%eax
  800420f86a:	84 c0                	test   %al,%al
  800420f86c:	0f 85 42 ff ff ff    	jne    800420f7b4 <_dwarf_frame_parse_lsb_cie_augment+0x86>
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		}
		aug_p++;
	}

	return (DW_DLE_NONE);
  800420f872:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f877:	c9                   	leaveq 
  800420f878:	c3                   	retq   

000000800420f879 <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, Dwarf_Cie ret_cie, Dwarf_Error *error)
{
  800420f879:	55                   	push   %rbp
  800420f87a:	48 89 e5             	mov    %rsp,%rbp
  800420f87d:	48 83 ec 60          	sub    $0x60,%rsp
  800420f881:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420f885:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420f889:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420f88d:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  800420f891:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  800420f895:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  800420f89a:	75 35                	jne    800420f8d1 <_dwarf_frame_set_cie+0x58>
  800420f89c:	48 b9 fd 3f 21 04 80 	movabs $0x8004213ffd,%rcx
  800420f8a3:	00 00 00 
  800420f8a6:	48 ba 47 3e 21 04 80 	movabs $0x8004213e47,%rdx
  800420f8ad:	00 00 00 
  800420f8b0:	be 7b 02 00 00       	mov    $0x27b,%esi
  800420f8b5:	48 bf 5c 3e 21 04 80 	movabs $0x8004213e5c,%rdi
  800420f8bc:	00 00 00 
  800420f8bf:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f8c4:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  800420f8cb:	00 00 00 
  800420f8ce:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  800420f8d1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420f8d5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  800420f8d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8dd:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f8e1:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  800420f8e4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420f8e8:	48 8b 10             	mov    (%rax),%rdx
  800420f8eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8ef:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  800420f8f3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f8f7:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f8fb:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f8ff:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800420f903:	48 89 d1             	mov    %rdx,%rcx
  800420f906:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  800420f90a:	ba 04 00 00 00       	mov    $0x4,%edx
  800420f90f:	48 89 cf             	mov    %rcx,%rdi
  800420f912:	ff d0                	callq  *%rax
  800420f914:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  800420f918:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420f91d:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800420f921:	75 2e                	jne    800420f951 <_dwarf_frame_set_cie+0xd8>
		dwarf_size = 8;
  800420f923:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  800420f92a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f92e:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f932:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f936:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800420f93a:	48 89 d1             	mov    %rdx,%rcx
  800420f93d:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  800420f941:	ba 08 00 00 00       	mov    $0x8,%edx
  800420f946:	48 89 cf             	mov    %rcx,%rdi
  800420f949:	ff d0                	callq  *%rax
  800420f94b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f94f:	eb 07                	jmp    800420f958 <_dwarf_frame_set_cie+0xdf>
	} else
		dwarf_size = 4;
  800420f951:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  800420f958:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f95c:	48 8b 50 40          	mov    0x40(%rax),%rdx
  800420f960:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420f964:	48 8b 00             	mov    (%rax),%rax
  800420f967:	48 29 c2             	sub    %rax,%rdx
  800420f96a:	48 89 d0             	mov    %rdx,%rax
  800420f96d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420f971:	73 0a                	jae    800420f97d <_dwarf_frame_set_cie+0x104>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  800420f973:	b8 12 00 00 00       	mov    $0x12,%eax
  800420f978:	e9 5d 03 00 00       	jmpq   800420fcda <_dwarf_frame_set_cie+0x461>
	}

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
  800420f97d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f981:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f985:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f989:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800420f98d:	48 89 d1             	mov    %rdx,%rcx
  800420f990:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420f993:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  800420f997:	48 89 cf             	mov    %rcx,%rdi
  800420f99a:	ff d0                	callq  *%rax
	cie->cie_length = length;
  800420f99c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f9a0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420f9a4:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  800420f9a8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f9ac:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f9b0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f9b4:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800420f9b8:	48 89 d1             	mov    %rdx,%rcx
  800420f9bb:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  800420f9bf:	ba 01 00 00 00       	mov    $0x1,%edx
  800420f9c4:	48 89 cf             	mov    %rcx,%rdi
  800420f9c7:	ff d0                	callq  *%rax
  800420f9c9:	89 c2                	mov    %eax,%edx
  800420f9cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f9cf:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  800420f9d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f9d7:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  800420f9db:	66 83 f8 01          	cmp    $0x1,%ax
  800420f9df:	74 26                	je     800420fa07 <_dwarf_frame_set_cie+0x18e>
  800420f9e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f9e5:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  800420f9e9:	66 83 f8 03          	cmp    $0x3,%ax
  800420f9ed:	74 18                	je     800420fa07 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
  800420f9ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f9f3:	0f b7 40 20          	movzwl 0x20(%rax),%eax

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
	cie->cie_length = length;

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  800420f9f7:	66 83 f8 04          	cmp    $0x4,%ax
  800420f9fb:	74 0a                	je     800420fa07 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  800420f9fd:	b8 16 00 00 00       	mov    $0x16,%eax
  800420fa02:	e9 d3 02 00 00       	jmpq   800420fcda <_dwarf_frame_set_cie+0x461>
	}

	cie->cie_augment = (uint8_t *)dbg->dbg_eh_offset + *off;
  800420fa07:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420fa0b:	48 8b 10             	mov    (%rax),%rdx
  800420fa0e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fa12:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420fa16:	48 01 d0             	add    %rdx,%rax
  800420fa19:	48 89 c2             	mov    %rax,%rdx
  800420fa1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa20:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *)dbg->dbg_eh_offset;
  800420fa24:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fa28:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420fa2c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  800420fa30:	90                   	nop
  800420fa31:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420fa35:	48 8b 00             	mov    (%rax),%rax
  800420fa38:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800420fa3c:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420fa40:	48 89 0a             	mov    %rcx,(%rdx)
  800420fa43:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420fa47:	48 01 d0             	add    %rdx,%rax
  800420fa4a:	0f b6 00             	movzbl (%rax),%eax
  800420fa4d:	84 c0                	test   %al,%al
  800420fa4f:	75 e0                	jne    800420fa31 <_dwarf_frame_set_cie+0x1b8>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  800420fa51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa55:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420fa59:	0f b6 00             	movzbl (%rax),%eax
  800420fa5c:	84 c0                	test   %al,%al
  800420fa5e:	74 48                	je     800420faa8 <_dwarf_frame_set_cie+0x22f>
  800420fa60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa64:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420fa68:	0f b6 00             	movzbl (%rax),%eax
  800420fa6b:	3c 7a                	cmp    $0x7a,%al
  800420fa6d:	74 39                	je     800420faa8 <_dwarf_frame_set_cie+0x22f>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  800420fa6f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa73:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420fa77:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  800420fa7b:	75 07                	jne    800420fa84 <_dwarf_frame_set_cie+0x20b>
  800420fa7d:	b8 04 00 00 00       	mov    $0x4,%eax
  800420fa82:	eb 05                	jmp    800420fa89 <_dwarf_frame_set_cie+0x210>
  800420fa84:	b8 0c 00 00 00       	mov    $0xc,%eax
  800420fa89:	48 01 c2             	add    %rax,%rdx
			cie->cie_length;
  800420fa8c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa90:	48 8b 40 18          	mov    0x18(%rax),%rax
	while (p[(*off)++] != '\0')
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  800420fa94:	48 01 c2             	add    %rax,%rdx
  800420fa97:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420fa9b:	48 89 10             	mov    %rdx,(%rax)
			cie->cie_length;
		return (DW_DLE_NONE);
  800420fa9e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420faa3:	e9 32 02 00 00       	jmpq   800420fcda <_dwarf_frame_set_cie+0x461>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  800420faa8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420faac:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420fab0:	48 be 05 40 21 04 80 	movabs $0x8004214005,%rsi
  800420fab7:	00 00 00 
  800420faba:	48 89 c7             	mov    %rax,%rdi
  800420fabd:	48 b8 bb be 20 04 80 	movabs $0x800420bebb,%rax
  800420fac4:	00 00 00 
  800420fac7:	ff d0                	callq  *%rax
  800420fac9:	48 85 c0             	test   %rax,%rax
  800420facc:	74 28                	je     800420faf6 <_dwarf_frame_set_cie+0x27d>
		cie->cie_ehdata = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  800420face:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fad2:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fad6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420fada:	8b 52 28             	mov    0x28(%rdx),%edx
  800420fadd:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800420fae1:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  800420fae5:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  800420fae9:	48 89 cf             	mov    %rcx,%rdi
  800420faec:	ff d0                	callq  *%rax
  800420faee:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420faf2:	48 89 42 30          	mov    %rax,0x30(%rdx)
					    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  800420faf6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fafa:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420fafe:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420fb02:	48 89 d6             	mov    %rdx,%rsi
  800420fb05:	48 89 c7             	mov    %rax,%rdi
  800420fb08:	48 b8 a8 c5 20 04 80 	movabs $0x800420c5a8,%rax
  800420fb0f:	00 00 00 
  800420fb12:	ff d0                	callq  *%rax
  800420fb14:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fb18:	48 89 42 38          	mov    %rax,0x38(%rdx)
	cie->cie_daf = _dwarf_read_sleb128((uint8_t *)dbg->dbg_eh_offset, off);
  800420fb1c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fb20:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420fb24:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420fb28:	48 89 d6             	mov    %rdx,%rsi
  800420fb2b:	48 89 c7             	mov    %rax,%rdi
  800420fb2e:	48 b8 04 c5 20 04 80 	movabs $0x800420c504,%rax
  800420fb35:	00 00 00 
  800420fb38:	ff d0                	callq  *%rax
  800420fb3a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fb3e:	48 89 42 40          	mov    %rax,0x40(%rdx)

	/* Return address register. */
	if (cie->cie_version == 1)
  800420fb42:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb46:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  800420fb4a:	66 83 f8 01          	cmp    $0x1,%ax
  800420fb4e:	75 2b                	jne    800420fb7b <_dwarf_frame_set_cie+0x302>
		cie->cie_ra = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  800420fb50:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fb54:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fb58:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420fb5c:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800420fb60:	48 89 d1             	mov    %rdx,%rcx
  800420fb63:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  800420fb67:	ba 01 00 00 00       	mov    $0x1,%edx
  800420fb6c:	48 89 cf             	mov    %rcx,%rdi
  800420fb6f:	ff d0                	callq  *%rax
  800420fb71:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fb75:	48 89 42 48          	mov    %rax,0x48(%rdx)
  800420fb79:	eb 26                	jmp    800420fba1 <_dwarf_frame_set_cie+0x328>
	else
		cie->cie_ra = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  800420fb7b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fb7f:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420fb83:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420fb87:	48 89 d6             	mov    %rdx,%rsi
  800420fb8a:	48 89 c7             	mov    %rax,%rdi
  800420fb8d:	48 b8 a8 c5 20 04 80 	movabs $0x800420c5a8,%rax
  800420fb94:	00 00 00 
  800420fb97:	ff d0                	callq  *%rax
  800420fb99:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fb9d:	48 89 42 48          	mov    %rax,0x48(%rdx)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  800420fba1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fba5:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420fba9:	0f b6 00             	movzbl (%rax),%eax
  800420fbac:	3c 7a                	cmp    $0x7a,%al
  800420fbae:	0f 85 93 00 00 00    	jne    800420fc47 <_dwarf_frame_set_cie+0x3ce>
		cie->cie_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  800420fbb4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fbb8:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420fbbc:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420fbc0:	48 89 d6             	mov    %rdx,%rsi
  800420fbc3:	48 89 c7             	mov    %rax,%rdi
  800420fbc6:	48 b8 a8 c5 20 04 80 	movabs $0x800420c5a8,%rax
  800420fbcd:	00 00 00 
  800420fbd0:	ff d0                	callq  *%rax
  800420fbd2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fbd6:	48 89 42 50          	mov    %rax,0x50(%rdx)
		cie->cie_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  800420fbda:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420fbde:	48 8b 10             	mov    (%rax),%rdx
  800420fbe1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fbe5:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420fbe9:	48 01 d0             	add    %rdx,%rax
  800420fbec:	48 89 c2             	mov    %rax,%rdx
  800420fbef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fbf3:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  800420fbf7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420fbfb:	48 8b 10             	mov    (%rax),%rdx
  800420fbfe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc02:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420fc06:	48 01 c2             	add    %rax,%rdx
  800420fc09:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420fc0d:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  800420fc10:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc14:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  800420fc18:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420fc1c:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420fc20:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fc24:	48 89 ce             	mov    %rcx,%rsi
  800420fc27:	48 89 c7             	mov    %rax,%rdi
  800420fc2a:	48 b8 2e f7 20 04 80 	movabs $0x800420f72e,%rax
  800420fc31:	00 00 00 
  800420fc34:	ff d0                	callq  *%rax
  800420fc36:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  800420fc39:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420fc3d:	74 08                	je     800420fc47 <_dwarf_frame_set_cie+0x3ce>
			return (ret);
  800420fc3f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420fc42:	e9 93 00 00 00       	jmpq   800420fcda <_dwarf_frame_set_cie+0x461>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = (uint8_t *)dbg->dbg_eh_offset + *off;
  800420fc47:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420fc4b:	48 8b 10             	mov    (%rax),%rdx
  800420fc4e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fc52:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420fc56:	48 01 d0             	add    %rdx,%rax
  800420fc59:	48 89 c2             	mov    %rax,%rdx
  800420fc5c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc60:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  800420fc64:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  800420fc68:	75 2a                	jne    800420fc94 <_dwarf_frame_set_cie+0x41b>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  800420fc6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc6e:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420fc72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fc76:	48 01 c2             	add    %rax,%rdx
  800420fc79:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420fc7d:	48 8b 00             	mov    (%rax),%rax
  800420fc80:	48 29 c2             	sub    %rax,%rdx
  800420fc83:	48 89 d0             	mov    %rdx,%rax
  800420fc86:	48 8d 50 04          	lea    0x4(%rax),%rdx
  800420fc8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc8e:	48 89 50 70          	mov    %rdx,0x70(%rax)
  800420fc92:	eb 28                	jmp    800420fcbc <_dwarf_frame_set_cie+0x443>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  800420fc94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc98:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420fc9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fca0:	48 01 c2             	add    %rax,%rdx
  800420fca3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420fca7:	48 8b 00             	mov    (%rax),%rax
  800420fcaa:	48 29 c2             	sub    %rax,%rdx
  800420fcad:	48 89 d0             	mov    %rdx,%rax
  800420fcb0:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  800420fcb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fcb8:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  800420fcbc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420fcc0:	48 8b 10             	mov    (%rax),%rdx
  800420fcc3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fcc7:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420fccb:	48 01 c2             	add    %rax,%rdx
  800420fcce:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420fcd2:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  800420fcd5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fcda:	c9                   	leaveq 
  800420fcdb:	c3                   	retq   

000000800420fcdc <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde ret_fde, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  800420fcdc:	55                   	push   %rbp
  800420fcdd:	48 89 e5             	mov    %rsp,%rbp
  800420fce0:	48 83 ec 70          	sub    $0x70,%rsp
  800420fce4:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420fce8:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420fcec:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420fcf0:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  800420fcf4:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
  800420fcf8:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = ret_fde;
  800420fcfc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420fd00:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	fde->fde_dbg = dbg;
  800420fd04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd08:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420fd0c:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = (uint8_t *)dbg->dbg_eh_offset + *off;
  800420fd0f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fd13:	48 8b 10             	mov    (%rax),%rdx
  800420fd16:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fd1a:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420fd1e:	48 01 d0             	add    %rdx,%rax
  800420fd21:	48 89 c2             	mov    %rax,%rdx
  800420fd24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd28:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  800420fd2c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fd30:	48 8b 10             	mov    (%rax),%rdx
  800420fd33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd37:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  800420fd3b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fd3f:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fd43:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420fd47:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800420fd4b:	48 89 d1             	mov    %rdx,%rcx
  800420fd4e:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800420fd52:	ba 04 00 00 00       	mov    $0x4,%edx
  800420fd57:	48 89 cf             	mov    %rcx,%rdi
  800420fd5a:	ff d0                	callq  *%rax
  800420fd5c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  800420fd60:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420fd65:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800420fd69:	75 2e                	jne    800420fd99 <_dwarf_frame_set_fde+0xbd>
		dwarf_size = 8;
  800420fd6b:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  800420fd72:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fd76:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fd7a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420fd7e:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800420fd82:	48 89 d1             	mov    %rdx,%rcx
  800420fd85:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800420fd89:	ba 08 00 00 00       	mov    $0x8,%edx
  800420fd8e:	48 89 cf             	mov    %rcx,%rdi
  800420fd91:	ff d0                	callq  *%rax
  800420fd93:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420fd97:	eb 07                	jmp    800420fda0 <_dwarf_frame_set_fde+0xc4>
	} else
		dwarf_size = 4;
  800420fd99:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  800420fda0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fda4:	48 8b 50 40          	mov    0x40(%rax),%rdx
  800420fda8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fdac:	48 8b 00             	mov    (%rax),%rax
  800420fdaf:	48 29 c2             	sub    %rax,%rdx
  800420fdb2:	48 89 d0             	mov    %rdx,%rax
  800420fdb5:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420fdb9:	73 0a                	jae    800420fdc5 <_dwarf_frame_set_fde+0xe9>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  800420fdbb:	b8 12 00 00 00       	mov    $0x12,%eax
  800420fdc0:	e9 ca 02 00 00       	jmpq   800421008f <_dwarf_frame_set_fde+0x3b3>
	}

	fde->fde_length = length;
  800420fdc5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fdc9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fdcd:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  800420fdd1:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  800420fdd5:	74 5e                	je     800420fe35 <_dwarf_frame_set_fde+0x159>
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  800420fdd7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fddb:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fddf:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420fde3:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800420fde7:	48 89 d1             	mov    %rdx,%rcx
  800420fdea:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800420fdee:	ba 04 00 00 00       	mov    $0x4,%edx
  800420fdf3:	48 89 cf             	mov    %rcx,%rdi
  800420fdf6:	ff d0                	callq  *%rax
  800420fdf8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fdfc:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = *off - (4 + fde->fde_cieoff);
  800420fe00:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fe04:	48 8b 10             	mov    (%rax),%rdx
  800420fe07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe0b:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420fe0f:	48 29 c2             	sub    %rax,%rdx
  800420fe12:	48 89 d0             	mov    %rdx,%rax
  800420fe15:	48 83 e8 04          	sub    $0x4,%rax
  800420fe19:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  800420fe1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe21:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fe25:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420fe29:	75 3d                	jne    800420fe68 <_dwarf_frame_set_fde+0x18c>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  800420fe2b:	b8 13 00 00 00       	mov    $0x13,%eax
  800420fe30:	e9 5a 02 00 00       	jmpq   800421008f <_dwarf_frame_set_fde+0x3b3>
		}
	} else {
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size);
  800420fe35:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fe39:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fe3d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420fe41:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800420fe45:	48 89 d1             	mov    %rdx,%rcx
  800420fe48:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420fe4b:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800420fe4f:	48 89 cf             	mov    %rcx,%rdi
  800420fe52:	ff d0                	callq  *%rax
  800420fe54:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fe58:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = fde->fde_cieoff;
  800420fe5c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe60:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420fe64:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  800420fe68:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  800420fe6c:	0f 84 c9 00 00 00    	je     800420ff3b <_dwarf_frame_set_fde+0x25f>
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  800420fe72:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420fe76:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420fe7a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fe7e:	48 8b 00             	mov    (%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  800420fe81:	4c 8d 0c 02          	lea    (%rdx,%rax,1),%r9
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  800420fe85:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fe89:	0f b6 40 60          	movzbl 0x60(%rax),%eax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  800420fe8d:	44 0f b6 c0          	movzbl %al,%r8d
						    (uint8_t *)dbg->dbg_eh_offset,
  800420fe91:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fe95:	48 8b 40 38          	mov    0x38(%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  800420fe99:	48 89 c2             	mov    %rax,%rdx
  800420fe9c:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800420fea0:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  800420fea4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fea8:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  800420feac:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420feb0:	48 89 c7             	mov    %rax,%rdi
  800420feb3:	48 b8 14 f5 20 04 80 	movabs $0x800420f514,%rax
  800420feba:	00 00 00 
  800420febd:	ff d0                	callq  *%rax
  800420febf:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
		if (ret != DW_DLE_NONE)
  800420fec2:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420fec6:	74 08                	je     800420fed0 <_dwarf_frame_set_fde+0x1f4>
			return (ret);
  800420fec8:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420fecb:	e9 bf 01 00 00       	jmpq   800421008f <_dwarf_frame_set_fde+0x3b3>
		fde->fde_initloc = val;
  800420fed0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420fed4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fed8:	48 89 50 30          	mov    %rdx,0x30(%rax)
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
  800420fedc:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fee0:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  800420fee4:	44 0f b6 c0          	movzbl %al,%r8d
						    (uint8_t *)dbg->dbg_eh_offset,
  800420fee8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420feec:	48 8b 40 38          	mov    0x38(%rax),%rax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  800420fef0:	48 89 c2             	mov    %rax,%rdx
  800420fef3:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800420fef7:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  800420fefb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420feff:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  800420ff03:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420ff07:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420ff0d:	48 89 c7             	mov    %rax,%rdi
  800420ff10:	48 b8 14 f5 20 04 80 	movabs $0x800420f514,%rax
  800420ff17:	00 00 00 
  800420ff1a:	ff d0                	callq  *%rax
  800420ff1c:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
  800420ff1f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420ff23:	74 08                	je     800420ff2d <_dwarf_frame_set_fde+0x251>
			return (ret);
  800420ff25:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420ff28:	e9 62 01 00 00       	jmpq   800421008f <_dwarf_frame_set_fde+0x3b3>
		fde->fde_adrange = val;
  800420ff2d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ff31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff35:	48 89 50 38          	mov    %rdx,0x38(%rax)
  800420ff39:	eb 50                	jmp    800420ff8b <_dwarf_frame_set_fde+0x2af>
	} else {
		fde->fde_initloc = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  800420ff3b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ff3f:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ff43:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420ff47:	8b 52 28             	mov    0x28(%rdx),%edx
  800420ff4a:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800420ff4e:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  800420ff52:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800420ff56:	48 89 cf             	mov    %rcx,%rdi
  800420ff59:	ff d0                	callq  *%rax
  800420ff5b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ff5f:	48 89 42 30          	mov    %rax,0x30(%rdx)
					     dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  800420ff63:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ff67:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ff6b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420ff6f:	8b 52 28             	mov    0x28(%rdx),%edx
  800420ff72:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800420ff76:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  800420ff7a:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800420ff7e:	48 89 cf             	mov    %rcx,%rdi
  800420ff81:	ff d0                	callq  *%rax
  800420ff83:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ff87:	48 89 42 38          	mov    %rax,0x38(%rdx)
					     dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  800420ff8b:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  800420ff8f:	74 6b                	je     800420fffc <_dwarf_frame_set_fde+0x320>
  800420ff91:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420ff95:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420ff99:	0f b6 00             	movzbl (%rax),%eax
  800420ff9c:	3c 7a                	cmp    $0x7a,%al
  800420ff9e:	75 5c                	jne    800420fffc <_dwarf_frame_set_fde+0x320>
		fde->fde_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  800420ffa0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ffa4:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420ffa8:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420ffac:	48 89 d6             	mov    %rdx,%rsi
  800420ffaf:	48 89 c7             	mov    %rax,%rdi
  800420ffb2:	48 b8 a8 c5 20 04 80 	movabs $0x800420c5a8,%rax
  800420ffb9:	00 00 00 
  800420ffbc:	ff d0                	callq  *%rax
  800420ffbe:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ffc2:	48 89 42 40          	mov    %rax,0x40(%rdx)
		fde->fde_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  800420ffc6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420ffca:	48 8b 10             	mov    (%rax),%rdx
  800420ffcd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ffd1:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420ffd5:	48 01 d0             	add    %rdx,%rax
  800420ffd8:	48 89 c2             	mov    %rax,%rdx
  800420ffdb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ffdf:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  800420ffe3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420ffe7:	48 8b 10             	mov    (%rax),%rdx
  800420ffea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ffee:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420fff2:	48 01 c2             	add    %rax,%rdx
  800420fff5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fff9:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = (uint8_t *)dbg->dbg_eh_offset + *off;
  800420fffc:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210000:	48 8b 10             	mov    (%rax),%rdx
  8004210003:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210007:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421000b:	48 01 d0             	add    %rdx,%rax
  800421000e:	48 89 c2             	mov    %rax,%rdx
  8004210011:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210015:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  8004210019:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  800421001d:	75 2a                	jne    8004210049 <_dwarf_frame_set_fde+0x36d>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  800421001f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210023:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004210027:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421002b:	48 01 c2             	add    %rax,%rdx
  800421002e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210032:	48 8b 00             	mov    (%rax),%rax
  8004210035:	48 29 c2             	sub    %rax,%rdx
  8004210038:	48 89 d0             	mov    %rdx,%rax
  800421003b:	48 8d 50 04          	lea    0x4(%rax),%rdx
  800421003f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210043:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004210047:	eb 28                	jmp    8004210071 <_dwarf_frame_set_fde+0x395>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  8004210049:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421004d:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004210051:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210055:	48 01 c2             	add    %rax,%rdx
  8004210058:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421005c:	48 8b 00             	mov    (%rax),%rax
  800421005f:	48 29 c2             	sub    %rax,%rdx
  8004210062:	48 89 d0             	mov    %rdx,%rax
  8004210065:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004210069:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421006d:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  8004210071:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210075:	48 8b 10             	mov    (%rax),%rdx
  8004210078:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421007c:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004210080:	48 01 c2             	add    %rax,%rdx
  8004210083:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210087:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  800421008a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421008f:	c9                   	leaveq 
  8004210090:	c3                   	retq   

0000008004210091 <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004210091:	55                   	push   %rbp
  8004210092:	48 89 e5             	mov    %rsp,%rbp
  8004210095:	48 83 ec 20          	sub    $0x20,%rsp
  8004210099:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421009d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	Dwarf_Regtable3 *rt = &global_rt_table;
  80042100a1:	48 b8 60 db 2b 04 80 	movabs $0x80042bdb60,%rax
  80042100a8:	00 00 00 
  80042100ab:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if (dbg->dbg_internal_reg_table != NULL)
  80042100af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042100b3:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042100b7:	48 85 c0             	test   %rax,%rax
  80042100ba:	74 07                	je     80042100c3 <_dwarf_frame_interal_table_init+0x32>
		return (DW_DLE_NONE);
  80042100bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042100c1:	eb 33                	jmp    80042100f6 <_dwarf_frame_interal_table_init+0x65>

	rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  80042100c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042100c7:	0f b7 50 48          	movzwl 0x48(%rax),%edx
  80042100cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042100cf:	66 89 50 18          	mov    %dx,0x18(%rax)
	rt->rt3_rules = global_rules;
  80042100d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042100d7:	48 b9 a0 e3 2b 04 80 	movabs $0x80042be3a0,%rcx
  80042100de:	00 00 00 
  80042100e1:	48 89 48 20          	mov    %rcx,0x20(%rax)

	dbg->dbg_internal_reg_table = rt;
  80042100e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042100e9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042100ed:	48 89 50 58          	mov    %rdx,0x58(%rax)

	return (DW_DLE_NONE);
  80042100f1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042100f6:	c9                   	leaveq 
  80042100f7:	c3                   	retq   

00000080042100f8 <_dwarf_get_next_fde>:

static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
		    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  80042100f8:	55                   	push   %rbp
  80042100f9:	48 89 e5             	mov    %rsp,%rbp
  80042100fc:	48 83 ec 60          	sub    $0x60,%rsp
  8004210100:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004210104:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  8004210107:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800421010b:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Section *ds = &debug_frame_sec; 
  800421010f:	48 b8 20 66 22 04 80 	movabs $0x8004226620,%rax
  8004210116:	00 00 00 
  8004210119:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  800421011d:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->curr_off_eh;
  8004210124:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210128:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421012c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	if (offset < dbg->dbg_eh_size) {
  8004210130:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210134:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004210138:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421013c:	48 39 c2             	cmp    %rax,%rdx
  800421013f:	0f 86 fe 01 00 00    	jbe    8004210343 <_dwarf_get_next_fde+0x24b>
		entry_off = offset;
  8004210145:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210149:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 4);
  800421014d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210151:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210155:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210159:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421015d:	48 89 d1             	mov    %rdx,%rcx
  8004210160:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004210164:	ba 04 00 00 00       	mov    $0x4,%edx
  8004210169:	48 89 cf             	mov    %rcx,%rdi
  800421016c:	ff d0                	callq  *%rax
  800421016e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  8004210172:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210177:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421017b:	75 2e                	jne    80042101ab <_dwarf_get_next_fde+0xb3>
			dwarf_size = 8;
  800421017d:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 8);
  8004210184:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210188:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421018c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210190:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004210194:	48 89 d1             	mov    %rdx,%rcx
  8004210197:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  800421019b:	ba 08 00 00 00       	mov    $0x8,%edx
  80042101a0:	48 89 cf             	mov    %rcx,%rdi
  80042101a3:	ff d0                	callq  *%rax
  80042101a5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042101a9:	eb 07                	jmp    80042101b2 <_dwarf_get_next_fde+0xba>
		} else
			dwarf_size = 4;
  80042101ab:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > dbg->dbg_eh_size - offset || (length == 0 && !eh_frame)) {
  80042101b2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042101b6:	48 8b 50 40          	mov    0x40(%rax),%rdx
  80042101ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042101be:	48 29 c2             	sub    %rax,%rdx
  80042101c1:	48 89 d0             	mov    %rdx,%rax
  80042101c4:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042101c8:	72 0d                	jb     80042101d7 <_dwarf_get_next_fde+0xdf>
  80042101ca:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042101cf:	75 10                	jne    80042101e1 <_dwarf_get_next_fde+0xe9>
  80042101d1:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80042101d5:	75 0a                	jne    80042101e1 <_dwarf_get_next_fde+0xe9>
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  80042101d7:	b8 12 00 00 00       	mov    $0x12,%eax
  80042101dc:	e9 67 01 00 00       	jmpq   8004210348 <_dwarf_get_next_fde+0x250>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  80042101e1:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80042101e5:	74 11                	je     80042101f8 <_dwarf_get_next_fde+0x100>
  80042101e7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042101ec:	75 0a                	jne    80042101f8 <_dwarf_get_next_fde+0x100>
			return(-1);
  80042101ee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042101f3:	e9 50 01 00 00       	jmpq   8004210348 <_dwarf_get_next_fde+0x250>

		cie_id = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, dwarf_size);
  80042101f8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042101fc:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210200:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210204:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004210208:	48 89 d1             	mov    %rdx,%rcx
  800421020b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421020e:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004210212:	48 89 cf             	mov    %rcx,%rdi
  8004210215:	ff d0                	callq  *%rax
  8004210217:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		if (eh_frame) {
  800421021b:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800421021f:	74 79                	je     800421029a <_dwarf_get_next_fde+0x1a2>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  8004210221:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004210226:	75 32                	jne    800421025a <_dwarf_get_next_fde+0x162>
				ret = _dwarf_frame_set_cie(dbg, ds,
  8004210228:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421022c:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004210230:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004210234:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004210238:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800421023c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210240:	49 89 f8             	mov    %rdi,%r8
  8004210243:	48 89 c7             	mov    %rax,%rdi
  8004210246:	48 b8 79 f8 20 04 80 	movabs $0x800420f879,%rax
  800421024d:	00 00 00 
  8004210250:	ff d0                	callq  *%rax
  8004210252:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004210255:	e9 c8 00 00 00       	jmpq   8004210322 <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  800421025a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421025e:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004210262:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  8004210266:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421026a:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800421026e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210272:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004210276:	48 89 3c 24          	mov    %rdi,(%rsp)
  800421027a:	4d 89 c1             	mov    %r8,%r9
  800421027d:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8004210283:	48 89 c7             	mov    %rax,%rdi
  8004210286:	48 b8 dc fc 20 04 80 	movabs $0x800420fcdc,%rax
  800421028d:	00 00 00 
  8004210290:	ff d0                	callq  *%rax
  8004210292:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004210295:	e9 88 00 00 00       	jmpq   8004210322 <_dwarf_get_next_fde+0x22a>
							   &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  800421029a:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  800421029e:	75 0b                	jne    80042102ab <_dwarf_get_next_fde+0x1b3>
  80042102a0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042102a5:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  80042102a9:	74 0d                	je     80042102b8 <_dwarf_get_next_fde+0x1c0>
  80042102ab:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  80042102af:	75 36                	jne    80042102e7 <_dwarf_get_next_fde+0x1ef>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  80042102b1:	48 83 7d e0 ff       	cmpq   $0xffffffffffffffff,-0x20(%rbp)
  80042102b6:	75 2f                	jne    80042102e7 <_dwarf_get_next_fde+0x1ef>
				ret = _dwarf_frame_set_cie(dbg, ds,
  80042102b8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042102bc:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042102c0:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042102c4:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80042102c8:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  80042102cc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042102d0:	49 89 f8             	mov    %rdi,%r8
  80042102d3:	48 89 c7             	mov    %rax,%rdi
  80042102d6:	48 b8 79 f8 20 04 80 	movabs $0x800420f879,%rax
  80042102dd:	00 00 00 
  80042102e0:	ff d0                	callq  *%rax
  80042102e2:	89 45 f0             	mov    %eax,-0x10(%rbp)
  80042102e5:	eb 3b                	jmp    8004210322 <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  80042102e7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042102eb:	4c 8b 40 08          	mov    0x8(%rax),%r8
  80042102ef:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80042102f3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042102f7:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042102fb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042102ff:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004210303:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004210307:	4d 89 c1             	mov    %r8,%r9
  800421030a:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8004210310:	48 89 c7             	mov    %rax,%rdi
  8004210313:	48 b8 dc fc 20 04 80 	movabs $0x800420fcdc,%rax
  800421031a:	00 00 00 
  800421031d:	ff d0                	callq  *%rax
  800421031f:	89 45 f0             	mov    %eax,-0x10(%rbp)
							   &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  8004210322:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8004210326:	74 07                	je     800421032f <_dwarf_get_next_fde+0x237>
			return(-1);
  8004210328:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421032d:	eb 19                	jmp    8004210348 <_dwarf_get_next_fde+0x250>

		offset = entry_off;
  800421032f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210333:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		dbg->curr_off_eh = offset;
  8004210337:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421033b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421033f:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  8004210343:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210348:	c9                   	leaveq 
  8004210349:	c3                   	retq   

000000800421034a <dwarf_set_frame_cfa_value>:

Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  800421034a:	55                   	push   %rbp
  800421034b:	48 89 e5             	mov    %rsp,%rbp
  800421034e:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004210352:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210356:	89 f0                	mov    %esi,%eax
  8004210358:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Half old_value;

	old_value = dbg->dbg_frame_cfa_value;
  800421035c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210360:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004210364:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
	dbg->dbg_frame_cfa_value = value;
  8004210368:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421036c:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  8004210370:	66 89 50 4c          	mov    %dx,0x4c(%rax)

	return (old_value);
  8004210374:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  8004210378:	c9                   	leaveq 
  8004210379:	c3                   	retq   

000000800421037a <dwarf_init_eh_section>:

int dwarf_init_eh_section(Dwarf_Debug dbg, Dwarf_Error *error)
{
  800421037a:	55                   	push   %rbp
  800421037b:	48 89 e5             	mov    %rsp,%rbp
  800421037e:	48 83 ec 10          	sub    $0x10,%rsp
  8004210382:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004210386:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	Dwarf_Section *section;

	if (dbg == NULL) {
  800421038a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421038f:	75 0a                	jne    800421039b <dwarf_init_eh_section+0x21>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  8004210391:	b8 01 00 00 00       	mov    $0x1,%eax
  8004210396:	e9 85 00 00 00       	jmpq   8004210420 <dwarf_init_eh_section+0xa6>
	}

	if (dbg->dbg_internal_reg_table == NULL) {
  800421039b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421039f:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042103a3:	48 85 c0             	test   %rax,%rax
  80042103a6:	75 25                	jne    80042103cd <dwarf_init_eh_section+0x53>
		if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  80042103a8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042103ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042103b0:	48 89 d6             	mov    %rdx,%rsi
  80042103b3:	48 89 c7             	mov    %rax,%rdi
  80042103b6:	48 b8 91 00 21 04 80 	movabs $0x8004210091,%rax
  80042103bd:	00 00 00 
  80042103c0:	ff d0                	callq  *%rax
  80042103c2:	85 c0                	test   %eax,%eax
  80042103c4:	74 07                	je     80042103cd <dwarf_init_eh_section+0x53>
			return (DW_DLV_ERROR);
  80042103c6:	b8 01 00 00 00       	mov    $0x1,%eax
  80042103cb:	eb 53                	jmp    8004210420 <dwarf_init_eh_section+0xa6>
	}

	_dwarf_find_section_enhanced(&debug_frame_sec);
  80042103cd:	48 bf 20 66 22 04 80 	movabs $0x8004226620,%rdi
  80042103d4:	00 00 00 
  80042103d7:	48 b8 46 de 20 04 80 	movabs $0x800420de46,%rax
  80042103de:	00 00 00 
  80042103e1:	ff d0                	callq  *%rax

	dbg->curr_off_eh = 0;
  80042103e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042103e7:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  80042103ee:	00 
	dbg->dbg_eh_offset = debug_frame_sec.ds_addr;
  80042103ef:	48 b8 20 66 22 04 80 	movabs $0x8004226620,%rax
  80042103f6:	00 00 00 
  80042103f9:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042103fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210401:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  8004210405:	48 b8 20 66 22 04 80 	movabs $0x8004226620,%rax
  800421040c:	00 00 00 
  800421040f:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004210413:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210417:	48 89 50 40          	mov    %rdx,0x40(%rax)

	return (DW_DLV_OK);
  800421041b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210420:	c9                   	leaveq 
  8004210421:	c3                   	retq   

0000008004210422 <_dwarf_lineno_run_program>:
int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
			  uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004210422:	55                   	push   %rbp
  8004210423:	48 89 e5             	mov    %rsp,%rbp
  8004210426:	53                   	push   %rbx
  8004210427:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  800421042e:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  8004210432:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  8004210436:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  800421043d:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  8004210444:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)
  800421044b:	4c 89 8d 60 ff ff ff 	mov    %r9,-0xa0(%rbp)
	uint64_t address, file, line, column, isa, opsize;
	int is_stmt, basic_block, end_sequence;
	int prologue_end, epilogue_begin;
	int ret;

	ln = &li->li_line;
  8004210452:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004210456:	48 83 c0 48          	add    $0x48,%rax
  800421045a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

	/*
	 *   ln->ln_li     = li;             \
	 * Set registers to their default values.
	 */
	RESET_REGISTERS;
  800421045e:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004210465:	00 
  8004210466:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  800421046d:	00 
  800421046e:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  8004210475:	00 
  8004210476:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  800421047d:	00 
  800421047e:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004210482:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004210486:	0f b6 c0             	movzbl %al,%eax
  8004210489:	89 45 cc             	mov    %eax,-0x34(%rbp)
  800421048c:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  8004210493:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  800421049a:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  80042104a1:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  80042104a8:	e9 0a 05 00 00       	jmpq   80042109b7 <_dwarf_lineno_run_program+0x595>
		if (*p == 0) {
  80042104ad:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042104b4:	0f b6 00             	movzbl (%rax),%eax
  80042104b7:	84 c0                	test   %al,%al
  80042104b9:	0f 85 78 01 00 00    	jne    8004210637 <_dwarf_lineno_run_program+0x215>

			/*
			 * Extended Opcodes.
			 */

			p++;
  80042104bf:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042104c6:	48 83 c0 01          	add    $0x1,%rax
  80042104ca:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
			opsize = _dwarf_decode_uleb128(&p);
  80042104d1:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042104d8:	48 89 c7             	mov    %rax,%rdi
  80042104db:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  80042104e2:	00 00 00 
  80042104e5:	ff d0                	callq  *%rax
  80042104e7:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			switch (*p) {
  80042104eb:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042104f2:	0f b6 00             	movzbl (%rax),%eax
  80042104f5:	0f b6 c0             	movzbl %al,%eax
  80042104f8:	83 f8 02             	cmp    $0x2,%eax
  80042104fb:	74 7a                	je     8004210577 <_dwarf_lineno_run_program+0x155>
  80042104fd:	83 f8 03             	cmp    $0x3,%eax
  8004210500:	0f 84 b3 00 00 00    	je     80042105b9 <_dwarf_lineno_run_program+0x197>
  8004210506:	83 f8 01             	cmp    $0x1,%eax
  8004210509:	0f 85 09 01 00 00    	jne    8004210618 <_dwarf_lineno_run_program+0x1f6>
			case DW_LNE_end_sequence:
				p++;
  800421050f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004210516:	48 83 c0 01          	add    $0x1,%rax
  800421051a:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				end_sequence = 1;
  8004210521:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
				RESET_REGISTERS;
  8004210528:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800421052f:	00 
  8004210530:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  8004210537:	00 
  8004210538:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  800421053f:	00 
  8004210540:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  8004210547:	00 
  8004210548:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421054c:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004210550:	0f b6 c0             	movzbl %al,%eax
  8004210553:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004210556:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  800421055d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004210564:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  800421056b:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  8004210572:	e9 bb 00 00 00       	jmpq   8004210632 <_dwarf_lineno_run_program+0x210>
			case DW_LNE_set_address:
				p++;
  8004210577:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421057e:	48 83 c0 01          	add    $0x1,%rax
  8004210582:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				address = dbg->decode(&p, cu->addr_size);
  8004210589:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  8004210590:	00 00 00 
  8004210593:	48 8b 00             	mov    (%rax),%rax
  8004210596:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421059a:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  800421059e:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  80042105a2:	0f b6 ca             	movzbl %dl,%ecx
  80042105a5:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  80042105ac:	89 ce                	mov    %ecx,%esi
  80042105ae:	48 89 d7             	mov    %rdx,%rdi
  80042105b1:	ff d0                	callq  *%rax
  80042105b3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				break;
  80042105b7:	eb 79                	jmp    8004210632 <_dwarf_lineno_run_program+0x210>
			case DW_LNE_define_file:
				p++;
  80042105b9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042105c0:	48 83 c0 01          	add    $0x1,%rax
  80042105c4:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				ret = _dwarf_lineno_add_file(li, &p, NULL,
  80042105cb:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  80042105d2:	00 00 00 
  80042105d5:	48 8b 08             	mov    (%rax),%rcx
  80042105d8:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042105df:	48 8d b5 78 ff ff ff 	lea    -0x88(%rbp),%rsi
  80042105e6:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042105ea:	49 89 c8             	mov    %rcx,%r8
  80042105ed:	48 89 d1             	mov    %rdx,%rcx
  80042105f0:	ba 00 00 00 00       	mov    $0x0,%edx
  80042105f5:	48 89 c7             	mov    %rax,%rdi
  80042105f8:	48 b8 da 09 21 04 80 	movabs $0x80042109da,%rax
  80042105ff:	00 00 00 
  8004210602:	ff d0                	callq  *%rax
  8004210604:	89 45 a4             	mov    %eax,-0x5c(%rbp)
							     error, dbg);
				if (ret != DW_DLE_NONE)
  8004210607:	83 7d a4 00          	cmpl   $0x0,-0x5c(%rbp)
  800421060b:	74 09                	je     8004210616 <_dwarf_lineno_run_program+0x1f4>
					goto prog_fail;
  800421060d:	90                   	nop

	return (DW_DLE_NONE);

prog_fail:

	return (ret);
  800421060e:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004210611:	e9 ba 03 00 00       	jmpq   80042109d0 <_dwarf_lineno_run_program+0x5ae>
				p++;
				ret = _dwarf_lineno_add_file(li, &p, NULL,
							     error, dbg);
				if (ret != DW_DLE_NONE)
					goto prog_fail;
				break;
  8004210616:	eb 1a                	jmp    8004210632 <_dwarf_lineno_run_program+0x210>
			default:
				/* Unrecognized extened opcodes. */
				p += opsize;
  8004210618:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  800421061f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210623:	48 01 d0             	add    %rdx,%rax
  8004210626:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  800421062d:	e9 85 03 00 00       	jmpq   80042109b7 <_dwarf_lineno_run_program+0x595>
  8004210632:	e9 80 03 00 00       	jmpq   80042109b7 <_dwarf_lineno_run_program+0x595>
			}

		} else if (*p > 0 && *p < li->li_opbase) {
  8004210637:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421063e:	0f b6 00             	movzbl (%rax),%eax
  8004210641:	84 c0                	test   %al,%al
  8004210643:	0f 84 3c 02 00 00    	je     8004210885 <_dwarf_lineno_run_program+0x463>
  8004210649:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004210650:	0f b6 10             	movzbl (%rax),%edx
  8004210653:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004210657:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  800421065b:	38 c2                	cmp    %al,%dl
  800421065d:	0f 83 22 02 00 00    	jae    8004210885 <_dwarf_lineno_run_program+0x463>

			/*
			 * Standard Opcodes.
			 */

			switch (*p++) {
  8004210663:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421066a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421066e:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  8004210675:	0f b6 00             	movzbl (%rax),%eax
  8004210678:	0f b6 c0             	movzbl %al,%eax
  800421067b:	83 f8 0c             	cmp    $0xc,%eax
  800421067e:	0f 87 fb 01 00 00    	ja     800421087f <_dwarf_lineno_run_program+0x45d>
  8004210684:	89 c0                	mov    %eax,%eax
  8004210686:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421068d:	00 
  800421068e:	48 b8 08 40 21 04 80 	movabs $0x8004214008,%rax
  8004210695:	00 00 00 
  8004210698:	48 01 d0             	add    %rdx,%rax
  800421069b:	48 8b 00             	mov    (%rax),%rax
  800421069e:	ff e0                	jmpq   *%rax
			case DW_LNS_copy:
				APPEND_ROW;
  80042106a0:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042106a7:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042106ab:	73 0a                	jae    80042106b7 <_dwarf_lineno_run_program+0x295>
  80042106ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80042106b2:	e9 19 03 00 00       	jmpq   80042109d0 <_dwarf_lineno_run_program+0x5ae>
  80042106b7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042106bb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042106bf:	48 89 10             	mov    %rdx,(%rax)
  80042106c2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042106c6:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80042106cd:	00 
  80042106ce:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042106d2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042106d6:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80042106da:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042106de:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042106e2:	48 89 50 18          	mov    %rdx,0x18(%rax)
  80042106e6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042106ea:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042106ee:	48 89 50 20          	mov    %rdx,0x20(%rax)
  80042106f2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042106f6:	8b 55 c8             	mov    -0x38(%rbp),%edx
  80042106f9:	89 50 28             	mov    %edx,0x28(%rax)
  80042106fc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210700:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004210703:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004210706:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421070a:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  800421070d:	89 50 30             	mov    %edx,0x30(%rax)
  8004210710:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004210714:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  800421071b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421071f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004210723:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
				basic_block = 0;
  800421072a:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
				prologue_end = 0;
  8004210731:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
				epilogue_begin = 0;
  8004210738:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  800421073f:	e9 3c 01 00 00       	jmpq   8004210880 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004210744:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421074b:	48 89 c7             	mov    %rax,%rdi
  800421074e:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  8004210755:	00 00 00 
  8004210758:	ff d0                	callq  *%rax
					li->li_minlen;
  800421075a:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  800421075e:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
				basic_block = 0;
				prologue_end = 0;
				epilogue_begin = 0;
				break;
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004210762:	0f b6 d2             	movzbl %dl,%edx
  8004210765:	48 0f af c2          	imul   %rdx,%rax
  8004210769:	48 01 45 e8          	add    %rax,-0x18(%rbp)
					li->li_minlen;
				break;
  800421076d:	e9 0e 01 00 00       	jmpq   8004210880 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_line:
				line += _dwarf_decode_sleb128(&p);
  8004210772:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004210779:	48 89 c7             	mov    %rax,%rdi
  800421077c:	48 b8 27 c6 20 04 80 	movabs $0x800420c627,%rax
  8004210783:	00 00 00 
  8004210786:	ff d0                	callq  *%rax
  8004210788:	48 01 45 d8          	add    %rax,-0x28(%rbp)
				break;
  800421078c:	e9 ef 00 00 00       	jmpq   8004210880 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_file:
				file = _dwarf_decode_uleb128(&p);
  8004210791:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004210798:	48 89 c7             	mov    %rax,%rdi
  800421079b:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  80042107a2:	00 00 00 
  80042107a5:	ff d0                	callq  *%rax
  80042107a7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				break;
  80042107ab:	e9 d0 00 00 00       	jmpq   8004210880 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_column:
				column = _dwarf_decode_uleb128(&p);
  80042107b0:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042107b7:	48 89 c7             	mov    %rax,%rdi
  80042107ba:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  80042107c1:	00 00 00 
  80042107c4:	ff d0                	callq  *%rax
  80042107c6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
				break;
  80042107ca:	e9 b1 00 00 00       	jmpq   8004210880 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_negate_stmt:
				is_stmt = !is_stmt;
  80042107cf:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80042107d3:	0f 94 c0             	sete   %al
  80042107d6:	0f b6 c0             	movzbl %al,%eax
  80042107d9:	89 45 cc             	mov    %eax,-0x34(%rbp)
				break;
  80042107dc:	e9 9f 00 00 00       	jmpq   8004210880 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_basic_block:
				basic_block = 1;
  80042107e1:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%rbp)
				break;
  80042107e8:	e9 93 00 00 00       	jmpq   8004210880 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_const_add_pc:
				address += ADDRESS(255);
  80042107ed:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042107f1:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042107f5:	0f b6 c0             	movzbl %al,%eax
  80042107f8:	ba ff 00 00 00       	mov    $0xff,%edx
  80042107fd:	89 d1                	mov    %edx,%ecx
  80042107ff:	29 c1                	sub    %eax,%ecx
  8004210801:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004210805:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004210809:	0f b6 d8             	movzbl %al,%ebx
  800421080c:	89 c8                	mov    %ecx,%eax
  800421080e:	99                   	cltd   
  800421080f:	f7 fb                	idiv   %ebx
  8004210811:	89 c2                	mov    %eax,%edx
  8004210813:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004210817:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  800421081b:	0f b6 c0             	movzbl %al,%eax
  800421081e:	0f af c2             	imul   %edx,%eax
  8004210821:	48 98                	cltq   
  8004210823:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  8004210827:	eb 57                	jmp    8004210880 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_fixed_advance_pc:
				address += dbg->decode(&p, 2);
  8004210829:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  8004210830:	00 00 00 
  8004210833:	48 8b 00             	mov    (%rax),%rax
  8004210836:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421083a:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  8004210841:	be 02 00 00 00       	mov    $0x2,%esi
  8004210846:	48 89 d7             	mov    %rdx,%rdi
  8004210849:	ff d0                	callq  *%rax
  800421084b:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  800421084f:	eb 2f                	jmp    8004210880 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_prologue_end:
				prologue_end = 1;
  8004210851:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%rbp)
				break;
  8004210858:	eb 26                	jmp    8004210880 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_epilogue_begin:
				epilogue_begin = 1;
  800421085a:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
				break;
  8004210861:	eb 1d                	jmp    8004210880 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_isa:
				isa = _dwarf_decode_uleb128(&p);
  8004210863:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421086a:	48 89 c7             	mov    %rax,%rdi
  800421086d:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  8004210874:	00 00 00 
  8004210877:	ff d0                	callq  *%rax
  8004210879:	48 89 45 98          	mov    %rax,-0x68(%rbp)
				break;
  800421087d:	eb 01                	jmp    8004210880 <_dwarf_lineno_run_program+0x45e>
			default:
				/* Unrecognized extened opcodes. What to do? */
				break;
  800421087f:	90                   	nop
			}

		} else {
  8004210880:	e9 32 01 00 00       	jmpq   80042109b7 <_dwarf_lineno_run_program+0x595>

			/*
			 * Special Opcodes.
			 */

			line += LINE(*p);
  8004210885:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004210889:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  800421088d:	0f be c8             	movsbl %al,%ecx
  8004210890:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004210897:	0f b6 00             	movzbl (%rax),%eax
  800421089a:	0f b6 d0             	movzbl %al,%edx
  800421089d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042108a1:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042108a5:	0f b6 c0             	movzbl %al,%eax
  80042108a8:	29 c2                	sub    %eax,%edx
  80042108aa:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042108ae:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042108b2:	0f b6 f0             	movzbl %al,%esi
  80042108b5:	89 d0                	mov    %edx,%eax
  80042108b7:	99                   	cltd   
  80042108b8:	f7 fe                	idiv   %esi
  80042108ba:	89 d0                	mov    %edx,%eax
  80042108bc:	01 c8                	add    %ecx,%eax
  80042108be:	48 98                	cltq   
  80042108c0:	48 01 45 d8          	add    %rax,-0x28(%rbp)
			address += ADDRESS(*p);
  80042108c4:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042108cb:	0f b6 00             	movzbl (%rax),%eax
  80042108ce:	0f b6 d0             	movzbl %al,%edx
  80042108d1:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042108d5:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042108d9:	0f b6 c0             	movzbl %al,%eax
  80042108dc:	89 d1                	mov    %edx,%ecx
  80042108de:	29 c1                	sub    %eax,%ecx
  80042108e0:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042108e4:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042108e8:	0f b6 d8             	movzbl %al,%ebx
  80042108eb:	89 c8                	mov    %ecx,%eax
  80042108ed:	99                   	cltd   
  80042108ee:	f7 fb                	idiv   %ebx
  80042108f0:	89 c2                	mov    %eax,%edx
  80042108f2:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042108f6:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  80042108fa:	0f b6 c0             	movzbl %al,%eax
  80042108fd:	0f af c2             	imul   %edx,%eax
  8004210900:	48 98                	cltq   
  8004210902:	48 01 45 e8          	add    %rax,-0x18(%rbp)
			APPEND_ROW;
  8004210906:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421090d:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004210911:	73 0a                	jae    800421091d <_dwarf_lineno_run_program+0x4fb>
  8004210913:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210918:	e9 b3 00 00 00       	jmpq   80042109d0 <_dwarf_lineno_run_program+0x5ae>
  800421091d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210921:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210925:	48 89 10             	mov    %rdx,(%rax)
  8004210928:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421092c:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004210933:	00 
  8004210934:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210938:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421093c:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004210940:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210944:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004210948:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421094c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210950:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210954:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004210958:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421095c:	8b 55 c8             	mov    -0x38(%rbp),%edx
  800421095f:	89 50 28             	mov    %edx,0x28(%rax)
  8004210962:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210966:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004210969:	89 50 2c             	mov    %edx,0x2c(%rax)
  800421096c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210970:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004210973:	89 50 30             	mov    %edx,0x30(%rax)
  8004210976:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421097a:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004210981:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210985:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004210989:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
			basic_block = 0;
  8004210990:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
			prologue_end = 0;
  8004210997:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
			epilogue_begin = 0;
  800421099e:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
			p++;
  80042109a5:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042109ac:	48 83 c0 01          	add    $0x1,%rax
  80042109b0:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	RESET_REGISTERS;

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  80042109b7:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042109be:	48 3b 85 70 ff ff ff 	cmp    -0x90(%rbp),%rax
  80042109c5:	0f 82 e2 fa ff ff    	jb     80042104ad <_dwarf_lineno_run_program+0x8b>
			epilogue_begin = 0;
			p++;
		}
	}

	return (DW_DLE_NONE);
  80042109cb:	b8 00 00 00 00       	mov    $0x0,%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  80042109d0:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  80042109d7:	5b                   	pop    %rbx
  80042109d8:	5d                   	pop    %rbp
  80042109d9:	c3                   	retq   

00000080042109da <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
		       Dwarf_Error *error, Dwarf_Debug dbg)
{
  80042109da:	55                   	push   %rbp
  80042109db:	48 89 e5             	mov    %rsp,%rbp
  80042109de:	53                   	push   %rbx
  80042109df:	48 83 ec 48          	sub    $0x48,%rsp
  80042109e3:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042109e7:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042109eb:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80042109ef:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  80042109f3:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
	char *fname;
	//const char *dirname;
	uint8_t *src;
	int slen;

	src = *p;
  80042109f7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042109fb:	48 8b 00             	mov    (%rax),%rax
  80042109fe:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
  return (DW_DLE_MEMORY);
  }
*/  
	//lf->lf_fullpath = NULL;
	fname = (char *) src;
  8004210a02:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210a06:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	src += strlen(fname) + 1;
  8004210a0a:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  8004210a0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a12:	48 89 c7             	mov    %rax,%rdi
  8004210a15:	48 b8 91 b7 20 04 80 	movabs $0x800420b791,%rax
  8004210a1c:	00 00 00 
  8004210a1f:	ff d0                	callq  *%rax
  8004210a21:	48 98                	cltq   
  8004210a23:	48 83 c0 01          	add    $0x1,%rax
  8004210a27:	48 01 d8             	add    %rbx,%rax
  8004210a2a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	_dwarf_decode_uleb128(&src);
  8004210a2e:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004210a32:	48 89 c7             	mov    %rax,%rdi
  8004210a35:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  8004210a3c:	00 00 00 
  8004210a3f:	ff d0                	callq  *%rax
	   snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
	   lf->lf_fname);
	   }
	   }
	*/
	_dwarf_decode_uleb128(&src);
  8004210a41:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004210a45:	48 89 c7             	mov    %rax,%rdi
  8004210a48:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  8004210a4f:	00 00 00 
  8004210a52:	ff d0                	callq  *%rax
	_dwarf_decode_uleb128(&src);
  8004210a54:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004210a58:	48 89 c7             	mov    %rax,%rdi
  8004210a5b:	48 b8 b9 c6 20 04 80 	movabs $0x800420c6b9,%rax
  8004210a62:	00 00 00 
  8004210a65:	ff d0                	callq  *%rax
	//STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
	//li->li_lflen++;

	*p = src;
  8004210a67:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210a6b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210a6f:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  8004210a72:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210a77:	48 83 c4 48          	add    $0x48,%rsp
  8004210a7b:	5b                   	pop    %rbx
  8004210a7c:	5d                   	pop    %rbp
  8004210a7d:	c3                   	retq   

0000008004210a7e <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  8004210a7e:	55                   	push   %rbp
  8004210a7f:	48 89 e5             	mov    %rsp,%rbp
  8004210a82:	53                   	push   %rbx
  8004210a83:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  8004210a8a:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  8004210a91:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  8004210a98:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  8004210a9f:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  8004210aa6:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
	Dwarf_Section myds = {.ds_name = ".debug_line"};
  8004210aad:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8004210ab4:	00 
  8004210ab5:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  8004210abc:	00 
  8004210abd:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  8004210ac4:	00 
  8004210ac5:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004210acc:	00 
  8004210acd:	48 b8 70 40 21 04 80 	movabs $0x8004214070,%rax
  8004210ad4:	00 00 00 
  8004210ad7:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  8004210adb:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8004210adf:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//Dwarf_LineFile lf, tlf;
	uint64_t length, hdroff, endoff;
	uint8_t *p;
	int dwarf_size, i, ret;
            
	cu = die->cu_header;
  8004210ae3:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004210aea:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  8004210af1:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	assert(cu != NULL); 
  8004210af5:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210afa:	75 35                	jne    8004210b31 <_dwarf_lineno_init+0xb3>
  8004210afc:	48 b9 7c 40 21 04 80 	movabs $0x800421407c,%rcx
  8004210b03:	00 00 00 
  8004210b06:	48 ba 87 40 21 04 80 	movabs $0x8004214087,%rdx
  8004210b0d:	00 00 00 
  8004210b10:	be 13 01 00 00       	mov    $0x113,%esi
  8004210b15:	48 bf 9c 40 21 04 80 	movabs $0x800421409c,%rdi
  8004210b1c:	00 00 00 
  8004210b1f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210b24:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004210b2b:	00 00 00 
  8004210b2e:	41 ff d0             	callq  *%r8
	assert(dbg != NULL);
  8004210b31:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  8004210b38:	00 00 00 
  8004210b3b:	48 8b 00             	mov    (%rax),%rax
  8004210b3e:	48 85 c0             	test   %rax,%rax
  8004210b41:	75 35                	jne    8004210b78 <_dwarf_lineno_init+0xfa>
  8004210b43:	48 b9 b3 40 21 04 80 	movabs $0x80042140b3,%rcx
  8004210b4a:	00 00 00 
  8004210b4d:	48 ba 87 40 21 04 80 	movabs $0x8004214087,%rdx
  8004210b54:	00 00 00 
  8004210b57:	be 14 01 00 00       	mov    $0x114,%esi
  8004210b5c:	48 bf 9c 40 21 04 80 	movabs $0x800421409c,%rdi
  8004210b63:	00 00 00 
  8004210b66:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210b6b:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004210b72:	00 00 00 
  8004210b75:	41 ff d0             	callq  *%r8

	if ((_dwarf_find_section_enhanced(ds)) != 0)
  8004210b78:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210b7c:	48 89 c7             	mov    %rax,%rdi
  8004210b7f:	48 b8 46 de 20 04 80 	movabs $0x800420de46,%rax
  8004210b86:	00 00 00 
  8004210b89:	ff d0                	callq  *%rax
  8004210b8b:	85 c0                	test   %eax,%eax
  8004210b8d:	74 0a                	je     8004210b99 <_dwarf_lineno_init+0x11b>
		return (DW_DLE_NONE);
  8004210b8f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210b94:	e9 4f 04 00 00       	jmpq   8004210fe8 <_dwarf_lineno_init+0x56a>

	li = linfo;
  8004210b99:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004210ba0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	 break;
	 }
	 }
	*/

	length = dbg->read(ds->ds_data, &offset, 4);
  8004210ba4:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  8004210bab:	00 00 00 
  8004210bae:	48 8b 00             	mov    (%rax),%rax
  8004210bb1:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210bb5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210bb9:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004210bbd:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004210bc4:	ba 04 00 00 00       	mov    $0x4,%edx
  8004210bc9:	48 89 cf             	mov    %rcx,%rdi
  8004210bcc:	ff d0                	callq  *%rax
  8004210bce:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (length == 0xffffffff) {
  8004210bd2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210bd7:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004210bdb:	75 37                	jne    8004210c14 <_dwarf_lineno_init+0x196>
		dwarf_size = 8;
  8004210bdd:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
		length = dbg->read(ds->ds_data, &offset, 8);
  8004210be4:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  8004210beb:	00 00 00 
  8004210bee:	48 8b 00             	mov    (%rax),%rax
  8004210bf1:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210bf5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210bf9:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004210bfd:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004210c04:	ba 08 00 00 00       	mov    $0x8,%edx
  8004210c09:	48 89 cf             	mov    %rcx,%rdi
  8004210c0c:	ff d0                	callq  *%rax
  8004210c0e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004210c12:	eb 07                	jmp    8004210c1b <_dwarf_lineno_init+0x19d>
	} else
		dwarf_size = 4;
  8004210c14:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

	if (length > ds->ds_size - offset) {
  8004210c1b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210c1f:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004210c23:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004210c2a:	48 29 c2             	sub    %rax,%rdx
  8004210c2d:	48 89 d0             	mov    %rdx,%rax
  8004210c30:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004210c34:	73 0a                	jae    8004210c40 <_dwarf_lineno_init+0x1c2>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
		return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004210c36:	b8 0f 00 00 00       	mov    $0xf,%eax
  8004210c3b:	e9 a8 03 00 00       	jmpq   8004210fe8 <_dwarf_lineno_init+0x56a>
	}
	/*
	 * Read in line number program header.
	 */
	li->li_length = length;
  8004210c40:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210c44:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210c48:	48 89 10             	mov    %rdx,(%rax)
	endoff = offset + length;
  8004210c4b:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  8004210c52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210c56:	48 01 d0             	add    %rdx,%rax
  8004210c59:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  8004210c5d:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  8004210c64:	00 00 00 
  8004210c67:	48 8b 00             	mov    (%rax),%rax
  8004210c6a:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210c6e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210c72:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004210c76:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004210c7d:	ba 02 00 00 00       	mov    $0x2,%edx
  8004210c82:	48 89 cf             	mov    %rcx,%rdi
  8004210c85:	ff d0                	callq  *%rax
  8004210c87:	89 c2                	mov    %eax,%edx
  8004210c89:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210c8d:	66 89 50 08          	mov    %dx,0x8(%rax)
	li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  8004210c91:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  8004210c98:	00 00 00 
  8004210c9b:	48 8b 00             	mov    (%rax),%rax
  8004210c9e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210ca2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210ca6:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004210caa:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004210cad:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004210cb4:	48 89 cf             	mov    %rcx,%rdi
  8004210cb7:	ff d0                	callq  *%rax
  8004210cb9:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004210cbd:	48 89 42 10          	mov    %rax,0x10(%rdx)
	hdroff = offset;
  8004210cc1:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004210cc8:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  8004210ccc:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  8004210cd3:	00 00 00 
  8004210cd6:	48 8b 00             	mov    (%rax),%rax
  8004210cd9:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210cdd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210ce1:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004210ce5:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004210cec:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210cf1:	48 89 cf             	mov    %rcx,%rdi
  8004210cf4:	ff d0                	callq  *%rax
  8004210cf6:	89 c2                	mov    %eax,%edx
  8004210cf8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210cfc:	88 50 18             	mov    %dl,0x18(%rax)
	li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  8004210cff:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  8004210d06:	00 00 00 
  8004210d09:	48 8b 00             	mov    (%rax),%rax
  8004210d0c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210d10:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210d14:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004210d18:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004210d1f:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210d24:	48 89 cf             	mov    %rcx,%rdi
  8004210d27:	ff d0                	callq  *%rax
  8004210d29:	89 c2                	mov    %eax,%edx
  8004210d2b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210d2f:	88 50 19             	mov    %dl,0x19(%rax)
	li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  8004210d32:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  8004210d39:	00 00 00 
  8004210d3c:	48 8b 00             	mov    (%rax),%rax
  8004210d3f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210d43:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210d47:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004210d4b:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004210d52:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210d57:	48 89 cf             	mov    %rcx,%rdi
  8004210d5a:	ff d0                	callq  *%rax
  8004210d5c:	89 c2                	mov    %eax,%edx
  8004210d5e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210d62:	88 50 1a             	mov    %dl,0x1a(%rax)
	li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  8004210d65:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  8004210d6c:	00 00 00 
  8004210d6f:	48 8b 00             	mov    (%rax),%rax
  8004210d72:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210d76:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210d7a:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004210d7e:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004210d85:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210d8a:	48 89 cf             	mov    %rcx,%rdi
  8004210d8d:	ff d0                	callq  *%rax
  8004210d8f:	89 c2                	mov    %eax,%edx
  8004210d91:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210d95:	88 50 1b             	mov    %dl,0x1b(%rax)
	li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  8004210d98:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  8004210d9f:	00 00 00 
  8004210da2:	48 8b 00             	mov    (%rax),%rax
  8004210da5:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210da9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210dad:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004210db1:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004210db8:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210dbd:	48 89 cf             	mov    %rcx,%rdi
  8004210dc0:	ff d0                	callq  *%rax
  8004210dc2:	89 c2                	mov    %eax,%edx
  8004210dc4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210dc8:	88 50 1c             	mov    %dl,0x1c(%rax)
	//STAILQ_INIT(&li->li_lflist);
	//STAILQ_INIT(&li->li_lnlist);

	if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  8004210dcb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210dcf:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004210dd3:	8d 50 fb             	lea    -0x5(%rax),%edx
  8004210dd6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210dda:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004210dde:	0f b6 c0             	movzbl %al,%eax
  8004210de1:	83 e8 01             	sub    $0x1,%eax
  8004210de4:	39 c2                	cmp    %eax,%edx
  8004210de6:	7d 0c                	jge    8004210df4 <_dwarf_lineno_init+0x376>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004210de8:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004210def:	e9 f1 01 00 00       	jmpq   8004210fe5 <_dwarf_lineno_init+0x567>
	}

	li->li_oplen = global_std_op;
  8004210df4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210df8:	48 bb e0 e9 2b 04 80 	movabs $0x80042be9e0,%rbx
  8004210dff:	00 00 00 
  8004210e02:	48 89 58 20          	mov    %rbx,0x20(%rax)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004210e06:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  8004210e0d:	eb 41                	jmp    8004210e50 <_dwarf_lineno_init+0x3d2>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  8004210e0f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210e13:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004210e17:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004210e1a:	48 98                	cltq   
  8004210e1c:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004210e20:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  8004210e27:	00 00 00 
  8004210e2a:	48 8b 00             	mov    (%rax),%rax
  8004210e2d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210e31:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210e35:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004210e39:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004210e40:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210e45:	48 89 cf             	mov    %rcx,%rdi
  8004210e48:	ff d0                	callq  *%rax
  8004210e4a:	88 03                	mov    %al,(%rbx)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004210e4c:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  8004210e50:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210e54:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004210e58:	0f b6 c0             	movzbl %al,%eax
  8004210e5b:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  8004210e5e:	7f af                	jg     8004210e0f <_dwarf_lineno_init+0x391>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);

	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
  8004210e60:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004210e67:	00 
	p = ds->ds_data + offset;
  8004210e68:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210e6c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004210e70:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004210e77:	48 01 d0             	add    %rdx,%rax
  8004210e7a:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	while (*p != '\0') {
  8004210e81:	eb 1f                	jmp    8004210ea2 <_dwarf_lineno_init+0x424>
		while (*p++ != '\0')
  8004210e83:	90                   	nop
  8004210e84:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004210e8b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210e8f:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
  8004210e96:	0f b6 00             	movzbl (%rax),%eax
  8004210e99:	84 c0                	test   %al,%al
  8004210e9b:	75 e7                	jne    8004210e84 <_dwarf_lineno_init+0x406>
			;
		length++;
  8004210e9d:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
	p = ds->ds_data + offset;
	while (*p != '\0') {
  8004210ea2:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004210ea9:	0f b6 00             	movzbl (%rax),%eax
  8004210eac:	84 c0                	test   %al,%al
  8004210eae:	75 d3                	jne    8004210e83 <_dwarf_lineno_init+0x405>
		while (*p++ != '\0')
			;
		length++;
	}
	li->li_inclen = length;
  8004210eb0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210eb4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210eb8:	48 89 50 30          	mov    %rdx,0x30(%rax)

	/* Sanity check. */
	if (p - ds->ds_data > (int) ds->ds_size) {
  8004210ebc:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004210ec3:	48 89 c2             	mov    %rax,%rdx
  8004210ec6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210eca:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210ece:	48 29 c2             	sub    %rax,%rdx
  8004210ed1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210ed5:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210ed9:	48 98                	cltq   
  8004210edb:	48 39 c2             	cmp    %rax,%rdx
  8004210ede:	7e 0c                	jle    8004210eec <_dwarf_lineno_init+0x46e>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004210ee0:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004210ee7:	e9 f9 00 00 00       	jmpq   8004210fe5 <_dwarf_lineno_init+0x567>
	}
	p++;
  8004210eec:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004210ef3:	48 83 c0 01          	add    $0x1,%rax
  8004210ef7:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  8004210efe:	eb 3c                	jmp    8004210f3c <_dwarf_lineno_init+0x4be>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  8004210f00:	48 b8 18 66 22 04 80 	movabs $0x8004226618,%rax
  8004210f07:	00 00 00 
  8004210f0a:	48 8b 08             	mov    (%rax),%rcx
  8004210f0d:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004210f14:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  8004210f1b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210f1f:	49 89 c8             	mov    %rcx,%r8
  8004210f22:	48 89 d1             	mov    %rdx,%rcx
  8004210f25:	ba 00 00 00 00       	mov    $0x0,%edx
  8004210f2a:	48 89 c7             	mov    %rax,%rdi
  8004210f2d:	48 b8 da 09 21 04 80 	movabs $0x80042109da,%rax
  8004210f34:	00 00 00 
  8004210f37:	ff d0                	callq  *%rax
  8004210f39:	89 45 dc             	mov    %eax,-0x24(%rbp)
	p++;

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  8004210f3c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004210f43:	0f b6 00             	movzbl (%rax),%eax
  8004210f46:	84 c0                	test   %al,%al
  8004210f48:	75 b6                	jne    8004210f00 <_dwarf_lineno_init+0x482>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
		//p++;
	}

	p++;
  8004210f4a:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004210f51:	48 83 c0 01          	add    $0x1,%rax
  8004210f55:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	/* Sanity check. */
	if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  8004210f5c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004210f63:	48 89 c2             	mov    %rax,%rdx
  8004210f66:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210f6a:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210f6e:	48 29 c2             	sub    %rax,%rdx
  8004210f71:	48 89 d0             	mov    %rdx,%rax
  8004210f74:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
  8004210f78:	48 89 c2             	mov    %rax,%rdx
  8004210f7b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210f7f:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004210f83:	48 39 c2             	cmp    %rax,%rdx
  8004210f86:	74 09                	je     8004210f91 <_dwarf_lineno_init+0x513>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004210f88:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004210f8f:	eb 54                	jmp    8004210fe5 <_dwarf_lineno_init+0x567>
	}

	/*
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  8004210f91:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210f95:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004210f99:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210f9d:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004210fa1:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  8004210fa8:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  8004210faf:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  8004210fb6:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004210fba:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210fbe:	4d 89 c1             	mov    %r8,%r9
  8004210fc1:	49 89 f8             	mov    %rdi,%r8
  8004210fc4:	48 89 c7             	mov    %rax,%rdi
  8004210fc7:	48 b8 22 04 21 04 80 	movabs $0x8004210422,%rax
  8004210fce:	00 00 00 
  8004210fd1:	ff d0                	callq  *%rax
  8004210fd3:	89 45 dc             	mov    %eax,-0x24(%rbp)
					error);
	if (ret != DW_DLE_NONE)
  8004210fd6:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004210fda:	74 02                	je     8004210fde <_dwarf_lineno_init+0x560>
		goto fail_cleanup;
  8004210fdc:	eb 07                	jmp    8004210fe5 <_dwarf_lineno_init+0x567>

	//cu->cu_lineinfo = li;

	return (DW_DLE_NONE);
  8004210fde:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210fe3:	eb 03                	jmp    8004210fe8 <_dwarf_lineno_init+0x56a>
fail_cleanup:

	/*if (li->li_oplen)
	  free(li->li_oplen);*/

	return (ret);
  8004210fe5:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  8004210fe8:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  8004210fef:	5b                   	pop    %rbx
  8004210ff0:	5d                   	pop    %rbp
  8004210ff1:	c3                   	retq   

0000008004210ff2 <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004210ff2:	55                   	push   %rbp
  8004210ff3:	48 89 e5             	mov    %rsp,%rbp
  8004210ff6:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004210ffd:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004211004:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  800421100b:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004211012:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
	_Dwarf_LineInfo li;
	Dwarf_Attribute *at;

	assert(die);
  8004211019:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  8004211020:	00 
  8004211021:	75 35                	jne    8004211058 <dwarf_srclines+0x66>
  8004211023:	48 b9 bf 40 21 04 80 	movabs $0x80042140bf,%rcx
  800421102a:	00 00 00 
  800421102d:	48 ba 87 40 21 04 80 	movabs $0x8004214087,%rdx
  8004211034:	00 00 00 
  8004211037:	be 9a 01 00 00       	mov    $0x19a,%esi
  800421103c:	48 bf 9c 40 21 04 80 	movabs $0x800421409c,%rdi
  8004211043:	00 00 00 
  8004211046:	b8 00 00 00 00       	mov    $0x0,%eax
  800421104b:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004211052:	00 00 00 
  8004211055:	41 ff d0             	callq  *%r8
	assert(linebuf);
  8004211058:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  800421105f:	00 
  8004211060:	75 35                	jne    8004211097 <dwarf_srclines+0xa5>
  8004211062:	48 b9 c3 40 21 04 80 	movabs $0x80042140c3,%rcx
  8004211069:	00 00 00 
  800421106c:	48 ba 87 40 21 04 80 	movabs $0x8004214087,%rdx
  8004211073:	00 00 00 
  8004211076:	be 9b 01 00 00       	mov    $0x19b,%esi
  800421107b:	48 bf 9c 40 21 04 80 	movabs $0x800421409c,%rdi
  8004211082:	00 00 00 
  8004211085:	b8 00 00 00 00       	mov    $0x0,%eax
  800421108a:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004211091:	00 00 00 
  8004211094:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  8004211097:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  800421109e:	ba 88 00 00 00       	mov    $0x88,%edx
  80042110a3:	be 00 00 00 00       	mov    $0x0,%esi
  80042110a8:	48 89 c7             	mov    %rax,%rdi
  80042110ab:	48 b8 96 ba 20 04 80 	movabs $0x800420ba96,%rax
  80042110b2:	00 00 00 
  80042110b5:	ff d0                	callq  *%rax

	if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  80042110b7:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042110be:	be 10 00 00 00       	mov    $0x10,%esi
  80042110c3:	48 89 c7             	mov    %rax,%rdi
  80042110c6:	48 b8 cb d9 20 04 80 	movabs $0x800420d9cb,%rax
  80042110cd:	00 00 00 
  80042110d0:	ff d0                	callq  *%rax
  80042110d2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042110d6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042110db:	75 0a                	jne    80042110e7 <dwarf_srclines+0xf5>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  80042110dd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042110e2:	e9 84 00 00 00       	jmpq   800421116b <dwarf_srclines+0x179>
	}

	if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  80042110e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042110eb:	48 8b 70 28          	mov    0x28(%rax),%rsi
  80042110ef:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  80042110f6:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  80042110fd:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  8004211104:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421110b:	49 89 f8             	mov    %rdi,%r8
  800421110e:	48 89 c7             	mov    %rax,%rdi
  8004211111:	48 b8 7e 0a 21 04 80 	movabs $0x8004210a7e,%rax
  8004211118:	00 00 00 
  800421111b:	ff d0                	callq  *%rax
  800421111d:	85 c0                	test   %eax,%eax
  800421111f:	74 07                	je     8004211128 <dwarf_srclines+0x136>
	    DW_DLE_NONE)
	{
		return (DW_DLV_ERROR);
  8004211121:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211126:	eb 43                	jmp    800421116b <dwarf_srclines+0x179>
	}
	*linebuf = li.li_line;
  8004211128:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800421112f:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004211133:	48 89 10             	mov    %rdx,(%rax)
  8004211136:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421113a:	48 89 50 08          	mov    %rdx,0x8(%rax)
  800421113e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211142:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004211146:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421114a:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421114e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004211152:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004211156:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421115a:	48 89 50 28          	mov    %rdx,0x28(%rax)
  800421115e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211162:	48 89 50 30          	mov    %rdx,0x30(%rax)

	return (DW_DLV_OK);
  8004211166:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421116b:	c9                   	leaveq 
  800421116c:	c3                   	retq   

000000800421116d <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  800421116d:	55                   	push   %rbp
  800421116e:	48 89 e5             	mov    %rsp,%rbp
  8004211171:	48 83 ec 20          	sub    $0x20,%rsp
  8004211175:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *ret=NULL;
  8004211179:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004211180:	00 
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  8004211181:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004211188:	eb 57                	jmp    80042111e1 <_dwarf_find_section+0x74>
		if(!strcmp(section_info[i].ds_name, name)) {
  800421118a:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211191:	00 00 00 
  8004211194:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004211197:	48 63 d2             	movslq %edx,%rdx
  800421119a:	48 c1 e2 05          	shl    $0x5,%rdx
  800421119e:	48 01 d0             	add    %rdx,%rax
  80042111a1:	48 8b 00             	mov    (%rax),%rax
  80042111a4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042111a8:	48 89 d6             	mov    %rdx,%rsi
  80042111ab:	48 89 c7             	mov    %rax,%rdi
  80042111ae:	48 b8 5f b9 20 04 80 	movabs $0x800420b95f,%rax
  80042111b5:	00 00 00 
  80042111b8:	ff d0                	callq  *%rax
  80042111ba:	85 c0                	test   %eax,%eax
  80042111bc:	75 1f                	jne    80042111dd <_dwarf_find_section+0x70>
			ret = (section_info + i);
  80042111be:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042111c1:	48 98                	cltq   
  80042111c3:	48 c1 e0 05          	shl    $0x5,%rax
  80042111c7:	48 89 c2             	mov    %rax,%rdx
  80042111ca:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  80042111d1:	00 00 00 
  80042111d4:	48 01 d0             	add    %rdx,%rax
  80042111d7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  80042111db:	eb 0a                	jmp    80042111e7 <_dwarf_find_section+0x7a>
_dwarf_find_section(const char *name)
{
	Dwarf_Section *ret=NULL;
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  80042111dd:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042111e1:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042111e5:	7e a3                	jle    800421118a <_dwarf_find_section+0x1d>
			ret = (section_info + i);
			break;
		}
	}

	return ret;
  80042111e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042111eb:	c9                   	leaveq 
  80042111ec:	c3                   	retq   

00000080042111ed <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  80042111ed:	55                   	push   %rbp
  80042111ee:	48 89 e5             	mov    %rsp,%rbp
  80042111f1:	48 83 ec 40          	sub    $0x40,%rsp
  80042111f5:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	Elf *ehdr = (Elf *)elf;
  80042111f9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042111fd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uintptr_t debug_address = USTABDATA;
  8004211201:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  8004211208:	00 
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  8004211209:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421120d:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004211211:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211215:	48 01 d0             	add    %rdx,%rax
  8004211218:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  800421121c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211220:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004211224:	0f b7 c0             	movzwl %ax,%eax
  8004211227:	48 c1 e0 06          	shl    $0x6,%rax
  800421122b:	48 89 c2             	mov    %rax,%rdx
  800421122e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211232:	48 01 d0             	add    %rdx,%rax
  8004211235:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Secthdr* esh = sh + ehdr->e_shnum;
  8004211239:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421123d:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004211241:	0f b7 c0             	movzwl %ax,%eax
  8004211244:	48 c1 e0 06          	shl    $0x6,%rax
  8004211248:	48 89 c2             	mov    %rax,%rdx
  800421124b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421124f:	48 01 d0             	add    %rdx,%rax
  8004211252:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;sh < esh; sh++) {
  8004211256:	e9 4b 02 00 00       	jmpq   80042114a6 <find_debug_sections+0x2b9>
		char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  800421125b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421125f:	8b 00                	mov    (%rax),%eax
  8004211261:	89 c2                	mov    %eax,%edx
  8004211263:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211267:	48 8b 48 18          	mov    0x18(%rax),%rcx
  800421126b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421126f:	48 01 c8             	add    %rcx,%rax
  8004211272:	48 01 d0             	add    %rdx,%rax
  8004211275:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!strcmp(name, ".debug_info")) {
  8004211279:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421127d:	48 be cb 40 21 04 80 	movabs $0x80042140cb,%rsi
  8004211284:	00 00 00 
  8004211287:	48 89 c7             	mov    %rax,%rdi
  800421128a:	48 b8 5f b9 20 04 80 	movabs $0x800420b95f,%rax
  8004211291:	00 00 00 
  8004211294:	ff d0                	callq  *%rax
  8004211296:	85 c0                	test   %eax,%eax
  8004211298:	75 4b                	jne    80042112e5 <find_debug_sections+0xf8>
			section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  800421129a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421129e:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  80042112a5:	00 00 00 
  80042112a8:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  80042112ac:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  80042112b3:	00 00 00 
  80042112b6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042112ba:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  80042112be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042112c2:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042112c6:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  80042112cd:	00 00 00 
  80042112d0:	48 89 50 18          	mov    %rdx,0x18(%rax)
			debug_address += sh->sh_size;
  80042112d4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042112d8:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042112dc:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042112e0:	e9 bc 01 00 00       	jmpq   80042114a1 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_abbrev")) {
  80042112e5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042112e9:	48 be d7 40 21 04 80 	movabs $0x80042140d7,%rsi
  80042112f0:	00 00 00 
  80042112f3:	48 89 c7             	mov    %rax,%rdi
  80042112f6:	48 b8 5f b9 20 04 80 	movabs $0x800420b95f,%rax
  80042112fd:	00 00 00 
  8004211300:	ff d0                	callq  *%rax
  8004211302:	85 c0                	test   %eax,%eax
  8004211304:	75 4b                	jne    8004211351 <find_debug_sections+0x164>
			section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  8004211306:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421130a:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211311:	00 00 00 
  8004211314:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  8004211318:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  800421131f:	00 00 00 
  8004211322:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211326:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  800421132a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421132e:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004211332:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211339:	00 00 00 
  800421133c:	48 89 50 38          	mov    %rdx,0x38(%rax)
			debug_address += sh->sh_size;
  8004211340:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211344:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004211348:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  800421134c:	e9 50 01 00 00       	jmpq   80042114a1 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_line")){
  8004211351:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211355:	48 be ef 40 21 04 80 	movabs $0x80042140ef,%rsi
  800421135c:	00 00 00 
  800421135f:	48 89 c7             	mov    %rax,%rdi
  8004211362:	48 b8 5f b9 20 04 80 	movabs $0x800420b95f,%rax
  8004211369:	00 00 00 
  800421136c:	ff d0                	callq  *%rax
  800421136e:	85 c0                	test   %eax,%eax
  8004211370:	75 4b                	jne    80042113bd <find_debug_sections+0x1d0>
			section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  8004211372:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211376:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  800421137d:	00 00 00 
  8004211380:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  8004211384:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  800421138b:	00 00 00 
  800421138e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211392:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  8004211396:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421139a:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421139e:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  80042113a5:	00 00 00 
  80042113a8:	48 89 50 78          	mov    %rdx,0x78(%rax)
			debug_address += sh->sh_size;
  80042113ac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042113b0:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042113b4:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042113b8:	e9 e4 00 00 00       	jmpq   80042114a1 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".eh_frame")){
  80042113bd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042113c1:	48 be e5 40 21 04 80 	movabs $0x80042140e5,%rsi
  80042113c8:	00 00 00 
  80042113cb:	48 89 c7             	mov    %rax,%rdi
  80042113ce:	48 b8 5f b9 20 04 80 	movabs $0x800420b95f,%rax
  80042113d5:	00 00 00 
  80042113d8:	ff d0                	callq  *%rax
  80042113da:	85 c0                	test   %eax,%eax
  80042113dc:	75 53                	jne    8004211431 <find_debug_sections+0x244>
			section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  80042113de:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042113e2:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042113e6:	48 89 c2             	mov    %rax,%rdx
  80042113e9:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  80042113f0:	00 00 00 
  80042113f3:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  80042113f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042113fb:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042113ff:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211406:	00 00 00 
  8004211409:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  800421140d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211411:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004211415:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  800421141c:	00 00 00 
  800421141f:	48 89 50 58          	mov    %rdx,0x58(%rax)
			debug_address += sh->sh_size;
  8004211423:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211427:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421142b:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  800421142f:	eb 70                	jmp    80042114a1 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_str")) {
  8004211431:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211435:	48 be fb 40 21 04 80 	movabs $0x80042140fb,%rsi
  800421143c:	00 00 00 
  800421143f:	48 89 c7             	mov    %rax,%rdi
  8004211442:	48 b8 5f b9 20 04 80 	movabs $0x800420b95f,%rax
  8004211449:	00 00 00 
  800421144c:	ff d0                	callq  *%rax
  800421144e:	85 c0                	test   %eax,%eax
  8004211450:	75 4f                	jne    80042114a1 <find_debug_sections+0x2b4>
			section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  8004211452:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211456:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  800421145d:	00 00 00 
  8004211460:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  8004211467:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  800421146e:	00 00 00 
  8004211471:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211475:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  800421147c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211480:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004211484:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  800421148b:	00 00 00 
  800421148e:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
			debug_address += sh->sh_size;
  8004211495:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211499:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421149d:	48 01 45 f8          	add    %rax,-0x8(%rbp)
	Elf *ehdr = (Elf *)elf;
	uintptr_t debug_address = USTABDATA;
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
	Secthdr* esh = sh + ehdr->e_shnum;
	for(;sh < esh; sh++) {
  80042114a1:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  80042114a6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042114aa:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80042114ae:	0f 82 a7 fd ff ff    	jb     800421125b <find_debug_sections+0x6e>
			section_info[DEBUG_STR].ds_size = sh->sh_size;
			debug_address += sh->sh_size;
		}
	}

}
  80042114b4:	c9                   	leaveq 
  80042114b5:	c3                   	retq   

00000080042114b6 <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  80042114b6:	55                   	push   %rbp
  80042114b7:	48 89 e5             	mov    %rsp,%rbp
  80042114ba:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  80042114c1:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  80042114c8:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
	Secthdr* secthdr_ptr[20] = {0};
  80042114cf:	48 8d b5 c0 fe ff ff 	lea    -0x140(%rbp),%rsi
  80042114d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042114db:	ba 14 00 00 00       	mov    $0x14,%edx
  80042114e0:	48 89 f7             	mov    %rsi,%rdi
  80042114e3:	48 89 d1             	mov    %rdx,%rcx
  80042114e6:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  80042114e9:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  80042114f0:	00 
  80042114f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042114f5:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  80042114fc:	48 01 d0             	add    %rdx,%rax
  80042114ff:	48 83 e8 01          	sub    $0x1,%rax
  8004211503:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004211507:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421150b:	ba 00 00 00 00       	mov    $0x0,%edx
  8004211510:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004211514:	48 89 d0             	mov    %rdx,%rax
  8004211517:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421151b:	48 29 c2             	sub    %rax,%rdx
  800421151e:	48 89 d0             	mov    %rdx,%rax
  8004211521:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	uint64_t kvoffset = 0;
  8004211525:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  800421152c:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  8004211530:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211534:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	char * secthdr = NULL;
  8004211538:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  800421153f:	00 
	uint64_t offset;
	if(elfhdr == KELFHDR)
  8004211540:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  8004211547:	00 00 00 
  800421154a:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  8004211551:	75 11                	jne    8004211564 <read_section_headers+0xae>
		offset = ((Elf*)elfhdr)->e_shoff;
  8004211553:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421155a:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421155e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211562:	eb 26                	jmp    800421158a <read_section_headers+0xd4>
	else
		offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  8004211564:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421156b:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800421156f:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004211576:	48 01 c2             	add    %rax,%rdx
  8004211579:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004211580:	ff ff ff 
  8004211583:	48 01 d0             	add    %rdx,%rax
  8004211586:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  800421158a:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004211591:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004211595:	0f b7 c0             	movzwl %ax,%eax
  8004211598:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  800421159b:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042115a2:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  80042115a6:	0f b7 c0             	movzwl %ax,%eax
  80042115a9:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  80042115ac:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042115b3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  80042115b7:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042115ba:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  80042115be:	48 63 f0             	movslq %eax,%rsi
  80042115c1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042115c5:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042115cc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042115d0:	48 89 c7             	mov    %rax,%rdi
  80042115d3:	48 b8 f5 1b 21 04 80 	movabs $0x8004211bf5,%rax
  80042115da:	00 00 00 
  80042115dd:	ff d0                	callq  *%rax
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  80042115df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042115e3:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042115e7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042115eb:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042115f1:	48 89 c2             	mov    %rax,%rdx
  80042115f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042115f8:	48 29 d0             	sub    %rdx,%rax
  80042115fb:	48 89 c2             	mov    %rax,%rdx
  80042115fe:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211602:	48 01 d0             	add    %rdx,%rax
  8004211605:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  8004211609:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004211610:	eb 24                	jmp    8004211636 <read_section_headers+0x180>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  8004211612:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211615:	48 98                	cltq   
  8004211617:	48 c1 e0 06          	shl    $0x6,%rax
  800421161b:	48 89 c2             	mov    %rax,%rdx
  800421161e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211622:	48 01 c2             	add    %rax,%rdx
  8004211625:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211628:	48 98                	cltq   
  800421162a:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  8004211631:	ff 
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
	for (i = 0; i < numSectionHeaders; i++)
  8004211632:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004211636:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211639:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  800421163c:	7c d4                	jl     8004211612 <read_section_headers+0x15c>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  800421163e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004211642:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004211646:	0f b7 c0             	movzwl %ax,%eax
  8004211649:	48 98                	cltq   
  800421164b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004211652:	ff 
  8004211653:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  8004211657:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  800421165e:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  8004211662:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211666:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421166a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421166e:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211672:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004211679:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421167d:	48 01 c8             	add    %rcx,%rax
  8004211680:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004211687:	48 89 c7             	mov    %rax,%rdi
  800421168a:	48 b8 f5 1b 21 04 80 	movabs $0x8004211bf5,%rax
  8004211691:	00 00 00 
  8004211694:	ff d0                	callq  *%rax
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  8004211696:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421169a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421169e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042116a2:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042116a6:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  80042116aa:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042116ae:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042116b4:	48 29 c2             	sub    %rax,%rdx
  80042116b7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042116bb:	48 01 c2             	add    %rax,%rdx
  80042116be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042116c2:	48 01 d0             	add    %rdx,%rax
  80042116c5:	48 89 45 90          	mov    %rax,-0x70(%rbp)

	for (i = 0; i < numSectionHeaders; i++)
  80042116c9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042116d0:	e9 04 05 00 00       	jmpq   8004211bd9 <read_section_headers+0x723>
	{
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  80042116d5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042116d8:	48 98                	cltq   
  80042116da:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042116e1:	ff 
  80042116e2:	8b 00                	mov    (%rax),%eax
  80042116e4:	89 c2                	mov    %eax,%edx
  80042116e6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042116ea:	48 01 d0             	add    %rdx,%rax
  80042116ed:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		assert(kvoffset % SECTSIZE == 0);
  80042116f1:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042116f8:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042116fd:	48 85 c0             	test   %rax,%rax
  8004211700:	74 35                	je     8004211737 <read_section_headers+0x281>
  8004211702:	48 b9 06 41 21 04 80 	movabs $0x8004214106,%rcx
  8004211709:	00 00 00 
  800421170c:	48 ba 1f 41 21 04 80 	movabs $0x800421411f,%rdx
  8004211713:	00 00 00 
  8004211716:	be 86 00 00 00       	mov    $0x86,%esi
  800421171b:	48 bf 34 41 21 04 80 	movabs $0x8004214134,%rdi
  8004211722:	00 00 00 
  8004211725:	b8 00 00 00 00       	mov    $0x0,%eax
  800421172a:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004211731:	00 00 00 
  8004211734:	41 ff d0             	callq  *%r8
		temp = kvoffset;
  8004211737:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  800421173e:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
  8004211742:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004211746:	48 be cb 40 21 04 80 	movabs $0x80042140cb,%rsi
  800421174d:	00 00 00 
  8004211750:	48 89 c7             	mov    %rax,%rdi
  8004211753:	48 b8 5f b9 20 04 80 	movabs $0x800420b95f,%rax
  800421175a:	00 00 00 
  800421175d:	ff d0                	callq  *%rax
  800421175f:	85 c0                	test   %eax,%eax
  8004211761:	0f 85 d8 00 00 00    	jne    800421183f <read_section_headers+0x389>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004211767:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421176a:	48 98                	cltq   
  800421176c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004211773:	ff 
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004211774:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004211778:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421177b:	48 98                	cltq   
  800421177d:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004211784:	ff 
  8004211785:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211789:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004211790:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211794:	48 01 c8             	add    %rcx,%rax
  8004211797:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421179e:	48 89 c7             	mov    %rax,%rdi
  80042117a1:	48 b8 f5 1b 21 04 80 	movabs $0x8004211bf5,%rax
  80042117a8:	00 00 00 
  80042117ab:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042117ad:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042117b0:	48 98                	cltq   
  80042117b2:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042117b9:	ff 
  80042117ba:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042117be:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042117c1:	48 98                	cltq   
  80042117c3:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042117ca:	ff 
  80042117cb:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042117cf:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  80042117d3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042117d7:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042117dd:	48 29 c2             	sub    %rax,%rdx
  80042117e0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042117e4:	48 01 c2             	add    %rax,%rdx
  80042117e7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042117eb:	48 01 c2             	add    %rax,%rdx
  80042117ee:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  80042117f5:	00 00 00 
  80042117f8:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  80042117fc:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211803:	00 00 00 
  8004211806:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421180a:	48 89 c2             	mov    %rax,%rdx
  800421180d:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211814:	00 00 00 
  8004211817:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  800421181b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421181e:	48 98                	cltq   
  8004211820:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004211827:	ff 
  8004211828:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421182c:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211833:	00 00 00 
  8004211836:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421183a:	e9 96 03 00 00       	jmpq   8004211bd5 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_abbrev"))
  800421183f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004211843:	48 be d7 40 21 04 80 	movabs $0x80042140d7,%rsi
  800421184a:	00 00 00 
  800421184d:	48 89 c7             	mov    %rax,%rdi
  8004211850:	48 b8 5f b9 20 04 80 	movabs $0x800420b95f,%rax
  8004211857:	00 00 00 
  800421185a:	ff d0                	callq  *%rax
  800421185c:	85 c0                	test   %eax,%eax
  800421185e:	0f 85 de 00 00 00    	jne    8004211942 <read_section_headers+0x48c>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004211864:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211867:	48 98                	cltq   
  8004211869:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004211870:	ff 
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_abbrev"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004211871:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004211875:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211878:	48 98                	cltq   
  800421187a:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004211881:	ff 
  8004211882:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211886:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  800421188d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211891:	48 01 c8             	add    %rcx,%rax
  8004211894:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421189b:	48 89 c7             	mov    %rax,%rdi
  800421189e:	48 b8 f5 1b 21 04 80 	movabs $0x8004211bf5,%rax
  80042118a5:	00 00 00 
  80042118a8:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042118aa:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042118ad:	48 98                	cltq   
  80042118af:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042118b6:	ff 
  80042118b7:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042118bb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042118be:	48 98                	cltq   
  80042118c0:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042118c7:	ff 
  80042118c8:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042118cc:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  80042118d3:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042118da:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042118e0:	48 29 c2             	sub    %rax,%rdx
  80042118e3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042118e7:	48 01 c2             	add    %rax,%rdx
  80042118ea:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042118ee:	48 01 c2             	add    %rax,%rdx
  80042118f1:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  80042118f8:	00 00 00 
  80042118fb:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  80042118ff:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211906:	00 00 00 
  8004211909:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421190d:	48 89 c2             	mov    %rax,%rdx
  8004211910:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211917:	00 00 00 
  800421191a:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  800421191e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211921:	48 98                	cltq   
  8004211923:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421192a:	ff 
  800421192b:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421192f:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211936:	00 00 00 
  8004211939:	48 89 50 38          	mov    %rdx,0x38(%rax)
  800421193d:	e9 93 02 00 00       	jmpq   8004211bd5 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_line"))
  8004211942:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004211946:	48 be ef 40 21 04 80 	movabs $0x80042140ef,%rsi
  800421194d:	00 00 00 
  8004211950:	48 89 c7             	mov    %rax,%rdi
  8004211953:	48 b8 5f b9 20 04 80 	movabs $0x800420b95f,%rax
  800421195a:	00 00 00 
  800421195d:	ff d0                	callq  *%rax
  800421195f:	85 c0                	test   %eax,%eax
  8004211961:	0f 85 de 00 00 00    	jne    8004211a45 <read_section_headers+0x58f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004211967:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421196a:	48 98                	cltq   
  800421196c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004211973:	ff 
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_line"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004211974:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004211978:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421197b:	48 98                	cltq   
  800421197d:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004211984:	ff 
  8004211985:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211989:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004211990:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211994:	48 01 c8             	add    %rcx,%rax
  8004211997:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421199e:	48 89 c7             	mov    %rax,%rdi
  80042119a1:	48 b8 f5 1b 21 04 80 	movabs $0x8004211bf5,%rax
  80042119a8:	00 00 00 
  80042119ab:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042119ad:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042119b0:	48 98                	cltq   
  80042119b2:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042119b9:	ff 
  80042119ba:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042119be:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042119c1:	48 98                	cltq   
  80042119c3:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042119ca:	ff 
  80042119cb:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042119cf:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  80042119d6:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042119dd:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042119e3:	48 29 c2             	sub    %rax,%rdx
  80042119e6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042119ea:	48 01 c2             	add    %rax,%rdx
  80042119ed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042119f1:	48 01 c2             	add    %rax,%rdx
  80042119f4:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  80042119fb:	00 00 00 
  80042119fe:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  8004211a02:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211a09:	00 00 00 
  8004211a0c:	48 8b 40 68          	mov    0x68(%rax),%rax
  8004211a10:	48 89 c2             	mov    %rax,%rdx
  8004211a13:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211a1a:	00 00 00 
  8004211a1d:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  8004211a21:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211a24:	48 98                	cltq   
  8004211a26:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004211a2d:	ff 
  8004211a2e:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004211a32:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211a39:	00 00 00 
  8004211a3c:	48 89 50 78          	mov    %rdx,0x78(%rax)
  8004211a40:	e9 90 01 00 00       	jmpq   8004211bd5 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".eh_frame"))
  8004211a45:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004211a49:	48 be e5 40 21 04 80 	movabs $0x80042140e5,%rsi
  8004211a50:	00 00 00 
  8004211a53:	48 89 c7             	mov    %rax,%rdi
  8004211a56:	48 b8 5f b9 20 04 80 	movabs $0x800420b95f,%rax
  8004211a5d:	00 00 00 
  8004211a60:	ff d0                	callq  *%rax
  8004211a62:	85 c0                	test   %eax,%eax
  8004211a64:	75 65                	jne    8004211acb <read_section_headers+0x615>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  8004211a66:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211a69:	48 98                	cltq   
  8004211a6b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004211a72:	ff 
  8004211a73:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004211a77:	48 89 c2             	mov    %rax,%rdx
  8004211a7a:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211a81:	00 00 00 
  8004211a84:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  8004211a88:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211a8f:	00 00 00 
  8004211a92:	48 8b 40 48          	mov    0x48(%rax),%rax
  8004211a96:	48 89 c2             	mov    %rax,%rdx
  8004211a99:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211aa0:	00 00 00 
  8004211aa3:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  8004211aa7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211aaa:	48 98                	cltq   
  8004211aac:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004211ab3:	ff 
  8004211ab4:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004211ab8:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211abf:	00 00 00 
  8004211ac2:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004211ac6:	e9 0a 01 00 00       	jmpq   8004211bd5 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_str"))
  8004211acb:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004211acf:	48 be fb 40 21 04 80 	movabs $0x80042140fb,%rsi
  8004211ad6:	00 00 00 
  8004211ad9:	48 89 c7             	mov    %rax,%rdi
  8004211adc:	48 b8 5f b9 20 04 80 	movabs $0x800420b95f,%rax
  8004211ae3:	00 00 00 
  8004211ae6:	ff d0                	callq  *%rax
  8004211ae8:	85 c0                	test   %eax,%eax
  8004211aea:	0f 85 e5 00 00 00    	jne    8004211bd5 <read_section_headers+0x71f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004211af0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211af3:	48 98                	cltq   
  8004211af5:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004211afc:	ff 
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_str"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004211afd:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004211b01:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211b04:	48 98                	cltq   
  8004211b06:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004211b0d:	ff 
  8004211b0e:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211b12:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004211b19:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211b1d:	48 01 c8             	add    %rcx,%rax
  8004211b20:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004211b27:	48 89 c7             	mov    %rax,%rdi
  8004211b2a:	48 b8 f5 1b 21 04 80 	movabs $0x8004211bf5,%rax
  8004211b31:	00 00 00 
  8004211b34:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004211b36:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211b39:	48 98                	cltq   
  8004211b3b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004211b42:	ff 
  8004211b43:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004211b47:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211b4a:	48 98                	cltq   
  8004211b4c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004211b53:	ff 
  8004211b54:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211b58:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  8004211b5f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211b66:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004211b6c:	48 29 c2             	sub    %rax,%rdx
  8004211b6f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211b73:	48 01 c2             	add    %rax,%rdx
  8004211b76:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211b7a:	48 01 c2             	add    %rax,%rdx
  8004211b7d:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211b84:	00 00 00 
  8004211b87:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  8004211b8e:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211b95:	00 00 00 
  8004211b98:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004211b9f:	48 89 c2             	mov    %rax,%rdx
  8004211ba2:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211ba9:	00 00 00 
  8004211bac:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  8004211bb3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211bb6:	48 98                	cltq   
  8004211bb8:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004211bbf:	ff 
  8004211bc0:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004211bc4:	48 b8 40 66 22 04 80 	movabs $0x8004226640,%rax
  8004211bcb:	00 00 00 
  8004211bce:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	temp = kvoffset;
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	

	for (i = 0; i < numSectionHeaders; i++)
  8004211bd5:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004211bd9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211bdc:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004211bdf:	0f 8c f0 fa ff ff    	jl     80042116d5 <read_section_headers+0x21f>
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
		}
	}
	
	return ((uintptr_t)kvbase + kvoffset);
  8004211be5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004211be9:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004211bf0:	48 01 d0             	add    %rdx,%rax
}
  8004211bf3:	c9                   	leaveq 
  8004211bf4:	c3                   	retq   

0000008004211bf5 <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  8004211bf5:	55                   	push   %rbp
  8004211bf6:	48 89 e5             	mov    %rsp,%rbp
  8004211bf9:	48 83 ec 30          	sub    $0x30,%rsp
  8004211bfd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211c01:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211c05:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004211c09:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  8004211c0d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211c11:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  8004211c15:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211c19:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211c1d:	48 01 d0             	add    %rdx,%rax
  8004211c20:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  8004211c24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c28:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004211c2d:	48 85 c0             	test   %rax,%rax
  8004211c30:	74 35                	je     8004211c67 <readseg+0x72>
  8004211c32:	48 b9 42 41 21 04 80 	movabs $0x8004214142,%rcx
  8004211c39:	00 00 00 
  8004211c3c:	48 ba 1f 41 21 04 80 	movabs $0x800421411f,%rdx
  8004211c43:	00 00 00 
  8004211c46:	be c0 00 00 00       	mov    $0xc0,%esi
  8004211c4b:	48 bf 34 41 21 04 80 	movabs $0x8004214134,%rdi
  8004211c52:	00 00 00 
  8004211c55:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211c5a:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004211c61:	00 00 00 
  8004211c64:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  8004211c67:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  8004211c6e:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  8004211c6f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211c73:	48 c1 e8 09          	shr    $0x9,%rax
  8004211c77:	48 83 c0 01          	add    $0x1,%rax
  8004211c7b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004211c7f:	eb 3c                	jmp    8004211cbd <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  8004211c81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c85:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004211c89:	48 89 d6             	mov    %rdx,%rsi
  8004211c8c:	48 89 c7             	mov    %rax,%rdi
  8004211c8f:	48 b8 85 1d 21 04 80 	movabs $0x8004211d85,%rax
  8004211c96:	00 00 00 
  8004211c99:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  8004211c9b:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  8004211ca2:	00 
		*kvoffset += SECTSIZE;
  8004211ca3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211ca7:	48 8b 00             	mov    (%rax),%rax
  8004211caa:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004211cb1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211cb5:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  8004211cb8:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004211cbd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211cc1:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004211cc5:	72 ba                	jb     8004211c81 <readseg+0x8c>
		pa += SECTSIZE;
		*kvoffset += SECTSIZE;
		offset++;
	}

	if(((orgoff % SECTSIZE) + count) > SECTSIZE)
  8004211cc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211ccb:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004211cd0:	48 89 c2             	mov    %rax,%rdx
  8004211cd3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211cd7:	48 01 d0             	add    %rdx,%rax
  8004211cda:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  8004211ce0:	76 2f                	jbe    8004211d11 <readseg+0x11c>
	{
		readsect((uint8_t*) pa, offset);
  8004211ce2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ce6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004211cea:	48 89 d6             	mov    %rdx,%rsi
  8004211ced:	48 89 c7             	mov    %rax,%rdi
  8004211cf0:	48 b8 85 1d 21 04 80 	movabs $0x8004211d85,%rax
  8004211cf7:	00 00 00 
  8004211cfa:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  8004211cfc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211d00:	48 8b 00             	mov    (%rax),%rax
  8004211d03:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004211d0a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211d0e:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  8004211d11:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211d15:	48 8b 00             	mov    (%rax),%rax
  8004211d18:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004211d1d:	48 85 c0             	test   %rax,%rax
  8004211d20:	74 35                	je     8004211d57 <readseg+0x162>
  8004211d22:	48 b9 55 41 21 04 80 	movabs $0x8004214155,%rcx
  8004211d29:	00 00 00 
  8004211d2c:	48 ba 1f 41 21 04 80 	movabs $0x800421411f,%rdx
  8004211d33:	00 00 00 
  8004211d36:	be d6 00 00 00       	mov    $0xd6,%esi
  8004211d3b:	48 bf 34 41 21 04 80 	movabs $0x8004214134,%rdi
  8004211d42:	00 00 00 
  8004211d45:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211d4a:	49 b8 50 01 20 04 80 	movabs $0x8004200150,%r8
  8004211d51:	00 00 00 
  8004211d54:	41 ff d0             	callq  *%r8
}
  8004211d57:	c9                   	leaveq 
  8004211d58:	c3                   	retq   

0000008004211d59 <waitdisk>:

void
waitdisk(void)
{
  8004211d59:	55                   	push   %rbp
  8004211d5a:	48 89 e5             	mov    %rsp,%rbp
  8004211d5d:	48 83 ec 10          	sub    $0x10,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  8004211d61:	90                   	nop
  8004211d62:	c7 45 fc f7 01 00 00 	movl   $0x1f7,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004211d69:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004211d6c:	89 c2                	mov    %eax,%edx
  8004211d6e:	ec                   	in     (%dx),%al
  8004211d6f:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  8004211d72:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004211d76:	0f b6 c0             	movzbl %al,%eax
  8004211d79:	25 c0 00 00 00       	and    $0xc0,%eax
  8004211d7e:	83 f8 40             	cmp    $0x40,%eax
  8004211d81:	75 df                	jne    8004211d62 <waitdisk+0x9>
		/* do nothing */;
}
  8004211d83:	c9                   	leaveq 
  8004211d84:	c3                   	retq   

0000008004211d85 <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  8004211d85:	55                   	push   %rbp
  8004211d86:	48 89 e5             	mov    %rsp,%rbp
  8004211d89:	48 83 ec 60          	sub    $0x60,%rsp
  8004211d8d:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004211d91:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	// wait for disk to be ready
	waitdisk();
  8004211d95:	48 b8 59 1d 21 04 80 	movabs $0x8004211d59,%rax
  8004211d9c:	00 00 00 
  8004211d9f:	ff d0                	callq  *%rax
  8004211da1:	c7 45 fc f2 01 00 00 	movl   $0x1f2,-0x4(%rbp)
  8004211da8:	c6 45 fb 01          	movb   $0x1,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004211dac:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004211db0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004211db3:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  8004211db4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211db8:	0f b6 c0             	movzbl %al,%eax
  8004211dbb:	c7 45 f4 f3 01 00 00 	movl   $0x1f3,-0xc(%rbp)
  8004211dc2:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004211dc5:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004211dc9:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004211dcc:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  8004211dcd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211dd1:	48 c1 e8 08          	shr    $0x8,%rax
  8004211dd5:	0f b6 c0             	movzbl %al,%eax
  8004211dd8:	c7 45 ec f4 01 00 00 	movl   $0x1f4,-0x14(%rbp)
  8004211ddf:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004211de2:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004211de6:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004211de9:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  8004211dea:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211dee:	48 c1 e8 10          	shr    $0x10,%rax
  8004211df2:	0f b6 c0             	movzbl %al,%eax
  8004211df5:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%rbp)
  8004211dfc:	88 45 e3             	mov    %al,-0x1d(%rbp)
  8004211dff:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004211e03:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004211e06:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  8004211e07:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211e0b:	48 c1 e8 18          	shr    $0x18,%rax
  8004211e0f:	83 c8 e0             	or     $0xffffffe0,%eax
  8004211e12:	0f b6 c0             	movzbl %al,%eax
  8004211e15:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%rbp)
  8004211e1c:	88 45 db             	mov    %al,-0x25(%rbp)
  8004211e1f:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004211e23:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004211e26:	ee                   	out    %al,(%dx)
  8004211e27:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%rbp)
  8004211e2e:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
  8004211e32:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004211e36:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004211e39:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  8004211e3a:	48 b8 59 1d 21 04 80 	movabs $0x8004211d59,%rax
  8004211e41:	00 00 00 
  8004211e44:	ff d0                	callq  *%rax
  8004211e46:	c7 45 cc f0 01 00 00 	movl   $0x1f0,-0x34(%rbp)
  8004211e4d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211e51:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004211e55:	c7 45 bc 80 00 00 00 	movl   $0x80,-0x44(%rbp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
  8004211e5c:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004211e5f:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004211e63:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004211e66:	48 89 ce             	mov    %rcx,%rsi
  8004211e69:	48 89 f7             	mov    %rsi,%rdi
  8004211e6c:	89 c1                	mov    %eax,%ecx
  8004211e6e:	fc                   	cld    
  8004211e6f:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  8004211e71:	89 c8                	mov    %ecx,%eax
  8004211e73:	48 89 fe             	mov    %rdi,%rsi
  8004211e76:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004211e7a:	89 45 bc             	mov    %eax,-0x44(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  8004211e7d:	c9                   	leaveq 
  8004211e7e:	c3                   	retq   
