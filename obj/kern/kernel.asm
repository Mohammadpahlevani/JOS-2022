
obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000000100000 <_head64>:
.text
.globl _head64
_head64:

# Save multiboot_info addr passed by bootloader
    movl $multiboot_info, %eax
  100000:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  100005:	89 18                	mov    %ebx,(%rax)

	movw $0x1234,0x472			# warm boot
  100007:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472(%rip)        # 100482 <verify_cpu_no_longmode+0x36f>
  10000e:	34 12 
# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  100010:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100015:	e8 cc 00 00 00       	callq  1000e6 <verify_cpu>
    movl $CR4_PAE,%eax
  10001a:	b8 20 00 00 00       	mov    $0x20,%eax
    movl %eax,%cr4
  10001f:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100022:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100027:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100029:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002e:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  100030:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100035:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  10003a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  100040:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100042:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100047:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10004a:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004d:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  100050:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100055:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  10005a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100060:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100062:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100067:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006c:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006f:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100072:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100074:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100079:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007e:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100083:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100089:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008e:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  100090:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100092:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100095:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100098:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009d:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  1000a0:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a3:	75 e9                	jne    10008e <_head64+0x8e>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a5:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000aa:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ad:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b2:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b4:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b8:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000ba:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bd:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000c0:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c5:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000ca:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000cf:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d2:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d5:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000da:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dd:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000df:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e4:	50                   	push   %rax

00000000001000e5 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e5:	cb                   	lret   

00000000001000e6 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e6:	9c                   	pushfq 
    popl %eax
  1000e7:	58                   	pop    %rax
    movl %eax,%ecx
  1000e8:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000ea:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ef:	50                   	push   %rax
    popfl
  1000f0:	9d                   	popfq  
    pushfl
  1000f1:	9c                   	pushfq 
    popl %eax
  1000f2:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f3:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f5:	74 1c                	je     100113 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f7:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fc:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fe:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100101:	72 10                	jb     100113 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100103:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100108:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  10010a:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  100110:	74 01                	je     100113 <verify_cpu_no_longmode>

    ret
  100112:	c3                   	retq   

0000000000100113 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100113:	eb fe                	jmp    100113 <verify_cpu_no_longmode>
  100115:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10011c:	00 00 00 
  10011f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100126:	00 00 00 
  100129:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100130:	00 00 00 
  100133:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10013a:	00 00 00 
  10013d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100144:	00 00 00 
  100147:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10014e:	00 00 00 
  100151:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100158:	00 00 00 
  10015b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100162:	00 00 00 
  100165:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10016c:	00 00 00 
  10016f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100176:	00 00 00 
  100179:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100180:	00 00 00 
  100183:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10018a:	00 00 00 
  10018d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100194:	00 00 00 
  100197:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10019e:	00 00 00 
  1001a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001a8:	00 00 00 
  1001ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001b2:	00 00 00 
  1001b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001bc:	00 00 00 
  1001bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001c6:	00 00 00 
  1001c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001d0:	00 00 00 
  1001d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001da:	00 00 00 
  1001dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001e4:	00 00 00 
  1001e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001ee:	00 00 00 
  1001f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001f8:	00 00 00 
  1001fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100202:	00 00 00 
  100205:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10020c:	00 00 00 
  10020f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100216:	00 00 00 
  100219:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100220:	00 00 00 
  100223:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10022a:	00 00 00 
  10022d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100234:	00 00 00 
  100237:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10023e:	00 00 00 
  100241:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100248:	00 00 00 
  10024b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100252:	00 00 00 
  100255:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10025c:	00 00 00 
  10025f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100266:	00 00 00 
  100269:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100270:	00 00 00 
  100273:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10027a:	00 00 00 
  10027d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100284:	00 00 00 
  100287:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10028e:	00 00 00 
  100291:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100298:	00 00 00 
  10029b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002a2:	00 00 00 
  1002a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ac:	00 00 00 
  1002af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002b6:	00 00 00 
  1002b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002c0:	00 00 00 
  1002c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ca:	00 00 00 
  1002cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002d4:	00 00 00 
  1002d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002de:	00 00 00 
  1002e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002e8:	00 00 00 
  1002eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002f2:	00 00 00 
  1002f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002fc:	00 00 00 
  1002ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100306:	00 00 00 
  100309:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100310:	00 00 00 
  100313:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10031a:	00 00 00 
  10031d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100324:	00 00 00 
  100327:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10032e:	00 00 00 
  100331:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100338:	00 00 00 
  10033b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100342:	00 00 00 
  100345:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10034c:	00 00 00 
  10034f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100356:	00 00 00 
  100359:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100360:	00 00 00 
  100363:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10036a:	00 00 00 
  10036d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100374:	00 00 00 
  100377:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10037e:	00 00 00 
  100381:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100388:	00 00 00 
  10038b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100392:	00 00 00 
  100395:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10039c:	00 00 00 
  10039f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003a6:	00 00 00 
  1003a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003b0:	00 00 00 
  1003b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ba:	00 00 00 
  1003bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003c4:	00 00 00 
  1003c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ce:	00 00 00 
  1003d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003d8:	00 00 00 
  1003db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003e2:	00 00 00 
  1003e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ec:	00 00 00 
  1003ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003f6:	00 00 00 
  1003f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100400:	00 00 00 
  100403:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10040a:	00 00 00 
  10040d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100414:	00 00 00 
  100417:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10041e:	00 00 00 
  100421:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100428:	00 00 00 
  10042b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100432:	00 00 00 
  100435:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10043c:	00 00 00 
  10043f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100446:	00 00 00 
  100449:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100450:	00 00 00 
  100453:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10045a:	00 00 00 
  10045d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100464:	00 00 00 
  100467:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10046e:	00 00 00 
  100471:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100478:	00 00 00 
  10047b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100482:	00 00 00 
  100485:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10048c:	00 00 00 
  10048f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100496:	00 00 00 
  100499:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004a0:	00 00 00 
  1004a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004aa:	00 00 00 
  1004ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004b4:	00 00 00 
  1004b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004be:	00 00 00 
  1004c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004c8:	00 00 00 
  1004cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004d2:	00 00 00 
  1004d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004dc:	00 00 00 
  1004df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004e6:	00 00 00 
  1004e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004f0:	00 00 00 
  1004f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004fa:	00 00 00 
  1004fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100504:	00 00 00 
  100507:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10050e:	00 00 00 
  100511:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100518:	00 00 00 
  10051b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100522:	00 00 00 
  100525:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10052c:	00 00 00 
  10052f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100536:	00 00 00 
  100539:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100540:	00 00 00 
  100543:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10054a:	00 00 00 
  10054d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100554:	00 00 00 
  100557:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10055e:	00 00 00 
  100561:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100568:	00 00 00 
  10056b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100572:	00 00 00 
  100575:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10057c:	00 00 00 
  10057f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100586:	00 00 00 
  100589:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100590:	00 00 00 
  100593:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10059a:	00 00 00 
  10059d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005a4:	00 00 00 
  1005a7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ae:	00 00 00 
  1005b1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005b8:	00 00 00 
  1005bb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005c2:	00 00 00 
  1005c5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005cc:	00 00 00 
  1005cf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005d6:	00 00 00 
  1005d9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005e0:	00 00 00 
  1005e3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ea:	00 00 00 
  1005ed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005f4:	00 00 00 
  1005f7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005fe:	00 00 00 
  100601:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100608:	00 00 00 
  10060b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100612:	00 00 00 
  100615:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10061c:	00 00 00 
  10061f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100626:	00 00 00 
  100629:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100630:	00 00 00 
  100633:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10063a:	00 00 00 
  10063d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100644:	00 00 00 
  100647:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10064e:	00 00 00 
  100651:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100658:	00 00 00 
  10065b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100662:	00 00 00 
  100665:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10066c:	00 00 00 
  10066f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100676:	00 00 00 
  100679:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100680:	00 00 00 
  100683:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10068a:	00 00 00 
  10068d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100694:	00 00 00 
  100697:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10069e:	00 00 00 
  1006a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006a8:	00 00 00 
  1006ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006b2:	00 00 00 
  1006b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006bc:	00 00 00 
  1006bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006c6:	00 00 00 
  1006c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006d0:	00 00 00 
  1006d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006da:	00 00 00 
  1006dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006e4:	00 00 00 
  1006e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006ee:	00 00 00 
  1006f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006f8:	00 00 00 
  1006fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100702:	00 00 00 
  100705:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10070c:	00 00 00 
  10070f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100716:	00 00 00 
  100719:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100720:	00 00 00 
  100723:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10072a:	00 00 00 
  10072d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100734:	00 00 00 
  100737:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10073e:	00 00 00 
  100741:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100748:	00 00 00 
  10074b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100752:	00 00 00 
  100755:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10075c:	00 00 00 
  10075f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100766:	00 00 00 
  100769:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100770:	00 00 00 
  100773:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10077a:	00 00 00 
  10077d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100784:	00 00 00 
  100787:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10078e:	00 00 00 
  100791:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100798:	00 00 00 
  10079b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007a2:	00 00 00 
  1007a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ac:	00 00 00 
  1007af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007b6:	00 00 00 
  1007b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007c0:	00 00 00 
  1007c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ca:	00 00 00 
  1007cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007d4:	00 00 00 
  1007d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007de:	00 00 00 
  1007e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007e8:	00 00 00 
  1007eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007f2:	00 00 00 
  1007f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007fc:	00 00 00 
  1007ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100806:	00 00 00 
  100809:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100810:	00 00 00 
  100813:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10081a:	00 00 00 
  10081d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100824:	00 00 00 
  100827:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10082e:	00 00 00 
  100831:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100838:	00 00 00 
  10083b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100842:	00 00 00 
  100845:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10084c:	00 00 00 
  10084f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100856:	00 00 00 
  100859:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100860:	00 00 00 
  100863:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10086a:	00 00 00 
  10086d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100874:	00 00 00 
  100877:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10087e:	00 00 00 
  100881:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100888:	00 00 00 
  10088b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100892:	00 00 00 
  100895:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10089c:	00 00 00 
  10089f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008a6:	00 00 00 
  1008a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008b0:	00 00 00 
  1008b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ba:	00 00 00 
  1008bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008c4:	00 00 00 
  1008c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ce:	00 00 00 
  1008d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008d8:	00 00 00 
  1008db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008e2:	00 00 00 
  1008e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ec:	00 00 00 
  1008ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008f6:	00 00 00 
  1008f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100900:	00 00 00 
  100903:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10090a:	00 00 00 
  10090d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100914:	00 00 00 
  100917:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10091e:	00 00 00 
  100921:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100928:	00 00 00 
  10092b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100932:	00 00 00 
  100935:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10093c:	00 00 00 
  10093f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100946:	00 00 00 
  100949:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100950:	00 00 00 
  100953:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10095a:	00 00 00 
  10095d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100964:	00 00 00 
  100967:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10096e:	00 00 00 
  100971:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100978:	00 00 00 
  10097b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100982:	00 00 00 
  100985:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10098c:	00 00 00 
  10098f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100996:	00 00 00 
  100999:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009a0:	00 00 00 
  1009a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009aa:	00 00 00 
  1009ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009b4:	00 00 00 
  1009b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009be:	00 00 00 
  1009c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009c8:	00 00 00 
  1009cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009d2:	00 00 00 
  1009d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009dc:	00 00 00 
  1009df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009e6:	00 00 00 
  1009e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009f0:	00 00 00 
  1009f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009fa:	00 00 00 
  1009fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a04:	00 00 00 
  100a07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a0e:	00 00 00 
  100a11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a18:	00 00 00 
  100a1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a22:	00 00 00 
  100a25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a2c:	00 00 00 
  100a2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a36:	00 00 00 
  100a39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a40:	00 00 00 
  100a43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a4a:	00 00 00 
  100a4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a54:	00 00 00 
  100a57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a5e:	00 00 00 
  100a61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a68:	00 00 00 
  100a6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a72:	00 00 00 
  100a75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a7c:	00 00 00 
  100a7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a86:	00 00 00 
  100a89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a90:	00 00 00 
  100a93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a9a:	00 00 00 
  100a9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aa4:	00 00 00 
  100aa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aae:	00 00 00 
  100ab1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ab8:	00 00 00 
  100abb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ac2:	00 00 00 
  100ac5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100acc:	00 00 00 
  100acf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ad6:	00 00 00 
  100ad9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ae0:	00 00 00 
  100ae3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aea:	00 00 00 
  100aed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100af4:	00 00 00 
  100af7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100afe:	00 00 00 
  100b01:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b08:	00 00 00 
  100b0b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b12:	00 00 00 
  100b15:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b1c:	00 00 00 
  100b1f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b26:	00 00 00 
  100b29:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b30:	00 00 00 
  100b33:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b3a:	00 00 00 
  100b3d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b44:	00 00 00 
  100b47:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b4e:	00 00 00 
  100b51:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b58:	00 00 00 
  100b5b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b62:	00 00 00 
  100b65:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b6c:	00 00 00 
  100b6f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b76:	00 00 00 
  100b79:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b80:	00 00 00 
  100b83:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b8a:	00 00 00 
  100b8d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b94:	00 00 00 
  100b97:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b9e:	00 00 00 
  100ba1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ba8:	00 00 00 
  100bab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bb2:	00 00 00 
  100bb5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bbc:	00 00 00 
  100bbf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bc6:	00 00 00 
  100bc9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bd0:	00 00 00 
  100bd3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bda:	00 00 00 
  100bdd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100be4:	00 00 00 
  100be7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bee:	00 00 00 
  100bf1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bf8:	00 00 00 
  100bfb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c02:	00 00 00 
  100c05:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c0c:	00 00 00 
  100c0f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c16:	00 00 00 
  100c19:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c20:	00 00 00 
  100c23:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c2a:	00 00 00 
  100c2d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c34:	00 00 00 
  100c37:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c3e:	00 00 00 
  100c41:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c48:	00 00 00 
  100c4b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c52:	00 00 00 
  100c55:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c5c:	00 00 00 
  100c5f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c66:	00 00 00 
  100c69:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c70:	00 00 00 
  100c73:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c7a:	00 00 00 
  100c7d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c84:	00 00 00 
  100c87:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c8e:	00 00 00 
  100c91:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c98:	00 00 00 
  100c9b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ca2:	00 00 00 
  100ca5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cac:	00 00 00 
  100caf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cb6:	00 00 00 
  100cb9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cc0:	00 00 00 
  100cc3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cca:	00 00 00 
  100ccd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cd4:	00 00 00 
  100cd7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cde:	00 00 00 
  100ce1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ce8:	00 00 00 
  100ceb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cf2:	00 00 00 
  100cf5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cfc:	00 00 00 
  100cff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d06:	00 00 00 
  100d09:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d10:	00 00 00 
  100d13:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d1a:	00 00 00 
  100d1d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d24:	00 00 00 
  100d27:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d2e:	00 00 00 
  100d31:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d38:	00 00 00 
  100d3b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d42:	00 00 00 
  100d45:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d4c:	00 00 00 
  100d4f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d56:	00 00 00 
  100d59:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d60:	00 00 00 
  100d63:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d6a:	00 00 00 
  100d6d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d74:	00 00 00 
  100d77:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d7e:	00 00 00 
  100d81:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d88:	00 00 00 
  100d8b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d92:	00 00 00 
  100d95:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d9c:	00 00 00 
  100d9f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100da6:	00 00 00 
  100da9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100db0:	00 00 00 
  100db3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dba:	00 00 00 
  100dbd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dc4:	00 00 00 
  100dc7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dce:	00 00 00 
  100dd1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dd8:	00 00 00 
  100ddb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100de2:	00 00 00 
  100de5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dec:	00 00 00 
  100def:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100df6:	00 00 00 
  100df9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e00:	00 00 00 
  100e03:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e0a:	00 00 00 
  100e0d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e14:	00 00 00 
  100e17:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e1e:	00 00 00 
  100e21:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e28:	00 00 00 
  100e2b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e32:	00 00 00 
  100e35:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e3c:	00 00 00 
  100e3f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e46:	00 00 00 
  100e49:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e50:	00 00 00 
  100e53:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e5a:	00 00 00 
  100e5d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e64:	00 00 00 
  100e67:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e6e:	00 00 00 
  100e71:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e78:	00 00 00 
  100e7b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e82:	00 00 00 
  100e85:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e8c:	00 00 00 
  100e8f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e96:	00 00 00 
  100e99:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ea0:	00 00 00 
  100ea3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eaa:	00 00 00 
  100ead:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eb4:	00 00 00 
  100eb7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ebe:	00 00 00 
  100ec1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ec8:	00 00 00 
  100ecb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ed2:	00 00 00 
  100ed5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100edc:	00 00 00 
  100edf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ee6:	00 00 00 
  100ee9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ef0:	00 00 00 
  100ef3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100efa:	00 00 00 
  100efd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f04:	00 00 00 
  100f07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f0e:	00 00 00 
  100f11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f18:	00 00 00 
  100f1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f22:	00 00 00 
  100f25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f2c:	00 00 00 
  100f2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f36:	00 00 00 
  100f39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f40:	00 00 00 
  100f43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f4a:	00 00 00 
  100f4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f54:	00 00 00 
  100f57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f5e:	00 00 00 
  100f61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f68:	00 00 00 
  100f6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f72:	00 00 00 
  100f75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f7c:	00 00 00 
  100f7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f86:	00 00 00 
  100f89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f90:	00 00 00 
  100f93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f9a:	00 00 00 
  100f9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fa4:	00 00 00 
  100fa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fae:	00 00 00 
  100fb1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fb8:	00 00 00 
  100fbb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fc2:	00 00 00 
  100fc5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fcc:	00 00 00 
  100fcf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fd6:	00 00 00 
  100fd9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fe0:	00 00 00 
  100fe3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fea:	00 00 00 
  100fed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ff4:	00 00 00 
  100ff7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  100ffe:	00 00 

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4phys>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Disassembly of section .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4 48                	in     $0x48,%al

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 a0 22 04 80 	movabs $0x800422a038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 a0 22 04 80 	movabs $0x800422a000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 1d 01 20 04 80 	movabs $0x800420011d,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
  800420005c:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004200060:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004200064:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004200067:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420006b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420006e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004200072:	f0 87 02             	lock xchg %eax,(%rdx)
  8004200075:	89 45 fc             	mov    %eax,-0x4(%rbp)
	"+m" (*addr), "=a" (result):
	"1"(newval):
	"cc");
	return result;
  8004200078:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420007b:	c9                   	leaveq 
  800420007c:	c3                   	retq   

000000800420007d <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800420007d:	55                   	push   %rbp
  800420007e:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004200081:	48 bf c0 a7 22 04 80 	movabs $0x800422a7c0,%rdi
  8004200088:	00 00 00 
  800420008b:	48 b8 48 6e 21 04 80 	movabs $0x8004216e48,%rax
  8004200092:	00 00 00 
  8004200095:	ff d0                	callq  *%rax
}
  8004200097:	5d                   	pop    %rbp
  8004200098:	c3                   	retq   

0000008004200099 <test_backtrace>:


// Test the stack backtrace function (lab 1 only)
void
test_backtrace(int x)
{
  8004200099:	55                   	push   %rbp
  800420009a:	48 89 e5             	mov    %rsp,%rbp
  800420009d:	48 83 ec 10          	sub    $0x10,%rsp
  80042000a1:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cprintf("entering test_backtrace %d\n", x);
  80042000a4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042000a7:	89 c6                	mov    %eax,%esi
  80042000a9:	48 bf 80 71 21 04 80 	movabs $0x8004217180,%rdi
  80042000b0:	00 00 00 
  80042000b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042000b8:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  80042000bf:	00 00 00 
  80042000c2:	ff d2                	callq  *%rdx
	if (x > 0)
  80042000c4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042000c8:	7e 16                	jle    80042000e0 <test_backtrace+0x47>
	        test_backtrace(x-1);
  80042000ca:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042000cd:	83 e8 01             	sub    $0x1,%eax
  80042000d0:	89 c7                	mov    %eax,%edi
  80042000d2:	48 b8 99 00 20 04 80 	movabs $0x8004200099,%rax
  80042000d9:	00 00 00 
  80042000dc:	ff d0                	callq  *%rax
  80042000de:	eb 1b                	jmp    80042000fb <test_backtrace+0x62>
	else
	      mon_backtrace(0, 0, 0);
  80042000e0:	ba 00 00 00 00       	mov    $0x0,%edx
  80042000e5:	be 00 00 00 00       	mov    $0x0,%esi
  80042000ea:	bf 00 00 00 00       	mov    $0x0,%edi
  80042000ef:	48 b8 78 14 20 04 80 	movabs $0x8004201478,%rax
  80042000f6:	00 00 00 
  80042000f9:	ff d0                	callq  *%rax
	cprintf("leaving test_backtrace %d\n", x);
  80042000fb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042000fe:	89 c6                	mov    %eax,%esi
  8004200100:	48 bf 9c 71 21 04 80 	movabs $0x800421719c,%rdi
  8004200107:	00 00 00 
  800420010a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420010f:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004200116:	00 00 00 
  8004200119:	ff d2                	callq  *%rdx
}
  800420011b:	c9                   	leaveq 
  800420011c:	c3                   	retq   

000000800420011d <i386_init>:

void
i386_init(void)
{
  800420011d:	55                   	push   %rbp
  800420011e:	48 89 e5             	mov    %rsp,%rbp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  8004200121:	48 ba 10 40 3e 04 80 	movabs $0x80043e4010,%rdx
  8004200128:	00 00 00 
  800420012b:	48 b8 4a f7 35 04 80 	movabs $0x800435f74a,%rax
  8004200132:	00 00 00 
  8004200135:	48 29 c2             	sub    %rax,%rdx
  8004200138:	48 89 d0             	mov    %rdx,%rax
  800420013b:	48 89 c2             	mov    %rax,%rdx
  800420013e:	be 00 00 00 00       	mov    $0x0,%esi
  8004200143:	48 bf 4a f7 35 04 80 	movabs $0x800435f74a,%rdi
  800420014a:	00 00 00 
  800420014d:	48 b8 b3 fb 20 04 80 	movabs $0x800420fbb3,%rax
  8004200154:	00 00 00 
  8004200157:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  8004200159:	48 b8 a8 11 20 04 80 	movabs $0x80042011a8,%rax
  8004200160:	00 00 00 
  8004200163:	ff d0                	callq  *%rax

	cprintf("6828 decimal is %o octal!\n", 6828);
  8004200165:	be ac 1a 00 00       	mov    $0x1aac,%esi
  800420016a:	48 bf b7 71 21 04 80 	movabs $0x80042171b7,%rdi
  8004200171:	00 00 00 
  8004200174:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200179:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004200180:	00 00 00 
  8004200183:	ff d2                	callq  *%rdx

    extern char end[];
    end_debug = read_section_headers((0x10000+KERNBASE), (uintptr_t)end); 
  8004200185:	48 b8 10 40 3e 04 80 	movabs $0x80043e4010,%rax
  800420018c:	00 00 00 
  800420018f:	48 89 c6             	mov    %rax,%rsi
  8004200192:	48 bf 00 00 01 04 80 	movabs $0x8004010000,%rdi
  8004200199:	00 00 00 
  800420019c:	48 b8 f9 55 21 04 80 	movabs $0x80042155f9,%rax
  80042001a3:	00 00 00 
  80042001a6:	ff d0                	callq  *%rax
  80042001a8:	48 ba 88 17 36 04 80 	movabs $0x8004361788,%rdx
  80042001af:	00 00 00 
  80042001b2:	48 89 02             	mov    %rax,(%rdx)

	// Lab 2 memory management initialization functions
	x64_vm_init();
  80042001b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042001ba:	48 ba 67 2d 20 04 80 	movabs $0x8004202d67,%rdx
  80042001c1:	00 00 00 
  80042001c4:	ff d2                	callq  *%rdx

	// Lab 3 user environment initialization functions
	env_init();
  80042001c6:	48 b8 20 7f 20 04 80 	movabs $0x8004207f20,%rax
  80042001cd:	00 00 00 
  80042001d0:	ff d0                	callq  *%rax
	trap_init();
  80042001d2:	48 b8 89 97 20 04 80 	movabs $0x8004209789,%rax
  80042001d9:	00 00 00 
  80042001dc:	ff d0                	callq  *%rax

	// Lab 4 multiprocessor initialization functions
	
	mp_init();
  80042001de:	48 b8 85 65 21 04 80 	movabs $0x8004216585,%rax
  80042001e5:	00 00 00 
  80042001e8:	ff d0                	callq  *%rax
	lapic_init();
  80042001ea:	48 b8 c6 68 21 04 80 	movabs $0x80042168c6,%rax
  80042001f1:	00 00 00 
  80042001f4:	ff d0                	callq  *%rax

	// Lab 4 multitasking initialization functions
	pic_init();
  80042001f6:	48 b8 41 93 20 04 80 	movabs $0x8004209341,%rax
  80042001fd:	00 00 00 
  8004200200:	ff d0                	callq  *%rax

	// Acquire the big kernel lock before waking up APs
	// Your code here:
	lock_kernel();
  8004200202:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  8004200209:	00 00 00 
  800420020c:	ff d0                	callq  *%rax
	// Starting non-boot CPUs
	boot_aps();
  800420020e:	48 b8 41 02 20 04 80 	movabs $0x8004200241,%rax
  8004200215:	00 00 00 
  8004200218:	ff d0                	callq  *%rax

#if defined(TEST)
	// Don't touch -- used by grading script!
	ENV_CREATE(TEST, ENV_TYPE_USER);
  800420021a:	be 00 00 00 00       	mov    $0x0,%esi
  800420021f:	48 bf d8 2e 35 04 80 	movabs $0x8004352ed8,%rdi
  8004200226:	00 00 00 
  8004200229:	48 b8 72 89 20 04 80 	movabs $0x8004208972,%rax
  8004200230:	00 00 00 
  8004200233:	ff d0                	callq  *%rax
	ENV_CREATE(user_spin, ENV_TYPE_USER);
	//ENV_CREATE(user_yield, ENV_TYPE_USER);
#endif // TEST*

	// Schedule and run the first user environment!
	sched_yield();
  8004200235:	48 b8 61 d2 20 04 80 	movabs $0x800420d261,%rax
  800420023c:	00 00 00 
  800420023f:	ff d0                	callq  *%rax

0000008004200241 <boot_aps>:
void *mpentry_kstack;

// Start the non-boot (AP) processors.
static void
boot_aps(void)
{
  8004200241:	55                   	push   %rbp
  8004200242:	48 89 e5             	mov    %rsp,%rbp
  8004200245:	48 83 ec 30          	sub    $0x30,%rsp
	extern unsigned char mpentry_start[], mpentry_end[];
	void *code;
	struct CpuInfo *c;

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
  8004200249:	48 c7 45 f0 00 70 00 	movq   $0x7000,-0x10(%rbp)
  8004200250:	00 
  8004200251:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200255:	48 c1 e8 0c          	shr    $0xc,%rax
  8004200259:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420025c:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420025f:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004200266:	00 00 00 
  8004200269:	48 8b 00             	mov    (%rax),%rax
  800420026c:	48 39 c2             	cmp    %rax,%rdx
  800420026f:	72 32                	jb     80042002a3 <boot_aps+0x62>
  8004200271:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200275:	48 89 c1             	mov    %rax,%rcx
  8004200278:	48 ba d8 71 21 04 80 	movabs $0x80042171d8,%rdx
  800420027f:	00 00 00 
  8004200282:	be 6d 00 00 00       	mov    $0x6d,%esi
  8004200287:	48 bf fb 71 21 04 80 	movabs $0x80042171fb,%rdi
  800420028e:	00 00 00 
  8004200291:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200296:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420029d:	00 00 00 
  80042002a0:	41 ff d0             	callq  *%r8
  80042002a3:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042002aa:	00 00 00 
  80042002ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042002b1:	48 01 d0             	add    %rdx,%rax
  80042002b4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
  80042002b8:	48 ba ae 60 21 04 80 	movabs $0x80042160ae,%rdx
  80042002bf:	00 00 00 
  80042002c2:	48 b8 c8 5f 21 04 80 	movabs $0x8004215fc8,%rax
  80042002c9:	00 00 00 
  80042002cc:	48 29 c2             	sub    %rax,%rdx
  80042002cf:	48 89 d0             	mov    %rdx,%rax
  80042002d2:	48 89 c2             	mov    %rax,%rdx
  80042002d5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042002d9:	48 be c8 5f 21 04 80 	movabs $0x8004215fc8,%rsi
  80042002e0:	00 00 00 
  80042002e3:	48 89 c7             	mov    %rax,%rdi
  80042002e6:	48 b8 3e fc 20 04 80 	movabs $0x800420fc3e,%rax
  80042002ed:	00 00 00 
  80042002f0:	ff d0                	callq  *%rax
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  80042002f2:	48 b8 20 30 36 04 80 	movabs $0x8004363020,%rax
  80042002f9:	00 00 00 
  80042002fc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004200300:	e9 0b 01 00 00       	jmpq   8004200410 <boot_aps+0x1cf>
		if (c == cpus + cpunum())  // We've started already.
  8004200305:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420030c:	00 00 00 
  800420030f:	ff d0                	callq  *%rax
  8004200311:	48 98                	cltq   
  8004200313:	48 c1 e0 03          	shl    $0x3,%rax
  8004200317:	48 89 c2             	mov    %rax,%rdx
  800420031a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420031e:	48 29 c2             	sub    %rax,%rdx
  8004200321:	48 b8 20 30 36 04 80 	movabs $0x8004363020,%rax
  8004200328:	00 00 00 
  800420032b:	48 01 d0             	add    %rdx,%rax
  800420032e:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004200332:	75 05                	jne    8004200339 <boot_aps+0xf8>
			continue;
  8004200334:	e9 d2 00 00 00       	jmpq   800420040b <boot_aps+0x1ca>

		// Tell mpentry.S what stack to use 
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
  8004200339:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420033d:	48 b8 20 30 36 04 80 	movabs $0x8004363020,%rax
  8004200344:	00 00 00 
  8004200347:	48 29 c2             	sub    %rax,%rdx
  800420034a:	48 89 d0             	mov    %rdx,%rax
  800420034d:	48 c1 f8 03          	sar    $0x3,%rax
  8004200351:	48 89 c2             	mov    %rax,%rdx
  8004200354:	48 b8 ef ee ee ee ee 	movabs $0xeeeeeeeeeeeeeeef,%rax
  800420035b:	ee ee ee 
  800420035e:	48 0f af c2          	imul   %rdx,%rax
  8004200362:	48 83 c0 01          	add    $0x1,%rax
  8004200366:	48 c1 e0 10          	shl    $0x10,%rax
  800420036a:	48 89 c2             	mov    %rax,%rdx
  800420036d:	48 b8 00 40 36 04 80 	movabs $0x8004364000,%rax
  8004200374:	00 00 00 
  8004200377:	48 01 c2             	add    %rax,%rdx
  800420037a:	48 b8 98 17 36 04 80 	movabs $0x8004361798,%rax
  8004200381:	00 00 00 
  8004200384:	48 89 10             	mov    %rdx,(%rax)
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
  8004200387:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420038b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420038f:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004200396:	00 00 00 
  8004200399:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  800420039d:	77 32                	ja     80042003d1 <boot_aps+0x190>
  800420039f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042003a3:	48 89 c1             	mov    %rax,%rcx
  80042003a6:	48 ba 08 72 21 04 80 	movabs $0x8004217208,%rdx
  80042003ad:	00 00 00 
  80042003b0:	be 77 00 00 00       	mov    $0x77,%esi
  80042003b5:	48 bf fb 71 21 04 80 	movabs $0x80042171fb,%rdi
  80042003bc:	00 00 00 
  80042003bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042003c4:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042003cb:	00 00 00 
  80042003ce:	41 ff d0             	callq  *%r8
  80042003d1:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042003d8:	ff ff ff 
  80042003db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042003df:	48 01 d0             	add    %rdx,%rax
  80042003e2:	89 c2                	mov    %eax,%edx
  80042003e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042003e8:	0f b6 00             	movzbl (%rax),%eax
  80042003eb:	0f b6 c0             	movzbl %al,%eax
  80042003ee:	89 d6                	mov    %edx,%esi
  80042003f0:	89 c7                	mov    %eax,%edi
  80042003f2:	48 b8 2d 6b 21 04 80 	movabs $0x8004216b2d,%rax
  80042003f9:	00 00 00 
  80042003fc:	ff d0                	callq  *%rax
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
  80042003fe:	90                   	nop
  80042003ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200403:	8b 40 04             	mov    0x4(%rax),%eax
  8004200406:	83 f8 01             	cmp    $0x1,%eax
  8004200409:	75 f4                	jne    80042003ff <boot_aps+0x1be>

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  800420040b:	48 83 45 f8 78       	addq   $0x78,-0x8(%rbp)
  8004200410:	48 b8 e8 33 36 04 80 	movabs $0x80043633e8,%rax
  8004200417:	00 00 00 
  800420041a:	8b 00                	mov    (%rax),%eax
  800420041c:	48 98                	cltq   
  800420041e:	48 c1 e0 03          	shl    $0x3,%rax
  8004200422:	48 89 c2             	mov    %rax,%rdx
  8004200425:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200429:	48 29 c2             	sub    %rax,%rdx
  800420042c:	48 b8 20 30 36 04 80 	movabs $0x8004363020,%rax
  8004200433:	00 00 00 
  8004200436:	48 01 d0             	add    %rdx,%rax
  8004200439:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420043d:	0f 87 c2 fe ff ff    	ja     8004200305 <boot_aps+0xc4>
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
			;
	}

}
  8004200443:	c9                   	leaveq 
  8004200444:	c3                   	retq   

0000008004200445 <mp_main>:

// Setup code for APs
void
mp_main(void)
{
  8004200445:	55                   	push   %rbp
  8004200446:	48 89 e5             	mov    %rsp,%rbp
  8004200449:	48 83 ec 10          	sub    $0x10,%rsp
	// We are in high EIP now, safe to switch to kern_pgdir 
	lcr3(boot_cr3);
  800420044d:	48 b8 a0 17 36 04 80 	movabs $0x80043617a0,%rax
  8004200454:	00 00 00 
  8004200457:	48 8b 00             	mov    (%rax),%rax
  800420045a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420045e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200462:	0f 22 d8             	mov    %rax,%cr3
	cprintf("SMP: CPU %d starting\n", cpunum());
  8004200465:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420046c:	00 00 00 
  800420046f:	ff d0                	callq  *%rax
  8004200471:	89 c6                	mov    %eax,%esi
  8004200473:	48 bf 2c 72 21 04 80 	movabs $0x800421722c,%rdi
  800420047a:	00 00 00 
  800420047d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200482:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004200489:	00 00 00 
  800420048c:	ff d2                	callq  *%rdx

	lapic_init();
  800420048e:	48 b8 c6 68 21 04 80 	movabs $0x80042168c6,%rax
  8004200495:	00 00 00 
  8004200498:	ff d0                	callq  *%rax
	env_init_percpu();
  800420049a:	48 b8 3f 80 20 04 80 	movabs $0x800420803f,%rax
  80042004a1:	00 00 00 
  80042004a4:	ff d0                	callq  *%rax
	trap_init_percpu();
  80042004a6:	48 b8 15 be 20 04 80 	movabs $0x800420be15,%rax
  80042004ad:	00 00 00 
  80042004b0:	ff d0                	callq  *%rax
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
  80042004b2:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  80042004b9:	00 00 00 
  80042004bc:	ff d0                	callq  *%rax
  80042004be:	48 98                	cltq   
  80042004c0:	48 c1 e0 03          	shl    $0x3,%rax
  80042004c4:	48 89 c2             	mov    %rax,%rdx
  80042004c7:	48 c1 e2 04          	shl    $0x4,%rdx
  80042004cb:	48 29 c2             	sub    %rax,%rdx
  80042004ce:	48 b8 20 30 36 04 80 	movabs $0x8004363020,%rax
  80042004d5:	00 00 00 
  80042004d8:	48 01 d0             	add    %rdx,%rax
  80042004db:	48 83 c0 04          	add    $0x4,%rax
  80042004df:	be 01 00 00 00       	mov    $0x1,%esi
  80042004e4:	48 89 c7             	mov    %rax,%rdi
  80042004e7:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  80042004ee:	00 00 00 
  80042004f1:	ff d0                	callq  *%rax
	// Now that we have finished some basic setup, call sched_yield()
	// to start running processes on this CPU.  But make sure that
	// only one CPU can enter the scheduler at a time!
	//
	// Your code here:
	lock_kernel();
  80042004f3:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  80042004fa:	00 00 00 
  80042004fd:	ff d0                	callq  *%rax
	sched_yield();
  80042004ff:	48 b8 61 d2 20 04 80 	movabs $0x800420d261,%rax
  8004200506:	00 00 00 
  8004200509:	ff d0                	callq  *%rax

000000800420050b <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  800420050b:	55                   	push   %rbp
  800420050c:	48 89 e5             	mov    %rsp,%rbp
  800420050f:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  8004200516:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420051d:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  8004200523:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420052a:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004200531:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004200538:	84 c0                	test   %al,%al
  800420053a:	74 20                	je     800420055c <_panic+0x51>
  800420053c:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004200540:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004200544:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004200548:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420054c:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004200550:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004200554:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004200558:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420055c:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	if (panicstr)
  8004200563:	48 b8 90 17 36 04 80 	movabs $0x8004361790,%rax
  800420056a:	00 00 00 
  800420056d:	48 8b 00             	mov    (%rax),%rax
  8004200570:	48 85 c0             	test   %rax,%rax
  8004200573:	74 05                	je     800420057a <_panic+0x6f>
		goto dead;
  8004200575:	e9 b5 00 00 00       	jmpq   800420062f <_panic+0x124>
	panicstr = fmt;
  800420057a:	48 b8 90 17 36 04 80 	movabs $0x8004361790,%rax
  8004200581:	00 00 00 
  8004200584:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420058b:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  800420058e:	fa                   	cli    
  800420058f:	fc                   	cld    

	va_start(ap, fmt);
  8004200590:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  8004200597:	00 00 00 
  800420059a:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  80042005a1:	00 00 00 
  80042005a4:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042005a8:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042005af:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042005b6:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
  80042005bd:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  80042005c4:	00 00 00 
  80042005c7:	ff d0                	callq  *%rax
  80042005c9:	8b 8d 24 ff ff ff    	mov    -0xdc(%rbp),%ecx
  80042005cf:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  80042005d6:	89 c6                	mov    %eax,%esi
  80042005d8:	48 bf 48 72 21 04 80 	movabs $0x8004217248,%rdi
  80042005df:	00 00 00 
  80042005e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042005e7:	49 b8 11 96 20 04 80 	movabs $0x8004209611,%r8
  80042005ee:	00 00 00 
  80042005f1:	41 ff d0             	callq  *%r8
	vcprintf(fmt, ap);
  80042005f4:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  80042005fb:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004200602:	48 89 d6             	mov    %rdx,%rsi
  8004200605:	48 89 c7             	mov    %rax,%rdi
  8004200608:	48 b8 b2 95 20 04 80 	movabs $0x80042095b2,%rax
  800420060f:	00 00 00 
  8004200612:	ff d0                	callq  *%rax
	cprintf("\n");
  8004200614:	48 bf 6a 72 21 04 80 	movabs $0x800421726a,%rdi
  800420061b:	00 00 00 
  800420061e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200623:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420062a:	00 00 00 
  800420062d:	ff d2                	callq  *%rdx
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  800420062f:	bf 00 00 00 00       	mov    $0x0,%edi
  8004200634:	48 b8 3c 22 20 04 80 	movabs $0x800420223c,%rax
  800420063b:	00 00 00 
  800420063e:	ff d0                	callq  *%rax
  8004200640:	eb ed                	jmp    800420062f <_panic+0x124>

0000008004200642 <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  8004200642:	55                   	push   %rbp
  8004200643:	48 89 e5             	mov    %rsp,%rbp
  8004200646:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420064d:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  8004200654:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  800420065a:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004200661:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004200668:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420066f:	84 c0                	test   %al,%al
  8004200671:	74 20                	je     8004200693 <_warn+0x51>
  8004200673:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004200677:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420067b:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420067f:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004200683:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004200687:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420068b:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420068f:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004200693:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420069a:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  80042006a1:	00 00 00 
  80042006a4:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  80042006ab:	00 00 00 
  80042006ae:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042006b2:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042006b9:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042006c0:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  80042006c7:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  80042006cd:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042006d4:	48 89 c6             	mov    %rax,%rsi
  80042006d7:	48 bf 6c 72 21 04 80 	movabs $0x800421726c,%rdi
  80042006de:	00 00 00 
  80042006e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042006e6:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  80042006ed:	00 00 00 
  80042006f0:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  80042006f2:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  80042006f9:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004200700:	48 89 d6             	mov    %rdx,%rsi
  8004200703:	48 89 c7             	mov    %rax,%rdi
  8004200706:	48 b8 b2 95 20 04 80 	movabs $0x80042095b2,%rax
  800420070d:	00 00 00 
  8004200710:	ff d0                	callq  *%rax
	cprintf("\n");
  8004200712:	48 bf 6a 72 21 04 80 	movabs $0x800421726a,%rdi
  8004200719:	00 00 00 
  800420071c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200721:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004200728:	00 00 00 
  800420072b:	ff d2                	callq  *%rdx
	va_end(ap);
}
  800420072d:	c9                   	leaveq 
  800420072e:	c3                   	retq   

000000800420072f <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  800420072f:	55                   	push   %rbp
  8004200730:	48 89 e5             	mov    %rsp,%rbp
  8004200733:	48 83 ec 20          	sub    $0x20,%rsp
  8004200737:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420073e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004200741:	89 c2                	mov    %eax,%edx
  8004200743:	ec                   	in     (%dx),%al
  8004200744:	88 45 fb             	mov    %al,-0x5(%rbp)
  8004200747:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)
  800420074e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200751:	89 c2                	mov    %eax,%edx
  8004200753:	ec                   	in     (%dx),%al
  8004200754:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004200757:	c7 45 ec 84 00 00 00 	movl   $0x84,-0x14(%rbp)
  800420075e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200761:	89 c2                	mov    %eax,%edx
  8004200763:	ec                   	in     (%dx),%al
  8004200764:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004200767:	c7 45 e4 84 00 00 00 	movl   $0x84,-0x1c(%rbp)
  800420076e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200771:	89 c2                	mov    %eax,%edx
  8004200773:	ec                   	in     (%dx),%al
  8004200774:	88 45 e3             	mov    %al,-0x1d(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  8004200777:	c9                   	leaveq 
  8004200778:	c3                   	retq   

0000008004200779 <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  8004200779:	55                   	push   %rbp
  800420077a:	48 89 e5             	mov    %rsp,%rbp
  800420077d:	48 83 ec 10          	sub    $0x10,%rsp
  8004200781:	c7 45 fc fd 03 00 00 	movl   $0x3fd,-0x4(%rbp)
  8004200788:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420078b:	89 c2                	mov    %eax,%edx
  800420078d:	ec                   	in     (%dx),%al
  800420078e:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  8004200791:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  8004200795:	0f b6 c0             	movzbl %al,%eax
  8004200798:	83 e0 01             	and    $0x1,%eax
  800420079b:	85 c0                	test   %eax,%eax
  800420079d:	75 07                	jne    80042007a6 <serial_proc_data+0x2d>
		return -1;
  800420079f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042007a4:	eb 17                	jmp    80042007bd <serial_proc_data+0x44>
  80042007a6:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042007ad:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042007b0:	89 c2                	mov    %eax,%edx
  80042007b2:	ec                   	in     (%dx),%al
  80042007b3:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  80042007b6:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(COM1+COM_RX);
  80042007ba:	0f b6 c0             	movzbl %al,%eax
}
  80042007bd:	c9                   	leaveq 
  80042007be:	c3                   	retq   

00000080042007bf <serial_intr>:

void
serial_intr(void)
{
  80042007bf:	55                   	push   %rbp
  80042007c0:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  80042007c3:	48 b8 00 00 36 04 80 	movabs $0x8004360000,%rax
  80042007ca:	00 00 00 
  80042007cd:	0f b6 00             	movzbl (%rax),%eax
  80042007d0:	84 c0                	test   %al,%al
  80042007d2:	74 16                	je     80042007ea <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  80042007d4:	48 bf 79 07 20 04 80 	movabs $0x8004200779,%rdi
  80042007db:	00 00 00 
  80042007de:	48 b8 2b 10 20 04 80 	movabs $0x800420102b,%rax
  80042007e5:	00 00 00 
  80042007e8:	ff d0                	callq  *%rax
}
  80042007ea:	5d                   	pop    %rbp
  80042007eb:	c3                   	retq   

00000080042007ec <serial_putc>:

static void
serial_putc(int c)
{
  80042007ec:	55                   	push   %rbp
  80042007ed:	48 89 e5             	mov    %rsp,%rbp
  80042007f0:	48 83 ec 28          	sub    $0x28,%rsp
  80042007f4:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int i;

	for (i = 0;
  80042007f7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042007fe:	eb 10                	jmp    8004200810 <serial_putc+0x24>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  8004200800:	48 b8 2f 07 20 04 80 	movabs $0x800420072f,%rax
  8004200807:	00 00 00 
  800420080a:	ff d0                	callq  *%rax
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
  800420080c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200810:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200817:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420081a:	89 c2                	mov    %eax,%edx
  800420081c:	ec                   	in     (%dx),%al
  800420081d:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  8004200820:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
serial_putc(int c)
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  8004200824:	0f b6 c0             	movzbl %al,%eax
  8004200827:	83 e0 20             	and    $0x20,%eax
static void
serial_putc(int c)
{
	int i;

	for (i = 0;
  800420082a:	85 c0                	test   %eax,%eax
  800420082c:	75 09                	jne    8004200837 <serial_putc+0x4b>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  800420082e:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  8004200835:	7e c9                	jle    8004200800 <serial_putc+0x14>
	     i++)
		delay();

	outb(COM1 + COM_TX, c);
  8004200837:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420083a:	0f b6 c0             	movzbl %al,%eax
  800420083d:	c7 45 f0 f8 03 00 00 	movl   $0x3f8,-0x10(%rbp)
  8004200844:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200847:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800420084b:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800420084e:	ee                   	out    %al,(%dx)
}
  800420084f:	c9                   	leaveq 
  8004200850:	c3                   	retq   

0000008004200851 <serial_init>:

static void
serial_init(void)
{
  8004200851:	55                   	push   %rbp
  8004200852:	48 89 e5             	mov    %rsp,%rbp
  8004200855:	48 83 ec 50          	sub    $0x50,%rsp
  8004200859:	c7 45 fc fa 03 00 00 	movl   $0x3fa,-0x4(%rbp)
  8004200860:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  8004200864:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200868:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420086b:	ee                   	out    %al,(%dx)
  800420086c:	c7 45 f4 fb 03 00 00 	movl   $0x3fb,-0xc(%rbp)
  8004200873:	c6 45 f3 80          	movb   $0x80,-0xd(%rbp)
  8004200877:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  800420087b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420087e:	ee                   	out    %al,(%dx)
  800420087f:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%rbp)
  8004200886:	c6 45 eb 0c          	movb   $0xc,-0x15(%rbp)
  800420088a:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  800420088e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200891:	ee                   	out    %al,(%dx)
  8004200892:	c7 45 e4 f9 03 00 00 	movl   $0x3f9,-0x1c(%rbp)
  8004200899:	c6 45 e3 00          	movb   $0x0,-0x1d(%rbp)
  800420089d:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  80042008a1:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042008a4:	ee                   	out    %al,(%dx)
  80042008a5:	c7 45 dc fb 03 00 00 	movl   $0x3fb,-0x24(%rbp)
  80042008ac:	c6 45 db 03          	movb   $0x3,-0x25(%rbp)
  80042008b0:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  80042008b4:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042008b7:	ee                   	out    %al,(%dx)
  80042008b8:	c7 45 d4 fc 03 00 00 	movl   $0x3fc,-0x2c(%rbp)
  80042008bf:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  80042008c3:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  80042008c7:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042008ca:	ee                   	out    %al,(%dx)
  80042008cb:	c7 45 cc f9 03 00 00 	movl   $0x3f9,-0x34(%rbp)
  80042008d2:	c6 45 cb 01          	movb   $0x1,-0x35(%rbp)
  80042008d6:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  80042008da:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042008dd:	ee                   	out    %al,(%dx)
  80042008de:	c7 45 c4 fd 03 00 00 	movl   $0x3fd,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042008e5:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042008e8:	89 c2                	mov    %eax,%edx
  80042008ea:	ec                   	in     (%dx),%al
  80042008eb:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  80042008ee:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  80042008f2:	3c ff                	cmp    $0xff,%al
  80042008f4:	0f 95 c2             	setne  %dl
  80042008f7:	48 b8 00 00 36 04 80 	movabs $0x8004360000,%rax
  80042008fe:	00 00 00 
  8004200901:	88 10                	mov    %dl,(%rax)
  8004200903:	c7 45 bc fa 03 00 00 	movl   $0x3fa,-0x44(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420090a:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420090d:	89 c2                	mov    %eax,%edx
  800420090f:	ec                   	in     (%dx),%al
  8004200910:	88 45 bb             	mov    %al,-0x45(%rbp)
  8004200913:	c7 45 b4 f8 03 00 00 	movl   $0x3f8,-0x4c(%rbp)
  800420091a:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420091d:	89 c2                	mov    %eax,%edx
  800420091f:	ec                   	in     (%dx),%al
  8004200920:	88 45 b3             	mov    %al,-0x4d(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

}
  8004200923:	c9                   	leaveq 
  8004200924:	c3                   	retq   

0000008004200925 <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  8004200925:	55                   	push   %rbp
  8004200926:	48 89 e5             	mov    %rsp,%rbp
  8004200929:	48 83 ec 38          	sub    $0x38,%rsp
  800420092d:	89 7d cc             	mov    %edi,-0x34(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200930:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004200937:	eb 10                	jmp    8004200949 <lpt_putc+0x24>
		delay();
  8004200939:	48 b8 2f 07 20 04 80 	movabs $0x800420072f,%rax
  8004200940:	00 00 00 
  8004200943:	ff d0                	callq  *%rax
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200945:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200949:	c7 45 f8 79 03 00 00 	movl   $0x379,-0x8(%rbp)
  8004200950:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004200953:	89 c2                	mov    %eax,%edx
  8004200955:	ec                   	in     (%dx),%al
  8004200956:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  8004200959:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  800420095d:	84 c0                	test   %al,%al
  800420095f:	78 09                	js     800420096a <lpt_putc+0x45>
  8004200961:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  8004200968:	7e cf                	jle    8004200939 <lpt_putc+0x14>
		delay();
	outb(0x378+0, c);
  800420096a:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420096d:	0f b6 c0             	movzbl %al,%eax
  8004200970:	c7 45 f0 78 03 00 00 	movl   $0x378,-0x10(%rbp)
  8004200977:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800420097a:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800420097e:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200981:	ee                   	out    %al,(%dx)
  8004200982:	c7 45 e8 7a 03 00 00 	movl   $0x37a,-0x18(%rbp)
  8004200989:	c6 45 e7 0d          	movb   $0xd,-0x19(%rbp)
  800420098d:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200991:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200994:	ee                   	out    %al,(%dx)
  8004200995:	c7 45 e0 7a 03 00 00 	movl   $0x37a,-0x20(%rbp)
  800420099c:	c6 45 df 08          	movb   $0x8,-0x21(%rbp)
  80042009a0:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80042009a4:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80042009a7:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  80042009a8:	c9                   	leaveq 
  80042009a9:	c3                   	retq   

00000080042009aa <cga_init>:
static uint16_t *crt_buf;
static uint16_t crt_pos;

static void
cga_init(void)
{
  80042009aa:	55                   	push   %rbp
  80042009ab:	48 89 e5             	mov    %rsp,%rbp
  80042009ae:	48 83 ec 30          	sub    $0x30,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  80042009b2:	48 b8 00 80 0b 04 80 	movabs $0x80040b8000,%rax
  80042009b9:	00 00 00 
  80042009bc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	was = *cp;
  80042009c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009c4:	0f b7 00             	movzwl (%rax),%eax
  80042009c7:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	*cp = (uint16_t) 0xA55A;
  80042009cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009cf:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  80042009d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009d8:	0f b7 00             	movzwl (%rax),%eax
  80042009db:	66 3d 5a a5          	cmp    $0xa55a,%ax
  80042009df:	74 20                	je     8004200a01 <cga_init+0x57>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  80042009e1:	48 b8 00 00 0b 04 80 	movabs $0x80040b0000,%rax
  80042009e8:	00 00 00 
  80042009eb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		addr_6845 = MONO_BASE;
  80042009ef:	48 b8 04 00 36 04 80 	movabs $0x8004360004,%rax
  80042009f6:	00 00 00 
  80042009f9:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  80042009ff:	eb 1b                	jmp    8004200a1c <cga_init+0x72>
	} else {
		*cp = was;
  8004200a01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a05:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004200a09:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  8004200a0c:	48 b8 04 00 36 04 80 	movabs $0x8004360004,%rax
  8004200a13:	00 00 00 
  8004200a16:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  8004200a1c:	48 b8 04 00 36 04 80 	movabs $0x8004360004,%rax
  8004200a23:	00 00 00 
  8004200a26:	8b 00                	mov    (%rax),%eax
  8004200a28:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004200a2b:	c6 45 eb 0e          	movb   $0xe,-0x15(%rbp)
  8004200a2f:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200a33:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200a36:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  8004200a37:	48 b8 04 00 36 04 80 	movabs $0x8004360004,%rax
  8004200a3e:	00 00 00 
  8004200a41:	8b 00                	mov    (%rax),%eax
  8004200a43:	83 c0 01             	add    $0x1,%eax
  8004200a46:	89 45 e4             	mov    %eax,-0x1c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a49:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200a4c:	89 c2                	mov    %eax,%edx
  8004200a4e:	ec                   	in     (%dx),%al
  8004200a4f:	88 45 e3             	mov    %al,-0x1d(%rbp)
	return data;
  8004200a52:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200a56:	0f b6 c0             	movzbl %al,%eax
  8004200a59:	c1 e0 08             	shl    $0x8,%eax
  8004200a5c:	89 45 f0             	mov    %eax,-0x10(%rbp)
	outb(addr_6845, 15);
  8004200a5f:	48 b8 04 00 36 04 80 	movabs $0x8004360004,%rax
  8004200a66:	00 00 00 
  8004200a69:	8b 00                	mov    (%rax),%eax
  8004200a6b:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004200a6e:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200a72:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200a76:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200a79:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  8004200a7a:	48 b8 04 00 36 04 80 	movabs $0x8004360004,%rax
  8004200a81:	00 00 00 
  8004200a84:	8b 00                	mov    (%rax),%eax
  8004200a86:	83 c0 01             	add    $0x1,%eax
  8004200a89:	89 45 d4             	mov    %eax,-0x2c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a8c:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004200a8f:	89 c2                	mov    %eax,%edx
  8004200a91:	ec                   	in     (%dx),%al
  8004200a92:	88 45 d3             	mov    %al,-0x2d(%rbp)
	return data;
  8004200a95:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200a99:	0f b6 c0             	movzbl %al,%eax
  8004200a9c:	09 45 f0             	or     %eax,-0x10(%rbp)

	crt_buf = (uint16_t*) cp;
  8004200a9f:	48 b8 08 00 36 04 80 	movabs $0x8004360008,%rax
  8004200aa6:	00 00 00 
  8004200aa9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200aad:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  8004200ab0:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004200ab3:	89 c2                	mov    %eax,%edx
  8004200ab5:	48 b8 10 00 36 04 80 	movabs $0x8004360010,%rax
  8004200abc:	00 00 00 
  8004200abf:	66 89 10             	mov    %dx,(%rax)
}
  8004200ac2:	c9                   	leaveq 
  8004200ac3:	c3                   	retq   

0000008004200ac4 <cga_putc>:



static void
cga_putc(int c)
{
  8004200ac4:	55                   	push   %rbp
  8004200ac5:	48 89 e5             	mov    %rsp,%rbp
  8004200ac8:	48 83 ec 40          	sub    $0x40,%rsp
  8004200acc:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
  8004200acf:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200ad2:	b0 00                	mov    $0x0,%al
  8004200ad4:	85 c0                	test   %eax,%eax
  8004200ad6:	75 07                	jne    8004200adf <cga_putc+0x1b>
		c |= 0x0700;
  8004200ad8:	81 4d cc 00 07 00 00 	orl    $0x700,-0x34(%rbp)

	switch (c & 0xff) {
  8004200adf:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200ae2:	0f b6 c0             	movzbl %al,%eax
  8004200ae5:	83 f8 09             	cmp    $0x9,%eax
  8004200ae8:	0f 84 f6 00 00 00    	je     8004200be4 <cga_putc+0x120>
  8004200aee:	83 f8 09             	cmp    $0x9,%eax
  8004200af1:	7f 0a                	jg     8004200afd <cga_putc+0x39>
  8004200af3:	83 f8 08             	cmp    $0x8,%eax
  8004200af6:	74 18                	je     8004200b10 <cga_putc+0x4c>
  8004200af8:	e9 3e 01 00 00       	jmpq   8004200c3b <cga_putc+0x177>
  8004200afd:	83 f8 0a             	cmp    $0xa,%eax
  8004200b00:	74 75                	je     8004200b77 <cga_putc+0xb3>
  8004200b02:	83 f8 0d             	cmp    $0xd,%eax
  8004200b05:	0f 84 89 00 00 00    	je     8004200b94 <cga_putc+0xd0>
  8004200b0b:	e9 2b 01 00 00       	jmpq   8004200c3b <cga_putc+0x177>
	case '\b':
		if (crt_pos > 0) {
  8004200b10:	48 b8 10 00 36 04 80 	movabs $0x8004360010,%rax
  8004200b17:	00 00 00 
  8004200b1a:	0f b7 00             	movzwl (%rax),%eax
  8004200b1d:	66 85 c0             	test   %ax,%ax
  8004200b20:	74 50                	je     8004200b72 <cga_putc+0xae>
			crt_pos--;
  8004200b22:	48 b8 10 00 36 04 80 	movabs $0x8004360010,%rax
  8004200b29:	00 00 00 
  8004200b2c:	0f b7 00             	movzwl (%rax),%eax
  8004200b2f:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004200b32:	48 b8 10 00 36 04 80 	movabs $0x8004360010,%rax
  8004200b39:	00 00 00 
  8004200b3c:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200b3f:	48 b8 08 00 36 04 80 	movabs $0x8004360008,%rax
  8004200b46:	00 00 00 
  8004200b49:	48 8b 10             	mov    (%rax),%rdx
  8004200b4c:	48 b8 10 00 36 04 80 	movabs $0x8004360010,%rax
  8004200b53:	00 00 00 
  8004200b56:	0f b7 00             	movzwl (%rax),%eax
  8004200b59:	0f b7 c0             	movzwl %ax,%eax
  8004200b5c:	48 01 c0             	add    %rax,%rax
  8004200b5f:	48 01 c2             	add    %rax,%rdx
  8004200b62:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200b65:	b0 00                	mov    $0x0,%al
  8004200b67:	83 c8 20             	or     $0x20,%eax
  8004200b6a:	66 89 02             	mov    %ax,(%rdx)
		}
		break;
  8004200b6d:	e9 04 01 00 00       	jmpq   8004200c76 <cga_putc+0x1b2>
  8004200b72:	e9 ff 00 00 00       	jmpq   8004200c76 <cga_putc+0x1b2>
	case '\n':
		crt_pos += CRT_COLS;
  8004200b77:	48 b8 10 00 36 04 80 	movabs $0x8004360010,%rax
  8004200b7e:	00 00 00 
  8004200b81:	0f b7 00             	movzwl (%rax),%eax
  8004200b84:	8d 50 50             	lea    0x50(%rax),%edx
  8004200b87:	48 b8 10 00 36 04 80 	movabs $0x8004360010,%rax
  8004200b8e:	00 00 00 
  8004200b91:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  8004200b94:	48 b8 10 00 36 04 80 	movabs $0x8004360010,%rax
  8004200b9b:	00 00 00 
  8004200b9e:	0f b7 30             	movzwl (%rax),%esi
  8004200ba1:	48 b8 10 00 36 04 80 	movabs $0x8004360010,%rax
  8004200ba8:	00 00 00 
  8004200bab:	0f b7 08             	movzwl (%rax),%ecx
  8004200bae:	0f b7 c1             	movzwl %cx,%eax
  8004200bb1:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  8004200bb7:	c1 e8 10             	shr    $0x10,%eax
  8004200bba:	89 c2                	mov    %eax,%edx
  8004200bbc:	66 c1 ea 06          	shr    $0x6,%dx
  8004200bc0:	89 d0                	mov    %edx,%eax
  8004200bc2:	c1 e0 02             	shl    $0x2,%eax
  8004200bc5:	01 d0                	add    %edx,%eax
  8004200bc7:	c1 e0 04             	shl    $0x4,%eax
  8004200bca:	29 c1                	sub    %eax,%ecx
  8004200bcc:	89 ca                	mov    %ecx,%edx
  8004200bce:	29 d6                	sub    %edx,%esi
  8004200bd0:	89 f2                	mov    %esi,%edx
  8004200bd2:	48 b8 10 00 36 04 80 	movabs $0x8004360010,%rax
  8004200bd9:	00 00 00 
  8004200bdc:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200bdf:	e9 92 00 00 00       	jmpq   8004200c76 <cga_putc+0x1b2>
	case '\t':
		cons_putc(' ');
  8004200be4:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200be9:	48 b8 68 11 20 04 80 	movabs $0x8004201168,%rax
  8004200bf0:	00 00 00 
  8004200bf3:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200bf5:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200bfa:	48 b8 68 11 20 04 80 	movabs $0x8004201168,%rax
  8004200c01:	00 00 00 
  8004200c04:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c06:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c0b:	48 b8 68 11 20 04 80 	movabs $0x8004201168,%rax
  8004200c12:	00 00 00 
  8004200c15:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c17:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c1c:	48 b8 68 11 20 04 80 	movabs $0x8004201168,%rax
  8004200c23:	00 00 00 
  8004200c26:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c28:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c2d:	48 b8 68 11 20 04 80 	movabs $0x8004201168,%rax
  8004200c34:	00 00 00 
  8004200c37:	ff d0                	callq  *%rax
		break;
  8004200c39:	eb 3b                	jmp    8004200c76 <cga_putc+0x1b2>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200c3b:	48 b8 08 00 36 04 80 	movabs $0x8004360008,%rax
  8004200c42:	00 00 00 
  8004200c45:	48 8b 30             	mov    (%rax),%rsi
  8004200c48:	48 b8 10 00 36 04 80 	movabs $0x8004360010,%rax
  8004200c4f:	00 00 00 
  8004200c52:	0f b7 00             	movzwl (%rax),%eax
  8004200c55:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200c58:	48 ba 10 00 36 04 80 	movabs $0x8004360010,%rdx
  8004200c5f:	00 00 00 
  8004200c62:	66 89 0a             	mov    %cx,(%rdx)
  8004200c65:	0f b7 c0             	movzwl %ax,%eax
  8004200c68:	48 01 c0             	add    %rax,%rax
  8004200c6b:	48 8d 14 06          	lea    (%rsi,%rax,1),%rdx
  8004200c6f:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200c72:	66 89 02             	mov    %ax,(%rdx)
		break;
  8004200c75:	90                   	nop
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
  8004200c76:	48 b8 10 00 36 04 80 	movabs $0x8004360010,%rax
  8004200c7d:	00 00 00 
  8004200c80:	0f b7 00             	movzwl (%rax),%eax
  8004200c83:	66 3d cf 07          	cmp    $0x7cf,%ax
  8004200c87:	0f 86 89 00 00 00    	jbe    8004200d16 <cga_putc+0x252>
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  8004200c8d:	48 b8 08 00 36 04 80 	movabs $0x8004360008,%rax
  8004200c94:	00 00 00 
  8004200c97:	48 8b 00             	mov    (%rax),%rax
  8004200c9a:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  8004200ca1:	48 b8 08 00 36 04 80 	movabs $0x8004360008,%rax
  8004200ca8:	00 00 00 
  8004200cab:	48 8b 00             	mov    (%rax),%rax
  8004200cae:	ba 00 0f 00 00       	mov    $0xf00,%edx
  8004200cb3:	48 89 ce             	mov    %rcx,%rsi
  8004200cb6:	48 89 c7             	mov    %rax,%rdi
  8004200cb9:	48 b8 3e fc 20 04 80 	movabs $0x800420fc3e,%rax
  8004200cc0:	00 00 00 
  8004200cc3:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200cc5:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200ccc:	eb 22                	jmp    8004200cf0 <cga_putc+0x22c>
			crt_buf[i] = 0x0700 | ' ';
  8004200cce:	48 b8 08 00 36 04 80 	movabs $0x8004360008,%rax
  8004200cd5:	00 00 00 
  8004200cd8:	48 8b 00             	mov    (%rax),%rax
  8004200cdb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200cde:	48 63 d2             	movslq %edx,%rdx
  8004200ce1:	48 01 d2             	add    %rdx,%rdx
  8004200ce4:	48 01 d0             	add    %rdx,%rax
  8004200ce7:	66 c7 00 20 07       	movw   $0x720,(%rax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200cec:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200cf0:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200cf7:	7e d5                	jle    8004200cce <cga_putc+0x20a>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
  8004200cf9:	48 b8 10 00 36 04 80 	movabs $0x8004360010,%rax
  8004200d00:	00 00 00 
  8004200d03:	0f b7 00             	movzwl (%rax),%eax
  8004200d06:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200d09:	48 b8 10 00 36 04 80 	movabs $0x8004360010,%rax
  8004200d10:	00 00 00 
  8004200d13:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  8004200d16:	48 b8 04 00 36 04 80 	movabs $0x8004360004,%rax
  8004200d1d:	00 00 00 
  8004200d20:	8b 00                	mov    (%rax),%eax
  8004200d22:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004200d25:	c6 45 f7 0e          	movb   $0xe,-0x9(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200d29:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200d2d:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200d30:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  8004200d31:	48 b8 10 00 36 04 80 	movabs $0x8004360010,%rax
  8004200d38:	00 00 00 
  8004200d3b:	0f b7 00             	movzwl (%rax),%eax
  8004200d3e:	66 c1 e8 08          	shr    $0x8,%ax
  8004200d42:	0f b6 c0             	movzbl %al,%eax
  8004200d45:	48 ba 04 00 36 04 80 	movabs $0x8004360004,%rdx
  8004200d4c:	00 00 00 
  8004200d4f:	8b 12                	mov    (%rdx),%edx
  8004200d51:	83 c2 01             	add    $0x1,%edx
  8004200d54:	89 55 f0             	mov    %edx,-0x10(%rbp)
  8004200d57:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004200d5a:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200d5e:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200d61:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  8004200d62:	48 b8 04 00 36 04 80 	movabs $0x8004360004,%rax
  8004200d69:	00 00 00 
  8004200d6c:	8b 00                	mov    (%rax),%eax
  8004200d6e:	89 45 e8             	mov    %eax,-0x18(%rbp)
  8004200d71:	c6 45 e7 0f          	movb   $0xf,-0x19(%rbp)
  8004200d75:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200d79:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200d7c:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  8004200d7d:	48 b8 10 00 36 04 80 	movabs $0x8004360010,%rax
  8004200d84:	00 00 00 
  8004200d87:	0f b7 00             	movzwl (%rax),%eax
  8004200d8a:	0f b6 c0             	movzbl %al,%eax
  8004200d8d:	48 ba 04 00 36 04 80 	movabs $0x8004360004,%rdx
  8004200d94:	00 00 00 
  8004200d97:	8b 12                	mov    (%rdx),%edx
  8004200d99:	83 c2 01             	add    $0x1,%edx
  8004200d9c:	89 55 e0             	mov    %edx,-0x20(%rbp)
  8004200d9f:	88 45 df             	mov    %al,-0x21(%rbp)
  8004200da2:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200da6:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200da9:	ee                   	out    %al,(%dx)
}
  8004200daa:	c9                   	leaveq 
  8004200dab:	c3                   	retq   

0000008004200dac <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  8004200dac:	55                   	push   %rbp
  8004200dad:	48 89 e5             	mov    %rsp,%rbp
  8004200db0:	48 83 ec 20          	sub    $0x20,%rsp
  8004200db4:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200dbb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200dbe:	89 c2                	mov    %eax,%edx
  8004200dc0:	ec                   	in     (%dx),%al
  8004200dc1:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004200dc4:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200dc8:	0f b6 c0             	movzbl %al,%eax
  8004200dcb:	83 e0 01             	and    $0x1,%eax
  8004200dce:	85 c0                	test   %eax,%eax
  8004200dd0:	75 0a                	jne    8004200ddc <kbd_proc_data+0x30>
		return -1;
  8004200dd2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200dd7:	e9 fc 01 00 00       	jmpq   8004200fd8 <kbd_proc_data+0x22c>
  8004200ddc:	c7 45 ec 60 00 00 00 	movl   $0x60,-0x14(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200de3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200de6:	89 c2                	mov    %eax,%edx
  8004200de8:	ec                   	in     (%dx),%al
  8004200de9:	88 45 eb             	mov    %al,-0x15(%rbp)
	return data;
  8004200dec:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax

	data = inb(KBDATAP);
  8004200df0:	88 45 fb             	mov    %al,-0x5(%rbp)

	if (data == 0xE0) {
  8004200df3:	80 7d fb e0          	cmpb   $0xe0,-0x5(%rbp)
  8004200df7:	75 27                	jne    8004200e20 <kbd_proc_data+0x74>
		// E0 escape character
		shift |= E0ESC;
  8004200df9:	48 b8 28 02 36 04 80 	movabs $0x8004360228,%rax
  8004200e00:	00 00 00 
  8004200e03:	8b 00                	mov    (%rax),%eax
  8004200e05:	83 c8 40             	or     $0x40,%eax
  8004200e08:	89 c2                	mov    %eax,%edx
  8004200e0a:	48 b8 28 02 36 04 80 	movabs $0x8004360228,%rax
  8004200e11:	00 00 00 
  8004200e14:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200e16:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200e1b:	e9 b8 01 00 00       	jmpq   8004200fd8 <kbd_proc_data+0x22c>
	} else if (data & 0x80) {
  8004200e20:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e24:	84 c0                	test   %al,%al
  8004200e26:	79 65                	jns    8004200e8d <kbd_proc_data+0xe1>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200e28:	48 b8 28 02 36 04 80 	movabs $0x8004360228,%rax
  8004200e2f:	00 00 00 
  8004200e32:	8b 00                	mov    (%rax),%eax
  8004200e34:	83 e0 40             	and    $0x40,%eax
  8004200e37:	85 c0                	test   %eax,%eax
  8004200e39:	75 09                	jne    8004200e44 <kbd_proc_data+0x98>
  8004200e3b:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e3f:	83 e0 7f             	and    $0x7f,%eax
  8004200e42:	eb 04                	jmp    8004200e48 <kbd_proc_data+0x9c>
  8004200e44:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e48:	88 45 fb             	mov    %al,-0x5(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200e4b:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e4f:	48 ba 60 a0 22 04 80 	movabs $0x800422a060,%rdx
  8004200e56:	00 00 00 
  8004200e59:	48 98                	cltq   
  8004200e5b:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200e5f:	83 c8 40             	or     $0x40,%eax
  8004200e62:	0f b6 c0             	movzbl %al,%eax
  8004200e65:	f7 d0                	not    %eax
  8004200e67:	89 c2                	mov    %eax,%edx
  8004200e69:	48 b8 28 02 36 04 80 	movabs $0x8004360228,%rax
  8004200e70:	00 00 00 
  8004200e73:	8b 00                	mov    (%rax),%eax
  8004200e75:	21 c2                	and    %eax,%edx
  8004200e77:	48 b8 28 02 36 04 80 	movabs $0x8004360228,%rax
  8004200e7e:	00 00 00 
  8004200e81:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200e83:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200e88:	e9 4b 01 00 00       	jmpq   8004200fd8 <kbd_proc_data+0x22c>
	} else if (shift & E0ESC) {
  8004200e8d:	48 b8 28 02 36 04 80 	movabs $0x8004360228,%rax
  8004200e94:	00 00 00 
  8004200e97:	8b 00                	mov    (%rax),%eax
  8004200e99:	83 e0 40             	and    $0x40,%eax
  8004200e9c:	85 c0                	test   %eax,%eax
  8004200e9e:	74 21                	je     8004200ec1 <kbd_proc_data+0x115>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004200ea0:	80 4d fb 80          	orb    $0x80,-0x5(%rbp)
		shift &= ~E0ESC;
  8004200ea4:	48 b8 28 02 36 04 80 	movabs $0x8004360228,%rax
  8004200eab:	00 00 00 
  8004200eae:	8b 00                	mov    (%rax),%eax
  8004200eb0:	83 e0 bf             	and    $0xffffffbf,%eax
  8004200eb3:	89 c2                	mov    %eax,%edx
  8004200eb5:	48 b8 28 02 36 04 80 	movabs $0x8004360228,%rax
  8004200ebc:	00 00 00 
  8004200ebf:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004200ec1:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200ec5:	48 ba 60 a0 22 04 80 	movabs $0x800422a060,%rdx
  8004200ecc:	00 00 00 
  8004200ecf:	48 98                	cltq   
  8004200ed1:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200ed5:	0f b6 d0             	movzbl %al,%edx
  8004200ed8:	48 b8 28 02 36 04 80 	movabs $0x8004360228,%rax
  8004200edf:	00 00 00 
  8004200ee2:	8b 00                	mov    (%rax),%eax
  8004200ee4:	09 c2                	or     %eax,%edx
  8004200ee6:	48 b8 28 02 36 04 80 	movabs $0x8004360228,%rax
  8004200eed:	00 00 00 
  8004200ef0:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004200ef2:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200ef6:	48 ba 60 a1 22 04 80 	movabs $0x800422a160,%rdx
  8004200efd:	00 00 00 
  8004200f00:	48 98                	cltq   
  8004200f02:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f06:	0f b6 d0             	movzbl %al,%edx
  8004200f09:	48 b8 28 02 36 04 80 	movabs $0x8004360228,%rax
  8004200f10:	00 00 00 
  8004200f13:	8b 00                	mov    (%rax),%eax
  8004200f15:	31 c2                	xor    %eax,%edx
  8004200f17:	48 b8 28 02 36 04 80 	movabs $0x8004360228,%rax
  8004200f1e:	00 00 00 
  8004200f21:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  8004200f23:	48 b8 28 02 36 04 80 	movabs $0x8004360228,%rax
  8004200f2a:	00 00 00 
  8004200f2d:	8b 00                	mov    (%rax),%eax
  8004200f2f:	83 e0 03             	and    $0x3,%eax
  8004200f32:	89 c2                	mov    %eax,%edx
  8004200f34:	48 b8 60 a5 22 04 80 	movabs $0x800422a560,%rax
  8004200f3b:	00 00 00 
  8004200f3e:	89 d2                	mov    %edx,%edx
  8004200f40:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8004200f44:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f48:	48 01 d0             	add    %rdx,%rax
  8004200f4b:	0f b6 00             	movzbl (%rax),%eax
  8004200f4e:	0f b6 c0             	movzbl %al,%eax
  8004200f51:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (shift & CAPSLOCK) {
  8004200f54:	48 b8 28 02 36 04 80 	movabs $0x8004360228,%rax
  8004200f5b:	00 00 00 
  8004200f5e:	8b 00                	mov    (%rax),%eax
  8004200f60:	83 e0 08             	and    $0x8,%eax
  8004200f63:	85 c0                	test   %eax,%eax
  8004200f65:	74 22                	je     8004200f89 <kbd_proc_data+0x1dd>
		if ('a' <= c && c <= 'z')
  8004200f67:	83 7d fc 60          	cmpl   $0x60,-0x4(%rbp)
  8004200f6b:	7e 0c                	jle    8004200f79 <kbd_proc_data+0x1cd>
  8004200f6d:	83 7d fc 7a          	cmpl   $0x7a,-0x4(%rbp)
  8004200f71:	7f 06                	jg     8004200f79 <kbd_proc_data+0x1cd>
			c += 'A' - 'a';
  8004200f73:	83 6d fc 20          	subl   $0x20,-0x4(%rbp)
  8004200f77:	eb 10                	jmp    8004200f89 <kbd_proc_data+0x1dd>
		else if ('A' <= c && c <= 'Z')
  8004200f79:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
  8004200f7d:	7e 0a                	jle    8004200f89 <kbd_proc_data+0x1dd>
  8004200f7f:	83 7d fc 5a          	cmpl   $0x5a,-0x4(%rbp)
  8004200f83:	7f 04                	jg     8004200f89 <kbd_proc_data+0x1dd>
			c += 'a' - 'A';
  8004200f85:	83 45 fc 20          	addl   $0x20,-0x4(%rbp)
	}

	// Process special keys
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  8004200f89:	48 b8 28 02 36 04 80 	movabs $0x8004360228,%rax
  8004200f90:	00 00 00 
  8004200f93:	8b 00                	mov    (%rax),%eax
  8004200f95:	f7 d0                	not    %eax
  8004200f97:	83 e0 06             	and    $0x6,%eax
  8004200f9a:	85 c0                	test   %eax,%eax
  8004200f9c:	75 37                	jne    8004200fd5 <kbd_proc_data+0x229>
  8004200f9e:	81 7d fc e9 00 00 00 	cmpl   $0xe9,-0x4(%rbp)
  8004200fa5:	75 2e                	jne    8004200fd5 <kbd_proc_data+0x229>
		cprintf("Rebooting!\n");
  8004200fa7:	48 bf 86 72 21 04 80 	movabs $0x8004217286,%rdi
  8004200fae:	00 00 00 
  8004200fb1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200fb6:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004200fbd:	00 00 00 
  8004200fc0:	ff d2                	callq  *%rdx
  8004200fc2:	c7 45 e4 92 00 00 00 	movl   $0x92,-0x1c(%rbp)
  8004200fc9:	c6 45 e3 03          	movb   $0x3,-0x1d(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200fcd:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200fd1:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200fd4:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
  8004200fd5:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004200fd8:	c9                   	leaveq 
  8004200fd9:	c3                   	retq   

0000008004200fda <kbd_intr>:

void
kbd_intr(void)
{
  8004200fda:	55                   	push   %rbp
  8004200fdb:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  8004200fde:	48 bf ac 0d 20 04 80 	movabs $0x8004200dac,%rdi
  8004200fe5:	00 00 00 
  8004200fe8:	48 b8 2b 10 20 04 80 	movabs $0x800420102b,%rax
  8004200fef:	00 00 00 
  8004200ff2:	ff d0                	callq  *%rax
}
  8004200ff4:	5d                   	pop    %rbp
  8004200ff5:	c3                   	retq   

0000008004200ff6 <kbd_init>:

static void
kbd_init(void)
{
  8004200ff6:	55                   	push   %rbp
  8004200ff7:	48 89 e5             	mov    %rsp,%rbp
	// Drain the kbd buffer so that Bochs generates interrupts.
	kbd_intr();
  8004200ffa:	48 b8 da 0f 20 04 80 	movabs $0x8004200fda,%rax
  8004201001:	00 00 00 
  8004201004:	ff d0                	callq  *%rax
	irq_setmask_8259A(irq_mask_8259A & ~(1<<1));
  8004201006:	48 b8 d2 a6 22 04 80 	movabs $0x800422a6d2,%rax
  800420100d:	00 00 00 
  8004201010:	0f b7 00             	movzwl (%rax),%eax
  8004201013:	0f b7 c0             	movzwl %ax,%eax
  8004201016:	25 fd ff 00 00       	and    $0xfffd,%eax
  800420101b:	89 c7                	mov    %eax,%edi
  800420101d:	48 b8 93 94 20 04 80 	movabs $0x8004209493,%rax
  8004201024:	00 00 00 
  8004201027:	ff d0                	callq  *%rax
}
  8004201029:	5d                   	pop    %rbp
  800420102a:	c3                   	retq   

000000800420102b <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  800420102b:	55                   	push   %rbp
  800420102c:	48 89 e5             	mov    %rsp,%rbp
  800420102f:	48 83 ec 20          	sub    $0x20,%rsp
  8004201033:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  8004201037:	eb 6a                	jmp    80042010a3 <cons_intr+0x78>
		if (c == 0)
  8004201039:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420103d:	75 02                	jne    8004201041 <cons_intr+0x16>
			continue;
  800420103f:	eb 62                	jmp    80042010a3 <cons_intr+0x78>
		cons.buf[cons.wpos++] = c;
  8004201041:	48 b8 20 00 36 04 80 	movabs $0x8004360020,%rax
  8004201048:	00 00 00 
  800420104b:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004201051:	8d 48 01             	lea    0x1(%rax),%ecx
  8004201054:	48 ba 20 00 36 04 80 	movabs $0x8004360020,%rdx
  800420105b:	00 00 00 
  800420105e:	89 8a 04 02 00 00    	mov    %ecx,0x204(%rdx)
  8004201064:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004201067:	89 d1                	mov    %edx,%ecx
  8004201069:	48 ba 20 00 36 04 80 	movabs $0x8004360020,%rdx
  8004201070:	00 00 00 
  8004201073:	89 c0                	mov    %eax,%eax
  8004201075:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
		if (cons.wpos == CONSBUFSIZE)
  8004201078:	48 b8 20 00 36 04 80 	movabs $0x8004360020,%rax
  800420107f:	00 00 00 
  8004201082:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004201088:	3d 00 02 00 00       	cmp    $0x200,%eax
  800420108d:	75 14                	jne    80042010a3 <cons_intr+0x78>
			cons.wpos = 0;
  800420108f:	48 b8 20 00 36 04 80 	movabs $0x8004360020,%rax
  8004201096:	00 00 00 
  8004201099:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  80042010a0:	00 00 00 
static void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
  80042010a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042010a7:	ff d0                	callq  *%rax
  80042010a9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80042010ac:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80042010b0:	75 87                	jne    8004201039 <cons_intr+0xe>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
  80042010b2:	c9                   	leaveq 
  80042010b3:	c3                   	retq   

00000080042010b4 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  80042010b4:	55                   	push   %rbp
  80042010b5:	48 89 e5             	mov    %rsp,%rbp
  80042010b8:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  80042010bc:	48 b8 bf 07 20 04 80 	movabs $0x80042007bf,%rax
  80042010c3:	00 00 00 
  80042010c6:	ff d0                	callq  *%rax
	kbd_intr();
  80042010c8:	48 b8 da 0f 20 04 80 	movabs $0x8004200fda,%rax
  80042010cf:	00 00 00 
  80042010d2:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  80042010d4:	48 b8 20 00 36 04 80 	movabs $0x8004360020,%rax
  80042010db:	00 00 00 
  80042010de:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  80042010e4:	48 b8 20 00 36 04 80 	movabs $0x8004360020,%rax
  80042010eb:	00 00 00 
  80042010ee:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042010f4:	39 c2                	cmp    %eax,%edx
  80042010f6:	74 69                	je     8004201161 <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  80042010f8:	48 b8 20 00 36 04 80 	movabs $0x8004360020,%rax
  80042010ff:	00 00 00 
  8004201102:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004201108:	8d 48 01             	lea    0x1(%rax),%ecx
  800420110b:	48 ba 20 00 36 04 80 	movabs $0x8004360020,%rdx
  8004201112:	00 00 00 
  8004201115:	89 8a 00 02 00 00    	mov    %ecx,0x200(%rdx)
  800420111b:	48 ba 20 00 36 04 80 	movabs $0x8004360020,%rdx
  8004201122:	00 00 00 
  8004201125:	89 c0                	mov    %eax,%eax
  8004201127:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420112b:	0f b6 c0             	movzbl %al,%eax
  800420112e:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (cons.rpos == CONSBUFSIZE)
  8004201131:	48 b8 20 00 36 04 80 	movabs $0x8004360020,%rax
  8004201138:	00 00 00 
  800420113b:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004201141:	3d 00 02 00 00       	cmp    $0x200,%eax
  8004201146:	75 14                	jne    800420115c <cons_getc+0xa8>
			cons.rpos = 0;
  8004201148:	48 b8 20 00 36 04 80 	movabs $0x8004360020,%rax
  800420114f:	00 00 00 
  8004201152:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  8004201159:	00 00 00 
		return c;
  800420115c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420115f:	eb 05                	jmp    8004201166 <cons_getc+0xb2>
	}
	return 0;
  8004201161:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201166:	c9                   	leaveq 
  8004201167:	c3                   	retq   

0000008004201168 <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  8004201168:	55                   	push   %rbp
  8004201169:	48 89 e5             	mov    %rsp,%rbp
  800420116c:	48 83 ec 10          	sub    $0x10,%rsp
  8004201170:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  8004201173:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201176:	89 c7                	mov    %eax,%edi
  8004201178:	48 b8 ec 07 20 04 80 	movabs $0x80042007ec,%rax
  800420117f:	00 00 00 
  8004201182:	ff d0                	callq  *%rax
	lpt_putc(c);
  8004201184:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201187:	89 c7                	mov    %eax,%edi
  8004201189:	48 b8 25 09 20 04 80 	movabs $0x8004200925,%rax
  8004201190:	00 00 00 
  8004201193:	ff d0                	callq  *%rax
	cga_putc(c);
  8004201195:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201198:	89 c7                	mov    %eax,%edi
  800420119a:	48 b8 c4 0a 20 04 80 	movabs $0x8004200ac4,%rax
  80042011a1:	00 00 00 
  80042011a4:	ff d0                	callq  *%rax
}
  80042011a6:	c9                   	leaveq 
  80042011a7:	c3                   	retq   

00000080042011a8 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  80042011a8:	55                   	push   %rbp
  80042011a9:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  80042011ac:	48 b8 aa 09 20 04 80 	movabs $0x80042009aa,%rax
  80042011b3:	00 00 00 
  80042011b6:	ff d0                	callq  *%rax
	kbd_init();
  80042011b8:	48 b8 f6 0f 20 04 80 	movabs $0x8004200ff6,%rax
  80042011bf:	00 00 00 
  80042011c2:	ff d0                	callq  *%rax
	serial_init();
  80042011c4:	48 b8 51 08 20 04 80 	movabs $0x8004200851,%rax
  80042011cb:	00 00 00 
  80042011ce:	ff d0                	callq  *%rax

	if (!serial_exists)
  80042011d0:	48 b8 00 00 36 04 80 	movabs $0x8004360000,%rax
  80042011d7:	00 00 00 
  80042011da:	0f b6 00             	movzbl (%rax),%eax
  80042011dd:	83 f0 01             	xor    $0x1,%eax
  80042011e0:	84 c0                	test   %al,%al
  80042011e2:	74 1b                	je     80042011ff <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  80042011e4:	48 bf 92 72 21 04 80 	movabs $0x8004217292,%rdi
  80042011eb:	00 00 00 
  80042011ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80042011f3:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  80042011fa:	00 00 00 
  80042011fd:	ff d2                	callq  *%rdx
}
  80042011ff:	5d                   	pop    %rbp
  8004201200:	c3                   	retq   

0000008004201201 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  8004201201:	55                   	push   %rbp
  8004201202:	48 89 e5             	mov    %rsp,%rbp
  8004201205:	48 83 ec 10          	sub    $0x10,%rsp
  8004201209:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  800420120c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420120f:	89 c7                	mov    %eax,%edi
  8004201211:	48 b8 68 11 20 04 80 	movabs $0x8004201168,%rax
  8004201218:	00 00 00 
  800420121b:	ff d0                	callq  *%rax
}
  800420121d:	c9                   	leaveq 
  800420121e:	c3                   	retq   

000000800420121f <getchar>:

int
getchar(void)
{
  800420121f:	55                   	push   %rbp
  8004201220:	48 89 e5             	mov    %rsp,%rbp
  8004201223:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  8004201227:	48 b8 b4 10 20 04 80 	movabs $0x80042010b4,%rax
  800420122e:	00 00 00 
  8004201231:	ff d0                	callq  *%rax
  8004201233:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004201236:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420123a:	74 eb                	je     8004201227 <getchar+0x8>
		/* do nothing */;
	return c;
  800420123c:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420123f:	c9                   	leaveq 
  8004201240:	c3                   	retq   

0000008004201241 <iscons>:

int
iscons(int fdnum)
{
  8004201241:	55                   	push   %rbp
  8004201242:	48 89 e5             	mov    %rsp,%rbp
  8004201245:	48 83 ec 04          	sub    $0x4,%rsp
  8004201249:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  800420124c:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201251:	c9                   	leaveq 
  8004201252:	c3                   	retq   

0000008004201253 <mon_help>:

/***** Implementations of basic kernel monitor commands *****/

int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  8004201253:	55                   	push   %rbp
  8004201254:	48 89 e5             	mov    %rsp,%rbp
  8004201257:	48 83 ec 30          	sub    $0x30,%rsp
  800420125b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420125e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004201262:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004201266:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420126d:	eb 6c                	jmp    80042012db <mon_help+0x88>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  800420126f:	48 b9 80 a5 22 04 80 	movabs $0x800422a580,%rcx
  8004201276:	00 00 00 
  8004201279:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420127c:	48 63 d0             	movslq %eax,%rdx
  800420127f:	48 89 d0             	mov    %rdx,%rax
  8004201282:	48 01 c0             	add    %rax,%rax
  8004201285:	48 01 d0             	add    %rdx,%rax
  8004201288:	48 c1 e0 03          	shl    $0x3,%rax
  800420128c:	48 01 c8             	add    %rcx,%rax
  800420128f:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004201293:	48 be 80 a5 22 04 80 	movabs $0x800422a580,%rsi
  800420129a:	00 00 00 
  800420129d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012a0:	48 63 d0             	movslq %eax,%rdx
  80042012a3:	48 89 d0             	mov    %rdx,%rax
  80042012a6:	48 01 c0             	add    %rax,%rax
  80042012a9:	48 01 d0             	add    %rdx,%rax
  80042012ac:	48 c1 e0 03          	shl    $0x3,%rax
  80042012b0:	48 01 f0             	add    %rsi,%rax
  80042012b3:	48 8b 00             	mov    (%rax),%rax
  80042012b6:	48 89 ca             	mov    %rcx,%rdx
  80042012b9:	48 89 c6             	mov    %rax,%rsi
  80042012bc:	48 bf 08 74 21 04 80 	movabs $0x8004217408,%rdi
  80042012c3:	00 00 00 
  80042012c6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042012cb:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  80042012d2:	00 00 00 
  80042012d5:	ff d1                	callq  *%rcx
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  80042012d7:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042012db:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012de:	83 f8 05             	cmp    $0x5,%eax
  80042012e1:	76 8c                	jbe    800420126f <mon_help+0x1c>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
	return 0;
  80042012e3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042012e8:	c9                   	leaveq 
  80042012e9:	c3                   	retq   

00000080042012ea <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  80042012ea:	55                   	push   %rbp
  80042012eb:	48 89 e5             	mov    %rsp,%rbp
  80042012ee:	48 83 ec 30          	sub    $0x30,%rsp
  80042012f2:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042012f5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042012f9:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  80042012fd:	48 bf 11 74 21 04 80 	movabs $0x8004217411,%rdi
  8004201304:	00 00 00 
  8004201307:	b8 00 00 00 00       	mov    $0x0,%eax
  800420130c:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201313:	00 00 00 
  8004201316:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  8004201318:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  800420131f:	00 00 00 
  8004201322:	48 bf 30 74 21 04 80 	movabs $0x8004217430,%rdi
  8004201329:	00 00 00 
  800420132c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201331:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201338:	00 00 00 
  800420133b:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  800420133d:	48 ba 0c 00 20 00 00 	movabs $0x20000c,%rdx
  8004201344:	00 00 00 
  8004201347:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  800420134e:	00 00 00 
  8004201351:	48 bf 58 74 21 04 80 	movabs $0x8004217458,%rdi
  8004201358:	00 00 00 
  800420135b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201360:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  8004201367:	00 00 00 
  800420136a:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  800420136c:	48 ba 69 71 21 00 00 	movabs $0x217169,%rdx
  8004201373:	00 00 00 
  8004201376:	48 be 69 71 21 04 80 	movabs $0x8004217169,%rsi
  800420137d:	00 00 00 
  8004201380:	48 bf 80 74 21 04 80 	movabs $0x8004217480,%rdi
  8004201387:	00 00 00 
  800420138a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420138f:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  8004201396:	00 00 00 
  8004201399:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  800420139b:	48 ba 4a f7 35 00 00 	movabs $0x35f74a,%rdx
  80042013a2:	00 00 00 
  80042013a5:	48 be 4a f7 35 04 80 	movabs $0x800435f74a,%rsi
  80042013ac:	00 00 00 
  80042013af:	48 bf a8 74 21 04 80 	movabs $0x80042174a8,%rdi
  80042013b6:	00 00 00 
  80042013b9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013be:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  80042013c5:	00 00 00 
  80042013c8:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  80042013ca:	48 ba 10 40 3e 00 00 	movabs $0x3e4010,%rdx
  80042013d1:	00 00 00 
  80042013d4:	48 be 10 40 3e 04 80 	movabs $0x80043e4010,%rsi
  80042013db:	00 00 00 
  80042013de:	48 bf d0 74 21 04 80 	movabs $0x80042174d0,%rdi
  80042013e5:	00 00 00 
  80042013e8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013ed:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  80042013f4:	00 00 00 
  80042013f7:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  80042013f9:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  8004201400:	00 
  8004201401:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  8004201408:	00 00 00 
  800420140b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420140f:	48 29 c2             	sub    %rax,%rdx
  8004201412:	48 b8 10 40 3e 04 80 	movabs $0x80043e4010,%rax
  8004201419:	00 00 00 
  800420141c:	48 83 e8 01          	sub    $0x1,%rax
  8004201420:	48 01 d0             	add    %rdx,%rax
  8004201423:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004201427:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420142b:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201430:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004201434:	48 89 d0             	mov    %rdx,%rax
  8004201437:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420143b:	48 29 c2             	sub    %rax,%rdx
  800420143e:	48 89 d0             	mov    %rdx,%rax
	cprintf("  _start                  %08x (phys)\n", _start);
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
	cprintf("Kernel executable memory footprint: %dKB\n",
  8004201441:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  8004201448:	48 85 c0             	test   %rax,%rax
  800420144b:	48 0f 48 c2          	cmovs  %rdx,%rax
  800420144f:	48 c1 f8 0a          	sar    $0xa,%rax
  8004201453:	48 89 c6             	mov    %rax,%rsi
  8004201456:	48 bf f8 74 21 04 80 	movabs $0x80042174f8,%rdi
  800420145d:	00 00 00 
  8004201460:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201465:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420146c:	00 00 00 
  800420146f:	ff d2                	callq  *%rdx
		ROUNDUP(end - entry, 1024) / 1024);
	return 0;
  8004201471:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201476:	c9                   	leaveq 
  8004201477:	c3                   	retq   

0000008004201478 <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  8004201478:	55                   	push   %rbp
  8004201479:	48 89 e5             	mov    %rsp,%rbp
  800420147c:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004201480:	89 7d 9c             	mov    %edi,-0x64(%rbp)
  8004201483:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  8004201487:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
       // Your code here.
        
        int rdi, rsi, rdx;
        
        asm __volatile("mov %%edx,%0" : "=r" (rdx)::);
  800420148b:	89 d0                	mov    %edx,%eax
  800420148d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
        asm __volatile("mov %%esi,%0" : "=r" (rsi)::);
  8004201490:	89 f0                	mov    %esi,%eax
  8004201492:	89 45 e0             	mov    %eax,-0x20(%rbp)
        asm __volatile("mov %%edi,%0" : "=r" (rdi)::);
  8004201495:	89 f8                	mov    %edi,%eax
  8004201497:	89 45 dc             	mov    %eax,-0x24(%rbp)
        
       struct Ripdebuginfo *info = 0;
  800420149a:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  80042014a1:	00 
       int args;
       int *d, i;
       cprintf("Stack backtrace: \n");
  80042014a2:	48 bf 22 75 21 04 80 	movabs $0x8004217522,%rdi
  80042014a9:	00 00 00 
  80042014ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014b1:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  80042014b8:	00 00 00 
  80042014bb:	ff d2                	callq  *%rdx

static __inline uint64_t
read_rbp(void)
{
        uint64_t rbp;
        __asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  80042014bd:	48 89 e8             	mov    %rbp,%rax
  80042014c0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        return rbp;
  80042014c4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
       uint64_t *prev_rbp;
       uint64_t *data = (uint64_t *)read_rbp();
  80042014c8:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
       uint64_t rbp, rip;
       
       read_rip(rip);
  80042014cc:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 42014d3 <_start+0x40014c7>
  80042014d3:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

static __inline uint64_t
read_rbp(void)
{
        uint64_t rbp;
        __asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  80042014d7:	48 89 e8             	mov    %rbp,%rax
  80042014da:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
        return rbp;
  80042014de:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
       rbp = read_rbp(); 
  80042014e2:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
       cprintf(" rbp %16.0x rip %16.0x\n", rbp, rip);
  80042014e6:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042014ea:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042014ee:	48 89 c6             	mov    %rax,%rsi
  80042014f1:	48 bf 35 75 21 04 80 	movabs $0x8004217535,%rdi
  80042014f8:	00 00 00 
  80042014fb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201500:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  8004201507:	00 00 00 
  800420150a:	ff d1                	callq  *%rcx
       debuginfo_rip(rip, info);
  800420150c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004201510:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201514:	48 89 d6             	mov    %rdx,%rsi
  8004201517:	48 89 c7             	mov    %rax,%rdi
  800420151a:	48 b8 eb e8 20 04 80 	movabs $0x800420e8eb,%rax
  8004201521:	00 00 00 
  8004201524:	ff d0                	callq  *%rax
        cprintf("      %s:%d: %s+%16.0x  args:%x ", info->rip_file, info->rip_line, info->rip_fn_name, rip-info->rip_fn_addr, info->rip_fn_narg);
  8004201526:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420152a:	8b 70 28             	mov    0x28(%rax),%esi
  800420152d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201531:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004201535:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004201539:	48 89 d7             	mov    %rdx,%rdi
  800420153c:	48 29 c7             	sub    %rax,%rdi
  800420153f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201543:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004201547:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420154b:	8b 50 08             	mov    0x8(%rax),%edx
  800420154e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201552:	48 8b 00             	mov    (%rax),%rax
  8004201555:	41 89 f1             	mov    %esi,%r9d
  8004201558:	49 89 f8             	mov    %rdi,%r8
  800420155b:	48 89 c6             	mov    %rax,%rsi
  800420155e:	48 bf 50 75 21 04 80 	movabs $0x8004217550,%rdi
  8004201565:	00 00 00 
  8004201568:	b8 00 00 00 00       	mov    $0x0,%eax
  800420156d:	49 ba 11 96 20 04 80 	movabs $0x8004209611,%r10
  8004201574:	00 00 00 
  8004201577:	41 ff d2             	callq  *%r10
        prev_rbp = (uint64_t *)rbp;
  800420157a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420157e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        d = (int *)(*prev_rbp);
  8004201582:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201586:	48 8b 00             	mov    (%rax),%rax
  8004201589:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
       	if(info->rip_fn_narg)
  800420158d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201591:	8b 40 28             	mov    0x28(%rax),%eax
  8004201594:	85 c0                	test   %eax,%eax
  8004201596:	74 29                	je     80042015c1 <mon_backtrace+0x149>
          cprintf("%16.0x %16.0x %16.0x\n", rdi, rsi, rdx);      
  8004201598:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420159b:	8b 55 e0             	mov    -0x20(%rbp),%edx
  800420159e:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042015a1:	89 c6                	mov    %eax,%esi
  80042015a3:	48 bf 71 75 21 04 80 	movabs $0x8004217571,%rdi
  80042015aa:	00 00 00 
  80042015ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015b2:	49 b8 11 96 20 04 80 	movabs $0x8004209611,%r8
  80042015b9:	00 00 00 
  80042015bc:	41 ff d0             	callq  *%r8
  80042015bf:	eb 1b                	jmp    80042015dc <mon_backtrace+0x164>
        else 
          cprintf("\n");
  80042015c1:	48 bf 87 75 21 04 80 	movabs $0x8004217587,%rdi
  80042015c8:	00 00 00 
  80042015cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015d0:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  80042015d7:	00 00 00 
  80042015da:	ff d2                	callq  *%rdx
       	
        cprintf("%16.0x %16.0x %16.0x\n", rdi, rsi, rdx);      
  80042015dc:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  80042015df:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80042015e2:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042015e5:	89 c6                	mov    %eax,%esi
  80042015e7:	48 bf 71 75 21 04 80 	movabs $0x8004217571,%rdi
  80042015ee:	00 00 00 
  80042015f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015f6:	49 b8 11 96 20 04 80 	movabs $0x8004209611,%r8
  80042015fd:	00 00 00 
  8004201600:	41 ff d0             	callq  *%r8

       while(*prev_rbp)
  8004201603:	e9 8c 01 00 00       	jmpq   8004201794 <mon_backtrace+0x31c>
       {
        
        rbp = (*prev_rbp);
  8004201608:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420160c:	48 8b 00             	mov    (%rax),%rax
  800420160f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        rip = (*(prev_rbp+1));
  8004201613:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201617:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420161b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        cprintf(" rbp %16.0x rip %16.0x\n", rbp, rip);
  800420161f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004201623:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004201627:	48 89 c6             	mov    %rax,%rsi
  800420162a:	48 bf 35 75 21 04 80 	movabs $0x8004217535,%rdi
  8004201631:	00 00 00 
  8004201634:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201639:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  8004201640:	00 00 00 
  8004201643:	ff d1                	callq  *%rcx
        debuginfo_rip(rip, info);
  8004201645:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004201649:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420164d:	48 89 d6             	mov    %rdx,%rsi
  8004201650:	48 89 c7             	mov    %rax,%rdi
  8004201653:	48 b8 eb e8 20 04 80 	movabs $0x800420e8eb,%rax
  800420165a:	00 00 00 
  800420165d:	ff d0                	callq  *%rax
        if(info->rip_fn_narg)
  800420165f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201663:	8b 40 28             	mov    0x28(%rax),%eax
  8004201666:	85 c0                	test   %eax,%eax
  8004201668:	0f 84 bf 00 00 00    	je     800420172d <mon_backtrace+0x2b5>
	  {
             cprintf("      %s:%d: %s+%16.0x  args:%x ", info->rip_file, info->rip_line, info->rip_fn_name, rip-info->rip_fn_addr, info->rip_fn_narg);
  800420166e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201672:	8b 70 28             	mov    0x28(%rax),%esi
  8004201675:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201679:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420167d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004201681:	48 89 d7             	mov    %rdx,%rdi
  8004201684:	48 29 c7             	sub    %rax,%rdi
  8004201687:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420168b:	48 8b 48 10          	mov    0x10(%rax),%rcx
  800420168f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201693:	8b 50 08             	mov    0x8(%rax),%edx
  8004201696:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420169a:	48 8b 00             	mov    (%rax),%rax
  800420169d:	41 89 f1             	mov    %esi,%r9d
  80042016a0:	49 89 f8             	mov    %rdi,%r8
  80042016a3:	48 89 c6             	mov    %rax,%rsi
  80042016a6:	48 bf 50 75 21 04 80 	movabs $0x8004217550,%rdi
  80042016ad:	00 00 00 
  80042016b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042016b5:	49 ba 11 96 20 04 80 	movabs $0x8004209611,%r10
  80042016bc:	00 00 00 
  80042016bf:	41 ff d2             	callq  *%r10
             for(i = 1; i <= info->rip_fn_narg; i++) 
  80042016c2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
  80042016c9:	eb 39                	jmp    8004201704 <mon_backtrace+0x28c>
                 cprintf("%16.0x ", *(d-i));      
  80042016cb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042016ce:	48 98                	cltq   
  80042016d0:	48 c1 e0 02          	shl    $0x2,%rax
  80042016d4:	48 f7 d8             	neg    %rax
  80042016d7:	48 89 c2             	mov    %rax,%rdx
  80042016da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042016de:	48 01 d0             	add    %rdx,%rax
  80042016e1:	8b 00                	mov    (%rax),%eax
  80042016e3:	89 c6                	mov    %eax,%esi
  80042016e5:	48 bf 89 75 21 04 80 	movabs $0x8004217589,%rdi
  80042016ec:	00 00 00 
  80042016ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80042016f4:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  80042016fb:	00 00 00 
  80042016fe:	ff d2                	callq  *%rdx
        cprintf(" rbp %16.0x rip %16.0x\n", rbp, rip);
        debuginfo_rip(rip, info);
        if(info->rip_fn_narg)
	  {
             cprintf("      %s:%d: %s+%16.0x  args:%x ", info->rip_file, info->rip_line, info->rip_fn_name, rip-info->rip_fn_addr, info->rip_fn_narg);
             for(i = 1; i <= info->rip_fn_narg; i++) 
  8004201700:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004201704:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201708:	8b 40 28             	mov    0x28(%rax),%eax
  800420170b:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  800420170e:	7d bb                	jge    80042016cb <mon_backtrace+0x253>
                 cprintf("%16.0x ", *(d-i));      
             cprintf("\n");
  8004201710:	48 bf 87 75 21 04 80 	movabs $0x8004217587,%rdi
  8004201717:	00 00 00 
  800420171a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420171f:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201726:	00 00 00 
  8004201729:	ff d2                	callq  *%rdx
  800420172b:	eb 54                	jmp    8004201781 <mon_backtrace+0x309>

	  }
        else
          cprintf("      %s:%d: %s+%16.0x  args:%x\n", info->rip_file, info->rip_line, info->rip_fn_name, rip-info->rip_fn_addr, info->rip_fn_narg);
  800420172d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201731:	8b 70 28             	mov    0x28(%rax),%esi
  8004201734:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201738:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420173c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004201740:	48 89 d7             	mov    %rdx,%rdi
  8004201743:	48 29 c7             	sub    %rax,%rdi
  8004201746:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420174a:	48 8b 48 10          	mov    0x10(%rax),%rcx
  800420174e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201752:	8b 50 08             	mov    0x8(%rax),%edx
  8004201755:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201759:	48 8b 00             	mov    (%rax),%rax
  800420175c:	41 89 f1             	mov    %esi,%r9d
  800420175f:	49 89 f8             	mov    %rdi,%r8
  8004201762:	48 89 c6             	mov    %rax,%rsi
  8004201765:	48 bf 98 75 21 04 80 	movabs $0x8004217598,%rdi
  800420176c:	00 00 00 
  800420176f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201774:	49 ba 11 96 20 04 80 	movabs $0x8004209611,%r10
  800420177b:	00 00 00 
  800420177e:	41 ff d2             	callq  *%r10

        prev_rbp = (uint64_t *)rbp;
  8004201781:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004201785:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        d = (int *)(*prev_rbp);
  8004201789:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420178d:	48 8b 00             	mov    (%rax),%rax
  8004201790:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        else 
          cprintf("\n");
       	
        cprintf("%16.0x %16.0x %16.0x\n", rdi, rsi, rdx);      

       while(*prev_rbp)
  8004201794:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201798:	48 8b 00             	mov    (%rax),%rax
  800420179b:	48 85 c0             	test   %rax,%rax
  800420179e:	0f 85 64 fe ff ff    	jne    8004201608 <mon_backtrace+0x190>

        prev_rbp = (uint64_t *)rbp;
        d = (int *)(*prev_rbp);
       }
     
     return 0;
  80042017a4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042017a9:	c9                   	leaveq 
  80042017aa:	c3                   	retq   

00000080042017ab <backtrace_lab1>:


int
backtrace_lab1(int argc, char **argv, struct Trapframe *tf)
{
  80042017ab:	55                   	push   %rbp
  80042017ac:	48 89 e5             	mov    %rsp,%rbp
  80042017af:	48 83 ec 60          	sub    $0x60,%rsp
  80042017b3:	89 7d bc             	mov    %edi,-0x44(%rbp)
  80042017b6:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  80042017ba:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
       // Your code here.
       // Your code here.
       struct Ripdebuginfo *info = 0;
  80042017be:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042017c5:	00 
       int args;
       int *d,i;
       cprintf("Stack backtrace: \n");
  80042017c6:	48 bf 22 75 21 04 80 	movabs $0x8004217522,%rdi
  80042017cd:	00 00 00 
  80042017d0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017d5:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  80042017dc:	00 00 00 
  80042017df:	ff d2                	callq  *%rdx
       uint64_t *prev_rbp;
       uint64_t rbp, rip;
       
       read_rip(rip);
  80042017e1:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 42017e8 <_start+0x40017dc>
  80042017e8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

static __inline uint64_t
read_rbp(void)
{
        uint64_t rbp;
        __asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  80042017ec:	48 89 e8             	mov    %rbp,%rax
  80042017ef:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        return rbp;
  80042017f3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
       rbp = read_rbp();
  80042017f7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
 
       cprintf(" rbp %16.0x rip %16.0x\n", rbp, rip);
  80042017fb:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042017ff:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201803:	48 89 c6             	mov    %rax,%rsi
  8004201806:	48 bf 35 75 21 04 80 	movabs $0x8004217535,%rdi
  800420180d:	00 00 00 
  8004201810:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201815:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  800420181c:	00 00 00 
  800420181f:	ff d1                	callq  *%rcx

       debuginfo_rip(rip, info);
  8004201821:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004201825:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201829:	48 89 d6             	mov    %rdx,%rsi
  800420182c:	48 89 c7             	mov    %rax,%rdi
  800420182f:	48 b8 eb e8 20 04 80 	movabs $0x800420e8eb,%rax
  8004201836:	00 00 00 
  8004201839:	ff d0                	callq  *%rax
       cprintf("      %s:%d: %s+%16.0x  args:%x  ", info->rip_file, info->rip_line, info->rip_fn_name, rip-info->rip_fn_addr, info->rip_fn_narg);
  800420183b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420183f:	8b 70 28             	mov    0x28(%rax),%esi
  8004201842:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201846:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420184a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420184e:	48 89 d7             	mov    %rdx,%rdi
  8004201851:	48 29 c7             	sub    %rax,%rdi
  8004201854:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201858:	48 8b 48 10          	mov    0x10(%rax),%rcx
  800420185c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201860:	8b 50 08             	mov    0x8(%rax),%edx
  8004201863:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201867:	48 8b 00             	mov    (%rax),%rax
  800420186a:	41 89 f1             	mov    %esi,%r9d
  800420186d:	49 89 f8             	mov    %rdi,%r8
  8004201870:	48 89 c6             	mov    %rax,%rsi
  8004201873:	48 bf c0 75 21 04 80 	movabs $0x80042175c0,%rdi
  800420187a:	00 00 00 
  800420187d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201882:	49 ba 11 96 20 04 80 	movabs $0x8004209611,%r10
  8004201889:	00 00 00 
  800420188c:	41 ff d2             	callq  *%r10

        prev_rbp = (uint64_t *)rbp;
  800420188f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201893:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
       	d = (int *)(*prev_rbp);        
  8004201897:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420189b:	48 8b 00             	mov    (%rax),%rax
  800420189e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        // It is not a right way we are not writing this function arguments but previous one
        for(i = 1; i <= info->rip_fn_narg; i++) 
  80042018a2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
  80042018a9:	eb 39                	jmp    80042018e4 <backtrace_lab1+0x139>
           cprintf("%16.0x ", *(d-i));      
  80042018ab:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042018ae:	48 98                	cltq   
  80042018b0:	48 c1 e0 02          	shl    $0x2,%rax
  80042018b4:	48 f7 d8             	neg    %rax
  80042018b7:	48 89 c2             	mov    %rax,%rdx
  80042018ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042018be:	48 01 d0             	add    %rdx,%rax
  80042018c1:	8b 00                	mov    (%rax),%eax
  80042018c3:	89 c6                	mov    %eax,%esi
  80042018c5:	48 bf 89 75 21 04 80 	movabs $0x8004217589,%rdi
  80042018cc:	00 00 00 
  80042018cf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018d4:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  80042018db:	00 00 00 
  80042018de:	ff d2                	callq  *%rdx
       cprintf("      %s:%d: %s+%16.0x  args:%x  ", info->rip_file, info->rip_line, info->rip_fn_name, rip-info->rip_fn_addr, info->rip_fn_narg);

        prev_rbp = (uint64_t *)rbp;
       	d = (int *)(*prev_rbp);        
        // It is not a right way we are not writing this function arguments but previous one
        for(i = 1; i <= info->rip_fn_narg; i++) 
  80042018e0:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042018e4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042018e8:	8b 40 28             	mov    0x28(%rax),%eax
  80042018eb:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  80042018ee:	7d bb                	jge    80042018ab <backtrace_lab1+0x100>
           cprintf("%16.0x ", *(d-i));      
        cprintf("\n");
  80042018f0:	48 bf 87 75 21 04 80 	movabs $0x8004217587,%rdi
  80042018f7:	00 00 00 
  80042018fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018ff:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201906:	00 00 00 
  8004201909:	ff d2                	callq  *%rdx


       while(*prev_rbp)
  800420190b:	e9 8c 01 00 00       	jmpq   8004201a9c <backtrace_lab1+0x2f1>
       {
        
        rbp = (*prev_rbp);
  8004201910:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201914:	48 8b 00             	mov    (%rax),%rax
  8004201917:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        rip = (*(prev_rbp+1));
  800420191b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420191f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004201923:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        cprintf(" rbp %16.0x rip %16.0x\n", rbp, rip);
  8004201927:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420192b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420192f:	48 89 c6             	mov    %rax,%rsi
  8004201932:	48 bf 35 75 21 04 80 	movabs $0x8004217535,%rdi
  8004201939:	00 00 00 
  800420193c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201941:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  8004201948:	00 00 00 
  800420194b:	ff d1                	callq  *%rcx
        debuginfo_rip(rip, info);
  800420194d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004201951:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201955:	48 89 d6             	mov    %rdx,%rsi
  8004201958:	48 89 c7             	mov    %rax,%rdi
  800420195b:	48 b8 eb e8 20 04 80 	movabs $0x800420e8eb,%rax
  8004201962:	00 00 00 
  8004201965:	ff d0                	callq  *%rax
        if(info->rip_fn_narg)
  8004201967:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420196b:	8b 40 28             	mov    0x28(%rax),%eax
  800420196e:	85 c0                	test   %eax,%eax
  8004201970:	0f 84 bf 00 00 00    	je     8004201a35 <backtrace_lab1+0x28a>
          {
           cprintf("      %s:%d: %s+%16.0x  args:%x ", info->rip_file, info->rip_line, info->rip_fn_name, rip-info->rip_fn_addr, info->rip_fn_narg);
  8004201976:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420197a:	8b 70 28             	mov    0x28(%rax),%esi
  800420197d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201981:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004201985:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004201989:	48 89 d7             	mov    %rdx,%rdi
  800420198c:	48 29 c7             	sub    %rax,%rdi
  800420198f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201993:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004201997:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420199b:	8b 50 08             	mov    0x8(%rax),%edx
  800420199e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042019a2:	48 8b 00             	mov    (%rax),%rax
  80042019a5:	41 89 f1             	mov    %esi,%r9d
  80042019a8:	49 89 f8             	mov    %rdi,%r8
  80042019ab:	48 89 c6             	mov    %rax,%rsi
  80042019ae:	48 bf 50 75 21 04 80 	movabs $0x8004217550,%rdi
  80042019b5:	00 00 00 
  80042019b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042019bd:	49 ba 11 96 20 04 80 	movabs $0x8004209611,%r10
  80042019c4:	00 00 00 
  80042019c7:	41 ff d2             	callq  *%r10
           
	   for(i = 1; i <= info->rip_fn_narg; i++) 
  80042019ca:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
  80042019d1:	eb 39                	jmp    8004201a0c <backtrace_lab1+0x261>
             cprintf("%16.0x ", *(d-i));      
  80042019d3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042019d6:	48 98                	cltq   
  80042019d8:	48 c1 e0 02          	shl    $0x2,%rax
  80042019dc:	48 f7 d8             	neg    %rax
  80042019df:	48 89 c2             	mov    %rax,%rdx
  80042019e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042019e6:	48 01 d0             	add    %rdx,%rax
  80042019e9:	8b 00                	mov    (%rax),%eax
  80042019eb:	89 c6                	mov    %eax,%esi
  80042019ed:	48 bf 89 75 21 04 80 	movabs $0x8004217589,%rdi
  80042019f4:	00 00 00 
  80042019f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042019fc:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201a03:	00 00 00 
  8004201a06:	ff d2                	callq  *%rdx
        debuginfo_rip(rip, info);
        if(info->rip_fn_narg)
          {
           cprintf("      %s:%d: %s+%16.0x  args:%x ", info->rip_file, info->rip_line, info->rip_fn_name, rip-info->rip_fn_addr, info->rip_fn_narg);
           
	   for(i = 1; i <= info->rip_fn_narg; i++) 
  8004201a08:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004201a0c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201a10:	8b 40 28             	mov    0x28(%rax),%eax
  8004201a13:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8004201a16:	7d bb                	jge    80042019d3 <backtrace_lab1+0x228>
             cprintf("%16.0x ", *(d-i));      
           cprintf("\n");
  8004201a18:	48 bf 87 75 21 04 80 	movabs $0x8004217587,%rdi
  8004201a1f:	00 00 00 
  8004201a22:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a27:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201a2e:	00 00 00 
  8004201a31:	ff d2                	callq  *%rdx
  8004201a33:	eb 54                	jmp    8004201a89 <backtrace_lab1+0x2de>

          }
        else
          cprintf("      %s:%d: %s+%16.0x  args:%x \n", info->rip_file, info->rip_line, info->rip_fn_name, rip-info->rip_fn_addr, info->rip_fn_narg);
  8004201a35:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201a39:	8b 70 28             	mov    0x28(%rax),%esi
  8004201a3c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201a40:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004201a44:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004201a48:	48 89 d7             	mov    %rdx,%rdi
  8004201a4b:	48 29 c7             	sub    %rax,%rdi
  8004201a4e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201a52:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004201a56:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201a5a:	8b 50 08             	mov    0x8(%rax),%edx
  8004201a5d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201a61:	48 8b 00             	mov    (%rax),%rax
  8004201a64:	41 89 f1             	mov    %esi,%r9d
  8004201a67:	49 89 f8             	mov    %rdi,%r8
  8004201a6a:	48 89 c6             	mov    %rax,%rsi
  8004201a6d:	48 bf e8 75 21 04 80 	movabs $0x80042175e8,%rdi
  8004201a74:	00 00 00 
  8004201a77:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a7c:	49 ba 11 96 20 04 80 	movabs $0x8004209611,%r10
  8004201a83:	00 00 00 
  8004201a86:	41 ff d2             	callq  *%r10

        prev_rbp = (uint64_t *)rbp;
  8004201a89:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201a8d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        d = (int *)(*prev_rbp);
  8004201a91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201a95:	48 8b 00             	mov    (%rax),%rax
  8004201a98:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        for(i = 1; i <= info->rip_fn_narg; i++) 
           cprintf("%16.0x ", *(d-i));      
        cprintf("\n");


       while(*prev_rbp)
  8004201a9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201aa0:	48 8b 00             	mov    (%rax),%rax
  8004201aa3:	48 85 c0             	test   %rax,%rax
  8004201aa6:	0f 85 64 fe ff ff    	jne    8004201910 <backtrace_lab1+0x165>

        prev_rbp = (uint64_t *)rbp;
        d = (int *)(*prev_rbp);
       }
     
     return 0;
  8004201aac:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201ab1:	c9                   	leaveq 
  8004201ab2:	c3                   	retq   

0000008004201ab3 <str_to_int>:

uint64_t str_to_int(char *s)
{
  8004201ab3:	55                   	push   %rbp
  8004201ab4:	48 89 e5             	mov    %rsp,%rbp
  8004201ab7:	48 83 ec 28          	sub    $0x28,%rsp
  8004201abb:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
 uint64_t i=0, offset=1;
  8004201abf:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004201ac6:	00 
  8004201ac7:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
  8004201ace:	00 
 uint64_t res=0;
  8004201acf:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004201ad6:	00 

 while(s[i]!='\0')
  8004201ad7:	eb 05                	jmp    8004201ade <str_to_int+0x2b>
    i++;
  8004201ad9:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
uint64_t str_to_int(char *s)
{
 uint64_t i=0, offset=1;
 uint64_t res=0;

 while(s[i]!='\0')
  8004201ade:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201ae2:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004201ae6:	48 01 d0             	add    %rdx,%rax
  8004201ae9:	0f b6 00             	movzbl (%rax),%eax
  8004201aec:	84 c0                	test   %al,%al
  8004201aee:	75 e9                	jne    8004201ad9 <str_to_int+0x26>
    i++;
   i--;
  8004201af0:	48 83 6d f8 01       	subq   $0x1,-0x8(%rbp)
  //cprintf("length %d\n", i);
  while(i >= 2)
  8004201af5:	e9 da 00 00 00       	jmpq   8004201bd4 <str_to_int+0x121>
   {
    if('0' <= s[i] && s[i]<= '9')
  8004201afa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201afe:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004201b02:	48 01 d0             	add    %rdx,%rax
  8004201b05:	0f b6 00             	movzbl (%rax),%eax
  8004201b08:	3c 2f                	cmp    $0x2f,%al
  8004201b0a:	7e 36                	jle    8004201b42 <str_to_int+0x8f>
  8004201b0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201b10:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004201b14:	48 01 d0             	add    %rdx,%rax
  8004201b17:	0f b6 00             	movzbl (%rax),%eax
  8004201b1a:	3c 39                	cmp    $0x39,%al
  8004201b1c:	7f 24                	jg     8004201b42 <str_to_int+0x8f>
      res = res + ((int)(s[i] - '0'))*offset;
  8004201b1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201b22:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004201b26:	48 01 d0             	add    %rdx,%rax
  8004201b29:	0f b6 00             	movzbl (%rax),%eax
  8004201b2c:	0f be c0             	movsbl %al,%eax
  8004201b2f:	83 e8 30             	sub    $0x30,%eax
  8004201b32:	48 98                	cltq   
  8004201b34:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  8004201b39:	48 01 45 e8          	add    %rax,-0x18(%rbp)
  8004201b3d:	e9 88 00 00 00       	jmpq   8004201bca <str_to_int+0x117>
    else if('a' <= s[i] && s[i]<= 'f')
  8004201b42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201b46:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004201b4a:	48 01 d0             	add    %rdx,%rax
  8004201b4d:	0f b6 00             	movzbl (%rax),%eax
  8004201b50:	3c 60                	cmp    $0x60,%al
  8004201b52:	7e 33                	jle    8004201b87 <str_to_int+0xd4>
  8004201b54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201b58:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004201b5c:	48 01 d0             	add    %rdx,%rax
  8004201b5f:	0f b6 00             	movzbl (%rax),%eax
  8004201b62:	3c 66                	cmp    $0x66,%al
  8004201b64:	7f 21                	jg     8004201b87 <str_to_int+0xd4>
      res = res + ((int)(s[i]-'a') + 10) * offset;
  8004201b66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201b6a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004201b6e:	48 01 d0             	add    %rdx,%rax
  8004201b71:	0f b6 00             	movzbl (%rax),%eax
  8004201b74:	0f be c0             	movsbl %al,%eax
  8004201b77:	83 e8 57             	sub    $0x57,%eax
  8004201b7a:	48 98                	cltq   
  8004201b7c:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  8004201b81:	48 01 45 e8          	add    %rax,-0x18(%rbp)
  8004201b85:	eb 43                	jmp    8004201bca <str_to_int+0x117>
    else if('A' <= s[i] && s[i]<= 'F')
  8004201b87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201b8b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004201b8f:	48 01 d0             	add    %rdx,%rax
  8004201b92:	0f b6 00             	movzbl (%rax),%eax
  8004201b95:	3c 40                	cmp    $0x40,%al
  8004201b97:	7e 31                	jle    8004201bca <str_to_int+0x117>
  8004201b99:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201b9d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004201ba1:	48 01 d0             	add    %rdx,%rax
  8004201ba4:	0f b6 00             	movzbl (%rax),%eax
  8004201ba7:	3c 46                	cmp    $0x46,%al
  8004201ba9:	7f 1f                	jg     8004201bca <str_to_int+0x117>
      res = res + ((int)(s[i]-'a') + 10) * offset;
  8004201bab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201baf:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004201bb3:	48 01 d0             	add    %rdx,%rax
  8004201bb6:	0f b6 00             	movzbl (%rax),%eax
  8004201bb9:	0f be c0             	movsbl %al,%eax
  8004201bbc:	83 e8 57             	sub    $0x57,%eax
  8004201bbf:	48 98                	cltq   
  8004201bc1:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  8004201bc6:	48 01 45 e8          	add    %rax,-0x18(%rbp)
      
    offset *= 16;    
  8004201bca:	48 c1 65 f0 04       	shlq   $0x4,-0x10(%rbp)
    //cprintf("data %d %d\n", res, i);
    i--;
  8004201bcf:	48 83 6d f8 01       	subq   $0x1,-0x8(%rbp)

 while(s[i]!='\0')
    i++;
   i--;
  //cprintf("length %d\n", i);
  while(i >= 2)
  8004201bd4:	48 83 7d f8 01       	cmpq   $0x1,-0x8(%rbp)
  8004201bd9:	0f 87 1b ff ff ff    	ja     8004201afa <str_to_int+0x47>
    offset *= 16;    
    //cprintf("data %d %d\n", res, i);
    i--;
   }
 //
 return res;
  8004201bdf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004201be3:	c9                   	leaveq 
  8004201be4:	c3                   	retq   

0000008004201be5 <check_permission>:

void check_permission(uintptr_t perm)
{
  8004201be5:	55                   	push   %rbp
  8004201be6:	48 89 e5             	mov    %rsp,%rbp
  8004201be9:	48 83 ec 10          	sub    $0x10,%rsp
  8004201bed:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if(perm & PTE_P)
  8004201bf1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201bf5:	83 e0 01             	and    $0x1,%eax
  8004201bf8:	48 85 c0             	test   %rax,%rax
  8004201bfb:	74 1b                	je     8004201c18 <check_permission+0x33>
   cprintf(" PTE_P");
  8004201bfd:	48 bf 0a 76 21 04 80 	movabs $0x800421760a,%rdi
  8004201c04:	00 00 00 
  8004201c07:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c0c:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201c13:	00 00 00 
  8004201c16:	ff d2                	callq  *%rdx

  if(perm & PTE_W)
  8004201c18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c1c:	83 e0 02             	and    $0x2,%eax
  8004201c1f:	48 85 c0             	test   %rax,%rax
  8004201c22:	74 1b                	je     8004201c3f <check_permission+0x5a>
   cprintf(" PTE_W");
  8004201c24:	48 bf 11 76 21 04 80 	movabs $0x8004217611,%rdi
  8004201c2b:	00 00 00 
  8004201c2e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c33:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201c3a:	00 00 00 
  8004201c3d:	ff d2                	callq  *%rdx

  if(perm & PTE_U)
  8004201c3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c43:	83 e0 04             	and    $0x4,%eax
  8004201c46:	48 85 c0             	test   %rax,%rax
  8004201c49:	74 1b                	je     8004201c66 <check_permission+0x81>
   cprintf(" PTE_U");
  8004201c4b:	48 bf 18 76 21 04 80 	movabs $0x8004217618,%rdi
  8004201c52:	00 00 00 
  8004201c55:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c5a:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201c61:	00 00 00 
  8004201c64:	ff d2                	callq  *%rdx
  
  if(perm & PTE_PWT)
  8004201c66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c6a:	83 e0 08             	and    $0x8,%eax
  8004201c6d:	48 85 c0             	test   %rax,%rax
  8004201c70:	74 1b                	je     8004201c8d <check_permission+0xa8>
   cprintf(" PTE_PWT");
  8004201c72:	48 bf 1f 76 21 04 80 	movabs $0x800421761f,%rdi
  8004201c79:	00 00 00 
  8004201c7c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c81:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201c88:	00 00 00 
  8004201c8b:	ff d2                	callq  *%rdx

 if(perm & PTE_PCD)
  8004201c8d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c91:	83 e0 10             	and    $0x10,%eax
  8004201c94:	48 85 c0             	test   %rax,%rax
  8004201c97:	74 1b                	je     8004201cb4 <check_permission+0xcf>
   cprintf(" PTE_PCD");
  8004201c99:	48 bf 28 76 21 04 80 	movabs $0x8004217628,%rdi
  8004201ca0:	00 00 00 
  8004201ca3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201ca8:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201caf:	00 00 00 
  8004201cb2:	ff d2                	callq  *%rdx

 if(perm & PTE_A)
  8004201cb4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201cb8:	83 e0 20             	and    $0x20,%eax
  8004201cbb:	48 85 c0             	test   %rax,%rax
  8004201cbe:	74 1b                	je     8004201cdb <check_permission+0xf6>
   cprintf(" PTE_A");
  8004201cc0:	48 bf 31 76 21 04 80 	movabs $0x8004217631,%rdi
  8004201cc7:	00 00 00 
  8004201cca:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201ccf:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201cd6:	00 00 00 
  8004201cd9:	ff d2                	callq  *%rdx

if(perm & PTE_D)
  8004201cdb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201cdf:	83 e0 40             	and    $0x40,%eax
  8004201ce2:	48 85 c0             	test   %rax,%rax
  8004201ce5:	74 1b                	je     8004201d02 <check_permission+0x11d>
   cprintf(" PTE_D");
  8004201ce7:	48 bf 38 76 21 04 80 	movabs $0x8004217638,%rdi
  8004201cee:	00 00 00 
  8004201cf1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201cf6:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201cfd:	00 00 00 
  8004201d00:	ff d2                	callq  *%rdx

if(perm & PTE_PS)
  8004201d02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201d06:	25 80 00 00 00       	and    $0x80,%eax
  8004201d0b:	48 85 c0             	test   %rax,%rax
  8004201d0e:	74 1b                	je     8004201d2b <check_permission+0x146>
   cprintf(" PTE_PS");
  8004201d10:	48 bf 3f 76 21 04 80 	movabs $0x800421763f,%rdi
  8004201d17:	00 00 00 
  8004201d1a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201d1f:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201d26:	00 00 00 
  8004201d29:	ff d2                	callq  *%rdx

if(perm & PTE_MBZ)
  8004201d2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201d2f:	25 80 01 00 00       	and    $0x180,%eax
  8004201d34:	48 85 c0             	test   %rax,%rax
  8004201d37:	74 1b                	je     8004201d54 <check_permission+0x16f>
   cprintf(" PTE_PBZ");
  8004201d39:	48 bf 47 76 21 04 80 	movabs $0x8004217647,%rdi
  8004201d40:	00 00 00 
  8004201d43:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201d48:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201d4f:	00 00 00 
  8004201d52:	ff d2                	callq  *%rdx

 cprintf("\n");
  8004201d54:	48 bf 87 75 21 04 80 	movabs $0x8004217587,%rdi
  8004201d5b:	00 00 00 
  8004201d5e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201d63:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201d6a:	00 00 00 
  8004201d6d:	ff d2                	callq  *%rdx

}
  8004201d6f:	c9                   	leaveq 
  8004201d70:	c3                   	retq   

0000008004201d71 <showmapping>:



int
showmapping(int argc, char **argv, struct Trapframe *tf)
{
  8004201d71:	55                   	push   %rbp
  8004201d72:	48 89 e5             	mov    %rsp,%rbp
  8004201d75:	48 83 ec 50          	sub    $0x50,%rsp
  8004201d79:	89 7d cc             	mov    %edi,-0x34(%rbp)
  8004201d7c:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004201d80:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
   if(argc < 3)
  8004201d84:	83 7d cc 02          	cmpl   $0x2,-0x34(%rbp)
  8004201d88:	7f 25                	jg     8004201daf <showmapping+0x3e>
   {
    cprintf("\ngive the start and end range\n");
  8004201d8a:	48 bf 50 76 21 04 80 	movabs $0x8004217650,%rdi
  8004201d91:	00 00 00 
  8004201d94:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201d99:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201da0:	00 00 00 
  8004201da3:	ff d2                	callq  *%rdx
    return 0;
  8004201da5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201daa:	e9 33 01 00 00       	jmpq   8004201ee2 <showmapping+0x171>
   }
   uintptr_t i, perm=0;
  8004201daf:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004201db6:	00 
 
   uintptr_t start = str_to_int(argv[1]);
  8004201db7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201dbb:	48 83 c0 08          	add    $0x8,%rax
  8004201dbf:	48 8b 00             	mov    (%rax),%rax
  8004201dc2:	48 89 c7             	mov    %rax,%rdi
  8004201dc5:	48 b8 b3 1a 20 04 80 	movabs $0x8004201ab3,%rax
  8004201dcc:	00 00 00 
  8004201dcf:	ff d0                	callq  *%rax
  8004201dd1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
   uintptr_t end = str_to_int(argv[2]);
  8004201dd5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201dd9:	48 83 c0 10          	add    $0x10,%rax
  8004201ddd:	48 8b 00             	mov    (%rax),%rax
  8004201de0:	48 89 c7             	mov    %rax,%rdi
  8004201de3:	48 b8 b3 1a 20 04 80 	movabs $0x8004201ab3,%rax
  8004201dea:	00 00 00 
  8004201ded:	ff d0                	callq  *%rax
  8004201def:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
   
   cprintf("\n virtual address        |   physical address   |  permissions \n");
  8004201df3:	48 bf 70 76 21 04 80 	movabs $0x8004217670,%rdi
  8004201dfa:	00 00 00 
  8004201dfd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201e02:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201e09:	00 00 00 
  8004201e0c:	ff d2                	callq  *%rdx
   for(i = start; i < end; i = i + PGSIZE)
  8004201e0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201e12:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004201e16:	e9 b4 00 00 00       	jmpq   8004201ecf <showmapping+0x15e>
   {
     pte_t *pte = pml4e_walk(boot_pml4e, (void *) i, 0); 
  8004201e1b:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004201e1f:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004201e26:	00 00 00 
  8004201e29:	48 8b 00             	mov    (%rax),%rax
  8004201e2c:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201e31:	48 89 ce             	mov    %rcx,%rsi
  8004201e34:	48 89 c7             	mov    %rax,%rdi
  8004201e37:	48 b8 cc 36 20 04 80 	movabs $0x80042036cc,%rax
  8004201e3e:	00 00 00 
  8004201e41:	ff d0                	callq  *%rax
  8004201e43:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
     perm = *pte & 0xfff;
  8004201e47:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201e4b:	48 8b 00             	mov    (%rax),%rax
  8004201e4e:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004201e53:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
     if(pte!=NULL)
  8004201e57:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004201e5c:	74 47                	je     8004201ea5 <showmapping+0x134>
      {
       cprintf("\n %16.0x           %16.0x          ", i, *pte & ~0xfff);
  8004201e5e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201e62:	48 8b 00             	mov    (%rax),%rax
  8004201e65:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004201e6b:	48 89 c2             	mov    %rax,%rdx
  8004201e6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201e72:	48 89 c6             	mov    %rax,%rsi
  8004201e75:	48 bf b8 76 21 04 80 	movabs $0x80042176b8,%rdi
  8004201e7c:	00 00 00 
  8004201e7f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201e84:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  8004201e8b:	00 00 00 
  8004201e8e:	ff d1                	callq  *%rcx
       check_permission(perm);
  8004201e90:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201e94:	48 89 c7             	mov    %rax,%rdi
  8004201e97:	48 b8 e5 1b 20 04 80 	movabs $0x8004201be5,%rax
  8004201e9e:	00 00 00 
  8004201ea1:	ff d0                	callq  *%rax
  8004201ea3:	eb 22                	jmp    8004201ec7 <showmapping+0x156>
  
      }
     else
       cprintf("\n %16.0x           Invalid          ", i);
  8004201ea5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201ea9:	48 89 c6             	mov    %rax,%rsi
  8004201eac:	48 bf e0 76 21 04 80 	movabs $0x80042176e0,%rdi
  8004201eb3:	00 00 00 
  8004201eb6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201ebb:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201ec2:	00 00 00 
  8004201ec5:	ff d2                	callq  *%rdx
 
   uintptr_t start = str_to_int(argv[1]);
   uintptr_t end = str_to_int(argv[2]);
   
   cprintf("\n virtual address        |   physical address   |  permissions \n");
   for(i = start; i < end; i = i + PGSIZE)
  8004201ec7:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004201ece:	00 
  8004201ecf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201ed3:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004201ed7:	0f 82 3e ff ff ff    	jb     8004201e1b <showmapping+0xaa>
     else
       cprintf("\n %16.0x           Invalid          ", i);
     
    }
    
  return 0;
  8004201edd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201ee2:	c9                   	leaveq 
  8004201ee3:	c3                   	retq   

0000008004201ee4 <change_permission>:

int
change_permission(int argc, char **argv, struct Trapframe *tf)
{
  8004201ee4:	55                   	push   %rbp
  8004201ee5:	48 89 e5             	mov    %rsp,%rbp
  8004201ee8:	48 83 ec 40          	sub    $0x40,%rsp
  8004201eec:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8004201eef:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004201ef3:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
 
  if(argc < 3)
  8004201ef7:	83 7d dc 02          	cmpl   $0x2,-0x24(%rbp)
  8004201efb:	7f 25                	jg     8004201f22 <change_permission+0x3e>
   {
    cprintf("\ngive the address and permission\n");
  8004201efd:	48 bf 08 77 21 04 80 	movabs $0x8004217708,%rdi
  8004201f04:	00 00 00 
  8004201f07:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201f0c:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201f13:	00 00 00 
  8004201f16:	ff d2                	callq  *%rdx
    return 0;
  8004201f18:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201f1d:	e9 07 01 00 00       	jmpq   8004202029 <change_permission+0x145>
   }
   uintptr_t i;
 
   uintptr_t start = str_to_int(argv[1]);
  8004201f22:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201f26:	48 83 c0 08          	add    $0x8,%rax
  8004201f2a:	48 8b 00             	mov    (%rax),%rax
  8004201f2d:	48 89 c7             	mov    %rax,%rdi
  8004201f30:	48 b8 b3 1a 20 04 80 	movabs $0x8004201ab3,%rax
  8004201f37:	00 00 00 
  8004201f3a:	ff d0                	callq  *%rax
  8004201f3c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
   uintptr_t perm = str_to_int(argv[2]);
  8004201f40:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201f44:	48 83 c0 10          	add    $0x10,%rax
  8004201f48:	48 8b 00             	mov    (%rax),%rax
  8004201f4b:	48 89 c7             	mov    %rax,%rdi
  8004201f4e:	48 b8 b3 1a 20 04 80 	movabs $0x8004201ab3,%rax
  8004201f55:	00 00 00 
  8004201f58:	ff d0                	callq  *%rax
  8004201f5a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  
     pte_t *pte = pml4e_walk(boot_pml4e, (void *) start, 0); 
  8004201f5e:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004201f62:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004201f69:	00 00 00 
  8004201f6c:	48 8b 00             	mov    (%rax),%rax
  8004201f6f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201f74:	48 89 ce             	mov    %rcx,%rsi
  8004201f77:	48 89 c7             	mov    %rax,%rdi
  8004201f7a:	48 b8 cc 36 20 04 80 	movabs $0x80042036cc,%rax
  8004201f81:	00 00 00 
  8004201f84:	ff d0                	callq  *%rax
  8004201f86:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
     if(pte!=NULL)
  8004201f8a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201f8f:	74 78                	je     8004202009 <change_permission+0x125>
     {
     cprintf("\n Before Permission %16.0x", *pte);
  8004201f91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201f95:	48 8b 00             	mov    (%rax),%rax
  8004201f98:	48 89 c6             	mov    %rax,%rsi
  8004201f9b:	48 bf 2a 77 21 04 80 	movabs $0x800421772a,%rdi
  8004201fa2:	00 00 00 
  8004201fa5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201faa:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004201fb1:	00 00 00 
  8004201fb4:	ff d2                	callq  *%rdx
     *pte = *pte & ~0xfff;
  8004201fb6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201fba:	48 8b 00             	mov    (%rax),%rax
  8004201fbd:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004201fc3:	48 89 c2             	mov    %rax,%rdx
  8004201fc6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201fca:	48 89 10             	mov    %rdx,(%rax)
     *pte = *pte | perm;
  8004201fcd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201fd1:	48 8b 00             	mov    (%rax),%rax
  8004201fd4:	48 0b 45 f0          	or     -0x10(%rbp),%rax
  8004201fd8:	48 89 c2             	mov    %rax,%rdx
  8004201fdb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201fdf:	48 89 10             	mov    %rdx,(%rax)
     cprintf("\n After Permission %16.0x\n", *pte);
  8004201fe2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201fe6:	48 8b 00             	mov    (%rax),%rax
  8004201fe9:	48 89 c6             	mov    %rax,%rsi
  8004201fec:	48 bf 45 77 21 04 80 	movabs $0x8004217745,%rdi
  8004201ff3:	00 00 00 
  8004201ff6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201ffb:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004202002:	00 00 00 
  8004202005:	ff d2                	callq  *%rdx
  8004202007:	eb 1b                	jmp    8004202024 <change_permission+0x140>
     }
     else
      cprintf("\npage not exist\n");   
  8004202009:	48 bf 60 77 21 04 80 	movabs $0x8004217760,%rdi
  8004202010:	00 00 00 
  8004202013:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202018:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420201f:	00 00 00 
  8004202022:	ff d2                	callq  *%rdx
  return 0;
  8004202024:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004202029:	c9                   	leaveq 
  800420202a:	c3                   	retq   

000000800420202b <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  800420202b:	55                   	push   %rbp
  800420202c:	48 89 e5             	mov    %rsp,%rbp
  800420202f:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004202036:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  800420203d:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  8004202044:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  800420204b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420204e:	48 98                	cltq   
  8004202050:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004202057:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  800420205c:	eb 15                	jmp    8004202073 <runcmd+0x48>
			*buf++ = 0;
  800420205e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004202065:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004202069:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
  8004202070:	c6 00 00             	movb   $0x0,(%rax)
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004202073:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420207a:	0f b6 00             	movzbl (%rax),%eax
  800420207d:	84 c0                	test   %al,%al
  800420207f:	74 2a                	je     80042020ab <runcmd+0x80>
  8004202081:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004202088:	0f b6 00             	movzbl (%rax),%eax
  800420208b:	0f be c0             	movsbl %al,%eax
  800420208e:	89 c6                	mov    %eax,%esi
  8004202090:	48 bf 71 77 21 04 80 	movabs $0x8004217771,%rdi
  8004202097:	00 00 00 
  800420209a:	48 b8 40 fb 20 04 80 	movabs $0x800420fb40,%rax
  80042020a1:	00 00 00 
  80042020a4:	ff d0                	callq  *%rax
  80042020a6:	48 85 c0             	test   %rax,%rax
  80042020a9:	75 b3                	jne    800420205e <runcmd+0x33>
			*buf++ = 0;
		if (*buf == 0)
  80042020ab:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042020b2:	0f b6 00             	movzbl (%rax),%eax
  80042020b5:	84 c0                	test   %al,%al
  80042020b7:	75 21                	jne    80042020da <runcmd+0xaf>
			break;
  80042020b9:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  80042020ba:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042020bd:	48 98                	cltq   
  80042020bf:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  80042020c6:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  80042020cb:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042020cf:	0f 85 a1 00 00 00    	jne    8004202176 <runcmd+0x14b>
  80042020d5:	e9 92 00 00 00       	jmpq   800420216c <runcmd+0x141>
			*buf++ = 0;
		if (*buf == 0)
			break;

		// save and scan past next arg
		if (argc == MAXARGS-1) {
  80042020da:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  80042020de:	75 2a                	jne    800420210a <runcmd+0xdf>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  80042020e0:	be 10 00 00 00       	mov    $0x10,%esi
  80042020e5:	48 bf 76 77 21 04 80 	movabs $0x8004217776,%rdi
  80042020ec:	00 00 00 
  80042020ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80042020f4:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  80042020fb:	00 00 00 
  80042020fe:	ff d2                	callq  *%rdx
			return 0;
  8004202100:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202105:	e9 30 01 00 00       	jmpq   800420223a <runcmd+0x20f>
		}
		argv[argc++] = buf;
  800420210a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420210d:	8d 50 01             	lea    0x1(%rax),%edx
  8004202110:	89 55 fc             	mov    %edx,-0x4(%rbp)
  8004202113:	48 98                	cltq   
  8004202115:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  800420211c:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  8004202123:	ff 
		while (*buf && !strchr(WHITESPACE, *buf))
  8004202124:	eb 08                	jmp    800420212e <runcmd+0x103>
			buf++;
  8004202126:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  800420212d:	01 
		if (argc == MAXARGS-1) {
			cprintf("Too many arguments (max %d)\n", MAXARGS);
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
  800420212e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004202135:	0f b6 00             	movzbl (%rax),%eax
  8004202138:	84 c0                	test   %al,%al
  800420213a:	74 2a                	je     8004202166 <runcmd+0x13b>
  800420213c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004202143:	0f b6 00             	movzbl (%rax),%eax
  8004202146:	0f be c0             	movsbl %al,%eax
  8004202149:	89 c6                	mov    %eax,%esi
  800420214b:	48 bf 71 77 21 04 80 	movabs $0x8004217771,%rdi
  8004202152:	00 00 00 
  8004202155:	48 b8 40 fb 20 04 80 	movabs $0x800420fb40,%rax
  800420215c:	00 00 00 
  800420215f:	ff d0                	callq  *%rax
  8004202161:	48 85 c0             	test   %rax,%rax
  8004202164:	74 c0                	je     8004202126 <runcmd+0xfb>
			buf++;
	}
  8004202166:	90                   	nop
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004202167:	e9 07 ff ff ff       	jmpq   8004202073 <runcmd+0x48>
	}
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
  800420216c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202171:	e9 c4 00 00 00       	jmpq   800420223a <runcmd+0x20f>
	for (i = 0; i < NCOMMANDS; i++) {
  8004202176:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  800420217d:	e9 82 00 00 00       	jmpq   8004202204 <runcmd+0x1d9>
		if (strcmp(argv[0], commands[i].name) == 0)
  8004202182:	48 b9 80 a5 22 04 80 	movabs $0x800422a580,%rcx
  8004202189:	00 00 00 
  800420218c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420218f:	48 63 d0             	movslq %eax,%rdx
  8004202192:	48 89 d0             	mov    %rdx,%rax
  8004202195:	48 01 c0             	add    %rax,%rax
  8004202198:	48 01 d0             	add    %rdx,%rax
  800420219b:	48 c1 e0 03          	shl    $0x3,%rax
  800420219f:	48 01 c8             	add    %rcx,%rax
  80042021a2:	48 8b 10             	mov    (%rax),%rdx
  80042021a5:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042021ac:	48 89 d6             	mov    %rdx,%rsi
  80042021af:	48 89 c7             	mov    %rax,%rdi
  80042021b2:	48 b8 7c fa 20 04 80 	movabs $0x800420fa7c,%rax
  80042021b9:	00 00 00 
  80042021bc:	ff d0                	callq  *%rax
  80042021be:	85 c0                	test   %eax,%eax
  80042021c0:	75 3e                	jne    8004202200 <runcmd+0x1d5>
			return commands[i].func(argc, argv, tf);
  80042021c2:	48 b9 80 a5 22 04 80 	movabs $0x800422a580,%rcx
  80042021c9:	00 00 00 
  80042021cc:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042021cf:	48 63 d0             	movslq %eax,%rdx
  80042021d2:	48 89 d0             	mov    %rdx,%rax
  80042021d5:	48 01 c0             	add    %rax,%rax
  80042021d8:	48 01 d0             	add    %rdx,%rax
  80042021db:	48 c1 e0 03          	shl    $0x3,%rax
  80042021df:	48 01 c8             	add    %rcx,%rax
  80042021e2:	48 83 c0 10          	add    $0x10,%rax
  80042021e6:	48 8b 00             	mov    (%rax),%rax
  80042021e9:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042021f0:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
  80042021f7:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042021fa:	89 cf                	mov    %ecx,%edi
  80042021fc:	ff d0                	callq  *%rax
  80042021fe:	eb 3a                	jmp    800420223a <runcmd+0x20f>
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
	for (i = 0; i < NCOMMANDS; i++) {
  8004202200:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004202204:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004202207:	83 f8 05             	cmp    $0x5,%eax
  800420220a:	0f 86 72 ff ff ff    	jbe    8004202182 <runcmd+0x157>
		if (strcmp(argv[0], commands[i].name) == 0)
			return commands[i].func(argc, argv, tf);
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  8004202210:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202217:	48 89 c6             	mov    %rax,%rsi
  800420221a:	48 bf 93 77 21 04 80 	movabs $0x8004217793,%rdi
  8004202221:	00 00 00 
  8004202224:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202229:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004202230:	00 00 00 
  8004202233:	ff d2                	callq  *%rdx
	return 0;
  8004202235:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420223a:	c9                   	leaveq 
  800420223b:	c3                   	retq   

000000800420223c <monitor>:

void
monitor(struct Trapframe *tf)
{
  800420223c:	55                   	push   %rbp
  800420223d:	48 89 e5             	mov    %rsp,%rbp
  8004202240:	48 83 ec 20          	sub    $0x20,%rsp
  8004202244:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  8004202248:	48 bf b0 77 21 04 80 	movabs $0x80042177b0,%rdi
  800420224f:	00 00 00 
  8004202252:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202257:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420225e:	00 00 00 
  8004202261:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  8004202263:	48 bf d8 77 21 04 80 	movabs $0x80042177d8,%rdi
  800420226a:	00 00 00 
  800420226d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202272:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004202279:	00 00 00 
  800420227c:	ff d2                	callq  *%rdx

	if (tf != NULL)
  800420227e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202283:	74 13                	je     8004202298 <monitor+0x5c>
	    print_trapframe(tf);
  8004202285:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202289:	48 89 c7             	mov    %rax,%rdi
  800420228c:	48 b8 ef c1 20 04 80 	movabs $0x800420c1ef,%rax
  8004202293:	00 00 00 
  8004202296:	ff d0                	callq  *%rax

	while (1) {
		buf = readline("K> ");
  8004202298:	48 bf fd 77 21 04 80 	movabs $0x80042177fd,%rdi
  800420229f:	00 00 00 
  80042022a2:	48 b8 5f f7 20 04 80 	movabs $0x800420f75f,%rax
  80042022a9:	00 00 00 
  80042022ac:	ff d0                	callq  *%rax
  80042022ae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  80042022b2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042022b7:	74 20                	je     80042022d9 <monitor+0x9d>
			if (runcmd(buf, tf) < 0)
  80042022b9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042022bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042022c1:	48 89 d6             	mov    %rdx,%rsi
  80042022c4:	48 89 c7             	mov    %rax,%rdi
  80042022c7:	48 b8 2b 20 20 04 80 	movabs $0x800420202b,%rax
  80042022ce:	00 00 00 
  80042022d1:	ff d0                	callq  *%rax
  80042022d3:	85 c0                	test   %eax,%eax
  80042022d5:	79 02                	jns    80042022d9 <monitor+0x9d>
				break;
  80042022d7:	eb 02                	jmp    80042022db <monitor+0x9f>
	}
  80042022d9:	eb bd                	jmp    8004202298 <monitor+0x5c>
}
  80042022db:	c9                   	leaveq 
  80042022dc:	c3                   	retq   

00000080042022dd <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  80042022dd:	55                   	push   %rbp
  80042022de:	48 89 e5             	mov    %rsp,%rbp
  80042022e1:	48 83 ec 08          	sub    $0x8,%rsp
  80042022e5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  80042022e9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042022ed:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  80042022f4:	00 00 00 
  80042022f7:	48 8b 00             	mov    (%rax),%rax
  80042022fa:	48 29 c2             	sub    %rax,%rdx
  80042022fd:	48 89 d0             	mov    %rdx,%rax
  8004202300:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004202304:	c9                   	leaveq 
  8004202305:	c3                   	retq   

0000008004202306 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004202306:	55                   	push   %rbp
  8004202307:	48 89 e5             	mov    %rsp,%rbp
  800420230a:	48 83 ec 08          	sub    $0x8,%rsp
  800420230e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004202312:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202316:	48 89 c7             	mov    %rax,%rdi
  8004202319:	48 b8 dd 22 20 04 80 	movabs $0x80042022dd,%rax
  8004202320:	00 00 00 
  8004202323:	ff d0                	callq  *%rax
  8004202325:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004202329:	c9                   	leaveq 
  800420232a:	c3                   	retq   

000000800420232b <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  800420232b:	55                   	push   %rbp
  800420232c:	48 89 e5             	mov    %rsp,%rbp
  800420232f:	48 83 ec 10          	sub    $0x10,%rsp
  8004202333:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004202337:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420233b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420233f:	48 89 c2             	mov    %rax,%rdx
  8004202342:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004202349:	00 00 00 
  800420234c:	48 8b 00             	mov    (%rax),%rax
  800420234f:	48 39 c2             	cmp    %rax,%rdx
  8004202352:	72 2a                	jb     800420237e <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004202354:	48 ba 08 78 21 04 80 	movabs $0x8004217808,%rdx
  800420235b:	00 00 00 
  800420235e:	be 54 00 00 00       	mov    $0x54,%esi
  8004202363:	48 bf 27 78 21 04 80 	movabs $0x8004217827,%rdi
  800420236a:	00 00 00 
  800420236d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202372:	48 b9 0b 05 20 04 80 	movabs $0x800420050b,%rcx
  8004202379:	00 00 00 
  800420237c:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  800420237e:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  8004202385:	00 00 00 
  8004202388:	48 8b 00             	mov    (%rax),%rax
  800420238b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420238f:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004202393:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202397:	48 01 d0             	add    %rdx,%rax
}
  800420239a:	c9                   	leaveq 
  800420239b:	c3                   	retq   

000000800420239c <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  800420239c:	55                   	push   %rbp
  800420239d:	48 89 e5             	mov    %rsp,%rbp
  80042023a0:	48 83 ec 20          	sub    $0x20,%rsp
  80042023a4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  80042023a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042023ac:	48 89 c7             	mov    %rax,%rdi
  80042023af:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  80042023b6:	00 00 00 
  80042023b9:	ff d0                	callq  *%rax
  80042023bb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042023bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042023c3:	48 c1 e8 0c          	shr    $0xc,%rax
  80042023c7:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042023ca:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042023cd:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  80042023d4:	00 00 00 
  80042023d7:	48 8b 00             	mov    (%rax),%rax
  80042023da:	48 39 c2             	cmp    %rax,%rdx
  80042023dd:	72 32                	jb     8004202411 <page2kva+0x75>
  80042023df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042023e3:	48 89 c1             	mov    %rax,%rcx
  80042023e6:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  80042023ed:	00 00 00 
  80042023f0:	be 5b 00 00 00       	mov    $0x5b,%esi
  80042023f5:	48 bf 27 78 21 04 80 	movabs $0x8004217827,%rdi
  80042023fc:	00 00 00 
  80042023ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202404:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420240b:	00 00 00 
  800420240e:	41 ff d0             	callq  *%r8
  8004202411:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202418:	00 00 00 
  800420241b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420241f:	48 01 d0             	add    %rdx,%rax
}
  8004202422:	c9                   	leaveq 
  8004202423:	c3                   	retq   

0000008004202424 <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  8004202424:	55                   	push   %rbp
  8004202425:	48 89 e5             	mov    %rsp,%rbp
  8004202428:	48 83 ec 08          	sub    $0x8,%rsp
  800420242c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420242f:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  8004202432:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  8004202436:	74 06                	je     800420243e <restrictive_type+0x1a>
  8004202438:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  800420243c:	75 07                	jne    8004202445 <restrictive_type+0x21>
    return MB_TYPE_BAD;
  800420243e:	b8 05 00 00 00       	mov    $0x5,%eax
  8004202443:	eb 3e                	jmp    8004202483 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  8004202445:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004202449:	74 06                	je     8004202451 <restrictive_type+0x2d>
  800420244b:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  800420244f:	75 07                	jne    8004202458 <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  8004202451:	b8 04 00 00 00       	mov    $0x4,%eax
  8004202456:	eb 2b                	jmp    8004202483 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  8004202458:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  800420245c:	74 06                	je     8004202464 <restrictive_type+0x40>
  800420245e:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  8004202462:	75 07                	jne    800420246b <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  8004202464:	b8 02 00 00 00       	mov    $0x2,%eax
  8004202469:	eb 18                	jmp    8004202483 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  800420246b:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  800420246f:	74 06                	je     8004202477 <restrictive_type+0x53>
  8004202471:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  8004202475:	75 07                	jne    800420247e <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  8004202477:	b8 03 00 00 00       	mov    $0x3,%eax
  800420247c:	eb 05                	jmp    8004202483 <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  800420247e:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004202483:	c9                   	leaveq 
  8004202484:	c3                   	retq   

0000008004202485 <nvram_read>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
  8004202485:	55                   	push   %rbp
  8004202486:	48 89 e5             	mov    %rsp,%rbp
  8004202489:	53                   	push   %rbx
  800420248a:	48 83 ec 18          	sub    $0x18,%rsp
  800420248e:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  8004202491:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202494:	89 c7                	mov    %eax,%edi
  8004202496:	48 b8 c5 92 20 04 80 	movabs $0x80042092c5,%rax
  800420249d:	00 00 00 
  80042024a0:	ff d0                	callq  *%rax
  80042024a2:	89 c3                	mov    %eax,%ebx
  80042024a4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042024a7:	83 c0 01             	add    $0x1,%eax
  80042024aa:	89 c7                	mov    %eax,%edi
  80042024ac:	48 b8 c5 92 20 04 80 	movabs $0x80042092c5,%rax
  80042024b3:	00 00 00 
  80042024b6:	ff d0                	callq  *%rax
  80042024b8:	c1 e0 08             	shl    $0x8,%eax
  80042024bb:	09 d8                	or     %ebx,%eax
}
  80042024bd:	48 83 c4 18          	add    $0x18,%rsp
  80042024c1:	5b                   	pop    %rbx
  80042024c2:	5d                   	pop    %rbp
  80042024c3:	c3                   	retq   

00000080042024c4 <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  80042024c4:	55                   	push   %rbp
  80042024c5:	48 89 e5             	mov    %rsp,%rbp
  80042024c8:	41 54                	push   %r12
  80042024ca:	53                   	push   %rbx
  80042024cb:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  80042024d2:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  80042024d9:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  80042024e0:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  80042024e7:	48 89 e0             	mov    %rsp,%rax
  80042024ea:	49 89 c4             	mov    %rax,%r12
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  80042024ed:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042024f4:	8b 40 30             	mov    0x30(%rax),%eax
  80042024f7:	89 c0                	mov    %eax,%eax
  80042024f9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  80042024fd:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004202504:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202507:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  800420250c:	f7 e2                	mul    %edx
  800420250e:	89 d0                	mov    %edx,%eax
  8004202510:	c1 e8 04             	shr    $0x4,%eax
  8004202513:	89 c0                	mov    %eax,%eax
  8004202515:	48 89 c2             	mov    %rax,%rdx
  8004202518:	48 83 ea 01          	sub    $0x1,%rdx
  800420251c:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004202520:	49 89 c0             	mov    %rax,%r8
  8004202523:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004202529:	48 89 c1             	mov    %rax,%rcx
  800420252c:	bb 00 00 00 00       	mov    $0x0,%ebx
  8004202531:	48 c1 e0 03          	shl    $0x3,%rax
  8004202535:	48 8d 50 07          	lea    0x7(%rax),%rdx
  8004202539:	b8 10 00 00 00       	mov    $0x10,%eax
  800420253e:	48 83 e8 01          	sub    $0x1,%rax
  8004202542:	48 01 d0             	add    %rdx,%rax
  8004202545:	bb 10 00 00 00       	mov    $0x10,%ebx
  800420254a:	ba 00 00 00 00       	mov    $0x0,%edx
  800420254f:	48 f7 f3             	div    %rbx
  8004202552:	48 6b c0 10          	imul   $0x10,%rax,%rax
  8004202556:	48 29 c4             	sub    %rax,%rsp
  8004202559:	48 89 e0             	mov    %rsp,%rax
  800420255c:	48 83 c0 07          	add    $0x7,%rax
  8004202560:	48 c1 e8 03          	shr    $0x3,%rax
  8004202564:	48 c1 e0 03          	shl    $0x3,%rax
  8004202568:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

    cprintf("\ne820 MEMORY MAP\n");
  800420256c:	48 bf 5b 78 21 04 80 	movabs $0x800421785b,%rdi
  8004202573:	00 00 00 
  8004202576:	b8 00 00 00 00       	mov    $0x0,%eax
  800420257b:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004202582:	00 00 00 
  8004202585:	ff d2                	callq  *%rdx
    for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202587:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  800420258e:	e9 6c 01 00 00       	jmpq   80042026ff <multiboot_read+0x23b>
    	memory_map_t* mmap = &mmap_base[i];
  8004202593:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202596:	48 63 d0             	movslq %eax,%rdx
  8004202599:	48 89 d0             	mov    %rdx,%rax
  800420259c:	48 01 c0             	add    %rax,%rax
  800420259f:	48 01 d0             	add    %rdx,%rax
  80042025a2:	48 c1 e0 03          	shl    $0x3,%rax
  80042025a6:	48 89 c2             	mov    %rax,%rdx
  80042025a9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042025ad:	48 01 d0             	add    %rdx,%rax
  80042025b0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

    	uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  80042025b4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042025b8:	8b 40 08             	mov    0x8(%rax),%eax
  80042025bb:	89 c0                	mov    %eax,%eax
  80042025bd:	48 c1 e0 20          	shl    $0x20,%rax
  80042025c1:	48 89 c2             	mov    %rax,%rdx
  80042025c4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042025c8:	8b 40 04             	mov    0x4(%rax),%eax
  80042025cb:	89 c0                	mov    %eax,%eax
  80042025cd:	48 01 d0             	add    %rdx,%rax
  80042025d0:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    	uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  80042025d4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042025d8:	8b 40 10             	mov    0x10(%rax),%eax
  80042025db:	89 c0                	mov    %eax,%eax
  80042025dd:	48 c1 e0 20          	shl    $0x20,%rax
  80042025e1:	48 89 c2             	mov    %rax,%rdx
  80042025e4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042025e8:	8b 40 0c             	mov    0xc(%rax),%eax
  80042025eb:	89 c0                	mov    %eax,%eax
  80042025ed:	48 01 d0             	add    %rdx,%rax
  80042025f0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        
        cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size, 
  80042025f4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042025f8:	8b 70 14             	mov    0x14(%rax),%esi
  80042025fb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042025ff:	8b 00                	mov    (%rax),%eax
  8004202601:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004202605:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004202609:	41 89 f0             	mov    %esi,%r8d
  800420260c:	89 c6                	mov    %eax,%esi
  800420260e:	48 bf 70 78 21 04 80 	movabs $0x8004217870,%rdi
  8004202615:	00 00 00 
  8004202618:	b8 00 00 00 00       	mov    $0x0,%eax
  800420261d:	49 b9 11 96 20 04 80 	movabs $0x8004209611,%r9
  8004202624:	00 00 00 
  8004202627:	41 ff d1             	callq  *%r9
                addr, len, mmap->type);

        if(mmap->type > 5 || mmap->type < 1)
  800420262a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420262e:	8b 40 14             	mov    0x14(%rax),%eax
  8004202631:	83 f8 05             	cmp    $0x5,%eax
  8004202634:	77 0b                	ja     8004202641 <multiboot_read+0x17d>
  8004202636:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420263a:	8b 40 14             	mov    0x14(%rax),%eax
  800420263d:	85 c0                	test   %eax,%eax
  800420263f:	75 0b                	jne    800420264c <multiboot_read+0x188>
        	mmap->type = MB_TYPE_RESERVED;
  8004202641:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202645:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)
       
        //Insert into the sorted list
        int j = 0;
  800420264c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
        for(;j<i;j++) {
  8004202653:	e9 85 00 00 00       	jmpq   80042026dd <multiboot_read+0x219>
        	memory_map_t* this = mmap_list[j];
  8004202658:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420265c:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420265f:	48 63 d2             	movslq %edx,%rdx
  8004202662:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202666:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
        	uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  800420266a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420266e:	8b 40 08             	mov    0x8(%rax),%eax
  8004202671:	89 c0                	mov    %eax,%eax
  8004202673:	48 c1 e0 20          	shl    $0x20,%rax
  8004202677:	48 89 c2             	mov    %rax,%rdx
  800420267a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420267e:	8b 40 04             	mov    0x4(%rax),%eax
  8004202681:	89 c0                	mov    %eax,%eax
  8004202683:	48 01 d0             	add    %rdx,%rax
  8004202686:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        	if(this_addr > addr) {
  800420268a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420268e:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004202692:	76 45                	jbe    80042026d9 <multiboot_read+0x215>
        		int last = i+1;
  8004202694:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202697:	83 c0 01             	add    $0x1,%eax
  800420269a:	89 45 e4             	mov    %eax,-0x1c(%rbp)
        		while(last != j) {
  800420269d:	eb 30                	jmp    80042026cf <multiboot_read+0x20b>
        			*(mmap_list + last) = *(mmap_list + last - 1);
  800420269f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042026a3:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042026a6:	48 63 d2             	movslq %edx,%rdx
  80042026a9:	48 c1 e2 03          	shl    $0x3,%rdx
  80042026ad:	48 01 c2             	add    %rax,%rdx
  80042026b0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042026b4:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  80042026b7:	48 63 c9             	movslq %ecx,%rcx
  80042026ba:	48 c1 e1 03          	shl    $0x3,%rcx
  80042026be:	48 83 e9 08          	sub    $0x8,%rcx
  80042026c2:	48 01 c8             	add    %rcx,%rax
  80042026c5:	48 8b 00             	mov    (%rax),%rax
  80042026c8:	48 89 02             	mov    %rax,(%rdx)
        			last--;
  80042026cb:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
        for(;j<i;j++) {
        	memory_map_t* this = mmap_list[j];
        	uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
        	if(this_addr > addr) {
        		int last = i+1;
        		while(last != j) {
  80042026cf:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042026d2:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  80042026d5:	75 c8                	jne    800420269f <multiboot_read+0x1db>
        			*(mmap_list + last) = *(mmap_list + last - 1);
        			last--;
        		}
        		break; 
  80042026d7:	eb 10                	jmp    80042026e9 <multiboot_read+0x225>
        if(mmap->type > 5 || mmap->type < 1)
        	mmap->type = MB_TYPE_RESERVED;
       
        //Insert into the sorted list
        int j = 0;
        for(;j<i;j++) {
  80042026d9:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  80042026dd:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042026e0:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  80042026e3:	0f 8c 6f ff ff ff    	jl     8004202658 <multiboot_read+0x194>
        			last--;
        		}
        		break; 
        	}
        }
        mmap_list[j] = mmap;  
  80042026e9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042026ed:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042026f0:	48 63 d2             	movslq %edx,%rdx
  80042026f3:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80042026f7:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];

    cprintf("\ne820 MEMORY MAP\n");
    for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042026fb:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042026ff:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202702:	48 63 c8             	movslq %eax,%rcx
  8004202705:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420270c:	8b 40 2c             	mov    0x2c(%rax),%eax
  800420270f:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202714:	f7 e2                	mul    %edx
  8004202716:	89 d0                	mov    %edx,%eax
  8004202718:	c1 e8 04             	shr    $0x4,%eax
  800420271b:	89 c0                	mov    %eax,%eax
  800420271d:	48 39 c1             	cmp    %rax,%rcx
  8004202720:	0f 82 6d fe ff ff    	jb     8004202593 <multiboot_read+0xcf>
        		break; 
        	}
        }
        mmap_list[j] = mmap;  
    }
    cprintf("\n");
  8004202726:	48 bf a7 78 21 04 80 	movabs $0x80042178a7,%rdi
  800420272d:	00 00 00 
  8004202730:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202735:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420273c:	00 00 00 
  800420273f:	ff d2                	callq  *%rdx
    
    // Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202741:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  8004202748:	e9 93 01 00 00       	jmpq   80042028e0 <multiboot_read+0x41c>
		memory_map_t* prev = mmap_list[i-1];
  800420274d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202750:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202753:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202757:	48 63 d2             	movslq %edx,%rdx
  800420275a:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  800420275e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  8004202762:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202766:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004202769:	48 63 d2             	movslq %edx,%rdx
  800420276c:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202770:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004202774:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202778:	8b 40 08             	mov    0x8(%rax),%eax
  800420277b:	89 c0                	mov    %eax,%eax
  800420277d:	48 c1 e0 20          	shl    $0x20,%rax
  8004202781:	48 89 c2             	mov    %rax,%rdx
  8004202784:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202788:	8b 40 04             	mov    0x4(%rax),%eax
  800420278b:	89 c0                	mov    %eax,%eax
  800420278d:	48 01 d0             	add    %rdx,%rax
  8004202790:	48 89 45 88          	mov    %rax,-0x78(%rbp)
        uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  8004202794:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202798:	8b 40 08             	mov    0x8(%rax),%eax
  800420279b:	89 c0                	mov    %eax,%eax
  800420279d:	48 c1 e0 20          	shl    $0x20,%rax
  80042027a1:	48 89 c2             	mov    %rax,%rdx
  80042027a4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042027a8:	8b 40 04             	mov    0x4(%rax),%eax
  80042027ab:	89 c0                	mov    %eax,%eax
  80042027ad:	48 01 d0             	add    %rdx,%rax
  80042027b0:	48 89 45 80          	mov    %rax,-0x80(%rbp)
        uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  80042027b4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042027b8:	8b 40 10             	mov    0x10(%rax),%eax
  80042027bb:	89 c0                	mov    %eax,%eax
  80042027bd:	48 c1 e0 20          	shl    $0x20,%rax
  80042027c1:	48 89 c2             	mov    %rax,%rdx
  80042027c4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042027c8:	8b 40 0c             	mov    0xc(%rax),%eax
  80042027cb:	89 c0                	mov    %eax,%eax
  80042027cd:	48 01 d0             	add    %rdx,%rax
  80042027d0:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  80042027d7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042027db:	8b 40 10             	mov    0x10(%rax),%eax
  80042027de:	89 c0                	mov    %eax,%eax
  80042027e0:	48 c1 e0 20          	shl    $0x20,%rax
  80042027e4:	48 89 c2             	mov    %rax,%rdx
  80042027e7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042027eb:	8b 40 0c             	mov    0xc(%rax),%eax
  80042027ee:	89 c0                	mov    %eax,%eax
  80042027f0:	48 01 d0             	add    %rdx,%rax
  80042027f3:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if(prev_addr + prev_length == this_addr && prev->type == this->type) {
  80042027fa:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004202801:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004202805:	48 01 d0             	add    %rdx,%rax
  8004202808:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  800420280c:	75 7c                	jne    800420288a <multiboot_read+0x3c6>
  800420280e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202812:	8b 50 14             	mov    0x14(%rax),%edx
  8004202815:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202819:	8b 40 14             	mov    0x14(%rax),%eax
  800420281c:	39 c2                	cmp    %eax,%edx
  800420281e:	75 6a                	jne    800420288a <multiboot_read+0x3c6>
			this->length_low = (uint32_t)prev_length + this_length;
  8004202820:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004202827:	89 c2                	mov    %eax,%edx
  8004202829:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202830:	01 c2                	add    %eax,%edx
  8004202832:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202836:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  8004202839:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202840:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004202847:	48 01 d0             	add    %rdx,%rax
  800420284a:	48 c1 e8 20          	shr    $0x20,%rax
  800420284e:	89 c2                	mov    %eax,%edx
  8004202850:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202854:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  8004202857:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420285b:	8b 50 04             	mov    0x4(%rax),%edx
  800420285e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202862:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  8004202865:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202869:	8b 50 08             	mov    0x8(%rax),%edx
  800420286c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202870:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  8004202873:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202876:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202879:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420287d:	48 63 d2             	movslq %edx,%rdx
  8004202880:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  8004202887:	00 
  8004202888:	eb 52                	jmp    80042028dc <multiboot_read+0x418>
		} else if(prev_addr + prev_length > this_addr) {
  800420288a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004202891:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004202895:	48 01 d0             	add    %rdx,%rax
  8004202898:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  800420289c:	76 3e                	jbe    80042028dc <multiboot_read+0x418>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  800420289e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042028a2:	8b 50 14             	mov    0x14(%rax),%edx
  80042028a5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042028a9:	8b 40 14             	mov    0x14(%rax),%eax
  80042028ac:	89 d6                	mov    %edx,%esi
  80042028ae:	89 c7                	mov    %eax,%edi
  80042028b0:	48 b8 24 24 20 04 80 	movabs $0x8004202424,%rax
  80042028b7:	00 00 00 
  80042028ba:	ff d0                	callq  *%rax
  80042028bc:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  80042028c2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042028c6:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  80042028cc:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  80042028cf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042028d3:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  80042028d9:	89 50 14             	mov    %edx,0x14(%rax)
        mmap_list[j] = mmap;  
    }
    cprintf("\n");
    
    // Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042028dc:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042028e0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042028e3:	48 63 c8             	movslq %eax,%rcx
  80042028e6:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042028ed:	8b 40 2c             	mov    0x2c(%rax),%eax
  80042028f0:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  80042028f5:	f7 e2                	mul    %edx
  80042028f7:	89 d0                	mov    %edx,%eax
  80042028f9:	c1 e8 04             	shr    $0x4,%eax
  80042028fc:	89 c0                	mov    %eax,%eax
  80042028fe:	48 39 c1             	cmp    %rax,%rcx
  8004202901:	0f 82 46 fe ff ff    	jb     800420274d <multiboot_read+0x289>
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202907:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  800420290e:	e9 dc 00 00 00       	jmpq   80042029ef <multiboot_read+0x52b>
		memory_map_t* mmap = mmap_list[i];
  8004202913:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202917:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420291a:	48 63 d2             	movslq %edx,%rdx
  800420291d:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202921:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if(mmap) {
  8004202928:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  800420292f:	00 
  8004202930:	0f 84 b5 00 00 00    	je     80042029eb <multiboot_read+0x527>
			if(mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  8004202936:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420293d:	8b 40 14             	mov    0x14(%rax),%eax
  8004202940:	83 f8 01             	cmp    $0x1,%eax
  8004202943:	74 13                	je     8004202958 <multiboot_read+0x494>
  8004202945:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420294c:	8b 40 14             	mov    0x14(%rax),%eax
  800420294f:	83 f8 03             	cmp    $0x3,%eax
  8004202952:	0f 85 93 00 00 00    	jne    80042029eb <multiboot_read+0x527>
				if(mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  8004202958:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420295f:	8b 40 04             	mov    0x4(%rax),%eax
  8004202962:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  8004202967:	77 49                	ja     80042029b2 <multiboot_read+0x4ee>
  8004202969:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202970:	8b 40 08             	mov    0x8(%rax),%eax
  8004202973:	85 c0                	test   %eax,%eax
  8004202975:	75 3b                	jne    80042029b2 <multiboot_read+0x4ee>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004202977:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420297e:	48 8b 10             	mov    (%rax),%rdx
  8004202981:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202988:	8b 40 10             	mov    0x10(%rax),%eax
  800420298b:	89 c0                	mov    %eax,%eax
  800420298d:	48 c1 e0 20          	shl    $0x20,%rax
  8004202991:	48 89 c1             	mov    %rax,%rcx
  8004202994:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420299b:	8b 40 0c             	mov    0xc(%rax),%eax
  800420299e:	89 c0                	mov    %eax,%eax
  80042029a0:	48 01 c8             	add    %rcx,%rax
  80042029a3:	48 01 c2             	add    %rax,%rdx
  80042029a6:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042029ad:	48 89 10             	mov    %rdx,(%rax)
  80042029b0:	eb 39                	jmp    80042029eb <multiboot_read+0x527>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  80042029b2:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042029b9:	48 8b 10             	mov    (%rax),%rdx
  80042029bc:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042029c3:	8b 40 10             	mov    0x10(%rax),%eax
  80042029c6:	89 c0                	mov    %eax,%eax
  80042029c8:	48 c1 e0 20          	shl    $0x20,%rax
  80042029cc:	48 89 c1             	mov    %rax,%rcx
  80042029cf:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042029d6:	8b 40 0c             	mov    0xc(%rax),%eax
  80042029d9:	89 c0                	mov    %eax,%eax
  80042029db:	48 01 c8             	add    %rcx,%rax
  80042029de:	48 01 c2             	add    %rax,%rdx
  80042029e1:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042029e8:	48 89 10             	mov    %rdx,(%rax)
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042029eb:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042029ef:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042029f2:	48 63 c8             	movslq %eax,%rcx
  80042029f5:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042029fc:	8b 40 2c             	mov    0x2c(%rax),%eax
  80042029ff:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202a04:	f7 e2                	mul    %edx
  8004202a06:	89 d0                	mov    %edx,%eax
  8004202a08:	c1 e8 04             	shr    $0x4,%eax
  8004202a0b:	89 c0                	mov    %eax,%eax
  8004202a0d:	48 39 c1             	cmp    %rax,%rcx
  8004202a10:	0f 82 fd fe ff ff    	jb     8004202913 <multiboot_read+0x44f>
  8004202a16:	4c 89 e4             	mov    %r12,%rsp
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
			}
		}
	}
}
  8004202a19:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  8004202a1d:	5b                   	pop    %rbx
  8004202a1e:	41 5c                	pop    %r12
  8004202a20:	5d                   	pop    %rbp
  8004202a21:	c3                   	retq   

0000008004202a22 <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  8004202a22:	55                   	push   %rbp
  8004202a23:	48 89 e5             	mov    %rsp,%rbp
  8004202a26:	48 83 ec 30          	sub    $0x30,%rsp
    size_t npages_extmem;
    size_t basemem = 0;
  8004202a2a:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004202a31:	00 
    size_t extmem = 0;
  8004202a32:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  8004202a39:	00 

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  8004202a3a:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  8004202a41:	00 00 00 
  8004202a44:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  8004202a48:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202a4c:	48 8b 00             	mov    (%rax),%rax
  8004202a4f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
	if(mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  8004202a53:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202a58:	74 2d                	je     8004202a87 <i386_detect_memory+0x65>
  8004202a5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202a5e:	8b 00                	mov    (%rax),%eax
  8004202a60:	83 e0 40             	and    $0x40,%eax
  8004202a63:	85 c0                	test   %eax,%eax
  8004202a65:	74 20                	je     8004202a87 <i386_detect_memory+0x65>
		multiboot_read(mbinfo, &basemem, &extmem);
  8004202a67:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004202a6b:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004202a6f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202a73:	48 89 ce             	mov    %rcx,%rsi
  8004202a76:	48 89 c7             	mov    %rax,%rdi
  8004202a79:	48 b8 c4 24 20 04 80 	movabs $0x80042024c4,%rax
  8004202a80:	00 00 00 
  8004202a83:	ff d0                	callq  *%rax
  8004202a85:	eb 34                	jmp    8004202abb <i386_detect_memory+0x99>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  8004202a87:	bf 15 00 00 00       	mov    $0x15,%edi
  8004202a8c:	48 b8 85 24 20 04 80 	movabs $0x8004202485,%rax
  8004202a93:	00 00 00 
  8004202a96:	ff d0                	callq  *%rax
  8004202a98:	c1 e0 0a             	shl    $0xa,%eax
  8004202a9b:	48 98                	cltq   
  8004202a9d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  8004202aa1:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202aa6:	48 b8 85 24 20 04 80 	movabs $0x8004202485,%rax
  8004202aad:	00 00 00 
  8004202ab0:	ff d0                	callq  *%rax
  8004202ab2:	c1 e0 0a             	shl    $0xa,%eax
  8004202ab5:	48 98                	cltq   
  8004202ab7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	}
    
	assert(basemem);
  8004202abb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202abf:	48 85 c0             	test   %rax,%rax
  8004202ac2:	75 35                	jne    8004202af9 <i386_detect_memory+0xd7>
  8004202ac4:	48 b9 a9 78 21 04 80 	movabs $0x80042178a9,%rcx
  8004202acb:	00 00 00 
  8004202ace:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004202ad5:	00 00 00 
  8004202ad8:	be 86 00 00 00       	mov    $0x86,%esi
  8004202add:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004202ae4:	00 00 00 
  8004202ae7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202aec:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004202af3:	00 00 00 
  8004202af6:	41 ff d0             	callq  *%r8
        npages_basemem = basemem / PGSIZE;
  8004202af9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202afd:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202b01:	48 89 c2             	mov    %rax,%rdx
  8004202b04:	48 b8 30 02 36 04 80 	movabs $0x8004360230,%rax
  8004202b0b:	00 00 00 
  8004202b0e:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  8004202b11:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202b15:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202b19:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		

	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  8004202b1d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202b22:	74 1a                	je     8004202b3e <i386_detect_memory+0x11c>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  8004202b24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202b28:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  8004202b2f:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004202b36:	00 00 00 
  8004202b39:	48 89 10             	mov    %rdx,(%rax)
  8004202b3c:	eb 1a                	jmp    8004202b58 <i386_detect_memory+0x136>
	else
		npages = npages_basemem;
  8004202b3e:	48 b8 30 02 36 04 80 	movabs $0x8004360230,%rax
  8004202b45:	00 00 00 
  8004202b48:	48 8b 10             	mov    (%rax),%rdx
  8004202b4b:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004202b52:	00 00 00 
  8004202b55:	48 89 10             	mov    %rdx,(%rax)

	if(nvram_read(NVRAM_EXTLO) == 0xffff) {
  8004202b58:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202b5d:	48 b8 85 24 20 04 80 	movabs $0x8004202485,%rax
  8004202b64:	00 00 00 
  8004202b67:	ff d0                	callq  *%rax
  8004202b69:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004202b6e:	75 2c                	jne    8004202b9c <i386_detect_memory+0x17a>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  8004202b70:	bf 34 00 00 00       	mov    $0x34,%edi
  8004202b75:	48 b8 85 24 20 04 80 	movabs $0x8004202485,%rax
  8004202b7c:	00 00 00 
  8004202b7f:	ff d0                	callq  *%rax
  8004202b81:	c1 e0 10             	shl    $0x10,%eax
  8004202b84:	48 98                	cltq   
  8004202b86:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  8004202b8a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202b8e:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  8004202b94:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202b98:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	
	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  8004202b9c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202ba1:	74 1a                	je     8004202bbd <i386_detect_memory+0x19b>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  8004202ba3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202ba7:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  8004202bae:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004202bb5:	00 00 00 
  8004202bb8:	48 89 10             	mov    %rdx,(%rax)
  8004202bbb:	eb 1a                	jmp    8004202bd7 <i386_detect_memory+0x1b5>
	else
		npages = npages_basemem;
  8004202bbd:	48 b8 30 02 36 04 80 	movabs $0x8004360230,%rax
  8004202bc4:	00 00 00 
  8004202bc7:	48 8b 10             	mov    (%rax),%rdx
  8004202bca:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004202bd1:	00 00 00 
  8004202bd4:	48 89 10             	mov    %rdx,(%rax)
	

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202bd7:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004202bde:	00 00 00 
  8004202be1:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  8004202be4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202be8:	48 c1 e0 0c          	shl    $0xc,%rax
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;
	

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202bec:	48 c1 e8 0a          	shr    $0xa,%rax
  8004202bf0:	48 89 c1             	mov    %rax,%rcx
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
  8004202bf3:	48 b8 30 02 36 04 80 	movabs $0x8004360230,%rax
  8004202bfa:	00 00 00 
  8004202bfd:	48 8b 00             	mov    (%rax),%rax
  8004202c00:	48 c1 e0 0c          	shl    $0xc,%rax
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;
	

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202c04:	48 c1 e8 0a          	shr    $0xa,%rax
  8004202c08:	48 89 c2             	mov    %rax,%rdx
		npages * PGSIZE / (1024 * 1024),
  8004202c0b:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004202c12:	00 00 00 
  8004202c15:	48 8b 00             	mov    (%rax),%rax
  8004202c18:	48 c1 e0 0c          	shl    $0xc,%rax
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;
	

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202c1c:	48 c1 e8 14          	shr    $0x14,%rax
  8004202c20:	49 89 f0             	mov    %rsi,%r8
  8004202c23:	48 89 c6             	mov    %rax,%rsi
  8004202c26:	48 bf d8 78 21 04 80 	movabs $0x80042178d8,%rdi
  8004202c2d:	00 00 00 
  8004202c30:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202c35:	49 b9 11 96 20 04 80 	movabs $0x8004209611,%r9
  8004202c3c:	00 00 00 
  8004202c3f:	41 ff d1             	callq  *%r9
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
		npages);
	
	//JOS is hardwired to support only 256M of physical memory
	if(npages > ((255 * 1024 * 1024)/PGSIZE)) {
  8004202c42:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004202c49:	00 00 00 
  8004202c4c:	48 8b 00             	mov    (%rax),%rax
  8004202c4f:	48 3d 00 ff 00 00    	cmp    $0xff00,%rax
  8004202c55:	76 44                	jbe    8004202c9b <i386_detect_memory+0x279>
		npages = (255 * 1024 * 1024) / PGSIZE;
  8004202c57:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004202c5e:	00 00 00 
  8004202c61:	48 c7 00 00 ff 00 00 	movq   $0xff00,(%rax)
		cprintf("Using only %uK of the available memory.\n", npages * PGSIZE/1024);
  8004202c68:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004202c6f:	00 00 00 
  8004202c72:	48 8b 00             	mov    (%rax),%rax
  8004202c75:	48 c1 e0 0c          	shl    $0xc,%rax
  8004202c79:	48 c1 e8 0a          	shr    $0xa,%rax
  8004202c7d:	48 89 c6             	mov    %rax,%rsi
  8004202c80:	48 bf 28 79 21 04 80 	movabs $0x8004217928,%rdi
  8004202c87:	00 00 00 
  8004202c8a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202c8f:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004202c96:	00 00 00 
  8004202c99:	ff d2                	callq  *%rdx
	}
}
  8004202c9b:	c9                   	leaveq 
  8004202c9c:	c3                   	retq   

0000008004202c9d <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  8004202c9d:	55                   	push   %rbp
  8004202c9e:	48 89 e5             	mov    %rsp,%rbp
  8004202ca1:	48 83 ec 24          	sub    $0x24,%rsp
  8004202ca5:	89 7d dc             	mov    %edi,-0x24(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  8004202ca8:	48 b8 48 02 36 04 80 	movabs $0x8004360248,%rax
  8004202caf:	00 00 00 
  8004202cb2:	48 8b 00             	mov    (%rax),%rax
  8004202cb5:	48 85 c0             	test   %rax,%rax
  8004202cb8:	75 4e                	jne    8004202d08 <boot_alloc+0x6b>
        extern uintptr_t end_debug;
		nextfree = ROUNDUP((char *) end_debug, PGSIZE);
  8004202cba:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  8004202cc1:	00 
  8004202cc2:	48 b8 88 17 36 04 80 	movabs $0x8004361788,%rax
  8004202cc9:	00 00 00 
  8004202ccc:	48 8b 10             	mov    (%rax),%rdx
  8004202ccf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202cd3:	48 01 d0             	add    %rdx,%rax
  8004202cd6:	48 83 e8 01          	sub    $0x1,%rax
  8004202cda:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202cde:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202ce2:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202ce7:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004202ceb:	48 89 d0             	mov    %rdx,%rax
  8004202cee:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004202cf2:	48 29 c2             	sub    %rax,%rdx
  8004202cf5:	48 89 d0             	mov    %rdx,%rax
  8004202cf8:	48 89 c2             	mov    %rax,%rdx
  8004202cfb:	48 b8 48 02 36 04 80 	movabs $0x8004360248,%rax
  8004202d02:	00 00 00 
  8004202d05:	48 89 10             	mov    %rdx,(%rax)
	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
        if(n == 0)
  8004202d08:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004202d0c:	75 0f                	jne    8004202d1d <boot_alloc+0x80>
           return nextfree;
  8004202d0e:	48 b8 48 02 36 04 80 	movabs $0x8004360248,%rax
  8004202d15:	00 00 00 
  8004202d18:	48 8b 00             	mov    (%rax),%rax
  8004202d1b:	eb 48                	jmp    8004202d65 <boot_alloc+0xc8>
        else
         {
            NOP = (n+PGSIZE-1)/PGSIZE;
  8004202d1d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004202d20:	05 ff 0f 00 00       	add    $0xfff,%eax
  8004202d25:	c1 e8 0c             	shr    $0xc,%eax
  8004202d28:	89 45 ec             	mov    %eax,-0x14(%rbp)
            result = nextfree;
  8004202d2b:	48 b8 48 02 36 04 80 	movabs $0x8004360248,%rax
  8004202d32:	00 00 00 
  8004202d35:	48 8b 00             	mov    (%rax),%rax
  8004202d38:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
            nextfree +=  NOP * PGSIZE;
  8004202d3c:	48 b8 48 02 36 04 80 	movabs $0x8004360248,%rax
  8004202d43:	00 00 00 
  8004202d46:	48 8b 10             	mov    (%rax),%rdx
  8004202d49:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202d4c:	c1 e0 0c             	shl    $0xc,%eax
  8004202d4f:	48 98                	cltq   
  8004202d51:	48 01 c2             	add    %rax,%rdx
  8004202d54:	48 b8 48 02 36 04 80 	movabs $0x8004360248,%rax
  8004202d5b:	00 00 00 
  8004202d5e:	48 89 10             	mov    %rdx,(%rax)
            return result;
  8004202d61:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
         }
	
}
  8004202d65:	c9                   	leaveq 
  8004202d66:	c3                   	retq   

0000008004202d67 <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  8004202d67:	55                   	push   %rbp
  8004202d68:	48 89 e5             	mov    %rsp,%rbp
  8004202d6b:	48 83 ec 70          	sub    $0x70,%rsp
	uint32_t cr0;
	uint64_t n;
	int r;
        uintptr_t size,addr;
	struct Env *env;
	i386_detect_memory();
  8004202d6f:	48 b8 22 2a 20 04 80 	movabs $0x8004202a22,%rax
  8004202d76:	00 00 00 
  8004202d79:	ff d0                	callq  *%rax
	//panic("i386_vm_init: This function is not finished\n");
	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	//panic("x64_vm_init: this function is not finished\n");
	pml4e = boot_alloc(PGSIZE);
  8004202d7b:	bf 00 10 00 00       	mov    $0x1000,%edi
  8004202d80:	48 b8 9d 2c 20 04 80 	movabs $0x8004202c9d,%rax
  8004202d87:	00 00 00 
  8004202d8a:	ff d0                	callq  *%rax
  8004202d8c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  8004202d90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202d94:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202d99:	be 00 00 00 00       	mov    $0x0,%esi
  8004202d9e:	48 89 c7             	mov    %rax,%rdi
  8004202da1:	48 b8 b3 fb 20 04 80 	movabs $0x800420fbb3,%rax
  8004202da8:	00 00 00 
  8004202dab:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  8004202dad:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004202db4:	00 00 00 
  8004202db7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202dbb:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  8004202dbe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202dc2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202dc6:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202dcd:	00 00 00 
  8004202dd0:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  8004202dd4:	77 32                	ja     8004202e08 <x64_vm_init+0xa1>
  8004202dd6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202dda:	48 89 c1             	mov    %rax,%rcx
  8004202ddd:	48 ba 58 79 21 04 80 	movabs $0x8004217958,%rdx
  8004202de4:	00 00 00 
  8004202de7:	be 01 01 00 00       	mov    $0x101,%esi
  8004202dec:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004202df3:	00 00 00 
  8004202df6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202dfb:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004202e02:	00 00 00 
  8004202e05:	41 ff d0             	callq  *%r8
  8004202e08:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202e0f:	ff ff ff 
  8004202e12:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202e16:	48 01 c2             	add    %rax,%rdx
  8004202e19:	48 b8 a0 17 36 04 80 	movabs $0x80043617a0,%rax
  8004202e20:	00 00 00 
  8004202e23:	48 89 10             	mov    %rdx,(%rax)
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:
	 pages = (struct PageInfo *)boot_alloc(sizeof(struct PageInfo) * npages);
  8004202e26:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004202e2d:	00 00 00 
  8004202e30:	48 8b 00             	mov    (%rax),%rax
  8004202e33:	c1 e0 04             	shl    $0x4,%eax
  8004202e36:	89 c7                	mov    %eax,%edi
  8004202e38:	48 b8 9d 2c 20 04 80 	movabs $0x8004202c9d,%rax
  8004202e3f:	00 00 00 
  8004202e42:	ff d0                	callq  *%rax
  8004202e44:	48 ba b8 17 36 04 80 	movabs $0x80043617b8,%rdx
  8004202e4b:	00 00 00 
  8004202e4e:	48 89 02             	mov    %rax,(%rdx)

        //////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.
	envs = (struct Env *) boot_alloc(sizeof(struct Env)*NENV);
  8004202e51:	bf 00 80 04 00       	mov    $0x48000,%edi
  8004202e56:	48 b8 9d 2c 20 04 80 	movabs $0x8004202c9d,%rax
  8004202e5d:	00 00 00 
  8004202e60:	ff d0                	callq  *%rax
  8004202e62:	48 ba 50 02 36 04 80 	movabs $0x8004360250,%rdx
  8004202e69:	00 00 00 
  8004202e6c:	48 89 02             	mov    %rax,(%rdx)
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	page_init();
  8004202e6f:	48 b8 fb 32 20 04 80 	movabs $0x80042032fb,%rax
  8004202e76:	00 00 00 
  8004202e79:	ff d0                	callq  *%rax
	// (ie. perm = PTE_U | PTE_P).
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.
	size = (sizeof(struct Env)*NENV);
  8004202e7b:	48 c7 45 e8 00 80 04 	movq   $0x48000,-0x18(%rbp)
  8004202e82:	00 
        addr = PADDR(envs);
  8004202e83:	48 b8 50 02 36 04 80 	movabs $0x8004360250,%rax
  8004202e8a:	00 00 00 
  8004202e8d:	48 8b 00             	mov    (%rax),%rax
  8004202e90:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004202e94:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202e9b:	00 00 00 
  8004202e9e:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004202ea2:	77 32                	ja     8004202ed6 <x64_vm_init+0x16f>
  8004202ea4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202ea8:	48 89 c1             	mov    %rax,%rcx
  8004202eab:	48 ba 58 79 21 04 80 	movabs $0x8004217958,%rdx
  8004202eb2:	00 00 00 
  8004202eb5:	be 29 01 00 00       	mov    $0x129,%esi
  8004202eba:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004202ec1:	00 00 00 
  8004202ec4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ec9:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004202ed0:	00 00 00 
  8004202ed3:	41 ff d0             	callq  *%r8
  8004202ed6:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202edd:	ff ff ff 
  8004202ee0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202ee4:	48 01 d0             	add    %rdx,%rax
  8004202ee7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	boot_map_region(pml4e, UENVS, size, addr, PTE_U|PTE_P);
  8004202eeb:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004202eef:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202ef3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202ef7:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  8004202efd:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  8004202f04:	00 00 00 
  8004202f07:	48 89 c7             	mov    %rax,%rdi
  8004202f0a:	48 b8 92 3c 20 04 80 	movabs $0x8004203c92,%rax
  8004202f11:	00 00 00 
  8004202f14:	ff d0                	callq  *%rax

        size = (sizeof(struct PageInfo) * npages);
  8004202f16:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004202f1d:	00 00 00 
  8004202f20:	48 8b 00             	mov    (%rax),%rax
  8004202f23:	48 c1 e0 04          	shl    $0x4,%rax
  8004202f27:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        addr = PADDR(pages);
  8004202f2b:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  8004202f32:	00 00 00 
  8004202f35:	48 8b 00             	mov    (%rax),%rax
  8004202f38:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004202f3c:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202f43:	00 00 00 
  8004202f46:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  8004202f4a:	77 32                	ja     8004202f7e <x64_vm_init+0x217>
  8004202f4c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202f50:	48 89 c1             	mov    %rax,%rcx
  8004202f53:	48 ba 58 79 21 04 80 	movabs $0x8004217958,%rdx
  8004202f5a:	00 00 00 
  8004202f5d:	be 2d 01 00 00       	mov    $0x12d,%esi
  8004202f62:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004202f69:	00 00 00 
  8004202f6c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202f71:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004202f78:	00 00 00 
  8004202f7b:	41 ff d0             	callq  *%r8
  8004202f7e:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202f85:	ff ff ff 
  8004202f88:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202f8c:	48 01 d0             	add    %rdx,%rax
  8004202f8f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        boot_map_region(pml4e, UPAGES, size, addr, PTE_U|PTE_P);
  8004202f93:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004202f97:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202f9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202f9f:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  8004202fa5:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  8004202fac:	00 00 00 
  8004202faf:	48 89 c7             	mov    %rax,%rdi
  8004202fb2:	48 b8 92 3c 20 04 80 	movabs $0x8004203c92,%rax
  8004202fb9:	00 00 00 
  8004202fbc:	ff d0                	callq  *%rax
	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:
        size = KSTKSIZE; 
  8004202fbe:	48 c7 45 e8 00 00 01 	movq   $0x10000,-0x18(%rbp)
  8004202fc5:	00 
        addr = KSTACKTOP-KSTKSIZE;
  8004202fc6:	48 b8 00 00 ff 03 80 	movabs $0x8003ff0000,%rax
  8004202fcd:	00 00 00 
  8004202fd0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        boot_map_region(pml4e, addr, size, PADDR(bootstack), PTE_W|PTE_P);
  8004202fd4:	48 b8 00 a0 21 04 80 	movabs $0x800421a000,%rax
  8004202fdb:	00 00 00 
  8004202fde:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004202fe2:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202fe9:	00 00 00 
  8004202fec:	48 39 45 c8          	cmp    %rax,-0x38(%rbp)
  8004202ff0:	77 32                	ja     8004203024 <x64_vm_init+0x2bd>
  8004202ff2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202ff6:	48 89 c1             	mov    %rax,%rcx
  8004202ff9:	48 ba 58 79 21 04 80 	movabs $0x8004217958,%rdx
  8004203000:	00 00 00 
  8004203003:	be 3d 01 00 00       	mov    $0x13d,%esi
  8004203008:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420300f:	00 00 00 
  8004203012:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203017:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420301e:	00 00 00 
  8004203021:	41 ff d0             	callq  *%r8
  8004203024:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420302b:	ff ff ff 
  800420302e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203032:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004203036:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420303a:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420303e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203042:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004203048:	48 89 c7             	mov    %rax,%rdi
  800420304b:	48 b8 92 3c 20 04 80 	movabs $0x8004203c92,%rax
  8004203052:	00 00 00 
  8004203055:	ff d0                	callq  *%rax
	//      the PA range [0, npages*PGSIZE)
	// Permissions: kernel RW, user NONE
	// Your code goes here: 
	// Check that the initial page directory has been set up correctly.
	// Initialize the SMP-related parts of the memory map
	mem_init_mp();
  8004203057:	48 b8 10 32 20 04 80 	movabs $0x8004203210,%rax
  800420305e:	00 00 00 
  8004203061:	ff d0                	callq  *%rax
	
	
	//////////////////////////////////////////////////////////////////////
	
        //code put here ,manoj
        size = npages*PGSIZE;
  8004203063:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  800420306a:	00 00 00 
  800420306d:	48 8b 00             	mov    (%rax),%rax
  8004203070:	48 c1 e0 0c          	shl    $0xc,%rax
  8004203074:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        addr = KERNBASE;
  8004203078:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800420307f:	00 00 00 
  8004203082:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        boot_map_region(pml4e, addr, size, 0, PTE_W|PTE_P);
  8004203086:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420308a:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420308e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203092:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004203098:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420309d:	48 89 c7             	mov    %rax,%rdi
  80042030a0:	48 b8 92 3c 20 04 80 	movabs $0x8004203c92,%rax
  80042030a7:	00 00 00 
  80042030aa:	ff d0                	callq  *%rax
        //////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE
	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  80042030ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030b0:	48 83 c0 08          	add    $0x8,%rax
  80042030b4:	48 8b 00             	mov    (%rax),%rax
  80042030b7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042030bd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042030c1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042030c5:	48 c1 e8 0c          	shr    $0xc,%rax
  80042030c9:	89 45 bc             	mov    %eax,-0x44(%rbp)
  80042030cc:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042030cf:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  80042030d6:	00 00 00 
  80042030d9:	48 8b 00             	mov    (%rax),%rax
  80042030dc:	48 39 c2             	cmp    %rax,%rdx
  80042030df:	72 32                	jb     8004203113 <x64_vm_init+0x3ac>
  80042030e1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042030e5:	48 89 c1             	mov    %rax,%rcx
  80042030e8:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  80042030ef:	00 00 00 
  80042030f2:	be 52 01 00 00       	mov    $0x152,%esi
  80042030f7:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042030fe:	00 00 00 
  8004203101:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203106:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420310d:	00 00 00 
  8004203110:	41 ff d0             	callq  *%r8
  8004203113:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420311a:	00 00 00 
  800420311d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203121:	48 01 d0             	add    %rdx,%rax
  8004203124:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004203128:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420312c:	48 8b 00             	mov    (%rax),%rax
  800420312f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203135:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  8004203139:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420313d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203141:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  8004203144:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004203147:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  800420314e:	00 00 00 
  8004203151:	48 8b 00             	mov    (%rax),%rax
  8004203154:	48 39 c2             	cmp    %rax,%rdx
  8004203157:	72 32                	jb     800420318b <x64_vm_init+0x424>
  8004203159:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420315d:	48 89 c1             	mov    %rax,%rcx
  8004203160:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  8004203167:	00 00 00 
  800420316a:	be 53 01 00 00       	mov    $0x153,%esi
  800420316f:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004203176:	00 00 00 
  8004203179:	b8 00 00 00 00       	mov    $0x0,%eax
  800420317e:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004203185:	00 00 00 
  8004203188:	41 ff d0             	callq  *%r8
  800420318b:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203192:	00 00 00 
  8004203195:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203199:	48 01 d0             	add    %rdx,%rax
  800420319c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	lcr3(boot_cr3);
  80042031a0:	48 b8 a0 17 36 04 80 	movabs $0x80043617a0,%rax
  80042031a7:	00 00 00 
  80042031aa:	48 8b 00             	mov    (%rax),%rax
  80042031ad:	48 89 45 90          	mov    %rax,-0x70(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  80042031b1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042031b5:	0f 22 d8             	mov    %rax,%cr3
        
	
        check_page_free_list(1);
  80042031b8:	bf 01 00 00 00       	mov    $0x1,%edi
  80042031bd:	48 b8 14 43 20 04 80 	movabs $0x8004204314,%rax
  80042031c4:	00 00 00 
  80042031c7:	ff d0                	callq  *%rax
	check_page_alloc();
  80042031c9:	48 b8 41 48 20 04 80 	movabs $0x8004204841,%rax
  80042031d0:	00 00 00 
  80042031d3:	ff d0                	callq  *%rax
	page_check();
  80042031d5:	48 b8 f5 5b 20 04 80 	movabs $0x8004205bf5,%rax
  80042031dc:	00 00 00 
  80042031df:	ff d0                	callq  *%rax
        check_page_free_list(0);
  80042031e1:	bf 00 00 00 00       	mov    $0x0,%edi
  80042031e6:	48 b8 14 43 20 04 80 	movabs $0x8004204314,%rax
  80042031ed:	00 00 00 
  80042031f0:	ff d0                	callq  *%rax
	check_boot_pml4e(boot_pml4e);
  80042031f2:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  80042031f9:	00 00 00 
  80042031fc:	48 8b 00             	mov    (%rax),%rax
  80042031ff:	48 89 c7             	mov    %rax,%rdi
  8004203202:	48 b8 2d 52 20 04 80 	movabs $0x800420522d,%rax
  8004203209:	00 00 00 
  800420320c:	ff d0                	callq  *%rax
}
  800420320e:	c9                   	leaveq 
  800420320f:	c3                   	retq   

0000008004203210 <mem_init_mp>:
// Modify mappings in boot_pml4e to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
	static void
mem_init_mp(void)
{
  8004203210:	55                   	push   %rbp
  8004203211:	48 89 e5             	mov    %rsp,%rbp
  8004203214:	48 83 ec 20          	sub    $0x20,%rsp
	// LAB 4: Your code here:

	int i;
	uint64_t size;
	uintptr_t addr;
 	for(i = 0; i < NCPU; i++)
  8004203218:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420321f:	e9 cb 00 00 00       	jmpq   80042032ef <mem_init_mp+0xdf>
	{
	   size = KSTKSIZE + KSTKGAP; 
  8004203224:	48 c7 45 f0 00 80 01 	movq   $0x18000,-0x10(%rbp)
  800420322b:	00 
           addr = KSTACKTOP - (i+1)*size + KSTKGAP;
  800420322c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420322f:	83 c0 01             	add    $0x1,%eax
  8004203232:	48 98                	cltq   
  8004203234:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  8004203239:	48 ba 00 80 00 04 80 	movabs $0x8004008000,%rdx
  8004203240:	00 00 00 
  8004203243:	48 29 c2             	sub    %rax,%rdx
  8004203246:	48 89 d0             	mov    %rdx,%rax
  8004203249:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	   boot_map_region(boot_pml4e, addr, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W|PTE_P);
  800420324d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004203250:	48 98                	cltq   
  8004203252:	48 c1 e0 10          	shl    $0x10,%rax
  8004203256:	48 89 c2             	mov    %rax,%rdx
  8004203259:	48 b8 00 40 36 04 80 	movabs $0x8004364000,%rax
  8004203260:	00 00 00 
  8004203263:	48 01 d0             	add    %rdx,%rax
  8004203266:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420326a:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004203271:	00 00 00 
  8004203274:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004203278:	77 32                	ja     80042032ac <mem_init_mp+0x9c>
  800420327a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420327e:	48 89 c1             	mov    %rax,%rcx
  8004203281:	48 ba 58 79 21 04 80 	movabs $0x8004217958,%rdx
  8004203288:	00 00 00 
  800420328b:	be 7d 01 00 00       	mov    $0x17d,%esi
  8004203290:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004203297:	00 00 00 
  800420329a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420329f:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042032a6:	00 00 00 
  80042032a9:	41 ff d0             	callq  *%r8
  80042032ac:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042032b3:	ff ff ff 
  80042032b6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042032ba:	48 01 c2             	add    %rax,%rdx
  80042032bd:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  80042032c4:	00 00 00 
  80042032c7:	48 8b 00             	mov    (%rax),%rax
  80042032ca:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  80042032ce:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  80042032d4:	48 89 d1             	mov    %rdx,%rcx
  80042032d7:	ba 00 00 01 00       	mov    $0x10000,%edx
  80042032dc:	48 89 c7             	mov    %rax,%rdi
  80042032df:	48 b8 92 3c 20 04 80 	movabs $0x8004203c92,%rax
  80042032e6:	00 00 00 
  80042032e9:	ff d0                	callq  *%rax
	// LAB 4: Your code here:

	int i;
	uint64_t size;
	uintptr_t addr;
 	for(i = 0; i < NCPU; i++)
  80042032eb:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042032ef:	83 7d fc 07          	cmpl   $0x7,-0x4(%rbp)
  80042032f3:	0f 8e 2b ff ff ff    	jle    8004203224 <mem_init_mp+0x14>
           addr = KSTACKTOP - (i+1)*size + KSTKGAP;
	   boot_map_region(boot_pml4e, addr, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W|PTE_P);
	
	}

}
  80042032f9:	c9                   	leaveq 
  80042032fa:	c3                   	retq   

00000080042032fb <page_init>:
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
	void
page_init(void)
{
  80042032fb:	55                   	push   %rbp
  80042032fc:	48 89 e5             	mov    %rsp,%rbp
  80042032ff:	48 83 ec 30          	sub    $0x30,%rsp
	// free pages!
    // NB: Make sure you preserve the direction in which your page_free_list 
    // is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)
        size_t i,PPN_START, PPN_END;
	struct PageInfo* last = NULL;
  8004203303:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420330a:	00 
	for (i = 0; i < npages; i++) 
  800420330b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004203312:	00 
  8004203313:	e9 ab 00 00 00       	jmpq   80042033c3 <page_init+0xc8>
         {
	   pages[i].pp_ref = 0;
  8004203318:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  800420331f:	00 00 00 
  8004203322:	48 8b 00             	mov    (%rax),%rax
  8004203325:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203329:	48 c1 e2 04          	shl    $0x4,%rdx
  800420332d:	48 01 d0             	add    %rdx,%rax
  8004203330:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
	   pages[i].pp_link = NULL;
  8004203336:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  800420333d:	00 00 00 
  8004203340:	48 8b 00             	mov    (%rax),%rax
  8004203343:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203347:	48 c1 e2 04          	shl    $0x4,%rdx
  800420334b:	48 01 d0             	add    %rdx,%rax
  800420334e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
         if(last)
  8004203355:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420335a:	74 21                	je     800420337d <page_init+0x82>
            last->pp_link = &pages[i];
  800420335c:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  8004203363:	00 00 00 
  8004203366:	48 8b 00             	mov    (%rax),%rax
  8004203369:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420336d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203371:	48 01 c2             	add    %rax,%rdx
  8004203374:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203378:	48 89 10             	mov    %rdx,(%rax)
  800420337b:	eb 25                	jmp    80042033a2 <page_init+0xa7>
         else
            page_free_list = &pages[i];
  800420337d:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  8004203384:	00 00 00 
  8004203387:	48 8b 00             	mov    (%rax),%rax
  800420338a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420338e:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203392:	48 01 c2             	add    %rax,%rdx
  8004203395:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  800420339c:	00 00 00 
  800420339f:	48 89 10             	mov    %rdx,(%rax)
            last = &pages[i];
  80042033a2:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  80042033a9:	00 00 00 
  80042033ac:	48 8b 00             	mov    (%rax),%rax
  80042033af:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042033b3:	48 c1 e2 04          	shl    $0x4,%rdx
  80042033b7:	48 01 d0             	add    %rdx,%rax
  80042033ba:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    // NB: Make sure you preserve the direction in which your page_free_list 
    // is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)
        size_t i,PPN_START, PPN_END;
	struct PageInfo* last = NULL;
	for (i = 0; i < npages; i++) 
  80042033be:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80042033c3:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  80042033ca:	00 00 00 
  80042033cd:	48 8b 00             	mov    (%rax),%rax
  80042033d0:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042033d4:	0f 82 3e ff ff ff    	jb     8004203318 <page_init+0x1d>
         else
            page_free_list = &pages[i];
            last = &pages[i];
	}
       
        pages[0].pp_link = NULL;
  80042033da:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  80042033e1:	00 00 00 
  80042033e4:	48 8b 00             	mov    (%rax),%rax
  80042033e7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        PPN_START = IOPHYSMEM/PGSIZE;
  80042033ee:	48 c7 45 e8 a0 00 00 	movq   $0xa0,-0x18(%rbp)
  80042033f5:	00 
        
        PPN_END = PADDR(boot_alloc(0))/PGSIZE; // 2pages in between are used by kernel 
  80042033f6:	bf 00 00 00 00       	mov    $0x0,%edi
  80042033fb:	48 b8 9d 2c 20 04 80 	movabs $0x8004202c9d,%rax
  8004203402:	00 00 00 
  8004203405:	ff d0                	callq  *%rax
  8004203407:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420340b:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004203412:	00 00 00 
  8004203415:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004203419:	77 32                	ja     800420344d <page_init+0x152>
  800420341b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420341f:	48 89 c1             	mov    %rax,%rcx
  8004203422:	48 ba 58 79 21 04 80 	movabs $0x8004217958,%rdx
  8004203429:	00 00 00 
  800420342c:	be ba 01 00 00       	mov    $0x1ba,%esi
  8004203431:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004203438:	00 00 00 
  800420343b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203440:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004203447:	00 00 00 
  800420344a:	41 ff d0             	callq  *%r8
  800420344d:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004203454:	ff ff ff 
  8004203457:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420345b:	48 01 d0             	add    %rdx,%rax
  800420345e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203462:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

        for(i = PPN_START; i < PPN_END; i++)
  8004203466:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420346a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420346e:	eb 24                	jmp    8004203494 <page_init+0x199>
           pages[i].pp_link = NULL;
  8004203470:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  8004203477:	00 00 00 
  800420347a:	48 8b 00             	mov    (%rax),%rax
  800420347d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203481:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203485:	48 01 d0             	add    %rdx,%rax
  8004203488:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        pages[0].pp_link = NULL;
        PPN_START = IOPHYSMEM/PGSIZE;
        
        PPN_END = PADDR(boot_alloc(0))/PGSIZE; // 2pages in between are used by kernel 

        for(i = PPN_START; i < PPN_END; i++)
  800420348f:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004203494:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203498:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420349c:	72 d2                	jb     8004203470 <page_init+0x175>
           pages[i].pp_link = NULL;
        page_free_list = &pages[1];
  800420349e:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  80042034a5:	00 00 00 
  80042034a8:	48 8b 00             	mov    (%rax),%rax
  80042034ab:	48 8d 50 10          	lea    0x10(%rax),%rdx
  80042034af:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  80042034b6:	00 00 00 
  80042034b9:	48 89 10             	mov    %rdx,(%rax)
        pages[PPN_START-1].pp_link = &pages[i];
  80042034bc:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  80042034c3:	00 00 00 
  80042034c6:	48 8b 00             	mov    (%rax),%rax
  80042034c9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042034cd:	48 c1 e2 04          	shl    $0x4,%rdx
  80042034d1:	48 83 ea 10          	sub    $0x10,%rdx
  80042034d5:	48 01 c2             	add    %rax,%rdx
  80042034d8:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  80042034df:	00 00 00 
  80042034e2:	48 8b 00             	mov    (%rax),%rax
  80042034e5:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80042034e9:	48 c1 e1 04          	shl    $0x4,%rcx
  80042034ed:	48 01 c8             	add    %rcx,%rax
  80042034f0:	48 89 02             	mov    %rax,(%rdx)

	// LAB4
	PPN_START = MPENTRY_PADDR/PGSIZE;
  80042034f3:	48 c7 45 e8 07 00 00 	movq   $0x7,-0x18(%rbp)
  80042034fa:	00 
	pages[PPN_START-1].pp_link = &pages[PPN_START+1];
  80042034fb:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  8004203502:	00 00 00 
  8004203505:	48 8b 00             	mov    (%rax),%rax
  8004203508:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420350c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203510:	48 83 ea 10          	sub    $0x10,%rdx
  8004203514:	48 01 c2             	add    %rax,%rdx
  8004203517:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  800420351e:	00 00 00 
  8004203521:	48 8b 00             	mov    (%rax),%rax
  8004203524:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004203528:	48 83 c1 01          	add    $0x1,%rcx
  800420352c:	48 c1 e1 04          	shl    $0x4,%rcx
  8004203530:	48 01 c8             	add    %rcx,%rax
  8004203533:	48 89 02             	mov    %rax,(%rdx)
	pages[PPN_START].pp_link = NULL;
  8004203536:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  800420353d:	00 00 00 
  8004203540:	48 8b 00             	mov    (%rax),%rax
  8004203543:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203547:	48 c1 e2 04          	shl    $0x4,%rdx
  800420354b:	48 01 d0             	add    %rdx,%rax
  800420354e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
                
}
  8004203555:	c9                   	leaveq 
  8004203556:	c3                   	retq   

0000008004203557 <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  8004203557:	55                   	push   %rbp
  8004203558:	48 89 e5             	mov    %rsp,%rbp
  800420355b:	48 83 ec 20          	sub    $0x20,%rsp
  800420355f:	89 7d ec             	mov    %edi,-0x14(%rbp)

  // Fill this function in
  uintptr_t pa;
  struct PageInfo * page;
  page = page_free_list;
  8004203562:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  8004203569:	00 00 00 
  800420356c:	48 8b 00             	mov    (%rax),%rax
  800420356f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if(page != NULL)
  8004203573:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203578:	74 72                	je     80042035ec <page_alloc+0x95>
  {
    pa = page2pa(page);
  800420357a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420357e:	48 89 c7             	mov    %rax,%rdi
  8004203581:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  8004203588:	00 00 00 
  800420358b:	ff d0                	callq  *%rax
  800420358d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    if(alloc_flags & ALLOC_ZERO)
  8004203591:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004203594:	83 e0 01             	and    $0x1,%eax
  8004203597:	85 c0                	test   %eax,%eax
  8004203599:	74 2c                	je     80042035c7 <page_alloc+0x70>
      memset(page2kva(page), '\0', PGSIZE);
  800420359b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420359f:	48 89 c7             	mov    %rax,%rdi
  80042035a2:	48 b8 9c 23 20 04 80 	movabs $0x800420239c,%rax
  80042035a9:	00 00 00 
  80042035ac:	ff d0                	callq  *%rax
  80042035ae:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042035b3:	be 00 00 00 00       	mov    $0x0,%esi
  80042035b8:	48 89 c7             	mov    %rax,%rdi
  80042035bb:	48 b8 b3 fb 20 04 80 	movabs $0x800420fbb3,%rax
  80042035c2:	00 00 00 
  80042035c5:	ff d0                	callq  *%rax
    page_free_list = page->pp_link;
  80042035c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042035cb:	48 8b 10             	mov    (%rax),%rdx
  80042035ce:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  80042035d5:	00 00 00 
  80042035d8:	48 89 10             	mov    %rdx,(%rax)
    page->pp_link = NULL;
  80042035db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042035df:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  }
  else 
    return NULL;

  return page;
  80042035e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042035ea:	eb 05                	jmp    80042035f1 <page_alloc+0x9a>
      memset(page2kva(page), '\0', PGSIZE);
    page_free_list = page->pp_link;
    page->pp_link = NULL;
  }
  else 
    return NULL;
  80042035ec:	b8 00 00 00 00       	mov    $0x0,%eax

  return page;

}
  80042035f1:	c9                   	leaveq 
  80042035f2:	c3                   	retq   

00000080042035f3 <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!
//
	static void
page_initpp(struct PageInfo *pp)
{
  80042035f3:	55                   	push   %rbp
  80042035f4:	48 89 e5             	mov    %rsp,%rbp
  80042035f7:	48 83 ec 10          	sub    $0x10,%rsp
  80042035fb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    memset(pp, 0, sizeof(*pp));
  80042035ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203603:	ba 10 00 00 00       	mov    $0x10,%edx
  8004203608:	be 00 00 00 00       	mov    $0x0,%esi
  800420360d:	48 89 c7             	mov    %rax,%rdi
  8004203610:	48 b8 b3 fb 20 04 80 	movabs $0x800420fbb3,%rax
  8004203617:	00 00 00 
  800420361a:	ff d0                	callq  *%rax
}
  800420361c:	c9                   	leaveq 
  800420361d:	c3                   	retq   

000000800420361e <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  800420361e:	55                   	push   %rbp
  800420361f:	48 89 e5             	mov    %rsp,%rbp
  8004203622:	48 83 ec 08          	sub    $0x8,%rsp
  8004203626:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
         //if(pp->pp_link != NULL || pp->pp_ref != 0)
           //panic("page_free: Page is still in use");
       
         pp->pp_ref = 0;
  800420362a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420362e:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
         if(page_free_list == NULL)
  8004203634:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  800420363b:	00 00 00 
  800420363e:	48 8b 00             	mov    (%rax),%rax
  8004203641:	48 85 c0             	test   %rax,%rax
  8004203644:	75 1e                	jne    8004203664 <page_free+0x46>
           {
             pp->pp_link = NULL;
  8004203646:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420364a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
             page_free_list = pp;
  8004203651:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  8004203658:	00 00 00 
  800420365b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420365f:	48 89 10             	mov    %rdx,(%rax)
  8004203662:	eb 25                	jmp    8004203689 <page_free+0x6b>
           }
         else
           {
	     pp->pp_link = page_free_list;
  8004203664:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  800420366b:	00 00 00 
  800420366e:	48 8b 10             	mov    (%rax),%rdx
  8004203671:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203675:	48 89 10             	mov    %rdx,(%rax)
             page_free_list = pp;
  8004203678:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  800420367f:	00 00 00 
  8004203682:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203686:	48 89 10             	mov    %rdx,(%rax)
	     
	   }
       
}          
  8004203689:	c9                   	leaveq 
  800420368a:	c3                   	retq   

000000800420368b <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  800420368b:	55                   	push   %rbp
  800420368c:	48 89 e5             	mov    %rsp,%rbp
  800420368f:	48 83 ec 08          	sub    $0x8,%rsp
  8004203693:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (--pp->pp_ref == 0)
  8004203697:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420369b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420369f:	8d 50 ff             	lea    -0x1(%rax),%edx
  80042036a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042036a6:	66 89 50 08          	mov    %dx,0x8(%rax)
  80042036aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042036ae:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042036b2:	66 85 c0             	test   %ax,%ax
  80042036b5:	75 13                	jne    80042036ca <page_decref+0x3f>
		page_free(pp);
  80042036b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042036bb:	48 89 c7             	mov    %rax,%rdi
  80042036be:	48 b8 1e 36 20 04 80 	movabs $0x800420361e,%rax
  80042036c5:	00 00 00 
  80042036c8:	ff d0                	callq  *%rax
}
  80042036ca:	c9                   	leaveq 
  80042036cb:	c3                   	retq   

00000080042036cc <pml4e_walk>:
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *
pml4e_walk(pml4e_t *pml4e, const void *va, int create)
{
  80042036cc:	55                   	push   %rbp
  80042036cd:	48 89 e5             	mov    %rsp,%rbp
  80042036d0:	53                   	push   %rbx
  80042036d1:	48 83 ec 78          	sub    $0x78,%rsp
  80042036d5:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  80042036d9:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  80042036dd:	89 55 8c             	mov    %edx,-0x74(%rbp)

   pte_t * pte;
   pdpe_t * addr;
   uintptr_t pdpe;
   int new = 0;
  80042036e0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
   struct PageInfo *page;
   int offset = PML4(va);// int because only 512 entries are there
  80042036e7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042036eb:	48 c1 e8 27          	shr    $0x27,%rax
  80042036ef:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042036f4:	89 45 d4             	mov    %eax,-0x2c(%rbp)
   pdpe = pml4e[offset];
  80042036f7:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80042036fa:	48 98                	cltq   
  80042036fc:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203703:	00 
  8004203704:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004203708:	48 01 d0             	add    %rdx,%rax
  800420370b:	48 8b 00             	mov    (%rax),%rax
  800420370e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
   physaddr_t perm = PTE_P | PTE_W | PTE_U;
  8004203712:	48 c7 45 c8 07 00 00 	movq   $0x7,-0x38(%rbp)
  8004203719:	00 

   if(!pdpe) //page not allocated yet
  800420371a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420371f:	0f 85 ce 00 00 00    	jne    80042037f3 <pml4e_walk+0x127>
   {
      if(create)
  8004203725:	83 7d 8c 00          	cmpl   $0x0,-0x74(%rbp)
  8004203729:	0f 84 ba 00 00 00    	je     80042037e9 <pml4e_walk+0x11d>
      {
        page = page_alloc(ALLOC_ZERO);
  800420372f:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203734:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  800420373b:	00 00 00 
  800420373e:	ff d0                	callq  *%rax
  8004203740:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        if(page == NULL)
  8004203744:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004203749:	75 0a                	jne    8004203755 <pml4e_walk+0x89>
           return NULL;
  800420374b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203750:	e9 73 01 00 00       	jmpq   80042038c8 <pml4e_walk+0x1fc>
         page->pp_ref++;
  8004203755:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203759:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420375d:	8d 50 01             	lea    0x1(%rax),%edx
  8004203760:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203764:	66 89 50 08          	mov    %dx,0x8(%rax)
        pml4e[offset] = page2pa(page);
  8004203768:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420376b:	48 98                	cltq   
  800420376d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203774:	00 
  8004203775:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004203779:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420377d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203781:	48 89 c7             	mov    %rax,%rdi
  8004203784:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  800420378b:	00 00 00 
  800420378e:	ff d0                	callq  *%rax
  8004203790:	48 89 03             	mov    %rax,(%rbx)
        pml4e[offset] = pml4e[offset]|perm;
  8004203793:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004203796:	48 98                	cltq   
  8004203798:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420379f:	00 
  80042037a0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042037a4:	48 01 c2             	add    %rax,%rdx
  80042037a7:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80042037aa:	48 98                	cltq   
  80042037ac:	48 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%rcx
  80042037b3:	00 
  80042037b4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042037b8:	48 01 c8             	add    %rcx,%rax
  80042037bb:	48 8b 00             	mov    (%rax),%rax
  80042037be:	48 0b 45 c8          	or     -0x38(%rbp),%rax
  80042037c2:	48 89 02             	mov    %rax,(%rdx)
         pdpe = pml4e[offset]; // very important to add at end
  80042037c5:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80042037c8:	48 98                	cltq   
  80042037ca:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042037d1:	00 
  80042037d2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042037d6:	48 01 d0             	add    %rdx,%rax
  80042037d9:	48 8b 00             	mov    (%rax),%rax
  80042037dc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
         new = 1;
  80042037e0:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%rbp)
  80042037e7:	eb 0a                	jmp    80042037f3 <pml4e_walk+0x127>
      }
     else
      return NULL;
  80042037e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042037ee:	e9 d5 00 00 00       	jmpq   80042038c8 <pml4e_walk+0x1fc>
   }
    	
   addr = (pdpe_t *)KADDR(pdpe & ~0xfff); // always apply ~0xfff because may be it is already present 
  80042037f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042037f7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042037fd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004203801:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203805:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203809:	89 45 bc             	mov    %eax,-0x44(%rbp)
  800420380c:	8b 55 bc             	mov    -0x44(%rbp),%edx
  800420380f:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004203816:	00 00 00 
  8004203819:	48 8b 00             	mov    (%rax),%rax
  800420381c:	48 39 c2             	cmp    %rax,%rdx
  800420381f:	72 32                	jb     8004203853 <pml4e_walk+0x187>
  8004203821:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203825:	48 89 c1             	mov    %rax,%rcx
  8004203828:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  800420382f:	00 00 00 
  8004203832:	be 53 02 00 00       	mov    $0x253,%esi
  8004203837:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420383e:	00 00 00 
  8004203841:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203846:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420384d:	00 00 00 
  8004203850:	41 ff d0             	callq  *%r8
  8004203853:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420385a:	00 00 00 
  800420385d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203861:	48 01 d0             	add    %rdx,%rax
  8004203864:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
   pte = pdpe_walk(addr, va, create);
  8004203868:	8b 55 8c             	mov    -0x74(%rbp),%edx
  800420386b:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  800420386f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203873:	48 89 ce             	mov    %rcx,%rsi
  8004203876:	48 89 c7             	mov    %rax,%rdi
  8004203879:	48 b8 cf 38 20 04 80 	movabs $0x80042038cf,%rax
  8004203880:	00 00 00 
  8004203883:	ff d0                	callq  *%rax
  8004203885:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
   if(pte == NULL && new)
  8004203889:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  800420388e:	75 34                	jne    80042038c4 <pml4e_walk+0x1f8>
  8004203890:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004203894:	74 2e                	je     80042038c4 <pml4e_walk+0x1f8>
    {
        page_free(page);
  8004203896:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420389a:	48 89 c7             	mov    %rax,%rdi
  800420389d:	48 b8 1e 36 20 04 80 	movabs $0x800420361e,%rax
  80042038a4:	00 00 00 
  80042038a7:	ff d0                	callq  *%rax
        pml4e[offset] = 0;
  80042038a9:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80042038ac:	48 98                	cltq   
  80042038ae:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042038b5:	00 
  80042038b6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042038ba:	48 01 d0             	add    %rdx,%rax
  80042038bd:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    }
  
   
return pte;
  80042038c4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
   }
  80042038c8:	48 83 c4 78          	add    $0x78,%rsp
  80042038cc:	5b                   	pop    %rbx
  80042038cd:	5d                   	pop    %rbp
  80042038ce:	c3                   	retq   

00000080042038cf <pdpe_walk>:
// Given a pdpe i.e page directory pointer pdpe_walk returns the pointer to page table entry
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create){
  80042038cf:	55                   	push   %rbp
  80042038d0:	48 89 e5             	mov    %rsp,%rbp
  80042038d3:	53                   	push   %rbx
  80042038d4:	48 83 ec 78          	sub    $0x78,%rsp
  80042038d8:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  80042038dc:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  80042038e0:	89 55 8c             	mov    %edx,-0x74(%rbp)

   pte_t * pte;
   pde_t * addr;
   uintptr_t pde;
   int new = 0;
  80042038e3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
   struct PageInfo *page;
   int offset = PDPE(va);// int because only 512 entries are there
  80042038ea:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042038ee:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042038f2:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042038f7:	89 45 d4             	mov    %eax,-0x2c(%rbp)
   pde = pdpe[offset];
  80042038fa:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80042038fd:	48 98                	cltq   
  80042038ff:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203906:	00 
  8004203907:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420390b:	48 01 d0             	add    %rdx,%rax
  800420390e:	48 8b 00             	mov    (%rax),%rax
  8004203911:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
   physaddr_t perm = PTE_P | PTE_W | PTE_U;
  8004203915:	48 c7 45 c8 07 00 00 	movq   $0x7,-0x38(%rbp)
  800420391c:	00 
   
   if(!pde)
  800420391d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203922:	0f 85 ce 00 00 00    	jne    80042039f6 <pdpe_walk+0x127>
   {
     if(create)
  8004203928:	83 7d 8c 00          	cmpl   $0x0,-0x74(%rbp)
  800420392c:	0f 84 ba 00 00 00    	je     80042039ec <pdpe_walk+0x11d>
     {
	page = page_alloc(ALLOC_ZERO);
  8004203932:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203937:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  800420393e:	00 00 00 
  8004203941:	ff d0                	callq  *%rax
  8004203943:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        if(page == NULL)
  8004203947:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420394c:	75 0a                	jne    8004203958 <pdpe_walk+0x89>
          return NULL;
  800420394e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203953:	e9 73 01 00 00       	jmpq   8004203acb <pdpe_walk+0x1fc>
        page->pp_ref++;
  8004203958:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420395c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203960:	8d 50 01             	lea    0x1(%rax),%edx
  8004203963:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203967:	66 89 50 08          	mov    %dx,0x8(%rax)
        pdpe[offset] = page2pa(page);
  800420396b:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420396e:	48 98                	cltq   
  8004203970:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203977:	00 
  8004203978:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420397c:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004203980:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203984:	48 89 c7             	mov    %rax,%rdi
  8004203987:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  800420398e:	00 00 00 
  8004203991:	ff d0                	callq  *%rax
  8004203993:	48 89 03             	mov    %rax,(%rbx)
        pdpe[offset] |= perm;
  8004203996:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004203999:	48 98                	cltq   
  800420399b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042039a2:	00 
  80042039a3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042039a7:	48 01 c2             	add    %rax,%rdx
  80042039aa:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80042039ad:	48 98                	cltq   
  80042039af:	48 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%rcx
  80042039b6:	00 
  80042039b7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042039bb:	48 01 c8             	add    %rcx,%rax
  80042039be:	48 8b 00             	mov    (%rax),%rax
  80042039c1:	48 0b 45 c8          	or     -0x38(%rbp),%rax
  80042039c5:	48 89 02             	mov    %rax,(%rdx)
        pde = pdpe[offset];
  80042039c8:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80042039cb:	48 98                	cltq   
  80042039cd:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042039d4:	00 
  80042039d5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042039d9:	48 01 d0             	add    %rdx,%rax
  80042039dc:	48 8b 00             	mov    (%rax),%rax
  80042039df:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        new = 1; 
  80042039e3:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%rbp)
  80042039ea:	eb 0a                	jmp    80042039f6 <pdpe_walk+0x127>
     }
     else
      return NULL;
  80042039ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042039f1:	e9 d5 00 00 00       	jmpq   8004203acb <pdpe_walk+0x1fc>
   }

   addr = KADDR(pde & ~0xfff);
  80042039f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042039fa:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203a00:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004203a04:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203a08:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203a0c:	89 45 bc             	mov    %eax,-0x44(%rbp)
  8004203a0f:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004203a12:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004203a19:	00 00 00 
  8004203a1c:	48 8b 00             	mov    (%rax),%rax
  8004203a1f:	48 39 c2             	cmp    %rax,%rdx
  8004203a22:	72 32                	jb     8004203a56 <pdpe_walk+0x187>
  8004203a24:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203a28:	48 89 c1             	mov    %rax,%rcx
  8004203a2b:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  8004203a32:	00 00 00 
  8004203a35:	be 81 02 00 00       	mov    $0x281,%esi
  8004203a3a:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004203a41:	00 00 00 
  8004203a44:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203a49:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004203a50:	00 00 00 
  8004203a53:	41 ff d0             	callq  *%r8
  8004203a56:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203a5d:	00 00 00 
  8004203a60:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203a64:	48 01 d0             	add    %rdx,%rax
  8004203a67:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
   pte = pgdir_walk(addr, va, create);
  8004203a6b:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004203a6e:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  8004203a72:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203a76:	48 89 ce             	mov    %rcx,%rsi
  8004203a79:	48 89 c7             	mov    %rax,%rdi
  8004203a7c:	48 b8 d2 3a 20 04 80 	movabs $0x8004203ad2,%rax
  8004203a83:	00 00 00 
  8004203a86:	ff d0                	callq  *%rax
  8004203a88:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
   
   if(pte == NULL && new)
  8004203a8c:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8004203a91:	75 34                	jne    8004203ac7 <pdpe_walk+0x1f8>
  8004203a93:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004203a97:	74 2e                	je     8004203ac7 <pdpe_walk+0x1f8>
   {
     page_free(page);
  8004203a99:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203a9d:	48 89 c7             	mov    %rax,%rdi
  8004203aa0:	48 b8 1e 36 20 04 80 	movabs $0x800420361e,%rax
  8004203aa7:	00 00 00 
  8004203aaa:	ff d0                	callq  *%rax
     pdpe[offset] = 0;
  8004203aac:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004203aaf:	48 98                	cltq   
  8004203ab1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203ab8:	00 
  8004203ab9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004203abd:	48 01 d0             	add    %rdx,%rax
  8004203ac0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
   }
  
  return pte;
  8004203ac7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
   
}
  8004203acb:	48 83 c4 78          	add    $0x78,%rsp
  8004203acf:	5b                   	pop    %rbx
  8004203ad0:	5d                   	pop    %rbp
  8004203ad1:	c3                   	retq   

0000008004203ad2 <pgdir_walk>:
// The programming logic and the hints are the same as pml4e_walk
// and pdpe_walk.

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
  8004203ad2:	55                   	push   %rbp
  8004203ad3:	48 89 e5             	mov    %rsp,%rbp
  8004203ad6:	53                   	push   %rbx
  8004203ad7:	48 83 ec 68          	sub    $0x68,%rsp
  8004203adb:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004203adf:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8004203ae3:	89 55 9c             	mov    %edx,-0x64(%rbp)

  pte_t * pte, *addr;
  //pde_t * addr;
  uintptr_t entry;
  int new = 0;
  8004203ae6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  struct PageInfo *page;
  int offset = PDX(va);// int because only 512 entries are there
  8004203aed:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203af1:	48 c1 e8 15          	shr    $0x15,%rax
  8004203af5:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203afa:	89 45 e0             	mov    %eax,-0x20(%rbp)
  entry = pgdir[offset];
  8004203afd:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203b00:	48 98                	cltq   
  8004203b02:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203b09:	00 
  8004203b0a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203b0e:	48 01 d0             	add    %rdx,%rax
  8004203b11:	48 8b 00             	mov    (%rax),%rax
  8004203b14:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  physaddr_t perm = PTE_P | PTE_W | PTE_U;
  8004203b18:	48 c7 45 d8 07 00 00 	movq   $0x7,-0x28(%rbp)
  8004203b1f:	00 
   
  if(!entry)
  8004203b20:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203b25:	0f 85 c7 00 00 00    	jne    8004203bf2 <pgdir_walk+0x120>
   {
      if(create)
  8004203b2b:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  8004203b2f:	0f 84 b3 00 00 00    	je     8004203be8 <pgdir_walk+0x116>
      {
         page = page_alloc(ALLOC_ZERO);
  8004203b35:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203b3a:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  8004203b41:	00 00 00 
  8004203b44:	ff d0                	callq  *%rax
  8004203b46:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
         if(!page)
  8004203b4a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004203b4f:	75 0a                	jne    8004203b5b <pgdir_walk+0x89>
           return NULL;
  8004203b51:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203b56:	e9 30 01 00 00       	jmpq   8004203c8b <pgdir_walk+0x1b9>
         page->pp_ref++;
  8004203b5b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203b5f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203b63:	8d 50 01             	lea    0x1(%rax),%edx
  8004203b66:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203b6a:	66 89 50 08          	mov    %dx,0x8(%rax)
         pgdir[offset] = page2pa(page);
  8004203b6e:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203b71:	48 98                	cltq   
  8004203b73:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203b7a:	00 
  8004203b7b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203b7f:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004203b83:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203b87:	48 89 c7             	mov    %rax,%rdi
  8004203b8a:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  8004203b91:	00 00 00 
  8004203b94:	ff d0                	callq  *%rax
  8004203b96:	48 89 03             	mov    %rax,(%rbx)
         pgdir[offset] |= perm;
  8004203b99:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203b9c:	48 98                	cltq   
  8004203b9e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203ba5:	00 
  8004203ba6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203baa:	48 01 c2             	add    %rax,%rdx
  8004203bad:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203bb0:	48 98                	cltq   
  8004203bb2:	48 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%rcx
  8004203bb9:	00 
  8004203bba:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203bbe:	48 01 c8             	add    %rcx,%rax
  8004203bc1:	48 8b 00             	mov    (%rax),%rax
  8004203bc4:	48 0b 45 d8          	or     -0x28(%rbp),%rax
  8004203bc8:	48 89 02             	mov    %rax,(%rdx)
         entry = pgdir[offset];
  8004203bcb:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203bce:	48 98                	cltq   
  8004203bd0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203bd7:	00 
  8004203bd8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203bdc:	48 01 d0             	add    %rdx,%rax
  8004203bdf:	48 8b 00             	mov    (%rax),%rax
  8004203be2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004203be6:	eb 0a                	jmp    8004203bf2 <pgdir_walk+0x120>
      }
      else
        return NULL;
  8004203be8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203bed:	e9 99 00 00 00       	jmpq   8004203c8b <pgdir_walk+0x1b9>
   }

   addr = KADDR(entry & ~0xfff);
  8004203bf2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203bf6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203bfc:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004203c00:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203c04:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203c08:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004203c0b:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004203c0e:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004203c15:	00 00 00 
  8004203c18:	48 8b 00             	mov    (%rax),%rax
  8004203c1b:	48 39 c2             	cmp    %rax,%rdx
  8004203c1e:	72 32                	jb     8004203c52 <pgdir_walk+0x180>
  8004203c20:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203c24:	48 89 c1             	mov    %rax,%rcx
  8004203c27:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  8004203c2e:	00 00 00 
  8004203c31:	be af 02 00 00       	mov    $0x2af,%esi
  8004203c36:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004203c3d:	00 00 00 
  8004203c40:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203c45:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004203c4c:	00 00 00 
  8004203c4f:	41 ff d0             	callq  *%r8
  8004203c52:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203c59:	00 00 00 
  8004203c5c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203c60:	48 01 d0             	add    %rdx,%rax
  8004203c63:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
   pte = addr+ PTX(va);
  8004203c67:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203c6b:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203c6f:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203c74:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203c7b:	00 
  8004203c7c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203c80:	48 01 d0             	add    %rdx,%rax
  8004203c83:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  
   return pte;
  8004203c87:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
}
  8004203c8b:	48 83 c4 68          	add    $0x68,%rsp
  8004203c8f:	5b                   	pop    %rbx
  8004203c90:	5d                   	pop    %rbp
  8004203c91:	c3                   	retq   

0000008004203c92 <boot_map_region>:
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  8004203c92:	55                   	push   %rbp
  8004203c93:	48 89 e5             	mov    %rsp,%rbp
  8004203c96:	48 83 ec 50          	sub    $0x50,%rsp
  8004203c9a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004203c9e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004203ca2:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004203ca6:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004203caa:	44 89 45 bc          	mov    %r8d,-0x44(%rbp)
      
   pte_t * entry;
   uintptr_t i;
   physaddr_t j;
   
   for( i = la, j = pa; i < la+size;  i += PGSIZE, j+=PGSIZE )
  8004203cae:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203cb2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203cb6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203cba:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004203cbe:	eb 4a                	jmp    8004203d0a <boot_map_region+0x78>
   {
    entry = pml4e_walk(pml4e, (uintptr_t *)i, 1);
  8004203cc0:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004203cc4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203cc8:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203ccd:	48 89 ce             	mov    %rcx,%rsi
  8004203cd0:	48 89 c7             	mov    %rax,%rdi
  8004203cd3:	48 b8 cc 36 20 04 80 	movabs $0x80042036cc,%rax
  8004203cda:	00 00 00 
  8004203cdd:	ff d0                	callq  *%rax
  8004203cdf:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    *entry = j | perm | PTE_P;
  8004203ce3:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004203ce6:	48 98                	cltq   
  8004203ce8:	48 0b 45 f0          	or     -0x10(%rbp),%rax
  8004203cec:	48 83 c8 01          	or     $0x1,%rax
  8004203cf0:	48 89 c2             	mov    %rax,%rdx
  8004203cf3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203cf7:	48 89 10             	mov    %rdx,(%rax)
      
   pte_t * entry;
   uintptr_t i;
   physaddr_t j;
   
   for( i = la, j = pa; i < la+size;  i += PGSIZE, j+=PGSIZE )
  8004203cfa:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004203d01:	00 
  8004203d02:	48 81 45 f0 00 10 00 	addq   $0x1000,-0x10(%rbp)
  8004203d09:	00 
  8004203d0a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203d0e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203d12:	48 01 d0             	add    %rdx,%rax
  8004203d15:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203d19:	77 a5                	ja     8004203cc0 <boot_map_region+0x2e>
   {
    entry = pml4e_walk(pml4e, (uintptr_t *)i, 1);
    *entry = j | perm | PTE_P;
   }

}
  8004203d1b:	c9                   	leaveq 
  8004203d1c:	c3                   	retq   

0000008004203d1d <page_insert>:
// and page2pa.
//

int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  8004203d1d:	55                   	push   %rbp
  8004203d1e:	48 89 e5             	mov    %rsp,%rbp
  8004203d21:	48 83 ec 30          	sub    $0x30,%rsp
  8004203d25:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203d29:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004203d2d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004203d31:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
    // Fill this function in
    // Don't check for physical address of page untill you sure that page exist; That's why we applied page check page2pa(pp)  later earlier it is giving error
    pte_t *pte;
    pte = pml4e_walk(pml4e, va, 1);
  8004203d34:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004203d38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203d3c:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203d41:	48 89 ce             	mov    %rcx,%rsi
  8004203d44:	48 89 c7             	mov    %rax,%rdi
  8004203d47:	48 b8 cc 36 20 04 80 	movabs $0x80042036cc,%rax
  8004203d4e:	00 00 00 
  8004203d51:	ff d0                	callq  *%rax
  8004203d53:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    
    if(pte != NULL)
  8004203d57:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203d5c:	0f 84 da 00 00 00    	je     8004203e3c <page_insert+0x11f>
    {
     if((*pte & PTE_P))
  8004203d62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d66:	48 8b 00             	mov    (%rax),%rax
  8004203d69:	83 e0 01             	and    $0x1,%eax
  8004203d6c:	48 85 c0             	test   %rax,%rax
  8004203d6f:	0f 84 83 00 00 00    	je     8004203df8 <page_insert+0xdb>
      {
          if(pp == pa2page(PTE_ADDR(*pte))) 
  8004203d75:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d79:	48 8b 00             	mov    (%rax),%rax
  8004203d7c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203d82:	48 89 c7             	mov    %rax,%rdi
  8004203d85:	48 b8 2b 23 20 04 80 	movabs $0x800420232b,%rax
  8004203d8c:	00 00 00 
  8004203d8f:	ff d0                	callq  *%rax
  8004203d91:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004203d95:	75 47                	jne    8004203dde <page_insert+0xc1>
          {
            *pte = PTE_ADDR(*pte) | perm | PTE_P;
  8004203d97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d9b:	48 8b 00             	mov    (%rax),%rax
  8004203d9e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203da4:	48 89 c2             	mov    %rax,%rdx
  8004203da7:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004203daa:	48 98                	cltq   
  8004203dac:	48 09 d0             	or     %rdx,%rax
  8004203daf:	48 83 c8 01          	or     $0x1,%rax
  8004203db3:	48 89 c2             	mov    %rax,%rdx
  8004203db6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203dba:	48 89 10             	mov    %rdx,(%rax)
	     tlb_invalidate(pml4e, va);
  8004203dbd:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004203dc1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203dc5:	48 89 d6             	mov    %rdx,%rsi
  8004203dc8:	48 89 c7             	mov    %rax,%rdi
  8004203dcb:	48 b8 53 3f 20 04 80 	movabs $0x8004203f53,%rax
  8004203dd2:	00 00 00 
  8004203dd5:	ff d0                	callq  *%rax
             return 0;
  8004203dd7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203ddc:	eb 63                	jmp    8004203e41 <page_insert+0x124>
          }
          page_remove(pml4e, va);
  8004203dde:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004203de2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203de6:	48 89 d6             	mov    %rdx,%rsi
  8004203de9:	48 89 c7             	mov    %rax,%rdi
  8004203dec:	48 b8 d8 3e 20 04 80 	movabs $0x8004203ed8,%rax
  8004203df3:	00 00 00 
  8004203df6:	ff d0                	callq  *%rax
      }
      *pte = page2pa(pp) | perm | PTE_P;
  8004203df8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203dfc:	48 89 c7             	mov    %rax,%rdi
  8004203dff:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  8004203e06:	00 00 00 
  8004203e09:	ff d0                	callq  *%rax
  8004203e0b:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203e0e:	48 63 d2             	movslq %edx,%rdx
  8004203e11:	48 09 d0             	or     %rdx,%rax
  8004203e14:	48 83 c8 01          	or     $0x1,%rax
  8004203e18:	48 89 c2             	mov    %rax,%rdx
  8004203e1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e1f:	48 89 10             	mov    %rdx,(%rax)
       pp->pp_ref++;
  8004203e22:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203e26:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203e2a:	8d 50 01             	lea    0x1(%rax),%edx
  8004203e2d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203e31:	66 89 50 08          	mov    %dx,0x8(%rax)
    }
    else
     return -1;
    
 return 0;
  8004203e35:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e3a:	eb 05                	jmp    8004203e41 <page_insert+0x124>
      }
      *pte = page2pa(pp) | perm | PTE_P;
       pp->pp_ref++;
    }
    else
     return -1;
  8004203e3c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    
 return 0;
}
  8004203e41:	c9                   	leaveq 
  8004203e42:	c3                   	retq   

0000008004203e43 <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  8004203e43:	55                   	push   %rbp
  8004203e44:	48 89 e5             	mov    %rsp,%rbp
  8004203e47:	48 83 ec 40          	sub    $0x40,%rsp
  8004203e4b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004203e4f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004203e53:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
   // Fill this function in
   pte_t *pte;
   struct PageInfo * page = 0;
  8004203e57:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004203e5e:	00 
   pte = pml4e_walk(pml4e, va, 0);
  8004203e5f:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8004203e63:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203e67:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203e6c:	48 89 ce             	mov    %rcx,%rsi
  8004203e6f:	48 89 c7             	mov    %rax,%rdi
  8004203e72:	48 b8 cc 36 20 04 80 	movabs $0x80042036cc,%rax
  8004203e79:	00 00 00 
  8004203e7c:	ff d0                	callq  *%rax
  8004203e7e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
   physaddr_t pa;
   //cprintf("\n%16.0x %16.0x \n", va, pte);
   if(pte != NULL)
  8004203e82:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004203e87:	74 48                	je     8004203ed1 <page_lookup+0x8e>
   {       
       if((*pte)&PTE_P)
  8004203e89:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203e8d:	48 8b 00             	mov    (%rax),%rax
  8004203e90:	83 e0 01             	and    $0x1,%eax
  8004203e93:	48 85 c0             	test   %rax,%rax
  8004203e96:	74 39                	je     8004203ed1 <page_lookup+0x8e>
         {
          *pte_store = pte;
  8004203e98:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203e9c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004203ea0:	48 89 10             	mov    %rdx,(%rax)
          pa = *pte & ~0xfff;
  8004203ea3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203ea7:	48 8b 00             	mov    (%rax),%rax
  8004203eaa:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203eb0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  	  page = pa2page(pa);  
  8004203eb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203eb8:	48 89 c7             	mov    %rax,%rdi
  8004203ebb:	48 b8 2b 23 20 04 80 	movabs $0x800420232b,%rax
  8004203ec2:	00 00 00 
  8004203ec5:	ff d0                	callq  *%rax
  8004203ec7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    	  return page;
  8004203ecb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ecf:	eb 05                	jmp    8004203ed6 <page_lookup+0x93>
	}
  }
   return NULL;
  8004203ed1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004203ed6:	c9                   	leaveq 
  8004203ed7:	c3                   	retq   

0000008004203ed8 <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  8004203ed8:	55                   	push   %rbp
  8004203ed9:	48 89 e5             	mov    %rsp,%rbp
  8004203edc:	48 83 ec 20          	sub    $0x20,%rsp
  8004203ee0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203ee4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
   //Fill this function in
   pte_t *pte;
   pte = 0;
  8004203ee8:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004203eef:	00 
   struct PageInfo* page;
   page = page_lookup(pml4e, va, &pte);
  8004203ef0:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8004203ef4:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203ef8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203efc:	48 89 ce             	mov    %rcx,%rsi
  8004203eff:	48 89 c7             	mov    %rax,%rdi
  8004203f02:	48 b8 43 3e 20 04 80 	movabs $0x8004203e43,%rax
  8004203f09:	00 00 00 
  8004203f0c:	ff d0                	callq  *%rax
  8004203f0e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
   if(page != NULL)
  8004203f12:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203f17:	74 38                	je     8004203f51 <page_remove+0x79>
   {
     page_decref(page);
  8004203f19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f1d:	48 89 c7             	mov    %rax,%rdi
  8004203f20:	48 b8 8b 36 20 04 80 	movabs $0x800420368b,%rax
  8004203f27:	00 00 00 
  8004203f2a:	ff d0                	callq  *%rax
     *pte = 0;    
  8004203f2c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203f30:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
     tlb_invalidate(pml4e, va);
  8004203f37:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203f3b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203f3f:	48 89 d6             	mov    %rdx,%rsi
  8004203f42:	48 89 c7             	mov    %rax,%rdi
  8004203f45:	48 b8 53 3f 20 04 80 	movabs $0x8004203f53,%rax
  8004203f4c:	00 00 00 
  8004203f4f:	ff d0                	callq  *%rax
   }  
}
  8004203f51:	c9                   	leaveq 
  8004203f52:	c3                   	retq   

0000008004203f53 <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  8004203f53:	55                   	push   %rbp
  8004203f54:	48 89 e5             	mov    %rsp,%rbp
  8004203f57:	48 83 ec 20          	sub    $0x20,%rsp
  8004203f5b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203f5f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Flush the entry only if we're modifying the current address space.
	assert(pml4e!=NULL);
  8004203f63:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203f68:	75 35                	jne    8004203f9f <tlb_invalidate+0x4c>
  8004203f6a:	48 b9 7c 79 21 04 80 	movabs $0x800421797c,%rcx
  8004203f71:	00 00 00 
  8004203f74:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004203f7b:	00 00 00 
  8004203f7e:	be 50 03 00 00       	mov    $0x350,%esi
  8004203f83:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004203f8a:	00 00 00 
  8004203f8d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f92:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004203f99:	00 00 00 
  8004203f9c:	41 ff d0             	callq  *%r8
	if (!curenv || curenv->env_pml4e == pml4e)
  8004203f9f:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004203fa6:	00 00 00 
  8004203fa9:	ff d0                	callq  *%rax
  8004203fab:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  8004203fb2:	00 00 00 
  8004203fb5:	48 98                	cltq   
  8004203fb7:	48 c1 e0 03          	shl    $0x3,%rax
  8004203fbb:	48 89 c2             	mov    %rax,%rdx
  8004203fbe:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203fc2:	48 29 c2             	sub    %rax,%rdx
  8004203fc5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004203fc9:	48 83 c0 08          	add    $0x8,%rax
  8004203fcd:	48 8b 00             	mov    (%rax),%rax
  8004203fd0:	48 85 c0             	test   %rax,%rax
  8004203fd3:	74 3e                	je     8004204013 <tlb_invalidate+0xc0>
  8004203fd5:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004203fdc:	00 00 00 
  8004203fdf:	ff d0                	callq  *%rax
  8004203fe1:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  8004203fe8:	00 00 00 
  8004203feb:	48 98                	cltq   
  8004203fed:	48 c1 e0 03          	shl    $0x3,%rax
  8004203ff1:	48 89 c2             	mov    %rax,%rdx
  8004203ff4:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203ff8:	48 29 c2             	sub    %rax,%rdx
  8004203ffb:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004203fff:	48 83 c0 08          	add    $0x8,%rax
  8004204003:	48 8b 00             	mov    (%rax),%rax
  8004204006:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420400d:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004204011:	75 0f                	jne    8004204022 <tlb_invalidate+0xcf>
  8004204013:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204017:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void 
invlpg(void *addr)
{ 
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  800420401b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420401f:	0f 01 38             	invlpg (%rax)
		invlpg(va);
}
  8004204022:	c9                   	leaveq 
  8004204023:	c3                   	retq   

0000008004204024 <mmio_map_region>:
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
void *
mmio_map_region(physaddr_t pa, size_t size)
{
  8004204024:	55                   	push   %rbp
  8004204025:	48 89 e5             	mov    %rsp,%rbp
  8004204028:	48 83 ec 30          	sub    $0x30,%rsp
  800420402c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004204030:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// Where to start the next region.  Initially, this is the
	// beginning of the MMIO region.  Because this is static, its
	// value will be preserved between calls to mmio_map_region
	// (just like nextfree in boot_alloc).
	static uintptr_t base = MMIOBASE;
	void *start = (void*) base; 
  8004204034:	48 b8 10 a6 22 04 80 	movabs $0x800422a610,%rax
  800420403b:	00 00 00 
  800420403e:	48 8b 00             	mov    (%rax),%rax
  8004204041:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	// okay to simply panic if this happens).
	//
	// Hint: The staff solution uses boot_map_region.
	//
	// Your code here:
	size_t size_up = ROUNDUP(size, PGSIZE);
  8004204045:	48 c7 45 f0 00 10 00 	movq   $0x1000,-0x10(%rbp)
  800420404c:	00 
  800420404d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004204051:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204055:	48 01 d0             	add    %rdx,%rax
  8004204058:	48 83 e8 01          	sub    $0x1,%rax
  800420405c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204060:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204064:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204069:	48 f7 75 f0          	divq   -0x10(%rbp)
  800420406d:	48 89 d0             	mov    %rdx,%rax
  8004204070:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004204074:	48 29 c2             	sub    %rax,%rdx
  8004204077:	48 89 d0             	mov    %rdx,%rax
  800420407a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	if(base + size_up > MMIOLIM)        
  800420407e:	48 b8 10 a6 22 04 80 	movabs $0x800422a610,%rax
  8004204085:	00 00 00 
  8004204088:	48 8b 10             	mov    (%rax),%rdx
  800420408b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420408f:	48 01 c2             	add    %rax,%rdx
  8004204092:	48 b8 00 00 e0 03 80 	movabs $0x8003e00000,%rax
  8004204099:	00 00 00 
  800420409c:	48 39 c2             	cmp    %rax,%rdx
  800420409f:	76 2a                	jbe    80042040cb <mmio_map_region+0xa7>
	   panic("mmio_map_region out of bound kern/pmap.c:mmio_map_region");
  80042040a1:	48 ba 88 79 21 04 80 	movabs $0x8004217988,%rdx
  80042040a8:	00 00 00 
  80042040ab:	be 78 03 00 00       	mov    $0x378,%esi
  80042040b0:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042040b7:	00 00 00 
  80042040ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80042040bf:	48 b9 0b 05 20 04 80 	movabs $0x800420050b,%rcx
  80042040c6:	00 00 00 
  80042040c9:	ff d1                	callq  *%rcx
        
	boot_map_region(boot_pml4e, base, size_up, pa, PTE_PCD | PTE_PWT | PTE_W | PTE_P);
  80042040cb:	48 b8 10 a6 22 04 80 	movabs $0x800422a610,%rax
  80042040d2:	00 00 00 
  80042040d5:	48 8b 30             	mov    (%rax),%rsi
  80042040d8:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  80042040df:	00 00 00 
  80042040e2:	48 8b 00             	mov    (%rax),%rax
  80042040e5:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042040e9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042040ed:	41 b8 1b 00 00 00    	mov    $0x1b,%r8d
  80042040f3:	48 89 c7             	mov    %rax,%rdi
  80042040f6:	48 b8 92 3c 20 04 80 	movabs $0x8004203c92,%rax
  80042040fd:	00 00 00 
  8004204100:	ff d0                	callq  *%rax
	base = base+size_up;
  8004204102:	48 b8 10 a6 22 04 80 	movabs $0x800422a610,%rax
  8004204109:	00 00 00 
  800420410c:	48 8b 10             	mov    (%rax),%rdx
  800420410f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204113:	48 01 c2             	add    %rax,%rdx
  8004204116:	48 b8 10 a6 22 04 80 	movabs $0x800422a610,%rax
  800420411d:	00 00 00 
  8004204120:	48 89 10             	mov    %rdx,(%rax)
	
	return start;
  8004204123:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004204127:	c9                   	leaveq 
  8004204128:	c3                   	retq   

0000008004204129 <user_mem_check>:
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
	int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  8004204129:	55                   	push   %rbp
  800420412a:	48 89 e5             	mov    %rsp,%rbp
  800420412d:	48 83 ec 60          	sub    $0x60,%rsp
  8004204131:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004204135:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004204139:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  800420413d:	89 4d a4             	mov    %ecx,-0x5c(%rbp)
	// LAB 3: Your code here.
	uintptr_t down, up, i;
        pte_t * pte;
        int permcheck;
  	down  = ROUNDDOWN((uintptr_t)va, PGSIZE);
  8004204140:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004204144:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004204148:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420414c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204152:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
   	up    = ROUNDUP((uintptr_t)(va+len), PGSIZE);
  8004204156:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  800420415d:	00 
  800420415e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004204162:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004204166:	48 01 d0             	add    %rdx,%rax
  8004204169:	48 89 c2             	mov    %rax,%rdx
  800420416c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204170:	48 01 d0             	add    %rdx,%rax
  8004204173:	48 83 e8 01          	sub    $0x1,%rax
  8004204177:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420417b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420417f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204184:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004204188:	48 89 d0             	mov    %rdx,%rax
  800420418b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420418f:	48 29 c2             	sub    %rax,%rdx
  8004204192:	48 89 d0             	mov    %rdx,%rax
  8004204195:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	
   	for(i = down; i < up; i = i + PGSIZE)
  8004204199:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420419d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042041a1:	e9 d2 00 00 00       	jmpq   8004204278 <user_mem_check+0x14f>
    	{
            if(i >= ULIM)
  80042041a6:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  80042041ad:	00 00 00 
  80042041b0:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042041b4:	76 38                	jbe    80042041ee <user_mem_check+0xc5>
	     {
		if(i == down)
  80042041b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042041ba:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042041be:	75 13                	jne    80042041d3 <user_mem_check+0xaa>
		  user_mem_check_addr = (uintptr_t)va;
  80042041c0:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042041c4:	48 b8 40 02 36 04 80 	movabs $0x8004360240,%rax
  80042041cb:	00 00 00 
  80042041ce:	48 89 10             	mov    %rdx,(%rax)
  80042041d1:	eb 11                	jmp    80042041e4 <user_mem_check+0xbb>
		else
		  user_mem_check_addr = down;
  80042041d3:	48 b8 40 02 36 04 80 	movabs $0x8004360240,%rax
  80042041da:	00 00 00 
  80042041dd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042041e1:	48 89 10             	mov    %rdx,(%rax)
		return -E_FAULT;
  80042041e4:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  80042041e9:	e9 9d 00 00 00       	jmpq   800420428b <user_mem_check+0x162>
	     }

       	    pte = pml4e_walk(env->env_pml4e, (void *)i , 0);
  80042041ee:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80042041f2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042041f6:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042041fd:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204202:	48 89 ce             	mov    %rcx,%rsi
  8004204205:	48 89 c7             	mov    %rax,%rdi
  8004204208:	48 b8 cc 36 20 04 80 	movabs $0x80042036cc,%rax
  800420420f:	00 00 00 
  8004204212:	ff d0                	callq  *%rax
  8004204214:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	    
	    if( pte == NULL || !((*pte&0xfff) & (perm|PTE_P)))
  8004204218:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420421d:	74 1c                	je     800420423b <user_mem_check+0x112>
  800420421f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204223:	48 8b 10             	mov    (%rax),%rdx
  8004204226:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004204229:	83 c8 01             	or     $0x1,%eax
  800420422c:	48 98                	cltq   
  800420422e:	48 21 d0             	and    %rdx,%rax
  8004204231:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004204236:	48 85 c0             	test   %rax,%rax
  8004204239:	75 35                	jne    8004204270 <user_mem_check+0x147>
            {
	       if(i == down)
  800420423b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420423f:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004204243:	75 13                	jne    8004204258 <user_mem_check+0x12f>
	         user_mem_check_addr = (uintptr_t)va;
  8004204245:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004204249:	48 b8 40 02 36 04 80 	movabs $0x8004360240,%rax
  8004204250:	00 00 00 
  8004204253:	48 89 10             	mov    %rdx,(%rax)
  8004204256:	eb 11                	jmp    8004204269 <user_mem_check+0x140>
	       else
		 user_mem_check_addr = i;
  8004204258:	48 b8 40 02 36 04 80 	movabs $0x8004360240,%rax
  800420425f:	00 00 00 
  8004204262:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204266:	48 89 10             	mov    %rdx,(%rax)
	         
               return -E_FAULT;
  8004204269:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  800420426e:	eb 1b                	jmp    800420428b <user_mem_check+0x162>
        pte_t * pte;
        int permcheck;
  	down  = ROUNDDOWN((uintptr_t)va, PGSIZE);
   	up    = ROUNDUP((uintptr_t)(va+len), PGSIZE);
	
   	for(i = down; i < up; i = i + PGSIZE)
  8004204270:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204277:	00 
  8004204278:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420427c:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004204280:	0f 82 20 ff ff ff    	jb     80042041a6 <user_mem_check+0x7d>
               return -E_FAULT;
	     }

	}
	
	return 0;
  8004204286:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420428b:	c9                   	leaveq 
  800420428c:	c3                   	retq   

000000800420428d <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
	void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  800420428d:	55                   	push   %rbp
  800420428e:	48 89 e5             	mov    %rsp,%rbp
  8004204291:	48 83 ec 20          	sub    $0x20,%rsp
  8004204295:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004204299:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420429d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042042a1:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  80042042a4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042042a7:	83 c8 04             	or     $0x4,%eax
  80042042aa:	89 c1                	mov    %eax,%ecx
  80042042ac:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042042b0:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042042b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042042b8:	48 89 c7             	mov    %rax,%rdi
  80042042bb:	48 b8 29 41 20 04 80 	movabs $0x8004204129,%rax
  80042042c2:	00 00 00 
  80042042c5:	ff d0                	callq  *%rax
  80042042c7:	85 c0                	test   %eax,%eax
  80042042c9:	79 47                	jns    8004204312 <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  80042042cb:	48 b8 40 02 36 04 80 	movabs $0x8004360240,%rax
  80042042d2:	00 00 00 
  80042042d5:	48 8b 10             	mov    (%rax),%rdx
  80042042d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042042dc:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042042e2:	89 c6                	mov    %eax,%esi
  80042042e4:	48 bf c8 79 21 04 80 	movabs $0x80042179c8,%rdi
  80042042eb:	00 00 00 
  80042042ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80042042f3:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  80042042fa:	00 00 00 
  80042042fd:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  80042042ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204303:	48 89 c7             	mov    %rax,%rdi
  8004204306:	48 b8 fe 8e 20 04 80 	movabs $0x8004208efe,%rax
  800420430d:	00 00 00 
  8004204310:	ff d0                	callq  *%rax
	}
}
  8004204312:	c9                   	leaveq 
  8004204313:	c3                   	retq   

0000008004204314 <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  8004204314:	55                   	push   %rbp
  8004204315:	48 89 e5             	mov    %rsp,%rbp
  8004204318:	48 83 ec 60          	sub    $0x60,%rsp
  800420431c:	89 f8                	mov    %edi,%eax
  800420431e:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  8004204321:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004204325:	74 07                	je     800420432e <check_page_free_list+0x1a>
  8004204327:	b8 01 00 00 00       	mov    $0x1,%eax
  800420432c:	eb 05                	jmp    8004204333 <check_page_free_list+0x1f>
  800420432e:	b8 00 02 00 00       	mov    $0x200,%eax
  8004204333:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  8004204336:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420433d:	00 
  800420433e:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204345:	00 
	char *first_free_page;

	if (!page_free_list)
  8004204346:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  800420434d:	00 00 00 
  8004204350:	48 8b 00             	mov    (%rax),%rax
  8004204353:	48 85 c0             	test   %rax,%rax
  8004204356:	75 2a                	jne    8004204382 <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  8004204358:	48 ba 00 7a 21 04 80 	movabs $0x8004217a00,%rdx
  800420435f:	00 00 00 
  8004204362:	be dd 03 00 00       	mov    $0x3dd,%esi
  8004204367:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420436e:	00 00 00 
  8004204371:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204376:	48 b9 0b 05 20 04 80 	movabs $0x800420050b,%rcx
  800420437d:	00 00 00 
  8004204380:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  8004204382:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004204386:	0f 84 a9 00 00 00    	je     8004204435 <check_page_free_list+0x121>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  800420438c:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8004204390:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004204394:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  8004204398:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  800420439c:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  80042043a3:	00 00 00 
  80042043a6:	48 8b 00             	mov    (%rax),%rax
  80042043a9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042043ad:	eb 58                	jmp    8004204407 <check_page_free_list+0xf3>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  80042043af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042043b3:	48 89 c7             	mov    %rax,%rdi
  80042043b6:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  80042043bd:	00 00 00 
  80042043c0:	ff d0                	callq  *%rax
  80042043c2:	48 c1 e8 15          	shr    $0x15,%rax
  80042043c6:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042043cb:	48 89 c2             	mov    %rax,%rdx
  80042043ce:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042043d1:	48 39 c2             	cmp    %rax,%rdx
  80042043d4:	0f 93 c0             	setae  %al
  80042043d7:	0f b6 c0             	movzbl %al,%eax
  80042043da:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  80042043dd:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042043e0:	48 98                	cltq   
  80042043e2:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  80042043e7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042043eb:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  80042043ee:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042043f2:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042043f5:	48 98                	cltq   
  80042043f7:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042043fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204400:	48 8b 00             	mov    (%rax),%rax
  8004204403:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204407:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420440c:	75 a1                	jne    80042043af <check_page_free_list+0x9b>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
  800420440e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004204412:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  8004204419:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420441d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004204421:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  8004204424:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204428:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  800420442f:	00 00 00 
  8004204432:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004204435:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  800420443c:	00 00 00 
  800420443f:	48 8b 00             	mov    (%rax),%rax
  8004204442:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204446:	eb 5e                	jmp    80042044a6 <check_page_free_list+0x192>
		if (PDX(page2pa(pp)) < pdx_limit)
  8004204448:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420444c:	48 89 c7             	mov    %rax,%rdi
  800420444f:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  8004204456:	00 00 00 
  8004204459:	ff d0                	callq  *%rax
  800420445b:	48 c1 e8 15          	shr    $0x15,%rax
  800420445f:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204464:	48 89 c2             	mov    %rax,%rdx
  8004204467:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420446a:	48 39 c2             	cmp    %rax,%rdx
  800420446d:	73 2c                	jae    800420449b <check_page_free_list+0x187>
			memset(page2kva(pp), 0x97, 128);
  800420446f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204473:	48 89 c7             	mov    %rax,%rdi
  8004204476:	48 b8 9c 23 20 04 80 	movabs $0x800420239c,%rax
  800420447d:	00 00 00 
  8004204480:	ff d0                	callq  *%rax
  8004204482:	ba 80 00 00 00       	mov    $0x80,%edx
  8004204487:	be 97 00 00 00       	mov    $0x97,%esi
  800420448c:	48 89 c7             	mov    %rax,%rdi
  800420448f:	48 b8 b3 fb 20 04 80 	movabs $0x800420fbb3,%rax
  8004204496:	00 00 00 
  8004204499:	ff d0                	callq  *%rax
		page_free_list = pp1;
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  800420449b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420449f:	48 8b 00             	mov    (%rax),%rax
  80042044a2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042044a6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042044ab:	75 9b                	jne    8004204448 <check_page_free_list+0x134>
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
  80042044ad:	bf 00 00 00 00       	mov    $0x0,%edi
  80042044b2:	48 b8 9d 2c 20 04 80 	movabs $0x8004202c9d,%rax
  80042044b9:	00 00 00 
  80042044bc:	ff d0                	callq  *%rax
  80042044be:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        //cprintf("\n first_free_page %x  page_free_list %x \n", first_free_page, page_free_list);
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042044c2:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  80042044c9:	00 00 00 
  80042044cc:	48 8b 00             	mov    (%rax),%rax
  80042044cf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042044d3:	e9 20 03 00 00       	jmpq   80042047f8 <check_page_free_list+0x4e4>
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
  80042044d8:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  80042044df:	00 00 00 
  80042044e2:	48 8b 00             	mov    (%rax),%rax
  80042044e5:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042044e9:	73 35                	jae    8004204520 <check_page_free_list+0x20c>
  80042044eb:	48 b9 24 7a 21 04 80 	movabs $0x8004217a24,%rcx
  80042044f2:	00 00 00 
  80042044f5:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042044fc:	00 00 00 
  80042044ff:	be f8 03 00 00       	mov    $0x3f8,%esi
  8004204504:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420450b:	00 00 00 
  800420450e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204513:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420451a:	00 00 00 
  800420451d:	41 ff d0             	callq  *%r8
		assert(pp < pages + npages);
  8004204520:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  8004204527:	00 00 00 
  800420452a:	48 8b 10             	mov    (%rax),%rdx
  800420452d:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004204534:	00 00 00 
  8004204537:	48 8b 00             	mov    (%rax),%rax
  800420453a:	48 c1 e0 04          	shl    $0x4,%rax
  800420453e:	48 01 d0             	add    %rdx,%rax
  8004204541:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204545:	77 35                	ja     800420457c <check_page_free_list+0x268>
  8004204547:	48 b9 30 7a 21 04 80 	movabs $0x8004217a30,%rcx
  800420454e:	00 00 00 
  8004204551:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204558:	00 00 00 
  800420455b:	be f9 03 00 00       	mov    $0x3f9,%esi
  8004204560:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204567:	00 00 00 
  800420456a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420456f:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204576:	00 00 00 
  8004204579:	41 ff d0             	callq  *%r8
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  800420457c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204580:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  8004204587:	00 00 00 
  800420458a:	48 8b 00             	mov    (%rax),%rax
  800420458d:	48 29 c2             	sub    %rax,%rdx
  8004204590:	48 89 d0             	mov    %rdx,%rax
  8004204593:	83 e0 0f             	and    $0xf,%eax
  8004204596:	48 85 c0             	test   %rax,%rax
  8004204599:	74 35                	je     80042045d0 <check_page_free_list+0x2bc>
  800420459b:	48 b9 48 7a 21 04 80 	movabs $0x8004217a48,%rcx
  80042045a2:	00 00 00 
  80042045a5:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042045ac:	00 00 00 
  80042045af:	be fa 03 00 00       	mov    $0x3fa,%esi
  80042045b4:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042045bb:	00 00 00 
  80042045be:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045c3:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042045ca:	00 00 00 
  80042045cd:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
  80042045d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042045d4:	48 89 c7             	mov    %rax,%rdi
  80042045d7:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  80042045de:	00 00 00 
  80042045e1:	ff d0                	callq  *%rax
  80042045e3:	48 85 c0             	test   %rax,%rax
  80042045e6:	75 35                	jne    800420461d <check_page_free_list+0x309>
  80042045e8:	48 b9 7a 7a 21 04 80 	movabs $0x8004217a7a,%rcx
  80042045ef:	00 00 00 
  80042045f2:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042045f9:	00 00 00 
  80042045fc:	be fd 03 00 00       	mov    $0x3fd,%esi
  8004204601:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204608:	00 00 00 
  800420460b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204610:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204617:	00 00 00 
  800420461a:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != IOPHYSMEM);
  800420461d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204621:	48 89 c7             	mov    %rax,%rdi
  8004204624:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  800420462b:	00 00 00 
  800420462e:	ff d0                	callq  *%rax
  8004204630:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004204636:	75 35                	jne    800420466d <check_page_free_list+0x359>
  8004204638:	48 b9 8b 7a 21 04 80 	movabs $0x8004217a8b,%rcx
  800420463f:	00 00 00 
  8004204642:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204649:	00 00 00 
  800420464c:	be fe 03 00 00       	mov    $0x3fe,%esi
  8004204651:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204658:	00 00 00 
  800420465b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204660:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204667:	00 00 00 
  800420466a:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  800420466d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204671:	48 89 c7             	mov    %rax,%rdi
  8004204674:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  800420467b:	00 00 00 
  800420467e:	ff d0                	callq  *%rax
  8004204680:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004204686:	75 35                	jne    80042046bd <check_page_free_list+0x3a9>
  8004204688:	48 b9 a8 7a 21 04 80 	movabs $0x8004217aa8,%rcx
  800420468f:	00 00 00 
  8004204692:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204699:	00 00 00 
  800420469c:	be ff 03 00 00       	mov    $0x3ff,%esi
  80042046a1:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042046a8:	00 00 00 
  80042046ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80042046b0:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042046b7:	00 00 00 
  80042046ba:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM);
  80042046bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042046c1:	48 89 c7             	mov    %rax,%rdi
  80042046c4:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  80042046cb:	00 00 00 
  80042046ce:	ff d0                	callq  *%rax
  80042046d0:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  80042046d6:	75 35                	jne    800420470d <check_page_free_list+0x3f9>
  80042046d8:	48 b9 cb 7a 21 04 80 	movabs $0x8004217acb,%rcx
  80042046df:	00 00 00 
  80042046e2:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042046e9:	00 00 00 
  80042046ec:	be 00 04 00 00       	mov    $0x400,%esi
  80042046f1:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042046f8:	00 00 00 
  80042046fb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204700:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204707:	00 00 00 
  800420470a:	41 ff d0             	callq  *%r8
                //cprintf("\npage_free_list %x currentpage %x EXTPHYSMEM %x page2pa(pp) %x\n", page_free_list, pp, EXTPHYSMEM, page2pa(pp));
		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
  800420470d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204711:	48 89 c7             	mov    %rax,%rdi
  8004204714:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  800420471b:	00 00 00 
  800420471e:	ff d0                	callq  *%rax
  8004204720:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004204726:	76 4e                	jbe    8004204776 <check_page_free_list+0x462>
  8004204728:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420472c:	48 89 c7             	mov    %rax,%rdi
  800420472f:	48 b8 9c 23 20 04 80 	movabs $0x800420239c,%rax
  8004204736:	00 00 00 
  8004204739:	ff d0                	callq  *%rax
  800420473b:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420473f:	73 35                	jae    8004204776 <check_page_free_list+0x462>
  8004204741:	48 b9 e8 7a 21 04 80 	movabs $0x8004217ae8,%rcx
  8004204748:	00 00 00 
  800420474b:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204752:	00 00 00 
  8004204755:	be 02 04 00 00       	mov    $0x402,%esi
  800420475a:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204761:	00 00 00 
  8004204764:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204769:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204770:	00 00 00 
  8004204773:	41 ff d0             	callq  *%r8
		// (new test for lab 4)
		assert(page2pa(pp) != MPENTRY_PADDR);
  8004204776:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420477a:	48 89 c7             	mov    %rax,%rdi
  800420477d:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  8004204784:	00 00 00 
  8004204787:	ff d0                	callq  *%rax
  8004204789:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  800420478f:	75 35                	jne    80042047c6 <check_page_free_list+0x4b2>
  8004204791:	48 b9 2d 7b 21 04 80 	movabs $0x8004217b2d,%rcx
  8004204798:	00 00 00 
  800420479b:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042047a2:	00 00 00 
  80042047a5:	be 04 04 00 00       	mov    $0x404,%esi
  80042047aa:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042047b1:	00 00 00 
  80042047b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042047b9:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042047c0:	00 00 00 
  80042047c3:	41 ff d0             	callq  *%r8

		if (page2pa(pp) < EXTPHYSMEM)
  80042047c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042047ca:	48 89 c7             	mov    %rax,%rdi
  80042047cd:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  80042047d4:	00 00 00 
  80042047d7:	ff d0                	callq  *%rax
  80042047d9:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  80042047df:	77 07                	ja     80042047e8 <check_page_free_list+0x4d4>
			++nfree_basemem;
  80042047e1:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  80042047e6:	eb 05                	jmp    80042047ed <check_page_free_list+0x4d9>
		else
			++nfree_extmem;
  80042047e8:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
        //cprintf("\n first_free_page %x  page_free_list %x \n", first_free_page, page_free_list);
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042047ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042047f1:	48 8b 00             	mov    (%rax),%rax
  80042047f4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042047f8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042047fd:	0f 85 d5 fc ff ff    	jne    80042044d8 <check_page_free_list+0x1c4>
			++nfree_basemem;
		else
			++nfree_extmem;
	}

	assert(nfree_extmem > 0);
  8004204803:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204808:	75 35                	jne    800420483f <check_page_free_list+0x52b>
  800420480a:	48 b9 4a 7b 21 04 80 	movabs $0x8004217b4a,%rcx
  8004204811:	00 00 00 
  8004204814:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  800420481b:	00 00 00 
  800420481e:	be 0c 04 00 00       	mov    $0x40c,%esi
  8004204823:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420482a:	00 00 00 
  800420482d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204832:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204839:	00 00 00 
  800420483c:	41 ff d0             	callq  *%r8
}
  800420483f:	c9                   	leaveq 
  8004204840:	c3                   	retq   

0000008004204841 <check_page_alloc>:
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
  8004204841:	55                   	push   %rbp
  8004204842:	48 89 e5             	mov    %rsp,%rbp
  8004204845:	48 83 ec 40          	sub    $0x40,%rsp
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204849:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  8004204850:	00 00 00 
  8004204853:	48 8b 00             	mov    (%rax),%rax
  8004204856:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420485a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004204861:	eb 37                	jmp    800420489a <check_page_alloc+0x59>
		memset(page2kva(pp0), 0x97, PGSIZE);
  8004204863:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204867:	48 89 c7             	mov    %rax,%rdi
  800420486a:	48 b8 9c 23 20 04 80 	movabs $0x800420239c,%rax
  8004204871:	00 00 00 
  8004204874:	ff d0                	callq  *%rax
  8004204876:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420487b:	be 97 00 00 00       	mov    $0x97,%esi
  8004204880:	48 89 c7             	mov    %rax,%rdi
  8004204883:	48 b8 b3 fb 20 04 80 	movabs $0x800420fbb3,%rax
  800420488a:	00 00 00 
  800420488d:	ff d0                	callq  *%rax
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  800420488f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204893:	48 8b 00             	mov    (%rax),%rax
  8004204896:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420489a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420489f:	75 c2                	jne    8004204863 <check_page_alloc+0x22>
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  80042048a1:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  80042048a8:	00 00 00 
  80042048ab:	48 8b 00             	mov    (%rax),%rax
  80042048ae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042048b2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  80042048b9:	e9 ec 01 00 00       	jmpq   8004204aaa <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
		assert(pp0 >= pages);
  80042048be:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  80042048c5:	00 00 00 
  80042048c8:	48 8b 00             	mov    (%rax),%rax
  80042048cb:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042048cf:	73 35                	jae    8004204906 <check_page_alloc+0xc5>
  80042048d1:	48 b9 5b 7b 21 04 80 	movabs $0x8004217b5b,%rcx
  80042048d8:	00 00 00 
  80042048db:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042048e2:	00 00 00 
  80042048e5:	be 26 04 00 00       	mov    $0x426,%esi
  80042048ea:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042048f1:	00 00 00 
  80042048f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042048f9:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204900:	00 00 00 
  8004204903:	41 ff d0             	callq  *%r8
		assert(pp0 < pages + npages);
  8004204906:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  800420490d:	00 00 00 
  8004204910:	48 8b 10             	mov    (%rax),%rdx
  8004204913:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  800420491a:	00 00 00 
  800420491d:	48 8b 00             	mov    (%rax),%rax
  8004204920:	48 c1 e0 04          	shl    $0x4,%rax
  8004204924:	48 01 d0             	add    %rdx,%rax
  8004204927:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420492b:	77 35                	ja     8004204962 <check_page_alloc+0x121>
  800420492d:	48 b9 68 7b 21 04 80 	movabs $0x8004217b68,%rcx
  8004204934:	00 00 00 
  8004204937:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  800420493e:	00 00 00 
  8004204941:	be 27 04 00 00       	mov    $0x427,%esi
  8004204946:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420494d:	00 00 00 
  8004204950:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204955:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420495c:	00 00 00 
  800420495f:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp0) != 0);
  8004204962:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204966:	48 89 c7             	mov    %rax,%rdi
  8004204969:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  8004204970:	00 00 00 
  8004204973:	ff d0                	callq  *%rax
  8004204975:	48 85 c0             	test   %rax,%rax
  8004204978:	75 35                	jne    80042049af <check_page_alloc+0x16e>
  800420497a:	48 b9 7d 7b 21 04 80 	movabs $0x8004217b7d,%rcx
  8004204981:	00 00 00 
  8004204984:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  800420498b:	00 00 00 
  800420498e:	be 2a 04 00 00       	mov    $0x42a,%esi
  8004204993:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420499a:	00 00 00 
  800420499d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042049a2:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042049a9:	00 00 00 
  80042049ac:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != IOPHYSMEM);
  80042049af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042049b3:	48 89 c7             	mov    %rax,%rdi
  80042049b6:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  80042049bd:	00 00 00 
  80042049c0:	ff d0                	callq  *%rax
  80042049c2:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  80042049c8:	75 35                	jne    80042049ff <check_page_alloc+0x1be>
  80042049ca:	48 b9 8f 7b 21 04 80 	movabs $0x8004217b8f,%rcx
  80042049d1:	00 00 00 
  80042049d4:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042049db:	00 00 00 
  80042049de:	be 2b 04 00 00       	mov    $0x42b,%esi
  80042049e3:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042049ea:	00 00 00 
  80042049ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042049f2:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042049f9:	00 00 00 
  80042049fc:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  80042049ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204a03:	48 89 c7             	mov    %rax,%rdi
  8004204a06:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  8004204a0d:	00 00 00 
  8004204a10:	ff d0                	callq  *%rax
  8004204a12:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004204a18:	75 35                	jne    8004204a4f <check_page_alloc+0x20e>
  8004204a1a:	48 b9 b0 7b 21 04 80 	movabs $0x8004217bb0,%rcx
  8004204a21:	00 00 00 
  8004204a24:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204a2b:	00 00 00 
  8004204a2e:	be 2c 04 00 00       	mov    $0x42c,%esi
  8004204a33:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204a3a:	00 00 00 
  8004204a3d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a42:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204a49:	00 00 00 
  8004204a4c:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM);
  8004204a4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204a53:	48 89 c7             	mov    %rax,%rdi
  8004204a56:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  8004204a5d:	00 00 00 
  8004204a60:	ff d0                	callq  *%rax
  8004204a62:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004204a68:	75 35                	jne    8004204a9f <check_page_alloc+0x25e>
  8004204a6a:	48 b9 d4 7b 21 04 80 	movabs $0x8004217bd4,%rcx
  8004204a71:	00 00 00 
  8004204a74:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204a7b:	00 00 00 
  8004204a7e:	be 2d 04 00 00       	mov    $0x42d,%esi
  8004204a83:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204a8a:	00 00 00 
  8004204a8d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a92:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204a99:	00 00 00 
  8004204a9c:	41 ff d0             	callq  *%r8
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204a9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204aa3:	48 8b 00             	mov    (%rax),%rax
  8004204aa6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204aaa:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204aaf:	0f 85 09 fe ff ff    	jne    80042048be <check_page_alloc+0x7d>
		assert(page2pa(pp0) != IOPHYSMEM);
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
		assert(page2pa(pp0) != EXTPHYSMEM);
	}
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
  8004204ab5:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204abc:	00 
  8004204abd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204ac1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204ac5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204ac9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204acd:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204ad2:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  8004204ad9:	00 00 00 
  8004204adc:	ff d0                	callq  *%rax
  8004204ade:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204ae2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204ae7:	75 35                	jne    8004204b1e <check_page_alloc+0x2dd>
  8004204ae9:	48 b9 ef 7b 21 04 80 	movabs $0x8004217bef,%rcx
  8004204af0:	00 00 00 
  8004204af3:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204afa:	00 00 00 
  8004204afd:	be 31 04 00 00       	mov    $0x431,%esi
  8004204b02:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204b09:	00 00 00 
  8004204b0c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b11:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204b18:	00 00 00 
  8004204b1b:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004204b1e:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204b23:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  8004204b2a:	00 00 00 
  8004204b2d:	ff d0                	callq  *%rax
  8004204b2f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204b33:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204b38:	75 35                	jne    8004204b6f <check_page_alloc+0x32e>
  8004204b3a:	48 b9 05 7c 21 04 80 	movabs $0x8004217c05,%rcx
  8004204b41:	00 00 00 
  8004204b44:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204b4b:	00 00 00 
  8004204b4e:	be 32 04 00 00       	mov    $0x432,%esi
  8004204b53:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204b5a:	00 00 00 
  8004204b5d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b62:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204b69:	00 00 00 
  8004204b6c:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004204b6f:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204b74:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  8004204b7b:	00 00 00 
  8004204b7e:	ff d0                	callq  *%rax
  8004204b80:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204b84:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204b89:	75 35                	jne    8004204bc0 <check_page_alloc+0x37f>
  8004204b8b:	48 b9 1b 7c 21 04 80 	movabs $0x8004217c1b,%rcx
  8004204b92:	00 00 00 
  8004204b95:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204b9c:	00 00 00 
  8004204b9f:	be 33 04 00 00       	mov    $0x433,%esi
  8004204ba4:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204bab:	00 00 00 
  8004204bae:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204bb3:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204bba:	00 00 00 
  8004204bbd:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204bc0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204bc5:	75 35                	jne    8004204bfc <check_page_alloc+0x3bb>
  8004204bc7:	48 b9 31 7c 21 04 80 	movabs $0x8004217c31,%rcx
  8004204bce:	00 00 00 
  8004204bd1:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204bd8:	00 00 00 
  8004204bdb:	be 34 04 00 00       	mov    $0x434,%esi
  8004204be0:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204be7:	00 00 00 
  8004204bea:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204bef:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204bf6:	00 00 00 
  8004204bf9:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204bfc:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204c01:	74 0a                	je     8004204c0d <check_page_alloc+0x3cc>
  8004204c03:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204c07:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204c0b:	75 35                	jne    8004204c42 <check_page_alloc+0x401>
  8004204c0d:	48 b9 35 7c 21 04 80 	movabs $0x8004217c35,%rcx
  8004204c14:	00 00 00 
  8004204c17:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204c1e:	00 00 00 
  8004204c21:	be 35 04 00 00       	mov    $0x435,%esi
  8004204c26:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204c2d:	00 00 00 
  8004204c30:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c35:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204c3c:	00 00 00 
  8004204c3f:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204c42:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204c47:	74 14                	je     8004204c5d <check_page_alloc+0x41c>
  8004204c49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204c4d:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204c51:	74 0a                	je     8004204c5d <check_page_alloc+0x41c>
  8004204c53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204c57:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204c5b:	75 35                	jne    8004204c92 <check_page_alloc+0x451>
  8004204c5d:	48 b9 48 7c 21 04 80 	movabs $0x8004217c48,%rcx
  8004204c64:	00 00 00 
  8004204c67:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204c6e:	00 00 00 
  8004204c71:	be 36 04 00 00       	mov    $0x436,%esi
  8004204c76:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204c7d:	00 00 00 
  8004204c80:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c85:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204c8c:	00 00 00 
  8004204c8f:	41 ff d0             	callq  *%r8
	assert(page2pa(pp0) < npages*PGSIZE);
  8004204c92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204c96:	48 89 c7             	mov    %rax,%rdi
  8004204c99:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  8004204ca0:	00 00 00 
  8004204ca3:	ff d0                	callq  *%rax
  8004204ca5:	48 ba b0 17 36 04 80 	movabs $0x80043617b0,%rdx
  8004204cac:	00 00 00 
  8004204caf:	48 8b 12             	mov    (%rdx),%rdx
  8004204cb2:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204cb6:	48 39 d0             	cmp    %rdx,%rax
  8004204cb9:	72 35                	jb     8004204cf0 <check_page_alloc+0x4af>
  8004204cbb:	48 b9 68 7c 21 04 80 	movabs $0x8004217c68,%rcx
  8004204cc2:	00 00 00 
  8004204cc5:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204ccc:	00 00 00 
  8004204ccf:	be 37 04 00 00       	mov    $0x437,%esi
  8004204cd4:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204cdb:	00 00 00 
  8004204cde:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ce3:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204cea:	00 00 00 
  8004204ced:	41 ff d0             	callq  *%r8
	assert(page2pa(pp1) < npages*PGSIZE);
  8004204cf0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204cf4:	48 89 c7             	mov    %rax,%rdi
  8004204cf7:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  8004204cfe:	00 00 00 
  8004204d01:	ff d0                	callq  *%rax
  8004204d03:	48 ba b0 17 36 04 80 	movabs $0x80043617b0,%rdx
  8004204d0a:	00 00 00 
  8004204d0d:	48 8b 12             	mov    (%rdx),%rdx
  8004204d10:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204d14:	48 39 d0             	cmp    %rdx,%rax
  8004204d17:	72 35                	jb     8004204d4e <check_page_alloc+0x50d>
  8004204d19:	48 b9 85 7c 21 04 80 	movabs $0x8004217c85,%rcx
  8004204d20:	00 00 00 
  8004204d23:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204d2a:	00 00 00 
  8004204d2d:	be 38 04 00 00       	mov    $0x438,%esi
  8004204d32:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204d39:	00 00 00 
  8004204d3c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d41:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204d48:	00 00 00 
  8004204d4b:	41 ff d0             	callq  *%r8
	assert(page2pa(pp2) < npages*PGSIZE);
  8004204d4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204d52:	48 89 c7             	mov    %rax,%rdi
  8004204d55:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  8004204d5c:	00 00 00 
  8004204d5f:	ff d0                	callq  *%rax
  8004204d61:	48 ba b0 17 36 04 80 	movabs $0x80043617b0,%rdx
  8004204d68:	00 00 00 
  8004204d6b:	48 8b 12             	mov    (%rdx),%rdx
  8004204d6e:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204d72:	48 39 d0             	cmp    %rdx,%rax
  8004204d75:	72 35                	jb     8004204dac <check_page_alloc+0x56b>
  8004204d77:	48 b9 a2 7c 21 04 80 	movabs $0x8004217ca2,%rcx
  8004204d7e:	00 00 00 
  8004204d81:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204d88:	00 00 00 
  8004204d8b:	be 39 04 00 00       	mov    $0x439,%esi
  8004204d90:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204d97:	00 00 00 
  8004204d9a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d9f:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204da6:	00 00 00 
  8004204da9:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004204dac:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  8004204db3:	00 00 00 
  8004204db6:	48 8b 00             	mov    (%rax),%rax
  8004204db9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	page_free_list = 0;
  8004204dbd:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  8004204dc4:	00 00 00 
  8004204dc7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004204dce:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204dd3:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  8004204dda:	00 00 00 
  8004204ddd:	ff d0                	callq  *%rax
  8004204ddf:	48 85 c0             	test   %rax,%rax
  8004204de2:	74 35                	je     8004204e19 <check_page_alloc+0x5d8>
  8004204de4:	48 b9 bf 7c 21 04 80 	movabs $0x8004217cbf,%rcx
  8004204deb:	00 00 00 
  8004204dee:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204df5:	00 00 00 
  8004204df8:	be 40 04 00 00       	mov    $0x440,%esi
  8004204dfd:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204e04:	00 00 00 
  8004204e07:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e0c:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204e13:	00 00 00 
  8004204e16:	41 ff d0             	callq  *%r8

	// free and re-allocate?
	page_free(pp0);
  8004204e19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204e1d:	48 89 c7             	mov    %rax,%rdi
  8004204e20:	48 b8 1e 36 20 04 80 	movabs $0x800420361e,%rax
  8004204e27:	00 00 00 
  8004204e2a:	ff d0                	callq  *%rax
	page_free(pp1);
  8004204e2c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204e30:	48 89 c7             	mov    %rax,%rdi
  8004204e33:	48 b8 1e 36 20 04 80 	movabs $0x800420361e,%rax
  8004204e3a:	00 00 00 
  8004204e3d:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204e3f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204e43:	48 89 c7             	mov    %rax,%rdi
  8004204e46:	48 b8 1e 36 20 04 80 	movabs $0x800420361e,%rax
  8004204e4d:	00 00 00 
  8004204e50:	ff d0                	callq  *%rax
	pp0 = pp1 = pp2 = 0;
  8004204e52:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204e59:	00 
  8004204e5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204e5e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204e62:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204e66:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204e6a:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204e6f:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  8004204e76:	00 00 00 
  8004204e79:	ff d0                	callq  *%rax
  8004204e7b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204e7f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204e84:	75 35                	jne    8004204ebb <check_page_alloc+0x67a>
  8004204e86:	48 b9 ef 7b 21 04 80 	movabs $0x8004217bef,%rcx
  8004204e8d:	00 00 00 
  8004204e90:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204e97:	00 00 00 
  8004204e9a:	be 47 04 00 00       	mov    $0x447,%esi
  8004204e9f:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204ea6:	00 00 00 
  8004204ea9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204eae:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204eb5:	00 00 00 
  8004204eb8:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004204ebb:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204ec0:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  8004204ec7:	00 00 00 
  8004204eca:	ff d0                	callq  *%rax
  8004204ecc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204ed0:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204ed5:	75 35                	jne    8004204f0c <check_page_alloc+0x6cb>
  8004204ed7:	48 b9 05 7c 21 04 80 	movabs $0x8004217c05,%rcx
  8004204ede:	00 00 00 
  8004204ee1:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204ee8:	00 00 00 
  8004204eeb:	be 48 04 00 00       	mov    $0x448,%esi
  8004204ef0:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204ef7:	00 00 00 
  8004204efa:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204eff:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204f06:	00 00 00 
  8004204f09:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004204f0c:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204f11:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  8004204f18:	00 00 00 
  8004204f1b:	ff d0                	callq  *%rax
  8004204f1d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204f21:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204f26:	75 35                	jne    8004204f5d <check_page_alloc+0x71c>
  8004204f28:	48 b9 1b 7c 21 04 80 	movabs $0x8004217c1b,%rcx
  8004204f2f:	00 00 00 
  8004204f32:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204f39:	00 00 00 
  8004204f3c:	be 49 04 00 00       	mov    $0x449,%esi
  8004204f41:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204f48:	00 00 00 
  8004204f4b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f50:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204f57:	00 00 00 
  8004204f5a:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204f5d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204f62:	75 35                	jne    8004204f99 <check_page_alloc+0x758>
  8004204f64:	48 b9 31 7c 21 04 80 	movabs $0x8004217c31,%rcx
  8004204f6b:	00 00 00 
  8004204f6e:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204f75:	00 00 00 
  8004204f78:	be 4a 04 00 00       	mov    $0x44a,%esi
  8004204f7d:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204f84:	00 00 00 
  8004204f87:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f8c:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204f93:	00 00 00 
  8004204f96:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204f99:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204f9e:	74 0a                	je     8004204faa <check_page_alloc+0x769>
  8004204fa0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204fa4:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204fa8:	75 35                	jne    8004204fdf <check_page_alloc+0x79e>
  8004204faa:	48 b9 35 7c 21 04 80 	movabs $0x8004217c35,%rcx
  8004204fb1:	00 00 00 
  8004204fb4:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004204fbb:	00 00 00 
  8004204fbe:	be 4b 04 00 00       	mov    $0x44b,%esi
  8004204fc3:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004204fca:	00 00 00 
  8004204fcd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204fd2:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004204fd9:	00 00 00 
  8004204fdc:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204fdf:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204fe4:	74 14                	je     8004204ffa <check_page_alloc+0x7b9>
  8004204fe6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204fea:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204fee:	74 0a                	je     8004204ffa <check_page_alloc+0x7b9>
  8004204ff0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204ff4:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204ff8:	75 35                	jne    800420502f <check_page_alloc+0x7ee>
  8004204ffa:	48 b9 48 7c 21 04 80 	movabs $0x8004217c48,%rcx
  8004205001:	00 00 00 
  8004205004:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  800420500b:	00 00 00 
  800420500e:	be 4c 04 00 00       	mov    $0x44c,%esi
  8004205013:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420501a:	00 00 00 
  800420501d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205022:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205029:	00 00 00 
  800420502c:	41 ff d0             	callq  *%r8
	assert(!page_alloc(0));
  800420502f:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205034:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  800420503b:	00 00 00 
  800420503e:	ff d0                	callq  *%rax
  8004205040:	48 85 c0             	test   %rax,%rax
  8004205043:	74 35                	je     800420507a <check_page_alloc+0x839>
  8004205045:	48 b9 bf 7c 21 04 80 	movabs $0x8004217cbf,%rcx
  800420504c:	00 00 00 
  800420504f:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004205056:	00 00 00 
  8004205059:	be 4d 04 00 00       	mov    $0x44d,%esi
  800420505e:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205065:	00 00 00 
  8004205068:	b8 00 00 00 00       	mov    $0x0,%eax
  800420506d:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205074:	00 00 00 
  8004205077:	41 ff d0             	callq  *%r8

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
  800420507a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420507e:	48 89 c7             	mov    %rax,%rdi
  8004205081:	48 b8 9c 23 20 04 80 	movabs $0x800420239c,%rax
  8004205088:	00 00 00 
  800420508b:	ff d0                	callq  *%rax
  800420508d:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205092:	be 01 00 00 00       	mov    $0x1,%esi
  8004205097:	48 89 c7             	mov    %rax,%rdi
  800420509a:	48 b8 b3 fb 20 04 80 	movabs $0x800420fbb3,%rax
  80042050a1:	00 00 00 
  80042050a4:	ff d0                	callq  *%rax
	page_free(pp0);
  80042050a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042050aa:	48 89 c7             	mov    %rax,%rdi
  80042050ad:	48 b8 1e 36 20 04 80 	movabs $0x800420361e,%rax
  80042050b4:	00 00 00 
  80042050b7:	ff d0                	callq  *%rax
	assert((pp = page_alloc(ALLOC_ZERO)));
  80042050b9:	bf 01 00 00 00       	mov    $0x1,%edi
  80042050be:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  80042050c5:	00 00 00 
  80042050c8:	ff d0                	callq  *%rax
  80042050ca:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042050ce:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042050d3:	75 35                	jne    800420510a <check_page_alloc+0x8c9>
  80042050d5:	48 b9 ce 7c 21 04 80 	movabs $0x8004217cce,%rcx
  80042050dc:	00 00 00 
  80042050df:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042050e6:	00 00 00 
  80042050e9:	be 52 04 00 00       	mov    $0x452,%esi
  80042050ee:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042050f5:	00 00 00 
  80042050f8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050fd:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205104:	00 00 00 
  8004205107:	41 ff d0             	callq  *%r8
	assert(pp && pp0 == pp);
  800420510a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420510f:	74 0a                	je     800420511b <check_page_alloc+0x8da>
  8004205111:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205115:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205119:	74 35                	je     8004205150 <check_page_alloc+0x90f>
  800420511b:	48 b9 ec 7c 21 04 80 	movabs $0x8004217cec,%rcx
  8004205122:	00 00 00 
  8004205125:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  800420512c:	00 00 00 
  800420512f:	be 53 04 00 00       	mov    $0x453,%esi
  8004205134:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420513b:	00 00 00 
  800420513e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205143:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420514a:	00 00 00 
  800420514d:	41 ff d0             	callq  *%r8
	c = page2kva(pp);
  8004205150:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205154:	48 89 c7             	mov    %rax,%rdi
  8004205157:	48 b8 9c 23 20 04 80 	movabs $0x800420239c,%rax
  800420515e:	00 00 00 
  8004205161:	ff d0                	callq  *%rax
  8004205163:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < PGSIZE; i++)
  8004205167:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  800420516e:	eb 4d                	jmp    80042051bd <check_page_alloc+0x97c>
		assert(c[i] == 0);
  8004205170:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004205173:	48 63 d0             	movslq %eax,%rdx
  8004205176:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420517a:	48 01 d0             	add    %rdx,%rax
  800420517d:	0f b6 00             	movzbl (%rax),%eax
  8004205180:	84 c0                	test   %al,%al
  8004205182:	74 35                	je     80042051b9 <check_page_alloc+0x978>
  8004205184:	48 b9 fc 7c 21 04 80 	movabs $0x8004217cfc,%rcx
  800420518b:	00 00 00 
  800420518e:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004205195:	00 00 00 
  8004205198:	be 56 04 00 00       	mov    $0x456,%esi
  800420519d:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042051a4:	00 00 00 
  80042051a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042051ac:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042051b3:	00 00 00 
  80042051b6:	41 ff d0             	callq  *%r8
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
  80042051b9:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042051bd:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  80042051c4:	7e aa                	jle    8004205170 <check_page_alloc+0x92f>
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;
  80042051c6:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  80042051cd:	00 00 00 
  80042051d0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042051d4:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_free(pp0);
  80042051d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042051db:	48 89 c7             	mov    %rax,%rdi
  80042051de:	48 b8 1e 36 20 04 80 	movabs $0x800420361e,%rax
  80042051e5:	00 00 00 
  80042051e8:	ff d0                	callq  *%rax
	page_free(pp1);
  80042051ea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042051ee:	48 89 c7             	mov    %rax,%rdi
  80042051f1:	48 b8 1e 36 20 04 80 	movabs $0x800420361e,%rax
  80042051f8:	00 00 00 
  80042051fb:	ff d0                	callq  *%rax
	page_free(pp2);
  80042051fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205201:	48 89 c7             	mov    %rax,%rdi
  8004205204:	48 b8 1e 36 20 04 80 	movabs $0x800420361e,%rax
  800420520b:	00 00 00 
  800420520e:	ff d0                	callq  *%rax

	cprintf("check_page_alloc() succeeded!\n");
  8004205210:	48 bf 08 7d 21 04 80 	movabs $0x8004217d08,%rdi
  8004205217:	00 00 00 
  800420521a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420521f:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004205226:	00 00 00 
  8004205229:	ff d2                	callq  *%rdx
}
  800420522b:	c9                   	leaveq 
  800420522c:	c3                   	retq   

000000800420522d <check_boot_pml4e>:
// but it is a pretty good sanity check.
//

static void
check_boot_pml4e(pml4e_t *pml4e)
{
  800420522d:	55                   	push   %rbp
  800420522e:	48 89 e5             	mov    %rsp,%rbp
  8004205231:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004205238:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
	uint64_t i, n;

	pml4e = boot_pml4e;
  800420523f:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004205246:	00 00 00 
  8004205249:	48 8b 00             	mov    (%rax),%rax
  800420524c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  8004205250:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8004205257:	00 
  8004205258:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  800420525f:	00 00 00 
  8004205262:	48 8b 00             	mov    (%rax),%rax
  8004205265:	48 c1 e0 04          	shl    $0x4,%rax
  8004205269:	48 89 c2             	mov    %rax,%rdx
  800420526c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205270:	48 01 d0             	add    %rdx,%rax
  8004205273:	48 83 e8 01          	sub    $0x1,%rax
  8004205277:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420527b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420527f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205284:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004205288:	48 89 d0             	mov    %rdx,%rax
  800420528b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420528f:	48 29 c2             	sub    %rax,%rdx
  8004205292:	48 89 d0             	mov    %rdx,%rax
  8004205295:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE) {
  8004205299:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042052a0:	00 
  80042052a1:	e9 d4 00 00 00       	jmpq   800420537a <check_boot_pml4e+0x14d>
		 //cprintf("%x %x %x %x %x\n", UPAGES, pml4e, i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  80042052a6:	48 ba 00 00 a0 00 80 	movabs $0x8000a00000,%rdx
  80042052ad:	00 00 00 
  80042052b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042052b4:	48 01 c2             	add    %rax,%rdx
  80042052b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042052bb:	48 89 d6             	mov    %rdx,%rsi
  80042052be:	48 89 c7             	mov    %rax,%rdi
  80042052c1:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  80042052c8:	00 00 00 
  80042052cb:	ff d0                	callq  *%rax
  80042052cd:	48 ba b8 17 36 04 80 	movabs $0x80043617b8,%rdx
  80042052d4:	00 00 00 
  80042052d7:	48 8b 12             	mov    (%rdx),%rdx
  80042052da:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  80042052de:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  80042052e5:	00 00 00 
  80042052e8:	48 39 55 d0          	cmp    %rdx,-0x30(%rbp)
  80042052ec:	77 32                	ja     8004205320 <check_boot_pml4e+0xf3>
  80042052ee:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042052f2:	48 89 c1             	mov    %rax,%rcx
  80042052f5:	48 ba 58 79 21 04 80 	movabs $0x8004217958,%rdx
  80042052fc:	00 00 00 
  80042052ff:	be 76 04 00 00       	mov    $0x476,%esi
  8004205304:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420530b:	00 00 00 
  800420530e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205313:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420531a:	00 00 00 
  800420531d:	41 ff d0             	callq  *%r8
  8004205320:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004205327:	ff ff ff 
  800420532a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420532e:	48 01 d1             	add    %rdx,%rcx
  8004205331:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004205335:	48 01 ca             	add    %rcx,%rdx
  8004205338:	48 39 d0             	cmp    %rdx,%rax
  800420533b:	74 35                	je     8004205372 <check_boot_pml4e+0x145>
  800420533d:	48 b9 28 7d 21 04 80 	movabs $0x8004217d28,%rcx
  8004205344:	00 00 00 
  8004205347:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  800420534e:	00 00 00 
  8004205351:	be 76 04 00 00       	mov    $0x476,%esi
  8004205356:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420535d:	00 00 00 
  8004205360:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205365:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420536c:	00 00 00 
  800420536f:	41 ff d0             	callq  *%r8

	pml4e = boot_pml4e;

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
	for (i = 0; i < n; i += PGSIZE) {
  8004205372:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205379:	00 
  800420537a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420537e:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004205382:	0f 82 1e ff ff ff    	jb     80042052a6 <check_boot_pml4e+0x79>
		 //cprintf("%x %x %x %x %x\n", UPAGES, pml4e, i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  8004205388:	48 c7 45 c8 00 10 00 	movq   $0x1000,-0x38(%rbp)
  800420538f:	00 
  8004205390:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205394:	48 05 ff 7f 04 00    	add    $0x47fff,%rax
  800420539a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800420539e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042053a2:	ba 00 00 00 00       	mov    $0x0,%edx
  80042053a7:	48 f7 75 c8          	divq   -0x38(%rbp)
  80042053ab:	48 89 d0             	mov    %rdx,%rax
  80042053ae:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042053b2:	48 29 c2             	sub    %rax,%rdx
  80042053b5:	48 89 d0             	mov    %rdx,%rax
  80042053b8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE)
  80042053bc:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042053c3:	00 
  80042053c4:	e9 d4 00 00 00       	jmpq   800420549d <check_boot_pml4e+0x270>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  80042053c9:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  80042053d0:	00 00 00 
  80042053d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042053d7:	48 01 c2             	add    %rax,%rdx
  80042053da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042053de:	48 89 d6             	mov    %rdx,%rsi
  80042053e1:	48 89 c7             	mov    %rax,%rdi
  80042053e4:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  80042053eb:	00 00 00 
  80042053ee:	ff d0                	callq  *%rax
  80042053f0:	48 ba 50 02 36 04 80 	movabs $0x8004360250,%rdx
  80042053f7:	00 00 00 
  80042053fa:	48 8b 12             	mov    (%rdx),%rdx
  80042053fd:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004205401:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004205408:	00 00 00 
  800420540b:	48 39 55 b8          	cmp    %rdx,-0x48(%rbp)
  800420540f:	77 32                	ja     8004205443 <check_boot_pml4e+0x216>
  8004205411:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205415:	48 89 c1             	mov    %rax,%rcx
  8004205418:	48 ba 58 79 21 04 80 	movabs $0x8004217958,%rdx
  800420541f:	00 00 00 
  8004205422:	be 7c 04 00 00       	mov    $0x47c,%esi
  8004205427:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420542e:	00 00 00 
  8004205431:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205436:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420543d:	00 00 00 
  8004205440:	41 ff d0             	callq  *%r8
  8004205443:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  800420544a:	ff ff ff 
  800420544d:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004205451:	48 01 d1             	add    %rdx,%rcx
  8004205454:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004205458:	48 01 ca             	add    %rcx,%rdx
  800420545b:	48 39 d0             	cmp    %rdx,%rax
  800420545e:	74 35                	je     8004205495 <check_boot_pml4e+0x268>
  8004205460:	48 b9 60 7d 21 04 80 	movabs $0x8004217d60,%rcx
  8004205467:	00 00 00 
  800420546a:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004205471:	00 00 00 
  8004205474:	be 7c 04 00 00       	mov    $0x47c,%esi
  8004205479:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205480:	00 00 00 
  8004205483:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205488:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420548f:	00 00 00 
  8004205492:	41 ff d0             	callq  *%r8
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
  8004205495:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  800420549c:	00 
  800420549d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042054a1:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80042054a5:	0f 82 1e ff ff ff    	jb     80042053c9 <check_boot_pml4e+0x19c>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  80042054ab:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042054b2:	00 
  80042054b3:	eb 6a                	jmp    800420551f <check_boot_pml4e+0x2f2>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);
  80042054b5:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042054bc:	00 00 00 
  80042054bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042054c3:	48 01 c2             	add    %rax,%rdx
  80042054c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042054ca:	48 89 d6             	mov    %rdx,%rsi
  80042054cd:	48 89 c7             	mov    %rax,%rdi
  80042054d0:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  80042054d7:	00 00 00 
  80042054da:	ff d0                	callq  *%rax
  80042054dc:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042054e0:	74 35                	je     8004205517 <check_boot_pml4e+0x2ea>
  80042054e2:	48 b9 98 7d 21 04 80 	movabs $0x8004217d98,%rcx
  80042054e9:	00 00 00 
  80042054ec:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042054f3:	00 00 00 
  80042054f6:	be 80 04 00 00       	mov    $0x480,%esi
  80042054fb:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205502:	00 00 00 
  8004205505:	b8 00 00 00 00       	mov    $0x0,%eax
  800420550a:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205511:	00 00 00 
  8004205514:	41 ff d0             	callq  *%r8
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004205517:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  800420551e:	00 
  800420551f:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004205526:	00 00 00 
  8004205529:	48 8b 00             	mov    (%rax),%rax
  800420552c:	48 c1 e0 0c          	shl    $0xc,%rax
  8004205530:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004205534:	0f 87 7b ff ff ff    	ja     80042054b5 <check_boot_pml4e+0x288>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  800420553a:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004205541:	00 
  8004205542:	e9 a1 01 00 00       	jmpq   80042056e8 <check_boot_pml4e+0x4bb>
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
  8004205547:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420554b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420554f:	48 89 d0             	mov    %rdx,%rax
  8004205552:	48 01 c0             	add    %rax,%rax
  8004205555:	48 01 d0             	add    %rdx,%rax
  8004205558:	48 c1 e0 0f          	shl    $0xf,%rax
  800420555c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205563:	00 00 00 
  8004205566:	48 29 c2             	sub    %rax,%rdx
  8004205569:	48 89 d0             	mov    %rdx,%rax
  800420556c:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004205570:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205577:	00 
  8004205578:	e9 e0 00 00 00       	jmpq   800420565d <check_boot_pml4e+0x430>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
  800420557d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205581:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004205585:	48 01 d0             	add    %rdx,%rax
  8004205588:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  800420558f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205593:	48 89 d6             	mov    %rdx,%rsi
  8004205596:	48 89 c7             	mov    %rax,%rdi
  8004205599:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  80042055a0:	00 00 00 
  80042055a3:	ff d0                	callq  *%rax
  80042055a5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042055a9:	48 89 d1             	mov    %rdx,%rcx
  80042055ac:	48 c1 e1 10          	shl    $0x10,%rcx
  80042055b0:	48 ba 00 40 36 04 80 	movabs $0x8004364000,%rdx
  80042055b7:	00 00 00 
  80042055ba:	48 01 ca             	add    %rcx,%rdx
  80042055bd:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  80042055c1:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  80042055c8:	00 00 00 
  80042055cb:	48 39 55 a8          	cmp    %rdx,-0x58(%rbp)
  80042055cf:	77 32                	ja     8004205603 <check_boot_pml4e+0x3d6>
  80042055d1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042055d5:	48 89 c1             	mov    %rax,%rcx
  80042055d8:	48 ba 58 79 21 04 80 	movabs $0x8004217958,%rdx
  80042055df:	00 00 00 
  80042055e2:	be 88 04 00 00       	mov    $0x488,%esi
  80042055e7:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042055ee:	00 00 00 
  80042055f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042055f6:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042055fd:	00 00 00 
  8004205600:	41 ff d0             	callq  *%r8
  8004205603:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  800420560a:	ff ff ff 
  800420560d:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004205611:	48 01 d1             	add    %rdx,%rcx
  8004205614:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004205618:	48 01 ca             	add    %rcx,%rdx
  800420561b:	48 39 d0             	cmp    %rdx,%rax
  800420561e:	74 35                	je     8004205655 <check_boot_pml4e+0x428>
  8004205620:	48 b9 c0 7d 21 04 80 	movabs $0x8004217dc0,%rcx
  8004205627:	00 00 00 
  800420562a:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004205631:	00 00 00 
  8004205634:	be 88 04 00 00       	mov    $0x488,%esi
  8004205639:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205640:	00 00 00 
  8004205643:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205648:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420564f:	00 00 00 
  8004205652:	41 ff d0             	callq  *%r8

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004205655:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  800420565c:	00 
  800420565d:	48 81 7d f8 ff ff 00 	cmpq   $0xffff,-0x8(%rbp)
  8004205664:	00 
  8004205665:	0f 86 12 ff ff ff    	jbe    800420557d <check_boot_pml4e+0x350>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  800420566b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205672:	00 
  8004205673:	eb 64                	jmp    80042056d9 <check_boot_pml4e+0x4ac>
			assert(check_va2pa(pml4e, base + i) == ~0);
  8004205675:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205679:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420567d:	48 01 c2             	add    %rax,%rdx
  8004205680:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205684:	48 89 d6             	mov    %rdx,%rsi
  8004205687:	48 89 c7             	mov    %rax,%rdi
  800420568a:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  8004205691:	00 00 00 
  8004205694:	ff d0                	callq  *%rax
  8004205696:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  800420569a:	74 35                	je     80042056d1 <check_boot_pml4e+0x4a4>
  800420569c:	48 b9 08 7e 21 04 80 	movabs $0x8004217e08,%rcx
  80042056a3:	00 00 00 
  80042056a6:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042056ad:	00 00 00 
  80042056b0:	be 8a 04 00 00       	mov    $0x48a,%esi
  80042056b5:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042056bc:	00 00 00 
  80042056bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042056c4:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042056cb:	00 00 00 
  80042056ce:	41 ff d0             	callq  *%r8
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  80042056d1:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042056d8:	00 
  80042056d9:	48 81 7d f8 ff 7f 00 	cmpq   $0x7fff,-0x8(%rbp)
  80042056e0:	00 
  80042056e1:	76 92                	jbe    8004205675 <check_boot_pml4e+0x448>
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  80042056e3:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  80042056e8:	48 83 7d f0 07       	cmpq   $0x7,-0x10(%rbp)
  80042056ed:	0f 86 54 fe ff ff    	jbe    8004205547 <check_boot_pml4e+0x31a>
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
			assert(check_va2pa(pml4e, base + i) == ~0);
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  80042056f3:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  80042056fa:	00 00 00 
  80042056fd:	48 8b 00             	mov    (%rax),%rax
  8004205700:	48 83 c0 08          	add    $0x8,%rax
  8004205704:	48 8b 00             	mov    (%rax),%rax
  8004205707:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420570d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004205711:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205715:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205719:	89 45 9c             	mov    %eax,-0x64(%rbp)
  800420571c:	8b 55 9c             	mov    -0x64(%rbp),%edx
  800420571f:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004205726:	00 00 00 
  8004205729:	48 8b 00             	mov    (%rax),%rax
  800420572c:	48 39 c2             	cmp    %rax,%rdx
  800420572f:	72 32                	jb     8004205763 <check_boot_pml4e+0x536>
  8004205731:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205735:	48 89 c1             	mov    %rax,%rcx
  8004205738:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  800420573f:	00 00 00 
  8004205742:	be 8d 04 00 00       	mov    $0x48d,%esi
  8004205747:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420574e:	00 00 00 
  8004205751:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205756:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420575d:	00 00 00 
  8004205760:	41 ff d0             	callq  *%r8
  8004205763:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420576a:	00 00 00 
  800420576d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205771:	48 01 d0             	add    %rdx,%rax
  8004205774:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004205778:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420577c:	48 8b 00             	mov    (%rax),%rax
  800420577f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205785:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004205789:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800420578d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205791:	89 45 84             	mov    %eax,-0x7c(%rbp)
  8004205794:	8b 55 84             	mov    -0x7c(%rbp),%edx
  8004205797:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  800420579e:	00 00 00 
  80042057a1:	48 8b 00             	mov    (%rax),%rax
  80042057a4:	48 39 c2             	cmp    %rax,%rdx
  80042057a7:	72 32                	jb     80042057db <check_boot_pml4e+0x5ae>
  80042057a9:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042057ad:	48 89 c1             	mov    %rax,%rcx
  80042057b0:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  80042057b7:	00 00 00 
  80042057ba:	be 8e 04 00 00       	mov    $0x48e,%esi
  80042057bf:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042057c6:	00 00 00 
  80042057c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042057ce:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042057d5:	00 00 00 
  80042057d8:	41 ff d0             	callq  *%r8
  80042057db:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042057e2:	00 00 00 
  80042057e5:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042057e9:	48 01 d0             	add    %rdx,%rax
  80042057ec:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  80042057f3:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042057fa:	00 
  80042057fb:	e9 50 01 00 00       	jmpq   8004205950 <check_boot_pml4e+0x723>
		switch (i) {
  8004205800:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205804:	48 83 f8 04          	cmp    $0x4,%rax
  8004205808:	72 67                	jb     8004205871 <check_boot_pml4e+0x644>
  800420580a:	48 83 f8 05          	cmp    $0x5,%rax
  800420580e:	76 06                	jbe    8004205816 <check_boot_pml4e+0x5e9>
  8004205810:	48 83 f8 1f          	cmp    $0x1f,%rax
  8004205814:	75 5b                	jne    8004205871 <check_boot_pml4e+0x644>
			//case PDX(UVPT):
			case PDX(KSTACKTOP - 1):
			case PDX(UPAGES):
			case PDX(UENVS):
				assert(pgdir[i] & PTE_P);
  8004205816:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420581a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205821:	00 
  8004205822:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205829:	48 01 d0             	add    %rdx,%rax
  800420582c:	48 8b 00             	mov    (%rax),%rax
  800420582f:	83 e0 01             	and    $0x1,%eax
  8004205832:	48 85 c0             	test   %rax,%rax
  8004205835:	75 35                	jne    800420586c <check_boot_pml4e+0x63f>
  8004205837:	48 b9 2b 7e 21 04 80 	movabs $0x8004217e2b,%rcx
  800420583e:	00 00 00 
  8004205841:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004205848:	00 00 00 
  800420584b:	be 96 04 00 00       	mov    $0x496,%esi
  8004205850:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205857:	00 00 00 
  800420585a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420585f:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205866:	00 00 00 
  8004205869:	41 ff d0             	callq  *%r8
				break;
  800420586c:	e9 da 00 00 00       	jmpq   800420594b <check_boot_pml4e+0x71e>
			default:
				if (i >= PDX(KERNBASE)) {
  8004205871:	48 83 7d f8 1f       	cmpq   $0x1f,-0x8(%rbp)
  8004205876:	0f 86 ce 00 00 00    	jbe    800420594a <check_boot_pml4e+0x71d>
					if (pgdir[i] & PTE_P)
  800420587c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205880:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205887:	00 
  8004205888:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420588f:	48 01 d0             	add    %rdx,%rax
  8004205892:	48 8b 00             	mov    (%rax),%rax
  8004205895:	83 e0 01             	and    $0x1,%eax
  8004205898:	48 85 c0             	test   %rax,%rax
  800420589b:	74 5a                	je     80042058f7 <check_boot_pml4e+0x6ca>
                        assert(pgdir[i] & PTE_W);
  800420589d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042058a1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042058a8:	00 
  80042058a9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042058b0:	48 01 d0             	add    %rdx,%rax
  80042058b3:	48 8b 00             	mov    (%rax),%rax
  80042058b6:	83 e0 02             	and    $0x2,%eax
  80042058b9:	48 85 c0             	test   %rax,%rax
  80042058bc:	0f 85 88 00 00 00    	jne    800420594a <check_boot_pml4e+0x71d>
  80042058c2:	48 b9 3c 7e 21 04 80 	movabs $0x8004217e3c,%rcx
  80042058c9:	00 00 00 
  80042058cc:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042058d3:	00 00 00 
  80042058d6:	be 9b 04 00 00       	mov    $0x49b,%esi
  80042058db:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042058e2:	00 00 00 
  80042058e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042058ea:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042058f1:	00 00 00 
  80042058f4:	41 ff d0             	callq  *%r8
                    else
                        assert(pgdir[i] == 0);
  80042058f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042058fb:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205902:	00 
  8004205903:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420590a:	48 01 d0             	add    %rdx,%rax
  800420590d:	48 8b 00             	mov    (%rax),%rax
  8004205910:	48 85 c0             	test   %rax,%rax
  8004205913:	74 35                	je     800420594a <check_boot_pml4e+0x71d>
  8004205915:	48 b9 4d 7e 21 04 80 	movabs $0x8004217e4d,%rcx
  800420591c:	00 00 00 
  800420591f:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004205926:	00 00 00 
  8004205929:	be 9d 04 00 00       	mov    $0x49d,%esi
  800420592e:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205935:	00 00 00 
  8004205938:	b8 00 00 00 00       	mov    $0x0,%eax
  800420593d:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205944:	00 00 00 
  8004205947:	41 ff d0             	callq  *%r8
				} 
				break;
  800420594a:	90                   	nop
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  800420594b:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004205950:	48 81 7d f8 ff 01 00 	cmpq   $0x1ff,-0x8(%rbp)
  8004205957:	00 
  8004205958:	0f 86 a2 fe ff ff    	jbe    8004205800 <check_boot_pml4e+0x5d3>
                        assert(pgdir[i] == 0);
				} 
				break;
		}
	}
	cprintf("check_boot_pml4e() succeeded!\n");
  800420595e:	48 bf 60 7e 21 04 80 	movabs $0x8004217e60,%rdi
  8004205965:	00 00 00 
  8004205968:	b8 00 00 00 00       	mov    $0x0,%eax
  800420596d:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004205974:	00 00 00 
  8004205977:	ff d2                	callq  *%rdx
}
  8004205979:	c9                   	leaveq 
  800420597a:	c3                   	retq   

000000800420597b <check_va2pa>:
// this functionality for us!  We define our own version to help check
// the check_boot_pml4e() function; it shouldn't be used elsewhere.

	static physaddr_t
check_va2pa(pml4e_t *pml4e, uintptr_t va)
{
  800420597b:	55                   	push   %rbp
  800420597c:	48 89 e5             	mov    %rsp,%rbp
  800420597f:	48 83 ec 60          	sub    $0x60,%rsp
  8004205983:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004205987:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	pte_t *pte;
	pdpe_t *pdpe;
	pde_t *pde;
	pml4e = &pml4e[PML4(va)];
  800420598b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420598f:	48 c1 e8 27          	shr    $0x27,%rax
  8004205993:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205998:	48 c1 e0 03          	shl    $0x3,%rax
  800420599c:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	if(!(*pml4e & PTE_P))
  80042059a0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042059a4:	48 8b 00             	mov    (%rax),%rax
  80042059a7:	83 e0 01             	and    $0x1,%eax
  80042059aa:	48 85 c0             	test   %rax,%rax
  80042059ad:	75 0c                	jne    80042059bb <check_va2pa+0x40>
		return ~0;
  80042059af:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80042059b6:	e9 38 02 00 00       	jmpq   8004205bf3 <check_va2pa+0x278>
	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  80042059bb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042059bf:	48 8b 00             	mov    (%rax),%rax
  80042059c2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042059c8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042059cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042059d0:	48 c1 e8 0c          	shr    $0xc,%rax
  80042059d4:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042059d7:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042059da:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  80042059e1:	00 00 00 
  80042059e4:	48 8b 00             	mov    (%rax),%rax
  80042059e7:	48 39 c2             	cmp    %rax,%rdx
  80042059ea:	72 32                	jb     8004205a1e <check_va2pa+0xa3>
  80042059ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042059f0:	48 89 c1             	mov    %rax,%rcx
  80042059f3:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  80042059fa:	00 00 00 
  80042059fd:	be b3 04 00 00       	mov    $0x4b3,%esi
  8004205a02:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205a09:	00 00 00 
  8004205a0c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a11:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205a18:	00 00 00 
  8004205a1b:	41 ff d0             	callq  *%r8
  8004205a1e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205a25:	00 00 00 
  8004205a28:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205a2c:	48 01 d0             	add    %rdx,%rax
  8004205a2f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// cprintf(" %x %x " , pdpe, *pdpe);
	if (!(pdpe[PDPE(va)] & PTE_P))
  8004205a33:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205a37:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205a3b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205a40:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205a47:	00 
  8004205a48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205a4c:	48 01 d0             	add    %rdx,%rax
  8004205a4f:	48 8b 00             	mov    (%rax),%rax
  8004205a52:	83 e0 01             	and    $0x1,%eax
  8004205a55:	48 85 c0             	test   %rax,%rax
  8004205a58:	75 0c                	jne    8004205a66 <check_va2pa+0xeb>
		return ~0;
  8004205a5a:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205a61:	e9 8d 01 00 00       	jmpq   8004205bf3 <check_va2pa+0x278>
	pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004205a66:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205a6a:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205a6e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205a73:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205a7a:	00 
  8004205a7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205a7f:	48 01 d0             	add    %rdx,%rax
  8004205a82:	48 8b 00             	mov    (%rax),%rax
  8004205a85:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205a8b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205a8f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a93:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205a97:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004205a9a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004205a9d:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004205aa4:	00 00 00 
  8004205aa7:	48 8b 00             	mov    (%rax),%rax
  8004205aaa:	48 39 c2             	cmp    %rax,%rdx
  8004205aad:	72 32                	jb     8004205ae1 <check_va2pa+0x166>
  8004205aaf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205ab3:	48 89 c1             	mov    %rax,%rcx
  8004205ab6:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  8004205abd:	00 00 00 
  8004205ac0:	be b7 04 00 00       	mov    $0x4b7,%esi
  8004205ac5:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205acc:	00 00 00 
  8004205acf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ad4:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205adb:	00 00 00 
  8004205ade:	41 ff d0             	callq  *%r8
  8004205ae1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205ae8:	00 00 00 
  8004205aeb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205aef:	48 01 d0             	add    %rdx,%rax
  8004205af2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	 //cprintf(" %x %x " , pde, *pde);
	pde = &pde[PDX(va)];
  8004205af6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205afa:	48 c1 e8 15          	shr    $0x15,%rax
  8004205afe:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205b03:	48 c1 e0 03          	shl    $0x3,%rax
  8004205b07:	48 01 45 d0          	add    %rax,-0x30(%rbp)
	if (!(*pde & PTE_P))
  8004205b0b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205b0f:	48 8b 00             	mov    (%rax),%rax
  8004205b12:	83 e0 01             	and    $0x1,%eax
  8004205b15:	48 85 c0             	test   %rax,%rax
  8004205b18:	75 0c                	jne    8004205b26 <check_va2pa+0x1ab>
		return ~0;
  8004205b1a:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205b21:	e9 cd 00 00 00       	jmpq   8004205bf3 <check_va2pa+0x278>
	pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  8004205b26:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205b2a:	48 8b 00             	mov    (%rax),%rax
  8004205b2d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205b33:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205b37:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205b3b:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205b3f:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004205b42:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004205b45:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004205b4c:	00 00 00 
  8004205b4f:	48 8b 00             	mov    (%rax),%rax
  8004205b52:	48 39 c2             	cmp    %rax,%rdx
  8004205b55:	72 32                	jb     8004205b89 <check_va2pa+0x20e>
  8004205b57:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205b5b:	48 89 c1             	mov    %rax,%rcx
  8004205b5e:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  8004205b65:	00 00 00 
  8004205b68:	be bc 04 00 00       	mov    $0x4bc,%esi
  8004205b6d:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205b74:	00 00 00 
  8004205b77:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b7c:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205b83:	00 00 00 
  8004205b86:	41 ff d0             	callq  *%r8
  8004205b89:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205b90:	00 00 00 
  8004205b93:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205b97:	48 01 d0             	add    %rdx,%rax
  8004205b9a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	 //cprintf(" %x %x " , pte, *pte);
	if (!(pte[PTX(va)] & PTE_P))
  8004205b9e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205ba2:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205ba6:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205bab:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205bb2:	00 
  8004205bb3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205bb7:	48 01 d0             	add    %rdx,%rax
  8004205bba:	48 8b 00             	mov    (%rax),%rax
  8004205bbd:	83 e0 01             	and    $0x1,%eax
  8004205bc0:	48 85 c0             	test   %rax,%rax
  8004205bc3:	75 09                	jne    8004205bce <check_va2pa+0x253>
		return ~0;
  8004205bc5:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205bcc:	eb 25                	jmp    8004205bf3 <check_va2pa+0x278>
	 //cprintf(" %x %x\n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
	return PTE_ADDR(pte[PTX(va)]);
  8004205bce:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205bd2:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205bd6:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205bdb:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205be2:	00 
  8004205be3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205be7:	48 01 d0             	add    %rdx,%rax
  8004205bea:	48 8b 00             	mov    (%rax),%rax
  8004205bed:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  8004205bf3:	c9                   	leaveq 
  8004205bf4:	c3                   	retq   

0000008004205bf5 <page_check>:


// check page_insert, page_remove, &c
static void
page_check(void)
{
  8004205bf5:	55                   	push   %rbp
  8004205bf6:	48 89 e5             	mov    %rsp,%rbp
  8004205bf9:	53                   	push   %rbx
  8004205bfa:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
	pdpe_t *pdpe;
	pde_t *pde;
	void *va;
	int i;
	uintptr_t mm1, mm2;
	pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  8004205c01:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004205c08:	00 
  8004205c09:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205c0d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205c11:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205c15:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004205c19:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205c1d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205c21:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205c25:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004205c29:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205c2d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	assert(pp0 = page_alloc(0));
  8004205c31:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205c36:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  8004205c3d:	00 00 00 
  8004205c40:	ff d0                	callq  *%rax
  8004205c42:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004205c46:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205c4b:	75 35                	jne    8004205c82 <page_check+0x8d>
  8004205c4d:	48 b9 7f 7e 21 04 80 	movabs $0x8004217e7f,%rcx
  8004205c54:	00 00 00 
  8004205c57:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004205c5e:	00 00 00 
  8004205c61:	be d2 04 00 00       	mov    $0x4d2,%esi
  8004205c66:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205c6d:	00 00 00 
  8004205c70:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c75:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205c7c:	00 00 00 
  8004205c7f:	41 ff d0             	callq  *%r8
	assert(pp1 = page_alloc(0));
  8004205c82:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205c87:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  8004205c8e:	00 00 00 
  8004205c91:	ff d0                	callq  *%rax
  8004205c93:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004205c97:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205c9c:	75 35                	jne    8004205cd3 <page_check+0xde>
  8004205c9e:	48 b9 93 7e 21 04 80 	movabs $0x8004217e93,%rcx
  8004205ca5:	00 00 00 
  8004205ca8:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004205caf:	00 00 00 
  8004205cb2:	be d3 04 00 00       	mov    $0x4d3,%esi
  8004205cb7:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205cbe:	00 00 00 
  8004205cc1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205cc6:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205ccd:	00 00 00 
  8004205cd0:	41 ff d0             	callq  *%r8
	assert(pp2 = page_alloc(0));
  8004205cd3:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205cd8:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  8004205cdf:	00 00 00 
  8004205ce2:	ff d0                	callq  *%rax
  8004205ce4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205ce8:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205ced:	75 35                	jne    8004205d24 <page_check+0x12f>
  8004205cef:	48 b9 a7 7e 21 04 80 	movabs $0x8004217ea7,%rcx
  8004205cf6:	00 00 00 
  8004205cf9:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004205d00:	00 00 00 
  8004205d03:	be d4 04 00 00       	mov    $0x4d4,%esi
  8004205d08:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205d0f:	00 00 00 
  8004205d12:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d17:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205d1e:	00 00 00 
  8004205d21:	41 ff d0             	callq  *%r8
	assert(pp3 = page_alloc(0));
  8004205d24:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205d29:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  8004205d30:	00 00 00 
  8004205d33:	ff d0                	callq  *%rax
  8004205d35:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004205d39:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205d3e:	75 35                	jne    8004205d75 <page_check+0x180>
  8004205d40:	48 b9 bb 7e 21 04 80 	movabs $0x8004217ebb,%rcx
  8004205d47:	00 00 00 
  8004205d4a:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004205d51:	00 00 00 
  8004205d54:	be d5 04 00 00       	mov    $0x4d5,%esi
  8004205d59:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205d60:	00 00 00 
  8004205d63:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d68:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205d6f:	00 00 00 
  8004205d72:	41 ff d0             	callq  *%r8
	assert(pp4 = page_alloc(0));
  8004205d75:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205d7a:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  8004205d81:	00 00 00 
  8004205d84:	ff d0                	callq  *%rax
  8004205d86:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205d8a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205d8f:	75 35                	jne    8004205dc6 <page_check+0x1d1>
  8004205d91:	48 b9 cf 7e 21 04 80 	movabs $0x8004217ecf,%rcx
  8004205d98:	00 00 00 
  8004205d9b:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004205da2:	00 00 00 
  8004205da5:	be d6 04 00 00       	mov    $0x4d6,%esi
  8004205daa:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205db1:	00 00 00 
  8004205db4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205db9:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205dc0:	00 00 00 
  8004205dc3:	41 ff d0             	callq  *%r8
	assert(pp5 = page_alloc(0));
  8004205dc6:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205dcb:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  8004205dd2:	00 00 00 
  8004205dd5:	ff d0                	callq  *%rax
  8004205dd7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205ddb:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205de0:	75 35                	jne    8004205e17 <page_check+0x222>
  8004205de2:	48 b9 e3 7e 21 04 80 	movabs $0x8004217ee3,%rcx
  8004205de9:	00 00 00 
  8004205dec:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004205df3:	00 00 00 
  8004205df6:	be d7 04 00 00       	mov    $0x4d7,%esi
  8004205dfb:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205e02:	00 00 00 
  8004205e05:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e0a:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205e11:	00 00 00 
  8004205e14:	41 ff d0             	callq  *%r8

	assert(pp0);
  8004205e17:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205e1c:	75 35                	jne    8004205e53 <page_check+0x25e>
  8004205e1e:	48 b9 31 7c 21 04 80 	movabs $0x8004217c31,%rcx
  8004205e25:	00 00 00 
  8004205e28:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004205e2f:	00 00 00 
  8004205e32:	be d9 04 00 00       	mov    $0x4d9,%esi
  8004205e37:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205e3e:	00 00 00 
  8004205e41:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e46:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205e4d:	00 00 00 
  8004205e50:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004205e53:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205e58:	74 0a                	je     8004205e64 <page_check+0x26f>
  8004205e5a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205e5e:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205e62:	75 35                	jne    8004205e99 <page_check+0x2a4>
  8004205e64:	48 b9 35 7c 21 04 80 	movabs $0x8004217c35,%rcx
  8004205e6b:	00 00 00 
  8004205e6e:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004205e75:	00 00 00 
  8004205e78:	be da 04 00 00       	mov    $0x4da,%esi
  8004205e7d:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205e84:	00 00 00 
  8004205e87:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e8c:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205e93:	00 00 00 
  8004205e96:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004205e99:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205e9e:	74 14                	je     8004205eb4 <page_check+0x2bf>
  8004205ea0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205ea4:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205ea8:	74 0a                	je     8004205eb4 <page_check+0x2bf>
  8004205eaa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205eae:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205eb2:	75 35                	jne    8004205ee9 <page_check+0x2f4>
  8004205eb4:	48 b9 48 7c 21 04 80 	movabs $0x8004217c48,%rcx
  8004205ebb:	00 00 00 
  8004205ebe:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004205ec5:	00 00 00 
  8004205ec8:	be db 04 00 00       	mov    $0x4db,%esi
  8004205ecd:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205ed4:	00 00 00 
  8004205ed7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205edc:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205ee3:	00 00 00 
  8004205ee6:	41 ff d0             	callq  *%r8
	assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  8004205ee9:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205eee:	74 1e                	je     8004205f0e <page_check+0x319>
  8004205ef0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205ef4:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205ef8:	74 14                	je     8004205f0e <page_check+0x319>
  8004205efa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205efe:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205f02:	74 0a                	je     8004205f0e <page_check+0x319>
  8004205f04:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205f08:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205f0c:	75 35                	jne    8004205f43 <page_check+0x34e>
  8004205f0e:	48 b9 f8 7e 21 04 80 	movabs $0x8004217ef8,%rcx
  8004205f15:	00 00 00 
  8004205f18:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004205f1f:	00 00 00 
  8004205f22:	be dc 04 00 00       	mov    $0x4dc,%esi
  8004205f27:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205f2e:	00 00 00 
  8004205f31:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f36:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205f3d:	00 00 00 
  8004205f40:	41 ff d0             	callq  *%r8
	assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  8004205f43:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205f48:	74 28                	je     8004205f72 <page_check+0x37d>
  8004205f4a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205f4e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205f52:	74 1e                	je     8004205f72 <page_check+0x37d>
  8004205f54:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205f58:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205f5c:	74 14                	je     8004205f72 <page_check+0x37d>
  8004205f5e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205f62:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205f66:	74 0a                	je     8004205f72 <page_check+0x37d>
  8004205f68:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205f6c:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205f70:	75 35                	jne    8004205fa7 <page_check+0x3b2>
  8004205f72:	48 b9 28 7f 21 04 80 	movabs $0x8004217f28,%rcx
  8004205f79:	00 00 00 
  8004205f7c:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004205f83:	00 00 00 
  8004205f86:	be dd 04 00 00       	mov    $0x4dd,%esi
  8004205f8b:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004205f92:	00 00 00 
  8004205f95:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f9a:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004205fa1:	00 00 00 
  8004205fa4:	41 ff d0             	callq  *%r8
	assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  8004205fa7:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205fac:	74 32                	je     8004205fe0 <page_check+0x3eb>
  8004205fae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205fb2:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004205fb6:	74 28                	je     8004205fe0 <page_check+0x3eb>
  8004205fb8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205fbc:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205fc0:	74 1e                	je     8004205fe0 <page_check+0x3eb>
  8004205fc2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205fc6:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205fca:	74 14                	je     8004205fe0 <page_check+0x3eb>
  8004205fcc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205fd0:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205fd4:	74 0a                	je     8004205fe0 <page_check+0x3eb>
  8004205fd6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205fda:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205fde:	75 35                	jne    8004206015 <page_check+0x420>
  8004205fe0:	48 b9 68 7f 21 04 80 	movabs $0x8004217f68,%rcx
  8004205fe7:	00 00 00 
  8004205fea:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004205ff1:	00 00 00 
  8004205ff4:	be de 04 00 00       	mov    $0x4de,%esi
  8004205ff9:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206000:	00 00 00 
  8004206003:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206008:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420600f:	00 00 00 
  8004206012:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004206015:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  800420601c:	00 00 00 
  800420601f:	48 8b 00             	mov    (%rax),%rax
  8004206022:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	page_free_list = NULL;
  8004206026:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  800420602d:	00 00 00 
  8004206030:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004206037:	bf 00 00 00 00       	mov    $0x0,%edi
  800420603c:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  8004206043:	00 00 00 
  8004206046:	ff d0                	callq  *%rax
  8004206048:	48 85 c0             	test   %rax,%rax
  800420604b:	74 35                	je     8004206082 <page_check+0x48d>
  800420604d:	48 b9 bf 7c 21 04 80 	movabs $0x8004217cbf,%rcx
  8004206054:	00 00 00 
  8004206057:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  800420605e:	00 00 00 
  8004206061:	be e5 04 00 00       	mov    $0x4e5,%esi
  8004206066:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420606d:	00 00 00 
  8004206070:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206075:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420607c:	00 00 00 
  800420607f:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
	assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  8004206082:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206089:	00 00 00 
  800420608c:	48 8b 00             	mov    (%rax),%rax
  800420608f:	48 8d 95 e8 fe ff ff 	lea    -0x118(%rbp),%rdx
  8004206096:	be 00 00 00 00       	mov    $0x0,%esi
  800420609b:	48 89 c7             	mov    %rax,%rdi
  800420609e:	48 b8 43 3e 20 04 80 	movabs $0x8004203e43,%rax
  80042060a5:	00 00 00 
  80042060a8:	ff d0                	callq  *%rax
  80042060aa:	48 85 c0             	test   %rax,%rax
  80042060ad:	74 35                	je     80042060e4 <page_check+0x4ef>
  80042060af:	48 b9 b8 7f 21 04 80 	movabs $0x8004217fb8,%rcx
  80042060b6:	00 00 00 
  80042060b9:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042060c0:	00 00 00 
  80042060c3:	be e8 04 00 00       	mov    $0x4e8,%esi
  80042060c8:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042060cf:	00 00 00 
  80042060d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042060d7:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042060de:	00 00 00 
  80042060e1:	41 ff d0             	callq  *%r8

	// there is no free memory, so we can't allocate a page table 
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  80042060e4:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  80042060eb:	00 00 00 
  80042060ee:	48 8b 00             	mov    (%rax),%rax
  80042060f1:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042060f5:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042060fa:	ba 00 00 00 00       	mov    $0x0,%edx
  80042060ff:	48 89 c7             	mov    %rax,%rdi
  8004206102:	48 b8 1d 3d 20 04 80 	movabs $0x8004203d1d,%rax
  8004206109:	00 00 00 
  800420610c:	ff d0                	callq  *%rax
  800420610e:	85 c0                	test   %eax,%eax
  8004206110:	78 35                	js     8004206147 <page_check+0x552>
  8004206112:	48 b9 f0 7f 21 04 80 	movabs $0x8004217ff0,%rcx
  8004206119:	00 00 00 
  800420611c:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206123:	00 00 00 
  8004206126:	be eb 04 00 00       	mov    $0x4eb,%esi
  800420612b:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206132:	00 00 00 
  8004206135:	b8 00 00 00 00       	mov    $0x0,%eax
  800420613a:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206141:	00 00 00 
  8004206144:	41 ff d0             	callq  *%r8

	// free pp0 and try again: pp0 should be used for page table
	page_free(pp0);
  8004206147:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420614b:	48 89 c7             	mov    %rax,%rdi
  800420614e:	48 b8 1e 36 20 04 80 	movabs $0x800420361e,%rax
  8004206155:	00 00 00 
  8004206158:	ff d0                	callq  *%rax
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  800420615a:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206161:	00 00 00 
  8004206164:	48 8b 00             	mov    (%rax),%rax
  8004206167:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420616b:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206170:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206175:	48 89 c7             	mov    %rax,%rdi
  8004206178:	48 b8 1d 3d 20 04 80 	movabs $0x8004203d1d,%rax
  800420617f:	00 00 00 
  8004206182:	ff d0                	callq  *%rax
  8004206184:	85 c0                	test   %eax,%eax
  8004206186:	78 35                	js     80042061bd <page_check+0x5c8>
  8004206188:	48 b9 f0 7f 21 04 80 	movabs $0x8004217ff0,%rcx
  800420618f:	00 00 00 
  8004206192:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206199:	00 00 00 
  800420619c:	be ef 04 00 00       	mov    $0x4ef,%esi
  80042061a1:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042061a8:	00 00 00 
  80042061ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061b0:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042061b7:	00 00 00 
  80042061ba:	41 ff d0             	callq  *%r8
	page_free(pp2);
  80042061bd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042061c1:	48 89 c7             	mov    %rax,%rdi
  80042061c4:	48 b8 1e 36 20 04 80 	movabs $0x800420361e,%rax
  80042061cb:	00 00 00 
  80042061ce:	ff d0                	callq  *%rax
	page_free(pp3);
  80042061d0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042061d4:	48 89 c7             	mov    %rax,%rdi
  80042061d7:	48 b8 1e 36 20 04 80 	movabs $0x800420361e,%rax
  80042061de:	00 00 00 
  80042061e1:	ff d0                	callq  *%rax
	//cprintf("pp1 ref count = %d\n",pp1->pp_ref);
	//cprintf("pp0 ref count = %d\n",pp0->pp_ref);
	//cprintf("pp2 ref count = %d\n",pp2->pp_ref);
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  80042061e3:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  80042061ea:	00 00 00 
  80042061ed:	48 8b 00             	mov    (%rax),%rax
  80042061f0:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042061f4:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042061f9:	ba 00 00 00 00       	mov    $0x0,%edx
  80042061fe:	48 89 c7             	mov    %rax,%rdi
  8004206201:	48 b8 1d 3d 20 04 80 	movabs $0x8004203d1d,%rax
  8004206208:	00 00 00 
  800420620b:	ff d0                	callq  *%rax
  800420620d:	85 c0                	test   %eax,%eax
  800420620f:	74 35                	je     8004206246 <page_check+0x651>
  8004206211:	48 b9 20 80 21 04 80 	movabs $0x8004218020,%rcx
  8004206218:	00 00 00 
  800420621b:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206222:	00 00 00 
  8004206225:	be f5 04 00 00       	mov    $0x4f5,%esi
  800420622a:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206231:	00 00 00 
  8004206234:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206239:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206240:	00 00 00 
  8004206243:	41 ff d0             	callq  *%r8
	assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  8004206246:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  800420624d:	00 00 00 
  8004206250:	48 8b 00             	mov    (%rax),%rax
  8004206253:	48 8b 00             	mov    (%rax),%rax
  8004206256:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420625c:	48 89 c3             	mov    %rax,%rbx
  800420625f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206263:	48 89 c7             	mov    %rax,%rdi
  8004206266:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  800420626d:	00 00 00 
  8004206270:	ff d0                	callq  *%rax
  8004206272:	48 39 c3             	cmp    %rax,%rbx
  8004206275:	0f 84 97 00 00 00    	je     8004206312 <page_check+0x71d>
  800420627b:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206282:	00 00 00 
  8004206285:	48 8b 00             	mov    (%rax),%rax
  8004206288:	48 8b 00             	mov    (%rax),%rax
  800420628b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206291:	48 89 c3             	mov    %rax,%rbx
  8004206294:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206298:	48 89 c7             	mov    %rax,%rdi
  800420629b:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  80042062a2:	00 00 00 
  80042062a5:	ff d0                	callq  *%rax
  80042062a7:	48 39 c3             	cmp    %rax,%rbx
  80042062aa:	74 66                	je     8004206312 <page_check+0x71d>
  80042062ac:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  80042062b3:	00 00 00 
  80042062b6:	48 8b 00             	mov    (%rax),%rax
  80042062b9:	48 8b 00             	mov    (%rax),%rax
  80042062bc:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042062c2:	48 89 c3             	mov    %rax,%rbx
  80042062c5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042062c9:	48 89 c7             	mov    %rax,%rdi
  80042062cc:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  80042062d3:	00 00 00 
  80042062d6:	ff d0                	callq  *%rax
  80042062d8:	48 39 c3             	cmp    %rax,%rbx
  80042062db:	74 35                	je     8004206312 <page_check+0x71d>
  80042062dd:	48 b9 50 80 21 04 80 	movabs $0x8004218050,%rcx
  80042062e4:	00 00 00 
  80042062e7:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042062ee:	00 00 00 
  80042062f1:	be f6 04 00 00       	mov    $0x4f6,%esi
  80042062f6:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042062fd:	00 00 00 
  8004206300:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206305:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420630c:	00 00 00 
  800420630f:	41 ff d0             	callq  *%r8
	
        assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  8004206312:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206319:	00 00 00 
  800420631c:	48 8b 00             	mov    (%rax),%rax
  800420631f:	be 00 00 00 00       	mov    $0x0,%esi
  8004206324:	48 89 c7             	mov    %rax,%rdi
  8004206327:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  800420632e:	00 00 00 
  8004206331:	ff d0                	callq  *%rax
  8004206333:	48 89 c3             	mov    %rax,%rbx
  8004206336:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420633a:	48 89 c7             	mov    %rax,%rdi
  800420633d:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  8004206344:	00 00 00 
  8004206347:	ff d0                	callq  *%rax
  8004206349:	48 39 c3             	cmp    %rax,%rbx
  800420634c:	74 35                	je     8004206383 <page_check+0x78e>
  800420634e:	48 b9 d8 80 21 04 80 	movabs $0x80042180d8,%rcx
  8004206355:	00 00 00 
  8004206358:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  800420635f:	00 00 00 
  8004206362:	be f8 04 00 00       	mov    $0x4f8,%esi
  8004206367:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420636e:	00 00 00 
  8004206371:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206376:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420637d:	00 00 00 
  8004206380:	41 ff d0             	callq  *%r8
        assert(pp1->pp_ref == 1);
  8004206383:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206387:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420638b:	66 83 f8 01          	cmp    $0x1,%ax
  800420638f:	74 35                	je     80042063c6 <page_check+0x7d1>
  8004206391:	48 b9 05 81 21 04 80 	movabs $0x8004218105,%rcx
  8004206398:	00 00 00 
  800420639b:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042063a2:	00 00 00 
  80042063a5:	be f9 04 00 00       	mov    $0x4f9,%esi
  80042063aa:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042063b1:	00 00 00 
  80042063b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063b9:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042063c0:	00 00 00 
  80042063c3:	41 ff d0             	callq  *%r8
	assert(pp0->pp_ref == 1);
  80042063c6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042063ca:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042063ce:	66 83 f8 01          	cmp    $0x1,%ax
  80042063d2:	74 35                	je     8004206409 <page_check+0x814>
  80042063d4:	48 b9 16 81 21 04 80 	movabs $0x8004218116,%rcx
  80042063db:	00 00 00 
  80042063de:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042063e5:	00 00 00 
  80042063e8:	be fa 04 00 00       	mov    $0x4fa,%esi
  80042063ed:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042063f4:	00 00 00 
  80042063f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063fc:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206403:	00 00 00 
  8004206406:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 1);
  8004206409:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420640d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206411:	66 83 f8 01          	cmp    $0x1,%ax
  8004206415:	74 35                	je     800420644c <page_check+0x857>
  8004206417:	48 b9 27 81 21 04 80 	movabs $0x8004218127,%rcx
  800420641e:	00 00 00 
  8004206421:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206428:	00 00 00 
  800420642b:	be fb 04 00 00       	mov    $0x4fb,%esi
  8004206430:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206437:	00 00 00 
  800420643a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420643f:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206446:	00 00 00 
  8004206449:	41 ff d0             	callq  *%r8
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
        
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  800420644c:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206453:	00 00 00 
  8004206456:	48 8b 00             	mov    (%rax),%rax
  8004206459:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420645d:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206462:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206467:	48 89 c7             	mov    %rax,%rdi
  800420646a:	48 b8 1d 3d 20 04 80 	movabs $0x8004203d1d,%rax
  8004206471:	00 00 00 
  8004206474:	ff d0                	callq  *%rax
  8004206476:	85 c0                	test   %eax,%eax
  8004206478:	74 35                	je     80042064af <page_check+0x8ba>
  800420647a:	48 b9 38 81 21 04 80 	movabs $0x8004218138,%rcx
  8004206481:	00 00 00 
  8004206484:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  800420648b:	00 00 00 
  800420648e:	be fe 04 00 00       	mov    $0x4fe,%esi
  8004206493:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420649a:	00 00 00 
  800420649d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064a2:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042064a9:	00 00 00 
  80042064ac:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  80042064af:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  80042064b6:	00 00 00 
  80042064b9:	48 8b 00             	mov    (%rax),%rax
  80042064bc:	be 00 10 00 00       	mov    $0x1000,%esi
  80042064c1:	48 89 c7             	mov    %rax,%rdi
  80042064c4:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  80042064cb:	00 00 00 
  80042064ce:	ff d0                	callq  *%rax
  80042064d0:	48 89 c3             	mov    %rax,%rbx
  80042064d3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042064d7:	48 89 c7             	mov    %rax,%rdi
  80042064da:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  80042064e1:	00 00 00 
  80042064e4:	ff d0                	callq  *%rax
  80042064e6:	48 39 c3             	cmp    %rax,%rbx
  80042064e9:	74 35                	je     8004206520 <page_check+0x92b>
  80042064eb:	48 b9 70 81 21 04 80 	movabs $0x8004218170,%rcx
  80042064f2:	00 00 00 
  80042064f5:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042064fc:	00 00 00 
  80042064ff:	be ff 04 00 00       	mov    $0x4ff,%esi
  8004206504:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420650b:	00 00 00 
  800420650e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206513:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420651a:	00 00 00 
  800420651d:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004206520:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206524:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206528:	66 83 f8 02          	cmp    $0x2,%ax
  800420652c:	74 35                	je     8004206563 <page_check+0x96e>
  800420652e:	48 b9 a0 81 21 04 80 	movabs $0x80042181a0,%rcx
  8004206535:	00 00 00 
  8004206538:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  800420653f:	00 00 00 
  8004206542:	be 00 05 00 00       	mov    $0x500,%esi
  8004206547:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420654e:	00 00 00 
  8004206551:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206556:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420655d:	00 00 00 
  8004206560:	41 ff d0             	callq  *%r8
        
	// should be no free memory
	assert(!page_alloc(0));
  8004206563:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206568:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  800420656f:	00 00 00 
  8004206572:	ff d0                	callq  *%rax
  8004206574:	48 85 c0             	test   %rax,%rax
  8004206577:	74 35                	je     80042065ae <page_check+0x9b9>
  8004206579:	48 b9 bf 7c 21 04 80 	movabs $0x8004217cbf,%rcx
  8004206580:	00 00 00 
  8004206583:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  800420658a:	00 00 00 
  800420658d:	be 03 05 00 00       	mov    $0x503,%esi
  8004206592:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206599:	00 00 00 
  800420659c:	b8 00 00 00 00       	mov    $0x0,%eax
  80042065a1:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042065a8:	00 00 00 
  80042065ab:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  80042065ae:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  80042065b5:	00 00 00 
  80042065b8:	48 8b 00             	mov    (%rax),%rax
  80042065bb:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042065bf:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042065c4:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042065c9:	48 89 c7             	mov    %rax,%rdi
  80042065cc:	48 b8 1d 3d 20 04 80 	movabs $0x8004203d1d,%rax
  80042065d3:	00 00 00 
  80042065d6:	ff d0                	callq  *%rax
  80042065d8:	85 c0                	test   %eax,%eax
  80042065da:	74 35                	je     8004206611 <page_check+0xa1c>
  80042065dc:	48 b9 38 81 21 04 80 	movabs $0x8004218138,%rcx
  80042065e3:	00 00 00 
  80042065e6:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042065ed:	00 00 00 
  80042065f0:	be 06 05 00 00       	mov    $0x506,%esi
  80042065f5:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042065fc:	00 00 00 
  80042065ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206604:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420660b:	00 00 00 
  800420660e:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004206611:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206618:	00 00 00 
  800420661b:	48 8b 00             	mov    (%rax),%rax
  800420661e:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206623:	48 89 c7             	mov    %rax,%rdi
  8004206626:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  800420662d:	00 00 00 
  8004206630:	ff d0                	callq  *%rax
  8004206632:	48 89 c3             	mov    %rax,%rbx
  8004206635:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206639:	48 89 c7             	mov    %rax,%rdi
  800420663c:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  8004206643:	00 00 00 
  8004206646:	ff d0                	callq  *%rax
  8004206648:	48 39 c3             	cmp    %rax,%rbx
  800420664b:	74 35                	je     8004206682 <page_check+0xa8d>
  800420664d:	48 b9 70 81 21 04 80 	movabs $0x8004218170,%rcx
  8004206654:	00 00 00 
  8004206657:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  800420665e:	00 00 00 
  8004206661:	be 07 05 00 00       	mov    $0x507,%esi
  8004206666:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420666d:	00 00 00 
  8004206670:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206675:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420667c:	00 00 00 
  800420667f:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004206682:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206686:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420668a:	66 83 f8 02          	cmp    $0x2,%ax
  800420668e:	74 35                	je     80042066c5 <page_check+0xad0>
  8004206690:	48 b9 a0 81 21 04 80 	movabs $0x80042181a0,%rcx
  8004206697:	00 00 00 
  800420669a:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042066a1:	00 00 00 
  80042066a4:	be 08 05 00 00       	mov    $0x508,%esi
  80042066a9:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042066b0:	00 00 00 
  80042066b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042066b8:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042066bf:	00 00 00 
  80042066c2:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));
  80042066c5:	bf 00 00 00 00       	mov    $0x0,%edi
  80042066ca:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  80042066d1:	00 00 00 
  80042066d4:	ff d0                	callq  *%rax
  80042066d6:	48 85 c0             	test   %rax,%rax
  80042066d9:	74 35                	je     8004206710 <page_check+0xb1b>
  80042066db:	48 b9 bf 7c 21 04 80 	movabs $0x8004217cbf,%rcx
  80042066e2:	00 00 00 
  80042066e5:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042066ec:	00 00 00 
  80042066ef:	be 0c 05 00 00       	mov    $0x50c,%esi
  80042066f4:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042066fb:	00 00 00 
  80042066fe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206703:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420670a:	00 00 00 
  800420670d:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  8004206710:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206717:	00 00 00 
  800420671a:	48 8b 00             	mov    (%rax),%rax
  800420671d:	48 8b 00             	mov    (%rax),%rax
  8004206720:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206726:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  800420672a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420672e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206732:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  8004206735:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004206738:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  800420673f:	00 00 00 
  8004206742:	48 8b 00             	mov    (%rax),%rax
  8004206745:	48 39 c2             	cmp    %rax,%rdx
  8004206748:	72 32                	jb     800420677c <page_check+0xb87>
  800420674a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420674e:	48 89 c1             	mov    %rax,%rcx
  8004206751:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  8004206758:	00 00 00 
  800420675b:	be 0e 05 00 00       	mov    $0x50e,%esi
  8004206760:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206767:	00 00 00 
  800420676a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420676f:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206776:	00 00 00 
  8004206779:	41 ff d0             	callq  *%r8
  800420677c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206783:	00 00 00 
  8004206786:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420678a:	48 01 d0             	add    %rdx,%rax
  800420678d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  8004206791:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206795:	48 8b 00             	mov    (%rax),%rax
  8004206798:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420679e:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  80042067a2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042067a6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042067aa:	89 45 8c             	mov    %eax,-0x74(%rbp)
  80042067ad:	8b 55 8c             	mov    -0x74(%rbp),%edx
  80042067b0:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  80042067b7:	00 00 00 
  80042067ba:	48 8b 00             	mov    (%rax),%rax
  80042067bd:	48 39 c2             	cmp    %rax,%rdx
  80042067c0:	72 32                	jb     80042067f4 <page_check+0xbff>
  80042067c2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042067c6:	48 89 c1             	mov    %rax,%rcx
  80042067c9:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  80042067d0:	00 00 00 
  80042067d3:	be 0f 05 00 00       	mov    $0x50f,%esi
  80042067d8:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042067df:	00 00 00 
  80042067e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042067e7:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042067ee:	00 00 00 
  80042067f1:	41 ff d0             	callq  *%r8
  80042067f4:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042067fb:	00 00 00 
  80042067fe:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004206802:	48 01 d0             	add    %rdx,%rax
  8004206805:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  8004206809:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800420680d:	48 8b 00             	mov    (%rax),%rax
  8004206810:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206816:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  800420681d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206824:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206828:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  800420682e:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  8004206834:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  800420683b:	00 00 00 
  800420683e:	48 8b 00             	mov    (%rax),%rax
  8004206841:	48 39 c2             	cmp    %rax,%rdx
  8004206844:	72 35                	jb     800420687b <page_check+0xc86>
  8004206846:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420684d:	48 89 c1             	mov    %rax,%rcx
  8004206850:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  8004206857:	00 00 00 
  800420685a:	be 10 05 00 00       	mov    $0x510,%esi
  800420685f:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206866:	00 00 00 
  8004206869:	b8 00 00 00 00       	mov    $0x0,%eax
  800420686e:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206875:	00 00 00 
  8004206878:	41 ff d0             	callq  *%r8
  800420687b:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206882:	00 00 00 
  8004206885:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420688c:	48 01 d0             	add    %rdx,%rax
  800420688f:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  8004206896:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  800420689d:	00 00 00 
  80042068a0:	48 8b 00             	mov    (%rax),%rax
  80042068a3:	ba 00 00 00 00       	mov    $0x0,%edx
  80042068a8:	be 00 10 00 00       	mov    $0x1000,%esi
  80042068ad:	48 89 c7             	mov    %rax,%rdi
  80042068b0:	48 b8 cc 36 20 04 80 	movabs $0x80042036cc,%rax
  80042068b7:	00 00 00 
  80042068ba:	ff d0                	callq  *%rax
  80042068bc:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
  80042068c3:	48 83 c2 08          	add    $0x8,%rdx
  80042068c7:	48 39 d0             	cmp    %rdx,%rax
  80042068ca:	74 35                	je     8004206901 <page_check+0xd0c>
  80042068cc:	48 b9 b8 81 21 04 80 	movabs $0x80042181b8,%rcx
  80042068d3:	00 00 00 
  80042068d6:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042068dd:	00 00 00 
  80042068e0:	be 11 05 00 00       	mov    $0x511,%esi
  80042068e5:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042068ec:	00 00 00 
  80042068ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80042068f4:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042068fb:	00 00 00 
  80042068fe:	41 ff d0             	callq  *%r8

	// should be able to change permissions too.
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  8004206901:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206908:	00 00 00 
  800420690b:	48 8b 00             	mov    (%rax),%rax
  800420690e:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004206912:	b9 04 00 00 00       	mov    $0x4,%ecx
  8004206917:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420691c:	48 89 c7             	mov    %rax,%rdi
  800420691f:	48 b8 1d 3d 20 04 80 	movabs $0x8004203d1d,%rax
  8004206926:	00 00 00 
  8004206929:	ff d0                	callq  *%rax
  800420692b:	85 c0                	test   %eax,%eax
  800420692d:	74 35                	je     8004206964 <page_check+0xd6f>
  800420692f:	48 b9 f8 81 21 04 80 	movabs $0x80042181f8,%rcx
  8004206936:	00 00 00 
  8004206939:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206940:	00 00 00 
  8004206943:	be 14 05 00 00       	mov    $0x514,%esi
  8004206948:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420694f:	00 00 00 
  8004206952:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206957:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420695e:	00 00 00 
  8004206961:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004206964:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  800420696b:	00 00 00 
  800420696e:	48 8b 00             	mov    (%rax),%rax
  8004206971:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206976:	48 89 c7             	mov    %rax,%rdi
  8004206979:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  8004206980:	00 00 00 
  8004206983:	ff d0                	callq  *%rax
  8004206985:	48 89 c3             	mov    %rax,%rbx
  8004206988:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420698c:	48 89 c7             	mov    %rax,%rdi
  800420698f:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  8004206996:	00 00 00 
  8004206999:	ff d0                	callq  *%rax
  800420699b:	48 39 c3             	cmp    %rax,%rbx
  800420699e:	74 35                	je     80042069d5 <page_check+0xde0>
  80042069a0:	48 b9 70 81 21 04 80 	movabs $0x8004218170,%rcx
  80042069a7:	00 00 00 
  80042069aa:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042069b1:	00 00 00 
  80042069b4:	be 15 05 00 00       	mov    $0x515,%esi
  80042069b9:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042069c0:	00 00 00 
  80042069c3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042069c8:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042069cf:	00 00 00 
  80042069d2:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  80042069d5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042069d9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042069dd:	66 83 f8 02          	cmp    $0x2,%ax
  80042069e1:	74 35                	je     8004206a18 <page_check+0xe23>
  80042069e3:	48 b9 a0 81 21 04 80 	movabs $0x80042181a0,%rcx
  80042069ea:	00 00 00 
  80042069ed:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042069f4:	00 00 00 
  80042069f7:	be 16 05 00 00       	mov    $0x516,%esi
  80042069fc:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206a03:	00 00 00 
  8004206a06:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a0b:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206a12:	00 00 00 
  8004206a15:	41 ff d0             	callq  *%r8
	assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  8004206a18:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206a1f:	00 00 00 
  8004206a22:	48 8b 00             	mov    (%rax),%rax
  8004206a25:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206a2a:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206a2f:	48 89 c7             	mov    %rax,%rdi
  8004206a32:	48 b8 cc 36 20 04 80 	movabs $0x80042036cc,%rax
  8004206a39:	00 00 00 
  8004206a3c:	ff d0                	callq  *%rax
  8004206a3e:	48 8b 00             	mov    (%rax),%rax
  8004206a41:	83 e0 04             	and    $0x4,%eax
  8004206a44:	48 85 c0             	test   %rax,%rax
  8004206a47:	75 35                	jne    8004206a7e <page_check+0xe89>
  8004206a49:	48 b9 38 82 21 04 80 	movabs $0x8004218238,%rcx
  8004206a50:	00 00 00 
  8004206a53:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206a5a:	00 00 00 
  8004206a5d:	be 17 05 00 00       	mov    $0x517,%esi
  8004206a62:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206a69:	00 00 00 
  8004206a6c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a71:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206a78:	00 00 00 
  8004206a7b:	41 ff d0             	callq  *%r8
	assert(boot_pml4e[0] & PTE_U);
  8004206a7e:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206a85:	00 00 00 
  8004206a88:	48 8b 00             	mov    (%rax),%rax
  8004206a8b:	48 8b 00             	mov    (%rax),%rax
  8004206a8e:	83 e0 04             	and    $0x4,%eax
  8004206a91:	48 85 c0             	test   %rax,%rax
  8004206a94:	75 35                	jne    8004206acb <page_check+0xed6>
  8004206a96:	48 b9 6b 82 21 04 80 	movabs $0x800421826b,%rcx
  8004206a9d:	00 00 00 
  8004206aa0:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206aa7:	00 00 00 
  8004206aaa:	be 18 05 00 00       	mov    $0x518,%esi
  8004206aaf:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206ab6:	00 00 00 
  8004206ab9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206abe:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206ac5:	00 00 00 
  8004206ac8:	41 ff d0             	callq  *%r8
        

	
	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  8004206acb:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206ad2:	00 00 00 
  8004206ad5:	48 8b 00             	mov    (%rax),%rax
  8004206ad8:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004206adc:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206ae1:	ba 00 00 20 00       	mov    $0x200000,%edx
  8004206ae6:	48 89 c7             	mov    %rax,%rdi
  8004206ae9:	48 b8 1d 3d 20 04 80 	movabs $0x8004203d1d,%rax
  8004206af0:	00 00 00 
  8004206af3:	ff d0                	callq  *%rax
  8004206af5:	85 c0                	test   %eax,%eax
  8004206af7:	78 35                	js     8004206b2e <page_check+0xf39>
  8004206af9:	48 b9 88 82 21 04 80 	movabs $0x8004218288,%rcx
  8004206b00:	00 00 00 
  8004206b03:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206b0a:	00 00 00 
  8004206b0d:	be 1d 05 00 00       	mov    $0x51d,%esi
  8004206b12:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206b19:	00 00 00 
  8004206b1c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b21:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206b28:	00 00 00 
  8004206b2b:	41 ff d0             	callq  *%r8
	
	// insert pp1 at PGSIZE (replacing pp3)
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004206b2e:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206b35:	00 00 00 
  8004206b38:	48 8b 00             	mov    (%rax),%rax
  8004206b3b:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206b3f:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206b44:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206b49:	48 89 c7             	mov    %rax,%rdi
  8004206b4c:	48 b8 1d 3d 20 04 80 	movabs $0x8004203d1d,%rax
  8004206b53:	00 00 00 
  8004206b56:	ff d0                	callq  *%rax
  8004206b58:	85 c0                	test   %eax,%eax
  8004206b5a:	74 35                	je     8004206b91 <page_check+0xf9c>
  8004206b5c:	48 b9 c0 82 21 04 80 	movabs $0x80042182c0,%rcx
  8004206b63:	00 00 00 
  8004206b66:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206b6d:	00 00 00 
  8004206b70:	be 20 05 00 00       	mov    $0x520,%esi
  8004206b75:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206b7c:	00 00 00 
  8004206b7f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b84:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206b8b:	00 00 00 
  8004206b8e:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  8004206b91:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206b98:	00 00 00 
  8004206b9b:	48 8b 00             	mov    (%rax),%rax
  8004206b9e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206ba3:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206ba8:	48 89 c7             	mov    %rax,%rdi
  8004206bab:	48 b8 cc 36 20 04 80 	movabs $0x80042036cc,%rax
  8004206bb2:	00 00 00 
  8004206bb5:	ff d0                	callq  *%rax
  8004206bb7:	48 8b 00             	mov    (%rax),%rax
  8004206bba:	83 e0 04             	and    $0x4,%eax
  8004206bbd:	48 85 c0             	test   %rax,%rax
  8004206bc0:	74 35                	je     8004206bf7 <page_check+0x1002>
  8004206bc2:	48 b9 f8 82 21 04 80 	movabs $0x80042182f8,%rcx
  8004206bc9:	00 00 00 
  8004206bcc:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206bd3:	00 00 00 
  8004206bd6:	be 21 05 00 00       	mov    $0x521,%esi
  8004206bdb:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206be2:	00 00 00 
  8004206be5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206bea:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206bf1:	00 00 00 
  8004206bf4:	41 ff d0             	callq  *%r8
	// should have pp1 at both 0 and PGSIZE
	assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  8004206bf7:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206bfe:	00 00 00 
  8004206c01:	48 8b 00             	mov    (%rax),%rax
  8004206c04:	be 00 00 00 00       	mov    $0x0,%esi
  8004206c09:	48 89 c7             	mov    %rax,%rdi
  8004206c0c:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  8004206c13:	00 00 00 
  8004206c16:	ff d0                	callq  *%rax
  8004206c18:	48 89 c3             	mov    %rax,%rbx
  8004206c1b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206c1f:	48 89 c7             	mov    %rax,%rdi
  8004206c22:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  8004206c29:	00 00 00 
  8004206c2c:	ff d0                	callq  *%rax
  8004206c2e:	48 39 c3             	cmp    %rax,%rbx
  8004206c31:	74 35                	je     8004206c68 <page_check+0x1073>
  8004206c33:	48 b9 30 83 21 04 80 	movabs $0x8004218330,%rcx
  8004206c3a:	00 00 00 
  8004206c3d:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206c44:	00 00 00 
  8004206c47:	be 23 05 00 00       	mov    $0x523,%esi
  8004206c4c:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206c53:	00 00 00 
  8004206c56:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c5b:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206c62:	00 00 00 
  8004206c65:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206c68:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206c6f:	00 00 00 
  8004206c72:	48 8b 00             	mov    (%rax),%rax
  8004206c75:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206c7a:	48 89 c7             	mov    %rax,%rdi
  8004206c7d:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  8004206c84:	00 00 00 
  8004206c87:	ff d0                	callq  *%rax
  8004206c89:	48 89 c3             	mov    %rax,%rbx
  8004206c8c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206c90:	48 89 c7             	mov    %rax,%rdi
  8004206c93:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  8004206c9a:	00 00 00 
  8004206c9d:	ff d0                	callq  *%rax
  8004206c9f:	48 39 c3             	cmp    %rax,%rbx
  8004206ca2:	74 35                	je     8004206cd9 <page_check+0x10e4>
  8004206ca4:	48 b9 60 83 21 04 80 	movabs $0x8004218360,%rcx
  8004206cab:	00 00 00 
  8004206cae:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206cb5:	00 00 00 
  8004206cb8:	be 24 05 00 00       	mov    $0x524,%esi
  8004206cbd:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206cc4:	00 00 00 
  8004206cc7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ccc:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206cd3:	00 00 00 
  8004206cd6:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
  8004206cd9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206cdd:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206ce1:	66 83 f8 02          	cmp    $0x2,%ax
  8004206ce5:	74 35                	je     8004206d1c <page_check+0x1127>
  8004206ce7:	48 b9 90 83 21 04 80 	movabs $0x8004218390,%rcx
  8004206cee:	00 00 00 
  8004206cf1:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206cf8:	00 00 00 
  8004206cfb:	be 26 05 00 00       	mov    $0x526,%esi
  8004206d00:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206d07:	00 00 00 
  8004206d0a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d0f:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206d16:	00 00 00 
  8004206d19:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206d1c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206d20:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206d24:	66 83 f8 01          	cmp    $0x1,%ax
  8004206d28:	74 35                	je     8004206d5f <page_check+0x116a>
  8004206d2a:	48 b9 a1 83 21 04 80 	movabs $0x80042183a1,%rcx
  8004206d31:	00 00 00 
  8004206d34:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206d3b:	00 00 00 
  8004206d3e:	be 27 05 00 00       	mov    $0x527,%esi
  8004206d43:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206d4a:	00 00 00 
  8004206d4d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d52:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206d59:	00 00 00 
  8004206d5c:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(boot_pml4e, 0x0);
  8004206d5f:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206d66:	00 00 00 
  8004206d69:	48 8b 00             	mov    (%rax),%rax
  8004206d6c:	be 00 00 00 00       	mov    $0x0,%esi
  8004206d71:	48 89 c7             	mov    %rax,%rdi
  8004206d74:	48 b8 d8 3e 20 04 80 	movabs $0x8004203ed8,%rax
  8004206d7b:	00 00 00 
  8004206d7e:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206d80:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206d87:	00 00 00 
  8004206d8a:	48 8b 00             	mov    (%rax),%rax
  8004206d8d:	be 00 00 00 00       	mov    $0x0,%esi
  8004206d92:	48 89 c7             	mov    %rax,%rdi
  8004206d95:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  8004206d9c:	00 00 00 
  8004206d9f:	ff d0                	callq  *%rax
  8004206da1:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206da5:	74 35                	je     8004206ddc <page_check+0x11e7>
  8004206da7:	48 b9 b8 83 21 04 80 	movabs $0x80042183b8,%rcx
  8004206dae:	00 00 00 
  8004206db1:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206db8:	00 00 00 
  8004206dbb:	be 2c 05 00 00       	mov    $0x52c,%esi
  8004206dc0:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206dc7:	00 00 00 
  8004206dca:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206dcf:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206dd6:	00 00 00 
  8004206dd9:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206ddc:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206de3:	00 00 00 
  8004206de6:	48 8b 00             	mov    (%rax),%rax
  8004206de9:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206dee:	48 89 c7             	mov    %rax,%rdi
  8004206df1:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  8004206df8:	00 00 00 
  8004206dfb:	ff d0                	callq  *%rax
  8004206dfd:	48 89 c3             	mov    %rax,%rbx
  8004206e00:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206e04:	48 89 c7             	mov    %rax,%rdi
  8004206e07:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  8004206e0e:	00 00 00 
  8004206e11:	ff d0                	callq  *%rax
  8004206e13:	48 39 c3             	cmp    %rax,%rbx
  8004206e16:	74 35                	je     8004206e4d <page_check+0x1258>
  8004206e18:	48 b9 60 83 21 04 80 	movabs $0x8004218360,%rcx
  8004206e1f:	00 00 00 
  8004206e22:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206e29:	00 00 00 
  8004206e2c:	be 2d 05 00 00       	mov    $0x52d,%esi
  8004206e31:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206e38:	00 00 00 
  8004206e3b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e40:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206e47:	00 00 00 
  8004206e4a:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004206e4d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206e51:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206e55:	66 83 f8 01          	cmp    $0x1,%ax
  8004206e59:	74 35                	je     8004206e90 <page_check+0x129b>
  8004206e5b:	48 b9 05 81 21 04 80 	movabs $0x8004218105,%rcx
  8004206e62:	00 00 00 
  8004206e65:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206e6c:	00 00 00 
  8004206e6f:	be 2e 05 00 00       	mov    $0x52e,%esi
  8004206e74:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206e7b:	00 00 00 
  8004206e7e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e83:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206e8a:	00 00 00 
  8004206e8d:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206e90:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206e94:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206e98:	66 83 f8 01          	cmp    $0x1,%ax
  8004206e9c:	74 35                	je     8004206ed3 <page_check+0x12de>
  8004206e9e:	48 b9 a1 83 21 04 80 	movabs $0x80042183a1,%rcx
  8004206ea5:	00 00 00 
  8004206ea8:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206eaf:	00 00 00 
  8004206eb2:	be 2f 05 00 00       	mov    $0x52f,%esi
  8004206eb7:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206ebe:	00 00 00 
  8004206ec1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ec6:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206ecd:	00 00 00 
  8004206ed0:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004206ed3:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206eda:	00 00 00 
  8004206edd:	48 8b 00             	mov    (%rax),%rax
  8004206ee0:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206ee4:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206ee9:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206eee:	48 89 c7             	mov    %rax,%rdi
  8004206ef1:	48 b8 1d 3d 20 04 80 	movabs $0x8004203d1d,%rax
  8004206ef8:	00 00 00 
  8004206efb:	ff d0                	callq  *%rax
  8004206efd:	85 c0                	test   %eax,%eax
  8004206eff:	74 35                	je     8004206f36 <page_check+0x1341>
  8004206f01:	48 b9 c0 82 21 04 80 	movabs $0x80042182c0,%rcx
  8004206f08:	00 00 00 
  8004206f0b:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206f12:	00 00 00 
  8004206f15:	be 33 05 00 00       	mov    $0x533,%esi
  8004206f1a:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206f21:	00 00 00 
  8004206f24:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f29:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206f30:	00 00 00 
  8004206f33:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref);
  8004206f36:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206f3a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206f3e:	66 85 c0             	test   %ax,%ax
  8004206f41:	75 35                	jne    8004206f78 <page_check+0x1383>
  8004206f43:	48 b9 db 83 21 04 80 	movabs $0x80042183db,%rcx
  8004206f4a:	00 00 00 
  8004206f4d:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206f54:	00 00 00 
  8004206f57:	be 34 05 00 00       	mov    $0x534,%esi
  8004206f5c:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206f63:	00 00 00 
  8004206f66:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f6b:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206f72:	00 00 00 
  8004206f75:	41 ff d0             	callq  *%r8
	assert(pp1->pp_link == NULL);
  8004206f78:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206f7c:	48 8b 00             	mov    (%rax),%rax
  8004206f7f:	48 85 c0             	test   %rax,%rax
  8004206f82:	74 35                	je     8004206fb9 <page_check+0x13c4>
  8004206f84:	48 b9 e7 83 21 04 80 	movabs $0x80042183e7,%rcx
  8004206f8b:	00 00 00 
  8004206f8e:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004206f95:	00 00 00 
  8004206f98:	be 35 05 00 00       	mov    $0x535,%esi
  8004206f9d:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004206fa4:	00 00 00 
  8004206fa7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206fac:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004206fb3:	00 00 00 
  8004206fb6:	41 ff d0             	callq  *%r8

	// unmapping pp1 at PGSIZE should free it
	page_remove(boot_pml4e, (void*) PGSIZE);
  8004206fb9:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206fc0:	00 00 00 
  8004206fc3:	48 8b 00             	mov    (%rax),%rax
  8004206fc6:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206fcb:	48 89 c7             	mov    %rax,%rdi
  8004206fce:	48 b8 d8 3e 20 04 80 	movabs $0x8004203ed8,%rax
  8004206fd5:	00 00 00 
  8004206fd8:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206fda:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004206fe1:	00 00 00 
  8004206fe4:	48 8b 00             	mov    (%rax),%rax
  8004206fe7:	be 00 00 00 00       	mov    $0x0,%esi
  8004206fec:	48 89 c7             	mov    %rax,%rdi
  8004206fef:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  8004206ff6:	00 00 00 
  8004206ff9:	ff d0                	callq  *%rax
  8004206ffb:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206fff:	74 35                	je     8004207036 <page_check+0x1441>
  8004207001:	48 b9 b8 83 21 04 80 	movabs $0x80042183b8,%rcx
  8004207008:	00 00 00 
  800420700b:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004207012:	00 00 00 
  8004207015:	be 39 05 00 00       	mov    $0x539,%esi
  800420701a:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004207021:	00 00 00 
  8004207024:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207029:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004207030:	00 00 00 
  8004207033:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  8004207036:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  800420703d:	00 00 00 
  8004207040:	48 8b 00             	mov    (%rax),%rax
  8004207043:	be 00 10 00 00       	mov    $0x1000,%esi
  8004207048:	48 89 c7             	mov    %rax,%rdi
  800420704b:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  8004207052:	00 00 00 
  8004207055:	ff d0                	callq  *%rax
  8004207057:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  800420705b:	74 35                	je     8004207092 <page_check+0x149d>
  800420705d:	48 b9 00 84 21 04 80 	movabs $0x8004218400,%rcx
  8004207064:	00 00 00 
  8004207067:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  800420706e:	00 00 00 
  8004207071:	be 3a 05 00 00       	mov    $0x53a,%esi
  8004207076:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420707d:	00 00 00 
  8004207080:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207085:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420708c:	00 00 00 
  800420708f:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  8004207092:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207096:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420709a:	66 85 c0             	test   %ax,%ax
  800420709d:	74 35                	je     80042070d4 <page_check+0x14df>
  800420709f:	48 b9 26 84 21 04 80 	movabs $0x8004218426,%rcx
  80042070a6:	00 00 00 
  80042070a9:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042070b0:	00 00 00 
  80042070b3:	be 3b 05 00 00       	mov    $0x53b,%esi
  80042070b8:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042070bf:	00 00 00 
  80042070c2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042070c7:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042070ce:	00 00 00 
  80042070d1:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  80042070d4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042070d8:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042070dc:	66 83 f8 01          	cmp    $0x1,%ax
  80042070e0:	74 35                	je     8004207117 <page_check+0x1522>
  80042070e2:	48 b9 a1 83 21 04 80 	movabs $0x80042183a1,%rcx
  80042070e9:	00 00 00 
  80042070ec:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042070f3:	00 00 00 
  80042070f6:	be 3c 05 00 00       	mov    $0x53c,%esi
  80042070fb:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004207102:	00 00 00 
  8004207105:	b8 00 00 00 00       	mov    $0x0,%eax
  800420710a:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004207111:	00 00 00 
  8004207114:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif

	// forcibly take pp3 back
	assert(PTE_ADDR(boot_pml4e[0]) == page2pa(pp3));
  8004207117:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  800420711e:	00 00 00 
  8004207121:	48 8b 00             	mov    (%rax),%rax
  8004207124:	48 8b 00             	mov    (%rax),%rax
  8004207127:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420712d:	48 89 c3             	mov    %rax,%rbx
  8004207130:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207134:	48 89 c7             	mov    %rax,%rdi
  8004207137:	48 b8 06 23 20 04 80 	movabs $0x8004202306,%rax
  800420713e:	00 00 00 
  8004207141:	ff d0                	callq  *%rax
  8004207143:	48 39 c3             	cmp    %rax,%rbx
  8004207146:	74 35                	je     800420717d <page_check+0x1588>
  8004207148:	48 b9 38 84 21 04 80 	movabs $0x8004218438,%rcx
  800420714f:	00 00 00 
  8004207152:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004207159:	00 00 00 
  800420715c:	be 50 05 00 00       	mov    $0x550,%esi
  8004207161:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004207168:	00 00 00 
  800420716b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207170:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004207177:	00 00 00 
  800420717a:	41 ff d0             	callq  *%r8
	boot_pml4e[0] = 0;
  800420717d:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004207184:	00 00 00 
  8004207187:	48 8b 00             	mov    (%rax),%rax
  800420718a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  8004207191:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207195:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207199:	66 83 f8 01          	cmp    $0x1,%ax
  800420719d:	74 35                	je     80042071d4 <page_check+0x15df>
  800420719f:	48 b9 a1 83 21 04 80 	movabs $0x80042183a1,%rcx
  80042071a6:	00 00 00 
  80042071a9:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042071b0:	00 00 00 
  80042071b3:	be 52 05 00 00       	mov    $0x552,%esi
  80042071b8:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042071bf:	00 00 00 
  80042071c2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042071c7:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042071ce:	00 00 00 
  80042071d1:	41 ff d0             	callq  *%r8
    page_decref(pp3);
  80042071d4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042071d8:	48 89 c7             	mov    %rax,%rdi
  80042071db:	48 b8 8b 36 20 04 80 	movabs $0x800420368b,%rax
  80042071e2:	00 00 00 
  80042071e5:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	page_decref(pp0);
  80042071e7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042071eb:	48 89 c7             	mov    %rax,%rdi
  80042071ee:	48 b8 8b 36 20 04 80 	movabs $0x800420368b,%rax
  80042071f5:	00 00 00 
  80042071f8:	ff d0                	callq  *%rax
	page_decref(pp2);
  80042071fa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042071fe:	48 89 c7             	mov    %rax,%rdi
  8004207201:	48 b8 8b 36 20 04 80 	movabs $0x800420368b,%rax
  8004207208:	00 00 00 
  800420720b:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  800420720d:	48 c7 85 68 ff ff ff 	movq   $0x64000,-0x98(%rbp)
  8004207214:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  8004207218:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  800420721f:	00 00 00 
  8004207222:	48 8b 00             	mov    (%rax),%rax
  8004207225:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
  800420722c:	ba 01 00 00 00       	mov    $0x1,%edx
  8004207231:	48 89 ce             	mov    %rcx,%rsi
  8004207234:	48 89 c7             	mov    %rax,%rdi
  8004207237:	48 b8 cc 36 20 04 80 	movabs $0x80042036cc,%rax
  800420723e:	00 00 00 
  8004207241:	ff d0                	callq  *%rax
  8004207243:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  800420724a:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004207251:	00 00 00 
  8004207254:	48 8b 00             	mov    (%rax),%rax
  8004207257:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  800420725e:	48 c1 ea 27          	shr    $0x27,%rdx
  8004207262:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004207268:	48 c1 e2 03          	shl    $0x3,%rdx
  800420726c:	48 01 d0             	add    %rdx,%rax
  800420726f:	48 8b 00             	mov    (%rax),%rax
  8004207272:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207278:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  800420727f:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004207286:	48 c1 e8 0c          	shr    $0xc,%rax
  800420728a:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%rbp)
  8004207290:	8b 95 5c ff ff ff    	mov    -0xa4(%rbp),%edx
  8004207296:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  800420729d:	00 00 00 
  80042072a0:	48 8b 00             	mov    (%rax),%rax
  80042072a3:	48 39 c2             	cmp    %rax,%rdx
  80042072a6:	72 35                	jb     80042072dd <page_check+0x16e8>
  80042072a8:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042072af:	48 89 c1             	mov    %rax,%rcx
  80042072b2:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  80042072b9:	00 00 00 
  80042072bc:	be 59 05 00 00       	mov    $0x559,%esi
  80042072c1:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042072c8:	00 00 00 
  80042072cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042072d0:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042072d7:	00 00 00 
  80042072da:	41 ff d0             	callq  *%r8
  80042072dd:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042072e4:	00 00 00 
  80042072e7:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042072ee:	48 01 d0             	add    %rdx,%rax
  80042072f1:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  80042072f5:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042072fc:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004207300:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004207305:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420730c:	00 
  800420730d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004207311:	48 01 d0             	add    %rdx,%rax
  8004207314:	48 8b 00             	mov    (%rax),%rax
  8004207317:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420731d:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  8004207324:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420732b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420732f:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
  8004207335:	8b 95 4c ff ff ff    	mov    -0xb4(%rbp),%edx
  800420733b:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004207342:	00 00 00 
  8004207345:	48 8b 00             	mov    (%rax),%rax
  8004207348:	48 39 c2             	cmp    %rax,%rdx
  800420734b:	72 35                	jb     8004207382 <page_check+0x178d>
  800420734d:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004207354:	48 89 c1             	mov    %rax,%rcx
  8004207357:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  800420735e:	00 00 00 
  8004207361:	be 5a 05 00 00       	mov    $0x55a,%esi
  8004207366:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420736d:	00 00 00 
  8004207370:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207375:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420737c:	00 00 00 
  800420737f:	41 ff d0             	callq  *%r8
  8004207382:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207389:	00 00 00 
  800420738c:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004207393:	48 01 d0             	add    %rdx,%rax
  8004207396:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  800420739a:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042073a1:	48 c1 e8 15          	shr    $0x15,%rax
  80042073a5:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042073aa:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042073b1:	00 
  80042073b2:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042073b6:	48 01 d0             	add    %rdx,%rax
  80042073b9:	48 8b 00             	mov    (%rax),%rax
  80042073bc:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042073c2:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042073c9:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  80042073d0:	48 c1 e8 0c          	shr    $0xc,%rax
  80042073d4:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%rbp)
  80042073da:	8b 95 3c ff ff ff    	mov    -0xc4(%rbp),%edx
  80042073e0:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  80042073e7:	00 00 00 
  80042073ea:	48 8b 00             	mov    (%rax),%rax
  80042073ed:	48 39 c2             	cmp    %rax,%rdx
  80042073f0:	72 35                	jb     8004207427 <page_check+0x1832>
  80042073f2:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  80042073f9:	48 89 c1             	mov    %rax,%rcx
  80042073fc:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  8004207403:	00 00 00 
  8004207406:	be 5b 05 00 00       	mov    $0x55b,%esi
  800420740b:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004207412:	00 00 00 
  8004207415:	b8 00 00 00 00       	mov    $0x0,%eax
  800420741a:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004207421:	00 00 00 
  8004207424:	41 ff d0             	callq  *%r8
  8004207427:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420742e:	00 00 00 
  8004207431:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004207438:	48 01 d0             	add    %rdx,%rax
  800420743b:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
	assert(ptep == ptep1 + PTX(va));
  8004207442:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004207449:	48 c1 e8 0c          	shr    $0xc,%rax
  800420744d:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004207452:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207459:	00 
  800420745a:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  8004207461:	48 01 c2             	add    %rax,%rdx
  8004207464:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  800420746b:	48 39 c2             	cmp    %rax,%rdx
  800420746e:	74 35                	je     80042074a5 <page_check+0x18b0>
  8004207470:	48 b9 60 84 21 04 80 	movabs $0x8004218460,%rcx
  8004207477:	00 00 00 
  800420747a:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004207481:	00 00 00 
  8004207484:	be 5c 05 00 00       	mov    $0x55c,%esi
  8004207489:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004207490:	00 00 00 
  8004207493:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207498:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420749f:	00 00 00 
  80042074a2:	41 ff d0             	callq  *%r8
	
    // check that new page tables get cleared
    page_decref(pp4);
  80042074a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042074a9:	48 89 c7             	mov    %rax,%rdi
  80042074ac:	48 b8 8b 36 20 04 80 	movabs $0x800420368b,%rax
  80042074b3:	00 00 00 
  80042074b6:	ff d0                	callq  *%rax
	memset(page2kva(pp4), 0xFF, PGSIZE);
  80042074b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042074bc:	48 89 c7             	mov    %rax,%rdi
  80042074bf:	48 b8 9c 23 20 04 80 	movabs $0x800420239c,%rax
  80042074c6:	00 00 00 
  80042074c9:	ff d0                	callq  *%rax
  80042074cb:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042074d0:	be ff 00 00 00       	mov    $0xff,%esi
  80042074d5:	48 89 c7             	mov    %rax,%rdi
  80042074d8:	48 b8 b3 fb 20 04 80 	movabs $0x800420fbb3,%rax
  80042074df:	00 00 00 
  80042074e2:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  80042074e4:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  80042074eb:	00 00 00 
  80042074ee:	48 8b 00             	mov    (%rax),%rax
  80042074f1:	ba 01 00 00 00       	mov    $0x1,%edx
  80042074f6:	be 00 00 00 00       	mov    $0x0,%esi
  80042074fb:	48 89 c7             	mov    %rax,%rdi
  80042074fe:	48 b8 cc 36 20 04 80 	movabs $0x80042036cc,%rax
  8004207505:	00 00 00 
  8004207508:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  800420750a:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004207511:	00 00 00 
  8004207514:	48 8b 00             	mov    (%rax),%rax
  8004207517:	48 8b 00             	mov    (%rax),%rax
  800420751a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207520:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  8004207527:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420752e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207532:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
  8004207538:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  800420753e:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004207545:	00 00 00 
  8004207548:	48 8b 00             	mov    (%rax),%rax
  800420754b:	48 39 c2             	cmp    %rax,%rdx
  800420754e:	72 35                	jb     8004207585 <page_check+0x1990>
  8004207550:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004207557:	48 89 c1             	mov    %rax,%rcx
  800420755a:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  8004207561:	00 00 00 
  8004207564:	be 62 05 00 00       	mov    $0x562,%esi
  8004207569:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004207570:	00 00 00 
  8004207573:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207578:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420757f:	00 00 00 
  8004207582:	41 ff d0             	callq  *%r8
  8004207585:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420758c:	00 00 00 
  800420758f:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004207596:	48 01 d0             	add    %rdx,%rax
  8004207599:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    pde  = KADDR(PTE_ADDR(pdpe[0]));
  800420759d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042075a1:	48 8b 00             	mov    (%rax),%rax
  80042075a4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042075aa:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  80042075b1:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042075b8:	48 c1 e8 0c          	shr    $0xc,%rax
  80042075bc:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
  80042075c2:	8b 95 14 ff ff ff    	mov    -0xec(%rbp),%edx
  80042075c8:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  80042075cf:	00 00 00 
  80042075d2:	48 8b 00             	mov    (%rax),%rax
  80042075d5:	48 39 c2             	cmp    %rax,%rdx
  80042075d8:	72 35                	jb     800420760f <page_check+0x1a1a>
  80042075da:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042075e1:	48 89 c1             	mov    %rax,%rcx
  80042075e4:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  80042075eb:	00 00 00 
  80042075ee:	be 63 05 00 00       	mov    $0x563,%esi
  80042075f3:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042075fa:	00 00 00 
  80042075fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207602:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004207609:	00 00 00 
  800420760c:	41 ff d0             	callq  *%r8
  800420760f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207616:	00 00 00 
  8004207619:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004207620:	48 01 d0             	add    %rdx,%rax
  8004207623:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    ptep  = KADDR(PTE_ADDR(pde[0]));
  8004207627:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800420762b:	48 8b 00             	mov    (%rax),%rax
  800420762e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207634:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  800420763b:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004207642:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207646:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
  800420764c:	8b 95 04 ff ff ff    	mov    -0xfc(%rbp),%edx
  8004207652:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004207659:	00 00 00 
  800420765c:	48 8b 00             	mov    (%rax),%rax
  800420765f:	48 39 c2             	cmp    %rax,%rdx
  8004207662:	72 35                	jb     8004207699 <page_check+0x1aa4>
  8004207664:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420766b:	48 89 c1             	mov    %rax,%rcx
  800420766e:	48 ba 38 78 21 04 80 	movabs $0x8004217838,%rdx
  8004207675:	00 00 00 
  8004207678:	be 64 05 00 00       	mov    $0x564,%esi
  800420767d:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004207684:	00 00 00 
  8004207687:	b8 00 00 00 00       	mov    $0x0,%eax
  800420768c:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004207693:	00 00 00 
  8004207696:	41 ff d0             	callq  *%r8
  8004207699:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042076a0:	00 00 00 
  80042076a3:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80042076aa:	48 01 d0             	add    %rdx,%rax
  80042076ad:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	for(i=0; i<NPTENTRIES; i++)
  80042076b4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042076bb:	eb 58                	jmp    8004207715 <page_check+0x1b20>
		assert((ptep[i] & PTE_P) == 0);
  80042076bd:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  80042076c4:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042076c7:	48 63 d2             	movslq %edx,%rdx
  80042076ca:	48 c1 e2 03          	shl    $0x3,%rdx
  80042076ce:	48 01 d0             	add    %rdx,%rax
  80042076d1:	48 8b 00             	mov    (%rax),%rax
  80042076d4:	83 e0 01             	and    $0x1,%eax
  80042076d7:	48 85 c0             	test   %rax,%rax
  80042076da:	74 35                	je     8004207711 <page_check+0x1b1c>
  80042076dc:	48 b9 78 84 21 04 80 	movabs $0x8004218478,%rcx
  80042076e3:	00 00 00 
  80042076e6:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042076ed:	00 00 00 
  80042076f0:	be 66 05 00 00       	mov    $0x566,%esi
  80042076f5:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042076fc:	00 00 00 
  80042076ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207704:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420770b:	00 00 00 
  800420770e:	41 ff d0             	callq  *%r8
	memset(page2kva(pp4), 0xFF, PGSIZE);
	pml4e_walk(boot_pml4e, 0x0, 1);
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
    pde  = KADDR(PTE_ADDR(pdpe[0]));
    ptep  = KADDR(PTE_ADDR(pde[0]));
	for(i=0; i<NPTENTRIES; i++)
  8004207711:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004207715:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  800420771c:	7e 9f                	jle    80042076bd <page_check+0x1ac8>
		assert((ptep[i] & PTE_P) == 0);
	boot_pml4e[0] = 0;
  800420771e:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004207725:	00 00 00 
  8004207728:	48 8b 00             	mov    (%rax),%rax
  800420772b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  8004207732:	48 b8 38 02 36 04 80 	movabs $0x8004360238,%rax
  8004207739:	00 00 00 
  800420773c:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004207740:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  8004207743:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207747:	48 89 c7             	mov    %rax,%rdi
  800420774a:	48 b8 8b 36 20 04 80 	movabs $0x800420368b,%rax
  8004207751:	00 00 00 
  8004207754:	ff d0                	callq  *%rax
	page_decref(pp1);
  8004207756:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420775a:	48 89 c7             	mov    %rax,%rdi
  800420775d:	48 b8 8b 36 20 04 80 	movabs $0x800420368b,%rax
  8004207764:	00 00 00 
  8004207767:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004207769:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420776d:	48 89 c7             	mov    %rax,%rdi
  8004207770:	48 b8 8b 36 20 04 80 	movabs $0x800420368b,%rax
  8004207777:	00 00 00 
  800420777a:	ff d0                	callq  *%rax

	// test mmio_map_region
	mm1 = (uintptr_t) mmio_map_region(0, 4097);
  800420777c:	be 01 10 00 00       	mov    $0x1001,%esi
  8004207781:	bf 00 00 00 00       	mov    $0x0,%edi
  8004207786:	48 b8 24 40 20 04 80 	movabs $0x8004204024,%rax
  800420778d:	00 00 00 
  8004207790:	ff d0                	callq  *%rax
  8004207792:	48 89 85 f8 fe ff ff 	mov    %rax,-0x108(%rbp)
	mm2 = (uintptr_t) mmio_map_region(0, 4096);
  8004207799:	be 00 10 00 00       	mov    $0x1000,%esi
  800420779e:	bf 00 00 00 00       	mov    $0x0,%edi
  80042077a3:	48 b8 24 40 20 04 80 	movabs $0x8004204024,%rax
  80042077aa:	00 00 00 
  80042077ad:	ff d0                	callq  *%rax
  80042077af:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	// check that they're in the right region
	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
  80042077b6:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  80042077bd:	00 00 00 
  80042077c0:	48 39 85 f8 fe ff ff 	cmp    %rax,-0x108(%rbp)
  80042077c7:	76 1d                	jbe    80042077e6 <page_check+0x1bf1>
  80042077c9:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  80042077d0:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  80042077d7:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  80042077de:	00 00 00 
  80042077e1:	48 39 c2             	cmp    %rax,%rdx
  80042077e4:	76 35                	jbe    800420781b <page_check+0x1c26>
  80042077e6:	48 b9 90 84 21 04 80 	movabs $0x8004218490,%rcx
  80042077ed:	00 00 00 
  80042077f0:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042077f7:	00 00 00 
  80042077fa:	be 75 05 00 00       	mov    $0x575,%esi
  80042077ff:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004207806:	00 00 00 
  8004207809:	b8 00 00 00 00       	mov    $0x0,%eax
  800420780e:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004207815:	00 00 00 
  8004207818:	41 ff d0             	callq  *%r8
	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
  800420781b:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004207822:	00 00 00 
  8004207825:	48 39 85 f0 fe ff ff 	cmp    %rax,-0x110(%rbp)
  800420782c:	76 1d                	jbe    800420784b <page_check+0x1c56>
  800420782e:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207835:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  800420783c:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004207843:	00 00 00 
  8004207846:	48 39 c2             	cmp    %rax,%rdx
  8004207849:	76 35                	jbe    8004207880 <page_check+0x1c8b>
  800420784b:	48 b9 b8 84 21 04 80 	movabs $0x80042184b8,%rcx
  8004207852:	00 00 00 
  8004207855:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  800420785c:	00 00 00 
  800420785f:	be 76 05 00 00       	mov    $0x576,%esi
  8004207864:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420786b:	00 00 00 
  800420786e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207873:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420787a:	00 00 00 
  800420787d:	41 ff d0             	callq  *%r8
	// check that they're page-aligned
	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
  8004207880:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207887:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420788c:	48 85 c0             	test   %rax,%rax
  800420788f:	75 11                	jne    80042078a2 <page_check+0x1cad>
  8004207891:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207898:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420789d:	48 85 c0             	test   %rax,%rax
  80042078a0:	74 35                	je     80042078d7 <page_check+0x1ce2>
  80042078a2:	48 b9 e0 84 21 04 80 	movabs $0x80042184e0,%rcx
  80042078a9:	00 00 00 
  80042078ac:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042078b3:	00 00 00 
  80042078b6:	be 78 05 00 00       	mov    $0x578,%esi
  80042078bb:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042078c2:	00 00 00 
  80042078c5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042078ca:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042078d1:	00 00 00 
  80042078d4:	41 ff d0             	callq  *%r8
	// check that they don't overlap
	assert(mm1 + 8096 <= mm2);
  80042078d7:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  80042078de:	48 05 a0 1f 00 00    	add    $0x1fa0,%rax
  80042078e4:	48 3b 85 f0 fe ff ff 	cmp    -0x110(%rbp),%rax
  80042078eb:	76 35                	jbe    8004207922 <page_check+0x1d2d>
  80042078ed:	48 b9 07 85 21 04 80 	movabs $0x8004218507,%rcx
  80042078f4:	00 00 00 
  80042078f7:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042078fe:	00 00 00 
  8004207901:	be 7a 05 00 00       	mov    $0x57a,%esi
  8004207906:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420790d:	00 00 00 
  8004207910:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207915:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420791c:	00 00 00 
  800420791f:	41 ff d0             	callq  *%r8
	// check page mappings
	
	assert(check_va2pa(boot_pml4e, mm1) == 0);
  8004207922:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004207929:	00 00 00 
  800420792c:	48 8b 00             	mov    (%rax),%rax
  800420792f:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004207936:	48 89 d6             	mov    %rdx,%rsi
  8004207939:	48 89 c7             	mov    %rax,%rdi
  800420793c:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  8004207943:	00 00 00 
  8004207946:	ff d0                	callq  *%rax
  8004207948:	48 85 c0             	test   %rax,%rax
  800420794b:	74 35                	je     8004207982 <page_check+0x1d8d>
  800420794d:	48 b9 20 85 21 04 80 	movabs $0x8004218520,%rcx
  8004207954:	00 00 00 
  8004207957:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  800420795e:	00 00 00 
  8004207961:	be 7d 05 00 00       	mov    $0x57d,%esi
  8004207966:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  800420796d:	00 00 00 
  8004207970:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207975:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420797c:	00 00 00 
  800420797f:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm1+PGSIZE) == PGSIZE);
  8004207982:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207989:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207990:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004207997:	00 00 00 
  800420799a:	48 8b 00             	mov    (%rax),%rax
  800420799d:	48 89 d6             	mov    %rdx,%rsi
  80042079a0:	48 89 c7             	mov    %rax,%rdi
  80042079a3:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  80042079aa:	00 00 00 
  80042079ad:	ff d0                	callq  *%rax
  80042079af:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  80042079b5:	74 35                	je     80042079ec <page_check+0x1df7>
  80042079b7:	48 b9 48 85 21 04 80 	movabs $0x8004218548,%rcx
  80042079be:	00 00 00 
  80042079c1:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  80042079c8:	00 00 00 
  80042079cb:	be 7e 05 00 00       	mov    $0x57e,%esi
  80042079d0:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  80042079d7:	00 00 00 
  80042079da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042079df:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042079e6:	00 00 00 
  80042079e9:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2) == 0);
  80042079ec:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  80042079f3:	00 00 00 
  80042079f6:	48 8b 00             	mov    (%rax),%rax
  80042079f9:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  8004207a00:	48 89 d6             	mov    %rdx,%rsi
  8004207a03:	48 89 c7             	mov    %rax,%rdi
  8004207a06:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  8004207a0d:	00 00 00 
  8004207a10:	ff d0                	callq  *%rax
  8004207a12:	48 85 c0             	test   %rax,%rax
  8004207a15:	74 35                	je     8004207a4c <page_check+0x1e57>
  8004207a17:	48 b9 78 85 21 04 80 	movabs $0x8004218578,%rcx
  8004207a1e:	00 00 00 
  8004207a21:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004207a28:	00 00 00 
  8004207a2b:	be 7f 05 00 00       	mov    $0x57f,%esi
  8004207a30:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004207a37:	00 00 00 
  8004207a3a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207a3f:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004207a46:	00 00 00 
  8004207a49:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2+PGSIZE) == ~0);
  8004207a4c:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207a53:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207a5a:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004207a61:	00 00 00 
  8004207a64:	48 8b 00             	mov    (%rax),%rax
  8004207a67:	48 89 d6             	mov    %rdx,%rsi
  8004207a6a:	48 89 c7             	mov    %rax,%rdi
  8004207a6d:	48 b8 7b 59 20 04 80 	movabs $0x800420597b,%rax
  8004207a74:	00 00 00 
  8004207a77:	ff d0                	callq  *%rax
  8004207a79:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004207a7d:	74 35                	je     8004207ab4 <page_check+0x1ebf>
  8004207a7f:	48 b9 a0 85 21 04 80 	movabs $0x80042185a0,%rcx
  8004207a86:	00 00 00 
  8004207a89:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004207a90:	00 00 00 
  8004207a93:	be 80 05 00 00       	mov    $0x580,%esi
  8004207a98:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004207a9f:	00 00 00 
  8004207aa2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207aa7:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004207aae:	00 00 00 
  8004207ab1:	41 ff d0             	callq  *%r8
	// check permissions
	assert(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
  8004207ab4:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  8004207abb:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004207ac2:	00 00 00 
  8004207ac5:	48 8b 00             	mov    (%rax),%rax
  8004207ac8:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207acd:	48 89 ce             	mov    %rcx,%rsi
  8004207ad0:	48 89 c7             	mov    %rax,%rdi
  8004207ad3:	48 b8 cc 36 20 04 80 	movabs $0x80042036cc,%rax
  8004207ada:	00 00 00 
  8004207add:	ff d0                	callq  *%rax
  8004207adf:	48 8b 00             	mov    (%rax),%rax
  8004207ae2:	83 e0 1a             	and    $0x1a,%eax
  8004207ae5:	48 85 c0             	test   %rax,%rax
  8004207ae8:	75 35                	jne    8004207b1f <page_check+0x1f2a>
  8004207aea:	48 b9 d0 85 21 04 80 	movabs $0x80042185d0,%rcx
  8004207af1:	00 00 00 
  8004207af4:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004207afb:	00 00 00 
  8004207afe:	be 82 05 00 00       	mov    $0x582,%esi
  8004207b03:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004207b0a:	00 00 00 
  8004207b0d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207b12:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004207b19:	00 00 00 
  8004207b1c:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & PTE_U));
  8004207b1f:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  8004207b26:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004207b2d:	00 00 00 
  8004207b30:	48 8b 00             	mov    (%rax),%rax
  8004207b33:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207b38:	48 89 ce             	mov    %rcx,%rsi
  8004207b3b:	48 89 c7             	mov    %rax,%rdi
  8004207b3e:	48 b8 cc 36 20 04 80 	movabs $0x80042036cc,%rax
  8004207b45:	00 00 00 
  8004207b48:	ff d0                	callq  *%rax
  8004207b4a:	48 8b 00             	mov    (%rax),%rax
  8004207b4d:	83 e0 04             	and    $0x4,%eax
  8004207b50:	48 85 c0             	test   %rax,%rax
  8004207b53:	74 35                	je     8004207b8a <page_check+0x1f95>
  8004207b55:	48 b9 18 86 21 04 80 	movabs $0x8004218618,%rcx
  8004207b5c:	00 00 00 
  8004207b5f:	48 ba b1 78 21 04 80 	movabs $0x80042178b1,%rdx
  8004207b66:	00 00 00 
  8004207b69:	be 83 05 00 00       	mov    $0x583,%esi
  8004207b6e:	48 bf c6 78 21 04 80 	movabs $0x80042178c6,%rdi
  8004207b75:	00 00 00 
  8004207b78:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207b7d:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004207b84:	00 00 00 
  8004207b87:	41 ff d0             	callq  *%r8
	// clear the mappings
	*pml4e_walk(boot_pml4e, (void*) mm1, 0) = 0;
  8004207b8a:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  8004207b91:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004207b98:	00 00 00 
  8004207b9b:	48 8b 00             	mov    (%rax),%rax
  8004207b9e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207ba3:	48 89 ce             	mov    %rcx,%rsi
  8004207ba6:	48 89 c7             	mov    %rax,%rdi
  8004207ba9:	48 b8 cc 36 20 04 80 	movabs $0x80042036cc,%rax
  8004207bb0:	00 00 00 
  8004207bb3:	ff d0                	callq  *%rax
  8004207bb5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm1 + PGSIZE, 0) = 0;
  8004207bbc:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207bc3:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004207bc9:	48 89 c1             	mov    %rax,%rcx
  8004207bcc:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004207bd3:	00 00 00 
  8004207bd6:	48 8b 00             	mov    (%rax),%rax
  8004207bd9:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207bde:	48 89 ce             	mov    %rcx,%rsi
  8004207be1:	48 89 c7             	mov    %rax,%rdi
  8004207be4:	48 b8 cc 36 20 04 80 	movabs $0x80042036cc,%rax
  8004207beb:	00 00 00 
  8004207bee:	ff d0                	callq  *%rax
  8004207bf0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm2, 0) = 0;
  8004207bf7:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207bfe:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004207c05:	00 00 00 
  8004207c08:	48 8b 00             	mov    (%rax),%rax
  8004207c0b:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207c10:	48 89 ce             	mov    %rcx,%rsi
  8004207c13:	48 89 c7             	mov    %rax,%rdi
  8004207c16:	48 b8 cc 36 20 04 80 	movabs $0x80042036cc,%rax
  8004207c1d:	00 00 00 
  8004207c20:	ff d0                	callq  *%rax
  8004207c22:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	cprintf("check_page() succeeded!\n");
  8004207c29:	48 bf 4b 86 21 04 80 	movabs $0x800421864b,%rdi
  8004207c30:	00 00 00 
  8004207c33:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207c38:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004207c3f:	00 00 00 
  8004207c42:	ff d2                	callq  *%rdx
}
  8004207c44:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  8004207c4b:	5b                   	pop    %rbx
  8004207c4c:	5d                   	pop    %rbp
  8004207c4d:	c3                   	retq   

0000008004207c4e <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004207c4e:	55                   	push   %rbp
  8004207c4f:	48 89 e5             	mov    %rsp,%rbp
  8004207c52:	48 83 ec 08          	sub    $0x8,%rsp
  8004207c56:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004207c5a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207c5e:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  8004207c65:	00 00 00 
  8004207c68:	48 8b 00             	mov    (%rax),%rax
  8004207c6b:	48 29 c2             	sub    %rax,%rdx
  8004207c6e:	48 89 d0             	mov    %rdx,%rax
  8004207c71:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004207c75:	c9                   	leaveq 
  8004207c76:	c3                   	retq   

0000008004207c77 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004207c77:	55                   	push   %rbp
  8004207c78:	48 89 e5             	mov    %rsp,%rbp
  8004207c7b:	48 83 ec 08          	sub    $0x8,%rsp
  8004207c7f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004207c83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207c87:	48 89 c7             	mov    %rax,%rdi
  8004207c8a:	48 b8 4e 7c 20 04 80 	movabs $0x8004207c4e,%rax
  8004207c91:	00 00 00 
  8004207c94:	ff d0                	callq  *%rax
  8004207c96:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004207c9a:	c9                   	leaveq 
  8004207c9b:	c3                   	retq   

0000008004207c9c <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004207c9c:	55                   	push   %rbp
  8004207c9d:	48 89 e5             	mov    %rsp,%rbp
  8004207ca0:	48 83 ec 10          	sub    $0x10,%rsp
  8004207ca4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004207ca8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207cac:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207cb0:	48 89 c2             	mov    %rax,%rdx
  8004207cb3:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004207cba:	00 00 00 
  8004207cbd:	48 8b 00             	mov    (%rax),%rax
  8004207cc0:	48 39 c2             	cmp    %rax,%rdx
  8004207cc3:	72 2a                	jb     8004207cef <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004207cc5:	48 ba 68 86 21 04 80 	movabs $0x8004218668,%rdx
  8004207ccc:	00 00 00 
  8004207ccf:	be 54 00 00 00       	mov    $0x54,%esi
  8004207cd4:	48 bf 87 86 21 04 80 	movabs $0x8004218687,%rdi
  8004207cdb:	00 00 00 
  8004207cde:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207ce3:	48 b9 0b 05 20 04 80 	movabs $0x800420050b,%rcx
  8004207cea:	00 00 00 
  8004207ced:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004207cef:	48 b8 b8 17 36 04 80 	movabs $0x80043617b8,%rax
  8004207cf6:	00 00 00 
  8004207cf9:	48 8b 00             	mov    (%rax),%rax
  8004207cfc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207d00:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004207d04:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207d08:	48 01 d0             	add    %rdx,%rax
}
  8004207d0b:	c9                   	leaveq 
  8004207d0c:	c3                   	retq   

0000008004207d0d <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004207d0d:	55                   	push   %rbp
  8004207d0e:	48 89 e5             	mov    %rsp,%rbp
  8004207d11:	48 83 ec 20          	sub    $0x20,%rsp
  8004207d15:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004207d19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207d1d:	48 89 c7             	mov    %rax,%rdi
  8004207d20:	48 b8 77 7c 20 04 80 	movabs $0x8004207c77,%rax
  8004207d27:	00 00 00 
  8004207d2a:	ff d0                	callq  *%rax
  8004207d2c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207d30:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d34:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207d38:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004207d3b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004207d3e:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004207d45:	00 00 00 
  8004207d48:	48 8b 00             	mov    (%rax),%rax
  8004207d4b:	48 39 c2             	cmp    %rax,%rdx
  8004207d4e:	72 32                	jb     8004207d82 <page2kva+0x75>
  8004207d50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d54:	48 89 c1             	mov    %rax,%rcx
  8004207d57:	48 ba 98 86 21 04 80 	movabs $0x8004218698,%rdx
  8004207d5e:	00 00 00 
  8004207d61:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004207d66:	48 bf 87 86 21 04 80 	movabs $0x8004218687,%rdi
  8004207d6d:	00 00 00 
  8004207d70:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207d75:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004207d7c:	00 00 00 
  8004207d7f:	41 ff d0             	callq  *%r8
  8004207d82:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207d89:	00 00 00 
  8004207d8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d90:	48 01 d0             	add    %rdx,%rax
}
  8004207d93:	c9                   	leaveq 
  8004207d94:	c3                   	retq   

0000008004207d95 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  8004207d95:	55                   	push   %rbp
  8004207d96:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  8004207d99:	48 bf c0 a7 22 04 80 	movabs $0x800422a7c0,%rdi
  8004207da0:	00 00 00 
  8004207da3:	48 b8 1f 6f 21 04 80 	movabs $0x8004216f1f,%rax
  8004207daa:	00 00 00 
  8004207dad:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  8004207daf:	f3 90                	pause  
}
  8004207db1:	5d                   	pop    %rbp
  8004207db2:	c3                   	retq   

0000008004207db3 <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
	int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  8004207db3:	55                   	push   %rbp
  8004207db4:	48 89 e5             	mov    %rsp,%rbp
  8004207db7:	53                   	push   %rbx
  8004207db8:	48 83 ec 28          	sub    $0x28,%rsp
  8004207dbc:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8004207dbf:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004207dc3:	89 d0                	mov    %edx,%eax
  8004207dc5:	88 45 d8             	mov    %al,-0x28(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  8004207dc8:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004207dcc:	75 42                	jne    8004207e10 <envid2env+0x5d>
		*env_store = curenv;
  8004207dce:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004207dd5:	00 00 00 
  8004207dd8:	ff d0                	callq  *%rax
  8004207dda:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  8004207de1:	00 00 00 
  8004207de4:	48 98                	cltq   
  8004207de6:	48 c1 e0 03          	shl    $0x3,%rax
  8004207dea:	48 89 c2             	mov    %rax,%rdx
  8004207ded:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207df1:	48 29 c2             	sub    %rax,%rdx
  8004207df4:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207df8:	48 83 c0 08          	add    $0x8,%rax
  8004207dfc:	48 8b 10             	mov    (%rax),%rdx
  8004207dff:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207e03:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  8004207e06:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207e0b:	e9 09 01 00 00       	jmpq   8004207f19 <envid2env+0x166>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  8004207e10:	48 b8 50 02 36 04 80 	movabs $0x8004360250,%rax
  8004207e17:	00 00 00 
  8004207e1a:	48 8b 08             	mov    (%rax),%rcx
  8004207e1d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004207e20:	48 98                	cltq   
  8004207e22:	25 ff 03 00 00       	and    $0x3ff,%eax
  8004207e27:	48 89 c2             	mov    %rax,%rdx
  8004207e2a:	48 89 d0             	mov    %rdx,%rax
  8004207e2d:	48 c1 e0 03          	shl    $0x3,%rax
  8004207e31:	48 01 d0             	add    %rdx,%rax
  8004207e34:	48 c1 e0 05          	shl    $0x5,%rax
  8004207e38:	48 01 c8             	add    %rcx,%rax
  8004207e3b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  8004207e3f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207e43:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004207e49:	85 c0                	test   %eax,%eax
  8004207e4b:	74 0f                	je     8004207e5c <envid2env+0xa9>
  8004207e4d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207e51:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207e57:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  8004207e5a:	74 15                	je     8004207e71 <envid2env+0xbe>
		*env_store = 0;
  8004207e5c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207e60:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207e67:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207e6c:	e9 a8 00 00 00       	jmpq   8004207f19 <envid2env+0x166>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  8004207e71:	80 7d d8 00          	cmpb   $0x0,-0x28(%rbp)
  8004207e75:	0f 84 8e 00 00 00    	je     8004207f09 <envid2env+0x156>
  8004207e7b:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004207e82:	00 00 00 
  8004207e85:	ff d0                	callq  *%rax
  8004207e87:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  8004207e8e:	00 00 00 
  8004207e91:	48 98                	cltq   
  8004207e93:	48 c1 e0 03          	shl    $0x3,%rax
  8004207e97:	48 89 c2             	mov    %rax,%rdx
  8004207e9a:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207e9e:	48 29 c2             	sub    %rax,%rdx
  8004207ea1:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207ea5:	48 83 c0 08          	add    $0x8,%rax
  8004207ea9:	48 8b 00             	mov    (%rax),%rax
  8004207eac:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004207eb0:	74 57                	je     8004207f09 <envid2env+0x156>
  8004207eb2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207eb6:	8b 98 cc 00 00 00    	mov    0xcc(%rax),%ebx
  8004207ebc:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004207ec3:	00 00 00 
  8004207ec6:	ff d0                	callq  *%rax
  8004207ec8:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  8004207ecf:	00 00 00 
  8004207ed2:	48 98                	cltq   
  8004207ed4:	48 c1 e0 03          	shl    $0x3,%rax
  8004207ed8:	48 89 c2             	mov    %rax,%rdx
  8004207edb:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207edf:	48 29 c2             	sub    %rax,%rdx
  8004207ee2:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207ee6:	48 83 c0 08          	add    $0x8,%rax
  8004207eea:	48 8b 00             	mov    (%rax),%rax
  8004207eed:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207ef3:	39 c3                	cmp    %eax,%ebx
  8004207ef5:	74 12                	je     8004207f09 <envid2env+0x156>
		*env_store = 0;
  8004207ef7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207efb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207f02:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207f07:	eb 10                	jmp    8004207f19 <envid2env+0x166>
	}

	*env_store = e;
  8004207f09:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207f0d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207f11:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  8004207f14:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207f19:	48 83 c4 28          	add    $0x28,%rsp
  8004207f1d:	5b                   	pop    %rbx
  8004207f1e:	5d                   	pop    %rbp
  8004207f1f:	c3                   	retq   

0000008004207f20 <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
	void
env_init(void)
{
  8004207f20:	55                   	push   %rbp
  8004207f21:	48 89 e5             	mov    %rsp,%rbp
  8004207f24:	48 83 ec 10          	sub    $0x10,%rsp
	// Set up envs array
	// LAB 3: Your code here.
	
	int  i;
        struct Env * last = NULL;
  8004207f28:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004207f2f:	00 
        for(i = 0; i < NENV; i++)
  8004207f30:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004207f37:	e9 bf 00 00 00       	jmpq   8004207ffb <env_init+0xdb>
         {
            envs[i].env_id = 0;
  8004207f3c:	48 b8 50 02 36 04 80 	movabs $0x8004360250,%rax
  8004207f43:	00 00 00 
  8004207f46:	48 8b 08             	mov    (%rax),%rcx
  8004207f49:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004207f4c:	48 63 d0             	movslq %eax,%rdx
  8004207f4f:	48 89 d0             	mov    %rdx,%rax
  8004207f52:	48 c1 e0 03          	shl    $0x3,%rax
  8004207f56:	48 01 d0             	add    %rdx,%rax
  8004207f59:	48 c1 e0 05          	shl    $0x5,%rax
  8004207f5d:	48 01 c8             	add    %rcx,%rax
  8004207f60:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%rax)
  8004207f67:	00 00 00 
            envs[i].env_status = ENV_FREE;
  8004207f6a:	48 b8 50 02 36 04 80 	movabs $0x8004360250,%rax
  8004207f71:	00 00 00 
  8004207f74:	48 8b 08             	mov    (%rax),%rcx
  8004207f77:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004207f7a:	48 63 d0             	movslq %eax,%rdx
  8004207f7d:	48 89 d0             	mov    %rdx,%rax
  8004207f80:	48 c1 e0 03          	shl    $0x3,%rax
  8004207f84:	48 01 d0             	add    %rdx,%rax
  8004207f87:	48 c1 e0 05          	shl    $0x5,%rax
  8004207f8b:	48 01 c8             	add    %rcx,%rax
  8004207f8e:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8004207f95:	00 00 00 
            if(last)
  8004207f98:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004207f9d:	74 30                	je     8004207fcf <env_init+0xaf>
              last->env_link = &envs[i]; 
  8004207f9f:	48 b8 50 02 36 04 80 	movabs $0x8004360250,%rax
  8004207fa6:	00 00 00 
  8004207fa9:	48 8b 08             	mov    (%rax),%rcx
  8004207fac:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004207faf:	48 63 d0             	movslq %eax,%rdx
  8004207fb2:	48 89 d0             	mov    %rdx,%rax
  8004207fb5:	48 c1 e0 03          	shl    $0x3,%rax
  8004207fb9:	48 01 d0             	add    %rdx,%rax
  8004207fbc:	48 c1 e0 05          	shl    $0x5,%rax
  8004207fc0:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004207fc4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207fc8:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
           
	    last = &envs[i];
  8004207fcf:	48 b8 50 02 36 04 80 	movabs $0x8004360250,%rax
  8004207fd6:	00 00 00 
  8004207fd9:	48 8b 08             	mov    (%rax),%rcx
  8004207fdc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004207fdf:	48 63 d0             	movslq %eax,%rdx
  8004207fe2:	48 89 d0             	mov    %rdx,%rax
  8004207fe5:	48 c1 e0 03          	shl    $0x3,%rax
  8004207fe9:	48 01 d0             	add    %rdx,%rax
  8004207fec:	48 c1 e0 05          	shl    $0x5,%rax
  8004207ff0:	48 01 c8             	add    %rcx,%rax
  8004207ff3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	// Set up envs array
	// LAB 3: Your code here.
	
	int  i;
        struct Env * last = NULL;
        for(i = 0; i < NENV; i++)
  8004207ff7:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004207ffb:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  8004208002:	0f 8e 34 ff ff ff    	jle    8004207f3c <env_init+0x1c>
            if(last)
              last->env_link = &envs[i]; 
           
	    last = &envs[i];
	 }  
        last->env_link = NULL;
  8004208008:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420800c:	48 c7 80 c0 00 00 00 	movq   $0x0,0xc0(%rax)
  8004208013:	00 00 00 00 
        env_free_list = envs;
  8004208017:	48 b8 50 02 36 04 80 	movabs $0x8004360250,%rax
  800420801e:	00 00 00 
  8004208021:	48 8b 10             	mov    (%rax),%rdx
  8004208024:	48 b8 58 02 36 04 80 	movabs $0x8004360258,%rax
  800420802b:	00 00 00 
  800420802e:	48 89 10             	mov    %rdx,(%rax)
        // Per-CPU part of the initialization
	env_init_percpu();
  8004208031:	48 b8 3f 80 20 04 80 	movabs $0x800420803f,%rax
  8004208038:	00 00 00 
  800420803b:	ff d0                	callq  *%rax
}
  800420803d:	c9                   	leaveq 
  800420803e:	c3                   	retq   

000000800420803f <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  800420803f:	55                   	push   %rbp
  8004208040:	48 89 e5             	mov    %rsp,%rbp
  8004208043:	53                   	push   %rbx
  8004208044:	48 83 ec 10          	sub    $0x10,%rsp
  8004208048:	48 b8 c8 a6 22 04 80 	movabs $0x800422a6c8,%rax
  800420804f:	00 00 00 
  8004208052:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}

static __inline void
lgdt(void *p)
{
	__asm __volatile("lgdt (%0)" : : "r" (p));
  8004208056:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420805a:	0f 01 10             	lgdt   (%rax)
lgdt(&gdt_pd);

// The kernel never uses GS or FS, so we leave those set to
// the user data segment.
asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  800420805d:	b8 23 00 00 00       	mov    $0x23,%eax
  8004208062:	8e e8                	mov    %eax,%gs
asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  8004208064:	b8 23 00 00 00       	mov    $0x23,%eax
  8004208069:	8e e0                	mov    %eax,%fs
// The kernel does use ES, DS, and SS.  We'll change between
// the kernel and user data segments as needed.
asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  800420806b:	b8 10 00 00 00       	mov    $0x10,%eax
  8004208070:	8e c0                	mov    %eax,%es
asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  8004208072:	b8 10 00 00 00       	mov    $0x10,%eax
  8004208077:	8e d8                	mov    %eax,%ds
asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  8004208079:	b8 10 00 00 00       	mov    $0x10,%eax
  800420807e:	8e d0                	mov    %eax,%ss
// Load the kernel text segment into CS.
asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  8004208080:	b8 08 00 00 00       	mov    $0x8,%eax
  8004208085:	89 c3                	mov    %eax,%ebx
  8004208087:	53                   	push   %rbx
  8004208088:	48 b8 95 80 20 04 80 	movabs $0x8004208095,%rax
  800420808f:	00 00 00 
  8004208092:	50                   	push   %rax
  8004208093:	48 cb                	lretq  
  8004208095:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
}

static __inline void
lldt(uint16_t sel)
{
	__asm __volatile("lldt %0" : : "r" (sel));
  800420809b:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  800420809f:	0f 00 d0             	lldt   %ax
// For good measure, clear the local descriptor table (LDT),
// since we don't use it.
lldt(0);
}
  80042080a2:	48 83 c4 10          	add    $0x10,%rsp
  80042080a6:	5b                   	pop    %rbx
  80042080a7:	5d                   	pop    %rbp
  80042080a8:	c3                   	retq   

00000080042080a9 <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
	static int
env_setup_vm(struct Env *e)
{
  80042080a9:	55                   	push   %rbp
  80042080aa:	48 89 e5             	mov    %rsp,%rbp
  80042080ad:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  80042080b1:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  80042080b5:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042080bc:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(0)))
  80042080bd:	bf 00 00 00 00       	mov    $0x0,%edi
  80042080c2:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  80042080c9:	00 00 00 
  80042080cc:	ff d0                	callq  *%rax
  80042080ce:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042080d2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042080d7:	75 0a                	jne    80042080e3 <env_setup_vm+0x3a>
		return -E_NO_MEM;
  80042080d9:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80042080de:	e9 98 03 00 00       	jmpq   800420847b <env_setup_vm+0x3d2>
	// LAB 3: Your code here.

	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	
	p->pp_ref++;
  80042080e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042080e7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042080eb:	8d 50 01             	lea    0x1(%rax),%edx
  80042080ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042080f2:	66 89 50 08          	mov    %dx,0x8(%rax)

	pde_t *pgdir;
	pgdir = (pde_t*)page2kva(p);	
  80042080f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042080fa:	48 89 c7             	mov    %rax,%rdi
  80042080fd:	48 b8 0d 7d 20 04 80 	movabs $0x8004207d0d,%rax
  8004208104:	00 00 00 
  8004208107:	ff d0                	callq  *%rax
  8004208109:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	
	// Data from UTOP here	
	pml4e_t *root_pml4e = boot_pml4e + PML4(UTOP);	
  800420810d:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  8004208114:	00 00 00 
  8004208117:	48 8b 00             	mov    (%rax),%rax
  800420811a:	48 83 c0 08          	add    $0x8,%rax
  800420811e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if(!(*root_pml4e & PTE_P))
  8004208122:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208126:	48 8b 00             	mov    (%rax),%rax
  8004208129:	83 e0 01             	and    $0x1,%eax
  800420812c:	48 85 c0             	test   %rax,%rax
  800420812f:	75 0a                	jne    800420813b <env_setup_vm+0x92>
		return -E_NO_MEM;
  8004208131:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004208136:	e9 40 03 00 00       	jmpq   800420847b <env_setup_vm+0x3d2>
	
	pdpe_t *root_pdpe = KADDR(PTE_ADDR(*root_pml4e));
  800420813b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420813f:	48 8b 00             	mov    (%rax),%rax
  8004208142:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208148:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420814c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208150:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208154:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004208157:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420815a:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004208161:	00 00 00 
  8004208164:	48 8b 00             	mov    (%rax),%rax
  8004208167:	48 39 c2             	cmp    %rax,%rdx
  800420816a:	72 32                	jb     800420819e <env_setup_vm+0xf5>
  800420816c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208170:	48 89 c1             	mov    %rax,%rcx
  8004208173:	48 ba 98 86 21 04 80 	movabs $0x8004218698,%rdx
  800420817a:	00 00 00 
  800420817d:	be db 00 00 00       	mov    $0xdb,%esi
  8004208182:	48 bf bb 86 21 04 80 	movabs $0x80042186bb,%rdi
  8004208189:	00 00 00 
  800420818c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208191:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004208198:	00 00 00 
  800420819b:	41 ff d0             	callq  *%r8
  800420819e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042081a5:	00 00 00 
  80042081a8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042081ac:	48 01 d0             	add    %rdx,%rax
  80042081af:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	root_pdpe += PDPE(UTOP);
	
	if(!(*root_pdpe & PTE_P))
  80042081b3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042081b7:	48 8b 00             	mov    (%rax),%rax
  80042081ba:	83 e0 01             	and    $0x1,%eax
  80042081bd:	48 85 c0             	test   %rax,%rax
  80042081c0:	75 0a                	jne    80042081cc <env_setup_vm+0x123>
		return -E_NO_MEM;
  80042081c2:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80042081c7:	e9 af 02 00 00       	jmpq   800420847b <env_setup_vm+0x3d2>

	pde_t *root_pgdir = KADDR(PTE_ADDR(*root_pdpe));
  80042081cc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042081d0:	48 8b 00             	mov    (%rax),%rax
  80042081d3:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042081d9:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042081dd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042081e1:	48 c1 e8 0c          	shr    $0xc,%rax
  80042081e5:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  80042081e8:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042081eb:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  80042081f2:	00 00 00 
  80042081f5:	48 8b 00             	mov    (%rax),%rax
  80042081f8:	48 39 c2             	cmp    %rax,%rdx
  80042081fb:	72 32                	jb     800420822f <env_setup_vm+0x186>
  80042081fd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208201:	48 89 c1             	mov    %rax,%rcx
  8004208204:	48 ba 98 86 21 04 80 	movabs $0x8004218698,%rdx
  800420820b:	00 00 00 
  800420820e:	be e1 00 00 00       	mov    $0xe1,%esi
  8004208213:	48 bf bb 86 21 04 80 	movabs $0x80042186bb,%rdi
  800420821a:	00 00 00 
  800420821d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208222:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004208229:	00 00 00 
  800420822c:	41 ff d0             	callq  *%r8
  800420822f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208236:	00 00 00 
  8004208239:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420823d:	48 01 d0             	add    %rdx,%rax
  8004208240:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	memcpy(pgdir, root_pgdir, PGSIZE);
  8004208244:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004208248:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420824c:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004208251:	48 89 ce             	mov    %rcx,%rsi
  8004208254:	48 89 c7             	mov    %rax,%rdi
  8004208257:	48 b8 55 fd 20 04 80 	movabs $0x800420fd55,%rax
  800420825e:	00 00 00 
  8004208261:	ff d0                	callq  *%rax
	

	if(!(p = page_alloc(ALLOC_ZERO)))
  8004208263:	bf 01 00 00 00       	mov    $0x1,%edi
  8004208268:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  800420826f:	00 00 00 
  8004208272:	ff d0                	callq  *%rax
  8004208274:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004208278:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420827d:	75 0a                	jne    8004208289 <env_setup_vm+0x1e0>
		return -E_NO_MEM;
  800420827f:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004208284:	e9 f2 01 00 00       	jmpq   800420847b <env_setup_vm+0x3d2>
	p->pp_ref++;
  8004208289:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420828d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004208291:	8d 50 01             	lea    0x1(%rax),%edx
  8004208294:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208298:	66 89 50 08          	mov    %dx,0x8(%rax)
	
	pdpe_t *pdpe = (pdpe_t*)page2kva(p);
  800420829c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042082a0:	48 89 c7             	mov    %rax,%rdi
  80042082a3:	48 b8 0d 7d 20 04 80 	movabs $0x8004207d0d,%rax
  80042082aa:	00 00 00 
  80042082ad:	ff d0                	callq  *%rax
  80042082af:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	pdpe[PDPE(UTOP)] = PADDR(pgdir) | PTE_USER;
  80042082b3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042082b7:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  80042082bb:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042082c2:	00 00 00 
  80042082c5:	48 39 45 a8          	cmp    %rax,-0x58(%rbp)
  80042082c9:	77 32                	ja     80042082fd <env_setup_vm+0x254>
  80042082cb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042082cf:	48 89 c1             	mov    %rax,%rcx
  80042082d2:	48 ba c8 86 21 04 80 	movabs $0x80042186c8,%rdx
  80042082d9:	00 00 00 
  80042082dc:	be ea 00 00 00       	mov    $0xea,%esi
  80042082e1:	48 bf bb 86 21 04 80 	movabs $0x80042186bb,%rdi
  80042082e8:	00 00 00 
  80042082eb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042082f0:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042082f7:	00 00 00 
  80042082fa:	41 ff d0             	callq  *%r8
  80042082fd:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004208304:	ff ff ff 
  8004208307:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420830b:	48 01 d0             	add    %rdx,%rax
  800420830e:	48 0d 07 0e 00 00    	or     $0xe07,%rax
  8004208314:	48 89 c2             	mov    %rax,%rdx
  8004208317:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420831b:	48 89 10             	mov    %rdx,(%rax)
	
	if(!(p = page_alloc(ALLOC_ZERO)))
  800420831e:	bf 01 00 00 00       	mov    $0x1,%edi
  8004208323:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  800420832a:	00 00 00 
  800420832d:	ff d0                	callq  *%rax
  800420832f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004208333:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004208338:	75 0a                	jne    8004208344 <env_setup_vm+0x29b>
		return -E_NO_MEM;
  800420833a:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420833f:	e9 37 01 00 00       	jmpq   800420847b <env_setup_vm+0x3d2>
	p->pp_ref++;
  8004208344:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208348:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420834c:	8d 50 01             	lea    0x1(%rax),%edx
  800420834f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208353:	66 89 50 08          	mov    %dx,0x8(%rax)
	
	e->env_pml4e = (pml4e_t*)page2kva(p);
  8004208357:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420835b:	48 89 c7             	mov    %rax,%rdi
  800420835e:	48 b8 0d 7d 20 04 80 	movabs $0x8004207d0d,%rax
  8004208365:	00 00 00 
  8004208368:	ff d0                	callq  *%rax
  800420836a:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  800420836e:	48 89 82 e0 00 00 00 	mov    %rax,0xe0(%rdx)
	e->env_pml4e[PML4(UTOP)] = PADDR(pdpe) | PTE_USER;
  8004208375:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004208379:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208380:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004208384:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004208388:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  800420838c:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004208393:	00 00 00 
  8004208396:	48 39 45 a0          	cmp    %rax,-0x60(%rbp)
  800420839a:	77 32                	ja     80042083ce <env_setup_vm+0x325>
  800420839c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042083a0:	48 89 c1             	mov    %rax,%rcx
  80042083a3:	48 ba c8 86 21 04 80 	movabs $0x80042186c8,%rdx
  80042083aa:	00 00 00 
  80042083ad:	be f1 00 00 00       	mov    $0xf1,%esi
  80042083b2:	48 bf bb 86 21 04 80 	movabs $0x80042186bb,%rdi
  80042083b9:	00 00 00 
  80042083bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042083c1:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042083c8:	00 00 00 
  80042083cb:	41 ff d0             	callq  *%r8
  80042083ce:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  80042083d5:	ff ff ff 
  80042083d8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042083dc:	48 01 c8             	add    %rcx,%rax
  80042083df:	48 0d 07 0e 00 00    	or     $0xe07,%rax
  80042083e5:	48 89 02             	mov    %rax,(%rdx)
	e->env_cr3 = PADDR(e->env_pml4e);
  80042083e8:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042083ec:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042083f3:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  80042083f7:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042083fe:	00 00 00 
  8004208401:	48 39 45 98          	cmp    %rax,-0x68(%rbp)
  8004208405:	77 32                	ja     8004208439 <env_setup_vm+0x390>
  8004208407:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420840b:	48 89 c1             	mov    %rax,%rcx
  800420840e:	48 ba c8 86 21 04 80 	movabs $0x80042186c8,%rdx
  8004208415:	00 00 00 
  8004208418:	be f2 00 00 00       	mov    $0xf2,%esi
  800420841d:	48 bf bb 86 21 04 80 	movabs $0x80042186bb,%rdi
  8004208424:	00 00 00 
  8004208427:	b8 00 00 00 00       	mov    $0x0,%eax
  800420842c:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004208433:	00 00 00 
  8004208436:	41 ff d0             	callq  *%r8
  8004208439:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004208440:	ff ff ff 
  8004208443:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208447:	48 01 c2             	add    %rax,%rdx
  800420844a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800420844e:	48 89 90 e8 00 00 00 	mov    %rdx,0xe8(%rax)

	e->env_pml4e[PML4(UVPT)] = e->env_cr3 | PTE_P | PTE_U;
  8004208455:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004208459:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208460:	48 8d 50 10          	lea    0x10(%rax),%rdx
  8004208464:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004208468:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  800420846f:	48 83 c8 05          	or     $0x5,%rax
  8004208473:	48 89 02             	mov    %rax,(%rdx)

	return 0;
  8004208476:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420847b:	c9                   	leaveq 
  800420847c:	c3                   	retq   

000000800420847d <env_alloc>:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
	int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  800420847d:	55                   	push   %rbp
  800420847e:	48 89 e5             	mov    %rsp,%rbp
  8004208481:	53                   	push   %rbx
  8004208482:	48 83 ec 38          	sub    $0x38,%rsp
  8004208486:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420848a:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = env_free_list))
  800420848d:	48 b8 58 02 36 04 80 	movabs $0x8004360258,%rax
  8004208494:	00 00 00 
  8004208497:	48 8b 00             	mov    (%rax),%rax
  800420849a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420849e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042084a3:	75 0a                	jne    80042084af <env_alloc+0x32>
		return -E_NO_FREE_ENV;
  80042084a5:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  80042084aa:	e9 13 02 00 00       	jmpq   80042086c2 <env_alloc+0x245>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  80042084af:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042084b3:	48 89 c7             	mov    %rax,%rdi
  80042084b6:	48 b8 a9 80 20 04 80 	movabs $0x80042080a9,%rax
  80042084bd:	00 00 00 
  80042084c0:	ff d0                	callq  *%rax
  80042084c2:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042084c5:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042084c9:	79 08                	jns    80042084d3 <env_alloc+0x56>
		return r;
  80042084cb:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042084ce:	e9 ef 01 00 00       	jmpq   80042086c2 <env_alloc+0x245>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  80042084d3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042084d7:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042084dd:	05 00 10 00 00       	add    $0x1000,%eax
  80042084e2:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  80042084e7:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  80042084ea:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80042084ee:	7f 07                	jg     80042084f7 <env_alloc+0x7a>
		generation = 1 << ENVGENSHIFT;
  80042084f0:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%rbp)
	e->env_id = generation | (e - envs);
  80042084f7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042084fb:	48 b8 50 02 36 04 80 	movabs $0x8004360250,%rax
  8004208502:	00 00 00 
  8004208505:	48 8b 00             	mov    (%rax),%rax
  8004208508:	48 29 c2             	sub    %rax,%rdx
  800420850b:	48 89 d0             	mov    %rdx,%rax
  800420850e:	48 c1 f8 05          	sar    $0x5,%rax
  8004208512:	48 89 c2             	mov    %rax,%rdx
  8004208515:	48 b8 39 8e e3 38 8e 	movabs $0x8e38e38e38e38e39,%rax
  800420851c:	e3 38 8e 
  800420851f:	48 0f af c2          	imul   %rdx,%rax
  8004208523:	0b 45 ec             	or     -0x14(%rbp),%eax
  8004208526:	89 c2                	mov    %eax,%edx
  8004208528:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420852c:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  8004208532:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208536:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004208539:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  800420853f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208543:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  800420854a:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  800420854d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208551:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004208558:	00 00 00 
	e->env_runs = 0;
  800420855b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420855f:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  8004208566:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  8004208569:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420856d:	ba c0 00 00 00       	mov    $0xc0,%edx
  8004208572:	be 00 00 00 00       	mov    $0x0,%esi
  8004208577:	48 89 c7             	mov    %rax,%rdi
  800420857a:	48 b8 b3 fb 20 04 80 	movabs $0x800420fbb3,%rax
  8004208581:	00 00 00 
  8004208584:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  8004208586:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420858a:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  8004208591:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  8004208593:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208597:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  800420859d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042085a1:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  80042085a8:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  80042085aa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042085ae:	bb 00 e0 7f ef       	mov    $0xef7fe000,%ebx
  80042085b3:	48 89 98 b0 00 00 00 	mov    %rbx,0xb0(%rax)
	e->env_tf.tf_cs = GD_UT | 3;
  80042085ba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042085be:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  80042085c5:	1b 00 
	// You will set e->env_tf.tf_rip later.

	// Enable interrupts while in user mode.
	// LAB 4: Your code here.
	e->env_tf.tf_eflags |= FL_IF;
  80042085c7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042085cb:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  80042085d2:	80 cc 02             	or     $0x2,%ah
  80042085d5:	48 89 c2             	mov    %rax,%rdx
  80042085d8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042085dc:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)

	// Clear the page fault handler until user installs one.
	e->env_pgfault_upcall = 0;
  80042085e3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042085e7:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  80042085ee:	00 00 00 00 

	// Also clear the IPC receiving flag.
	e->env_ipc_recving = 0;
  80042085f2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042085f6:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  80042085fd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208601:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  8004208608:	48 b8 58 02 36 04 80 	movabs $0x8004360258,%rax
  800420860f:	00 00 00 
  8004208612:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  8004208615:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208619:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420861d:	48 89 10             	mov    %rdx,(%rax)

	cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
  8004208620:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208624:	8b 98 c8 00 00 00    	mov    0xc8(%rax),%ebx
  800420862a:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004208631:	00 00 00 
  8004208634:	ff d0                	callq  *%rax
  8004208636:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420863d:	00 00 00 
  8004208640:	48 98                	cltq   
  8004208642:	48 c1 e0 03          	shl    $0x3,%rax
  8004208646:	48 89 c2             	mov    %rax,%rdx
  8004208649:	48 c1 e2 04          	shl    $0x4,%rdx
  800420864d:	48 29 c2             	sub    %rax,%rdx
  8004208650:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208654:	48 83 c0 08          	add    $0x8,%rax
  8004208658:	48 8b 00             	mov    (%rax),%rax
  800420865b:	48 85 c0             	test   %rax,%rax
  800420865e:	74 39                	je     8004208699 <env_alloc+0x21c>
  8004208660:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004208667:	00 00 00 
  800420866a:	ff d0                	callq  *%rax
  800420866c:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  8004208673:	00 00 00 
  8004208676:	48 98                	cltq   
  8004208678:	48 c1 e0 03          	shl    $0x3,%rax
  800420867c:	48 89 c2             	mov    %rax,%rdx
  800420867f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208683:	48 29 c2             	sub    %rax,%rdx
  8004208686:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420868a:	48 83 c0 08          	add    $0x8,%rax
  800420868e:	48 8b 00             	mov    (%rax),%rax
  8004208691:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004208697:	eb 05                	jmp    800420869e <env_alloc+0x221>
  8004208699:	b8 00 00 00 00       	mov    $0x0,%eax
  800420869e:	89 da                	mov    %ebx,%edx
  80042086a0:	89 c6                	mov    %eax,%esi
  80042086a2:	48 bf ec 86 21 04 80 	movabs $0x80042186ec,%rdi
  80042086a9:	00 00 00 
  80042086ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80042086b1:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  80042086b8:	00 00 00 
  80042086bb:	ff d1                	callq  *%rcx
	return 0;
  80042086bd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042086c2:	48 83 c4 38          	add    $0x38,%rsp
  80042086c6:	5b                   	pop    %rbx
  80042086c7:	5d                   	pop    %rbp
  80042086c8:	c3                   	retq   

00000080042086c9 <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  80042086c9:	55                   	push   %rbp
  80042086ca:	48 89 e5             	mov    %rsp,%rbp
  80042086cd:	48 83 ec 60          	sub    $0x60,%rsp
  80042086d1:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  80042086d5:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  80042086d9:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)

	
	char *start = (char *)ROUNDDOWN(va, PGSIZE);
  80042086dd:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042086e1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042086e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042086e9:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042086ef:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	char *end = (char*)ROUNDUP((char*)va+len, PGSIZE);
  80042086f3:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  80042086fa:	00 
  80042086fb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042086ff:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004208703:	48 01 d0             	add    %rdx,%rax
  8004208706:	48 89 c2             	mov    %rax,%rdx
  8004208709:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420870d:	48 01 d0             	add    %rdx,%rax
  8004208710:	48 83 e8 01          	sub    $0x1,%rax
  8004208714:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004208718:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420871c:	ba 00 00 00 00       	mov    $0x0,%edx
  8004208721:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004208725:	48 89 d0             	mov    %rdx,%rax
  8004208728:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420872c:	48 29 c2             	sub    %rax,%rdx
  800420872f:	48 89 d0             	mov    %rdx,%rax
  8004208732:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	struct PageInfo *p;
	char *v;
	for (v = start; v < end; v+=PGSIZE) 
  8004208736:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420873a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420873e:	eb 75                	jmp    80042087b5 <region_alloc+0xec>
	{
		p = page_alloc(ALLOC_ZERO);
  8004208740:	bf 01 00 00 00       	mov    $0x1,%edi
  8004208745:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  800420874c:	00 00 00 
  800420874f:	ff d0                	callq  *%rax
  8004208751:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		if(p == NULL)
  8004208755:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420875a:	75 2a                	jne    8004208786 <region_alloc+0xbd>
		    panic("Page alloc fail\n");
  800420875c:	48 ba 01 87 21 04 80 	movabs $0x8004218701,%rdx
  8004208763:	00 00 00 
  8004208766:	be 5d 01 00 00       	mov    $0x15d,%esi
  800420876b:	48 bf bb 86 21 04 80 	movabs $0x80042186bb,%rdi
  8004208772:	00 00 00 
  8004208775:	b8 00 00 00 00       	mov    $0x0,%eax
  800420877a:	48 b9 0b 05 20 04 80 	movabs $0x800420050b,%rcx
  8004208781:	00 00 00 
  8004208784:	ff d1                	callq  *%rcx
		page_insert(e->env_pml4e, p, v, PTE_P | PTE_U | PTE_W);
  8004208786:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420878a:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208791:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004208795:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8004208799:	b9 07 00 00 00       	mov    $0x7,%ecx
  800420879e:	48 89 c7             	mov    %rax,%rdi
  80042087a1:	48 b8 1d 3d 20 04 80 	movabs $0x8004203d1d,%rax
  80042087a8:	00 00 00 
  80042087ab:	ff d0                	callq  *%rax
	
	char *start = (char *)ROUNDDOWN(va, PGSIZE);
	char *end = (char*)ROUNDUP((char*)va+len, PGSIZE);
	struct PageInfo *p;
	char *v;
	for (v = start; v < end; v+=PGSIZE) 
  80042087ad:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042087b4:	00 
  80042087b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042087b9:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042087bd:	72 81                	jb     8004208740 <region_alloc+0x77>
		p = page_alloc(ALLOC_ZERO);
		if(p == NULL)
		    panic("Page alloc fail\n");
		page_insert(e->env_pml4e, p, v, PTE_P | PTE_U | PTE_W);
	}
}
  80042087bf:	c9                   	leaveq 
  80042087c0:	c3                   	retq   

00000080042087c1 <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  80042087c1:	55                   	push   %rbp
  80042087c2:	48 89 e5             	mov    %rsp,%rbp
  80042087c5:	53                   	push   %rbx
  80042087c6:	48 83 ec 48          	sub    $0x48,%rsp
  80042087ca:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  80042087ce:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)

	   // LAB 3: Your code here.
	    //cprintf("\nIn load mode\n");
	    struct Proghdr *ph, *eph;
	    struct Elf * header;
	    e->elf = binary;
  80042087d2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042087d6:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042087da:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)
	    header = (struct Elf *) binary;
  80042087e1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042087e5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	    
	    if (header->e_magic != ELF_MAGIC)
  80042087e9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042087ed:	8b 00                	mov    (%rax),%eax
  80042087ef:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  80042087f4:	74 2a                	je     8004208820 <load_icode+0x5f>
		panic("header Problem");
  80042087f6:	48 ba 12 87 21 04 80 	movabs $0x8004218712,%rdx
  80042087fd:	00 00 00 
  8004208800:	be a3 01 00 00       	mov    $0x1a3,%esi
  8004208805:	48 bf bb 86 21 04 80 	movabs $0x80042186bb,%rdi
  800420880c:	00 00 00 
  800420880f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208814:	48 b9 0b 05 20 04 80 	movabs $0x800420050b,%rcx
  800420881b:	00 00 00 
  800420881e:	ff d1                	callq  *%rcx
	    
	    ph = (struct Proghdr *) ((uint8_t *) header + header->e_phoff);
  8004208820:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208824:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004208828:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420882c:	48 01 d0             	add    %rdx,%rax
  800420882f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	    eph = ph + header->e_phnum; 
  8004208833:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208837:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  800420883b:	0f b7 c0             	movzwl %ax,%eax
  800420883e:	48 c1 e0 03          	shl    $0x3,%rax
  8004208842:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208849:	00 
  800420884a:	48 29 c2             	sub    %rax,%rdx
  800420884d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208851:	48 01 d0             	add    %rdx,%rax
  8004208854:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	    for (; ph < eph; ph++)
  8004208858:	e9 c0 00 00 00       	jmpq   800420891d <load_icode+0x15c>
	      {
		if(ph->p_type == ELF_PROG_LOAD)
  800420885d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208861:	8b 00                	mov    (%rax),%eax
  8004208863:	83 f8 01             	cmp    $0x1,%eax
  8004208866:	0f 85 ac 00 00 00    	jne    8004208918 <load_icode+0x157>
		  {
		     region_alloc(e, (void *)ph->p_va, ph->p_memsz);
  800420886c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208870:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004208874:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208878:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420887c:	48 89 c1             	mov    %rax,%rcx
  800420887f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208883:	48 89 ce             	mov    %rcx,%rsi
  8004208886:	48 89 c7             	mov    %rax,%rdi
  8004208889:	48 b8 c9 86 20 04 80 	movabs $0x80042086c9,%rax
  8004208890:	00 00 00 
  8004208893:	ff d0                	callq  *%rax
		     lcr3(e->env_cr3);
  8004208895:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208899:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042088a0:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  80042088a4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042088a8:	0f 22 d8             	mov    %rax,%cr3
		     memset((void *)ph->p_va, 0, ph->p_memsz);
  80042088ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042088af:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042088b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042088b7:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042088bb:	be 00 00 00 00       	mov    $0x0,%esi
  80042088c0:	48 89 c7             	mov    %rax,%rdi
  80042088c3:	48 b8 b3 fb 20 04 80 	movabs $0x800420fbb3,%rax
  80042088ca:	00 00 00 
  80042088cd:	ff d0                	callq  *%rax
		     memcpy((void *)ph->p_va, (uint8_t *)header + ph->p_offset, ph->p_filesz);
  80042088cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042088d3:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042088d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042088db:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042088df:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042088e3:	48 01 c1             	add    %rax,%rcx
  80042088e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042088ea:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042088ee:	48 89 ce             	mov    %rcx,%rsi
  80042088f1:	48 89 c7             	mov    %rax,%rdi
  80042088f4:	48 b8 55 fd 20 04 80 	movabs $0x800420fd55,%rax
  80042088fb:	00 00 00 
  80042088fe:	ff d0                	callq  *%rax
		     lcr3(boot_cr3);
  8004208900:	48 b8 a0 17 36 04 80 	movabs $0x80043617a0,%rax
  8004208907:	00 00 00 
  800420890a:	48 8b 00             	mov    (%rax),%rax
  800420890d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004208911:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208915:	0f 22 d8             	mov    %rax,%cr3
		panic("header Problem");
	    
	    ph = (struct Proghdr *) ((uint8_t *) header + header->e_phoff);
	    eph = ph + header->e_phnum; 

	    for (; ph < eph; ph++)
  8004208918:	48 83 45 e8 38       	addq   $0x38,-0x18(%rbp)
  800420891d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208921:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004208925:	0f 82 32 ff ff ff    	jb     800420885d <load_icode+0x9c>
		     lcr3(boot_cr3);
		  }

	      }

	    e->env_tf.tf_rip = (uintptr_t)(header->e_entry);
  800420892b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420892f:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004208933:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208937:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
            e->env_tf.tf_rsp = (USTACKTOP);
  800420893e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208942:	bb 00 e0 7f ef       	mov    $0xef7fe000,%ebx
  8004208947:	48 89 98 b0 00 00 00 	mov    %rbx,0xb0(%rax)
	    region_alloc (e , (void *)(USTACKTOP - PGSIZE), PGSIZE);
  800420894e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208952:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004208957:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  800420895c:	48 89 c7             	mov    %rax,%rdi
  800420895f:	48 b8 c9 86 20 04 80 	movabs $0x80042086c9,%rax
  8004208966:	00 00 00 
  8004208969:	ff d0                	callq  *%rax
        		
}
  800420896b:	48 83 c4 48          	add    $0x48,%rsp
  800420896f:	5b                   	pop    %rbx
  8004208970:	5d                   	pop    %rbp
  8004208971:	c3                   	retq   

0000008004208972 <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  8004208972:	55                   	push   %rbp
  8004208973:	48 89 e5             	mov    %rsp,%rbp
  8004208976:	48 83 ec 20          	sub    $0x20,%rsp
  800420897a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420897e:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// LAB 3: Your code here.

   struct Env *env;
   //env_alloc(&env, curenv->env_id);
   env_alloc(&env, 0);
  8004208981:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  8004208985:	be 00 00 00 00       	mov    $0x0,%esi
  800420898a:	48 89 c7             	mov    %rax,%rdi
  800420898d:	48 b8 7d 84 20 04 80 	movabs $0x800420847d,%rax
  8004208994:	00 00 00 
  8004208997:	ff d0                	callq  *%rax
   load_icode(env, binary);
  8004208999:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420899d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042089a1:	48 89 d6             	mov    %rdx,%rsi
  80042089a4:	48 89 c7             	mov    %rax,%rdi
  80042089a7:	48 b8 c1 87 20 04 80 	movabs $0x80042087c1,%rax
  80042089ae:	00 00 00 
  80042089b1:	ff d0                	callq  *%rax
   env->env_type = type;  
  80042089b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042089b7:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042089ba:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
}
  80042089c0:	c9                   	leaveq 
  80042089c1:	c3                   	retq   

00000080042089c2 <env_free>:
//
// Frees env e and all memory it uses.
//
	void
env_free(struct Env *e)
{
  80042089c2:	55                   	push   %rbp
  80042089c3:	48 89 e5             	mov    %rsp,%rbp
  80042089c6:	53                   	push   %rbx
  80042089c7:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  80042089ce:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
	physaddr_t pa;

	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  80042089d5:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  80042089dc:	00 00 00 
  80042089df:	ff d0                	callq  *%rax
  80042089e1:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  80042089e8:	00 00 00 
  80042089eb:	48 98                	cltq   
  80042089ed:	48 c1 e0 03          	shl    $0x3,%rax
  80042089f1:	48 89 c2             	mov    %rax,%rdx
  80042089f4:	48 c1 e2 04          	shl    $0x4,%rdx
  80042089f8:	48 29 c2             	sub    %rax,%rdx
  80042089fb:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042089ff:	48 83 c0 08          	add    $0x8,%rax
  8004208a03:	48 8b 00             	mov    (%rax),%rax
  8004208a06:	48 3b 85 68 ff ff ff 	cmp    -0x98(%rbp),%rax
  8004208a0d:	75 1e                	jne    8004208a2d <env_free+0x6b>
		lcr3(boot_cr3);
  8004208a0f:	48 b8 a0 17 36 04 80 	movabs $0x80043617a0,%rax
  8004208a16:	00 00 00 
  8004208a19:	48 8b 00             	mov    (%rax),%rax
  8004208a1c:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004208a23:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208a2a:	0f 22 d8             	mov    %rax,%cr3

	// Note the environment's demise.
	cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
  8004208a2d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208a34:	8b 98 c8 00 00 00    	mov    0xc8(%rax),%ebx
  8004208a3a:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004208a41:	00 00 00 
  8004208a44:	ff d0                	callq  *%rax
  8004208a46:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  8004208a4d:	00 00 00 
  8004208a50:	48 98                	cltq   
  8004208a52:	48 c1 e0 03          	shl    $0x3,%rax
  8004208a56:	48 89 c2             	mov    %rax,%rdx
  8004208a59:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208a5d:	48 29 c2             	sub    %rax,%rdx
  8004208a60:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208a64:	48 83 c0 08          	add    $0x8,%rax
  8004208a68:	48 8b 00             	mov    (%rax),%rax
  8004208a6b:	48 85 c0             	test   %rax,%rax
  8004208a6e:	74 39                	je     8004208aa9 <env_free+0xe7>
  8004208a70:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004208a77:	00 00 00 
  8004208a7a:	ff d0                	callq  *%rax
  8004208a7c:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  8004208a83:	00 00 00 
  8004208a86:	48 98                	cltq   
  8004208a88:	48 c1 e0 03          	shl    $0x3,%rax
  8004208a8c:	48 89 c2             	mov    %rax,%rdx
  8004208a8f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208a93:	48 29 c2             	sub    %rax,%rdx
  8004208a96:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208a9a:	48 83 c0 08          	add    $0x8,%rax
  8004208a9e:	48 8b 00             	mov    (%rax),%rax
  8004208aa1:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004208aa7:	eb 05                	jmp    8004208aae <env_free+0xec>
  8004208aa9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208aae:	89 da                	mov    %ebx,%edx
  8004208ab0:	89 c6                	mov    %eax,%esi
  8004208ab2:	48 bf 21 87 21 04 80 	movabs $0x8004218721,%rdi
  8004208ab9:	00 00 00 
  8004208abc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208ac1:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  8004208ac8:	00 00 00 
  8004208acb:	ff d1                	callq  *%rcx

	// Flush all mapped pages in the user portion of the address space
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  8004208acd:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208ad4:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208adb:	48 8b 00             	mov    (%rax),%rax
  8004208ade:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208ae4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004208ae8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208aec:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208af0:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004208af3:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004208af6:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004208afd:	00 00 00 
  8004208b00:	48 8b 00             	mov    (%rax),%rax
  8004208b03:	48 39 c2             	cmp    %rax,%rdx
  8004208b06:	72 32                	jb     8004208b3a <env_free+0x178>
  8004208b08:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208b0c:	48 89 c1             	mov    %rax,%rcx
  8004208b0f:	48 ba 98 86 21 04 80 	movabs $0x8004218698,%rdx
  8004208b16:	00 00 00 
  8004208b19:	be e2 01 00 00       	mov    $0x1e2,%esi
  8004208b1e:	48 bf bb 86 21 04 80 	movabs $0x80042186bb,%rdi
  8004208b25:	00 00 00 
  8004208b28:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208b2d:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004208b34:	00 00 00 
  8004208b37:	41 ff d0             	callq  *%r8
  8004208b3a:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208b41:	00 00 00 
  8004208b44:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208b48:	48 01 d0             	add    %rdx,%rax
  8004208b4b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004208b4f:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004208b56:	00 
  8004208b57:	e9 ab 02 00 00       	jmpq   8004208e07 <env_free+0x445>
		if(!(env_pdpe[pdpe_index] & PTE_P))
  8004208b5c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208b60:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208b67:	00 
  8004208b68:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004208b6c:	48 01 d0             	add    %rdx,%rax
  8004208b6f:	48 8b 00             	mov    (%rax),%rax
  8004208b72:	83 e0 01             	and    $0x1,%eax
  8004208b75:	48 85 c0             	test   %rax,%rax
  8004208b78:	75 05                	jne    8004208b7f <env_free+0x1bd>
			continue;
  8004208b7a:	e9 83 02 00 00       	jmpq   8004208e02 <env_free+0x440>
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  8004208b7f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208b83:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208b8a:	00 
  8004208b8b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004208b8f:	48 01 d0             	add    %rdx,%rax
  8004208b92:	48 8b 00             	mov    (%rax),%rax
  8004208b95:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208b9b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004208b9f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208ba3:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208ba7:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  8004208baa:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004208bad:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004208bb4:	00 00 00 
  8004208bb7:	48 8b 00             	mov    (%rax),%rax
  8004208bba:	48 39 c2             	cmp    %rax,%rdx
  8004208bbd:	72 32                	jb     8004208bf1 <env_free+0x22f>
  8004208bbf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208bc3:	48 89 c1             	mov    %rax,%rcx
  8004208bc6:	48 ba 98 86 21 04 80 	movabs $0x8004218698,%rdx
  8004208bcd:	00 00 00 
  8004208bd0:	be ea 01 00 00       	mov    $0x1ea,%esi
  8004208bd5:	48 bf bb 86 21 04 80 	movabs $0x80042186bb,%rdi
  8004208bdc:	00 00 00 
  8004208bdf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208be4:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004208beb:	00 00 00 
  8004208bee:	41 ff d0             	callq  *%r8
  8004208bf1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208bf8:	00 00 00 
  8004208bfb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208bff:	48 01 d0             	add    %rdx,%rax
  8004208c02:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  8004208c06:	48 83 7d d8 03       	cmpq   $0x3,-0x28(%rbp)
  8004208c0b:	75 07                	jne    8004208c14 <env_free+0x252>
  8004208c0d:	b8 04 00 00 00       	mov    $0x4,%eax
  8004208c12:	eb 05                	jmp    8004208c19 <env_free+0x257>
  8004208c14:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  8004208c19:	89 45 a4             	mov    %eax,-0x5c(%rbp)
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208c1c:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004208c23:	00 
  8004208c24:	e9 6e 01 00 00       	jmpq   8004208d97 <env_free+0x3d5>

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
  8004208c29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208c2d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208c34:	00 
  8004208c35:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208c39:	48 01 d0             	add    %rdx,%rax
  8004208c3c:	48 8b 00             	mov    (%rax),%rax
  8004208c3f:	83 e0 01             	and    $0x1,%eax
  8004208c42:	48 85 c0             	test   %rax,%rax
  8004208c45:	75 05                	jne    8004208c4c <env_free+0x28a>
				continue;
  8004208c47:	e9 46 01 00 00       	jmpq   8004208d92 <env_free+0x3d0>
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
  8004208c4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208c50:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208c57:	00 
  8004208c58:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208c5c:	48 01 d0             	add    %rdx,%rax
  8004208c5f:	48 8b 00             	mov    (%rax),%rax
  8004208c62:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208c68:	48 89 45 98          	mov    %rax,-0x68(%rbp)
			pt = (pte_t*) KADDR(pa);
  8004208c6c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208c70:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004208c74:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004208c78:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208c7c:	89 45 8c             	mov    %eax,-0x74(%rbp)
  8004208c7f:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004208c82:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004208c89:	00 00 00 
  8004208c8c:	48 8b 00             	mov    (%rax),%rax
  8004208c8f:	48 39 c2             	cmp    %rax,%rdx
  8004208c92:	72 32                	jb     8004208cc6 <env_free+0x304>
  8004208c94:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004208c98:	48 89 c1             	mov    %rax,%rcx
  8004208c9b:	48 ba 98 86 21 04 80 	movabs $0x8004218698,%rdx
  8004208ca2:	00 00 00 
  8004208ca5:	be f4 01 00 00       	mov    $0x1f4,%esi
  8004208caa:	48 bf bb 86 21 04 80 	movabs $0x80042186bb,%rdi
  8004208cb1:	00 00 00 
  8004208cb4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208cb9:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004208cc0:	00 00 00 
  8004208cc3:	41 ff d0             	callq  *%r8
  8004208cc6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208ccd:	00 00 00 
  8004208cd0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004208cd4:	48 01 d0             	add    %rdx,%rax
  8004208cd7:	48 89 45 80          	mov    %rax,-0x80(%rbp)

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004208cdb:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004208ce2:	00 
  8004208ce3:	eb 67                	jmp    8004208d4c <env_free+0x38a>
				if (pt[pteno] & PTE_P){
  8004208ce5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208ce9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208cf0:	00 
  8004208cf1:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004208cf5:	48 01 d0             	add    %rdx,%rax
  8004208cf8:	48 8b 00             	mov    (%rax),%rax
  8004208cfb:	83 e0 01             	and    $0x1,%eax
  8004208cfe:	48 85 c0             	test   %rax,%rax
  8004208d01:	74 44                	je     8004208d47 <env_free+0x385>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  8004208d03:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208d07:	48 c1 e0 1e          	shl    $0x1e,%rax
  8004208d0b:	48 89 c2             	mov    %rax,%rdx
  8004208d0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208d12:	48 c1 e0 15          	shl    $0x15,%rax
  8004208d16:	48 09 c2             	or     %rax,%rdx
  8004208d19:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208d1d:	48 c1 e0 0c          	shl    $0xc,%rax
  8004208d21:	48 09 d0             	or     %rdx,%rax
  8004208d24:	48 89 c2             	mov    %rax,%rdx
  8004208d27:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208d2e:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208d35:	48 89 d6             	mov    %rdx,%rsi
  8004208d38:	48 89 c7             	mov    %rax,%rdi
  8004208d3b:	48 b8 d8 3e 20 04 80 	movabs $0x8004203ed8,%rax
  8004208d42:	00 00 00 
  8004208d45:	ff d0                	callq  *%rax
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
			pt = (pte_t*) KADDR(pa);

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004208d47:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
  8004208d4c:	48 81 7d e0 fe 01 00 	cmpq   $0x1fe,-0x20(%rbp)
  8004208d53:	00 
  8004208d54:	76 8f                	jbe    8004208ce5 <env_free+0x323>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
				}
			}

			// free the page table itself
			env_pgdir[pdeno] = 0;
  8004208d56:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208d5a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208d61:	00 
  8004208d62:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208d66:	48 01 d0             	add    %rdx,%rax
  8004208d69:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  8004208d70:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208d74:	48 89 c7             	mov    %rax,%rdi
  8004208d77:	48 b8 9c 7c 20 04 80 	movabs $0x8004207c9c,%rax
  8004208d7e:	00 00 00 
  8004208d81:	ff d0                	callq  *%rax
  8004208d83:	48 89 c7             	mov    %rax,%rdi
  8004208d86:	48 b8 8b 36 20 04 80 	movabs $0x800420368b,%rax
  8004208d8d:	00 00 00 
  8004208d90:	ff d0                	callq  *%rax
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208d92:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004208d97:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004208d9a:	48 98                	cltq   
  8004208d9c:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004208da0:	0f 87 83 fe ff ff    	ja     8004208c29 <env_free+0x267>
			// free the page table itself
			env_pgdir[pdeno] = 0;
			page_decref(pa2page(pa));
		}
		// free the page directory
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
  8004208da6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208daa:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208db1:	00 
  8004208db2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004208db6:	48 01 d0             	add    %rdx,%rax
  8004208db9:	48 8b 00             	mov    (%rax),%rax
  8004208dbc:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208dc2:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		env_pdpe[pdpe_index] = 0;
  8004208dc6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208dca:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208dd1:	00 
  8004208dd2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004208dd6:	48 01 d0             	add    %rdx,%rax
  8004208dd9:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		page_decref(pa2page(pa));
  8004208de0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208de4:	48 89 c7             	mov    %rax,%rdi
  8004208de7:	48 b8 9c 7c 20 04 80 	movabs $0x8004207c9c,%rax
  8004208dee:	00 00 00 
  8004208df1:	ff d0                	callq  *%rax
  8004208df3:	48 89 c7             	mov    %rax,%rdi
  8004208df6:	48 b8 8b 36 20 04 80 	movabs $0x800420368b,%rax
  8004208dfd:	00 00 00 
  8004208e00:	ff d0                	callq  *%rax
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004208e02:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8004208e07:	48 83 7d d8 03       	cmpq   $0x3,-0x28(%rbp)
  8004208e0c:	0f 86 4a fd ff ff    	jbe    8004208b5c <env_free+0x19a>
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
		env_pdpe[pdpe_index] = 0;
		page_decref(pa2page(pa));
	}
	// free the page directory pointer
	page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  8004208e12:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208e19:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208e20:	48 8b 00             	mov    (%rax),%rax
  8004208e23:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208e29:	48 89 c7             	mov    %rax,%rdi
  8004208e2c:	48 b8 9c 7c 20 04 80 	movabs $0x8004207c9c,%rax
  8004208e33:	00 00 00 
  8004208e36:	ff d0                	callq  *%rax
  8004208e38:	48 89 c7             	mov    %rax,%rdi
  8004208e3b:	48 b8 8b 36 20 04 80 	movabs $0x800420368b,%rax
  8004208e42:	00 00 00 
  8004208e45:	ff d0                	callq  *%rax
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  8004208e47:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208e4e:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208e55:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  8004208e5c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208e63:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208e6a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	e->env_pml4e = 0;
  8004208e6e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208e75:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  8004208e7c:	00 00 00 00 
	e->env_cr3 = 0;
  8004208e80:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208e87:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8004208e8e:	00 00 00 00 
	page_decref(pa2page(pa));
  8004208e92:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208e96:	48 89 c7             	mov    %rax,%rdi
  8004208e99:	48 b8 9c 7c 20 04 80 	movabs $0x8004207c9c,%rax
  8004208ea0:	00 00 00 
  8004208ea3:	ff d0                	callq  *%rax
  8004208ea5:	48 89 c7             	mov    %rax,%rdi
  8004208ea8:	48 b8 8b 36 20 04 80 	movabs $0x800420368b,%rax
  8004208eaf:	00 00 00 
  8004208eb2:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  8004208eb4:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208ebb:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8004208ec2:	00 00 00 
	e->env_link = env_free_list;
  8004208ec5:	48 b8 58 02 36 04 80 	movabs $0x8004360258,%rax
  8004208ecc:	00 00 00 
  8004208ecf:	48 8b 10             	mov    (%rax),%rdx
  8004208ed2:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208ed9:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  8004208ee0:	48 b8 58 02 36 04 80 	movabs $0x8004360258,%rax
  8004208ee7:	00 00 00 
  8004208eea:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004208ef1:	48 89 10             	mov    %rdx,(%rax)
}
  8004208ef4:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  8004208efb:	5b                   	pop    %rbx
  8004208efc:	5d                   	pop    %rbp
  8004208efd:	c3                   	retq   

0000008004208efe <env_destroy>:
// If e was the current env, then runs a new environment (and does not return
// to the caller).
//
	void
env_destroy(struct Env *e)
{
  8004208efe:	55                   	push   %rbp
  8004208eff:	48 89 e5             	mov    %rsp,%rbp
  8004208f02:	48 83 ec 10          	sub    $0x10,%rsp
  8004208f06:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// If e is currently running on other CPUs, we change its state to
	// ENV_DYING. A zombie environment will be freed the next time
	// it traps to the kernel.
	if (e->env_status == ENV_RUNNING && curenv != e) {
  8004208f0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208f0e:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004208f14:	83 f8 03             	cmp    $0x3,%eax
  8004208f17:	75 4a                	jne    8004208f63 <env_destroy+0x65>
  8004208f19:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004208f20:	00 00 00 
  8004208f23:	ff d0                	callq  *%rax
  8004208f25:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  8004208f2c:	00 00 00 
  8004208f2f:	48 98                	cltq   
  8004208f31:	48 c1 e0 03          	shl    $0x3,%rax
  8004208f35:	48 89 c2             	mov    %rax,%rdx
  8004208f38:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208f3c:	48 29 c2             	sub    %rax,%rdx
  8004208f3f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208f43:	48 83 c0 08          	add    $0x8,%rax
  8004208f47:	48 8b 00             	mov    (%rax),%rax
  8004208f4a:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208f4e:	74 13                	je     8004208f63 <env_destroy+0x65>
		e->env_status = ENV_DYING;
  8004208f50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208f54:	c7 80 d4 00 00 00 01 	movl   $0x1,0xd4(%rax)
  8004208f5b:	00 00 00 
		return;
  8004208f5e:	e9 8b 00 00 00       	jmpq   8004208fee <env_destroy+0xf0>
	}

	env_free(e);
  8004208f63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208f67:	48 89 c7             	mov    %rax,%rdi
  8004208f6a:	48 b8 c2 89 20 04 80 	movabs $0x80042089c2,%rax
  8004208f71:	00 00 00 
  8004208f74:	ff d0                	callq  *%rax

	if (curenv == e) {
  8004208f76:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004208f7d:	00 00 00 
  8004208f80:	ff d0                	callq  *%rax
  8004208f82:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  8004208f89:	00 00 00 
  8004208f8c:	48 98                	cltq   
  8004208f8e:	48 c1 e0 03          	shl    $0x3,%rax
  8004208f92:	48 89 c2             	mov    %rax,%rdx
  8004208f95:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208f99:	48 29 c2             	sub    %rax,%rdx
  8004208f9c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208fa0:	48 83 c0 08          	add    $0x8,%rax
  8004208fa4:	48 8b 00             	mov    (%rax),%rax
  8004208fa7:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208fab:	75 41                	jne    8004208fee <env_destroy+0xf0>
		curenv = NULL;
  8004208fad:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004208fb4:	00 00 00 
  8004208fb7:	ff d0                	callq  *%rax
  8004208fb9:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  8004208fc0:	00 00 00 
  8004208fc3:	48 98                	cltq   
  8004208fc5:	48 c1 e0 03          	shl    $0x3,%rax
  8004208fc9:	48 89 c2             	mov    %rax,%rdx
  8004208fcc:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208fd0:	48 29 c2             	sub    %rax,%rdx
  8004208fd3:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208fd7:	48 83 c0 08          	add    $0x8,%rax
  8004208fdb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		sched_yield();
  8004208fe2:	48 b8 61 d2 20 04 80 	movabs $0x800420d261,%rax
  8004208fe9:	00 00 00 
  8004208fec:	ff d0                	callq  *%rax
	}
}
  8004208fee:	c9                   	leaveq 
  8004208fef:	c3                   	retq   

0000008004208ff0 <env_pop_tf>:
//
// This function does not return.
//
	void
env_pop_tf(struct Trapframe *tf)
{
  8004208ff0:	55                   	push   %rbp
  8004208ff1:	48 89 e5             	mov    %rsp,%rbp
  8004208ff4:	53                   	push   %rbx
  8004208ff5:	48 83 ec 18          	sub    $0x18,%rsp
  8004208ff9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Record the CPU we are running on for user-space debugging
	curenv->env_cpunum = cpunum();
  8004208ffd:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004209004:	00 00 00 
  8004209007:	ff d0                	callq  *%rax
  8004209009:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  8004209010:	00 00 00 
  8004209013:	48 98                	cltq   
  8004209015:	48 c1 e0 03          	shl    $0x3,%rax
  8004209019:	48 89 c2             	mov    %rax,%rdx
  800420901c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209020:	48 29 c2             	sub    %rax,%rdx
  8004209023:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004209027:	48 83 c0 08          	add    $0x8,%rax
  800420902b:	48 8b 18             	mov    (%rax),%rbx
  800420902e:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004209035:	00 00 00 
  8004209038:	ff d0                	callq  *%rax
  800420903a:	89 83 dc 00 00 00    	mov    %eax,0xdc(%rbx)

	//cprintf("\n\n tf %16.0x\n\n", tf->tf_rip);
	__asm __volatile("movq %0,%%rsp\n"
  8004209040:	48 8b 65 e8          	mov    -0x18(%rbp),%rsp
  8004209044:	4c 8b 3c 24          	mov    (%rsp),%r15
  8004209048:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  800420904d:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  8004209052:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  8004209057:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  800420905c:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  8004209061:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  8004209066:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  800420906b:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  8004209070:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  8004209075:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  800420907a:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  800420907f:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  8004209084:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  8004209089:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800420908e:	48 83 c4 78          	add    $0x78,%rsp
  8004209092:	8e 04 24             	mov    (%rsp),%es
  8004209095:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  8004209099:	48 83 c4 10          	add    $0x10,%rsp
  800420909d:	48 83 c4 10          	add    $0x10,%rsp
  80042090a1:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  80042090a3:	48 ba 37 87 21 04 80 	movabs $0x8004218737,%rdx
  80042090aa:	00 00 00 
  80042090ad:	be 43 02 00 00       	mov    $0x243,%esi
  80042090b2:	48 bf bb 86 21 04 80 	movabs $0x80042186bb,%rdi
  80042090b9:	00 00 00 
  80042090bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042090c1:	48 b9 0b 05 20 04 80 	movabs $0x800420050b,%rcx
  80042090c8:	00 00 00 
  80042090cb:	ff d1                	callq  *%rcx

00000080042090cd <env_run>:
// Note: if this is the first call to env_run, curenv is NULL.
//
// This function does not return.
//
void env_run(struct Env *e)
{
  80042090cd:	55                   	push   %rbp
  80042090ce:	48 89 e5             	mov    %rsp,%rbp
  80042090d1:	48 83 ec 20          	sub    $0x20,%rsp
  80042090d5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//	e->env_tf to sensible values.

	// LAB 3: Your code here.
        //cprintf("\nIn running mode\n");
	
	if (curenv != NULL && curenv->env_status == ENV_RUNNING)
  80042090d9:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  80042090e0:	00 00 00 
  80042090e3:	ff d0                	callq  *%rax
  80042090e5:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  80042090ec:	00 00 00 
  80042090ef:	48 98                	cltq   
  80042090f1:	48 c1 e0 03          	shl    $0x3,%rax
  80042090f5:	48 89 c2             	mov    %rax,%rdx
  80042090f8:	48 c1 e2 04          	shl    $0x4,%rdx
  80042090fc:	48 29 c2             	sub    %rax,%rdx
  80042090ff:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004209103:	48 83 c0 08          	add    $0x8,%rax
  8004209107:	48 8b 00             	mov    (%rax),%rax
  800420910a:	48 85 c0             	test   %rax,%rax
  800420910d:	74 77                	je     8004209186 <env_run+0xb9>
  800420910f:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004209116:	00 00 00 
  8004209119:	ff d0                	callq  *%rax
  800420911b:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  8004209122:	00 00 00 
  8004209125:	48 98                	cltq   
  8004209127:	48 c1 e0 03          	shl    $0x3,%rax
  800420912b:	48 89 c2             	mov    %rax,%rdx
  800420912e:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209132:	48 29 c2             	sub    %rax,%rdx
  8004209135:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004209139:	48 83 c0 08          	add    $0x8,%rax
  800420913d:	48 8b 00             	mov    (%rax),%rax
  8004209140:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004209146:	83 f8 03             	cmp    $0x3,%eax
  8004209149:	75 3b                	jne    8004209186 <env_run+0xb9>
	   curenv->env_status = ENV_RUNNABLE;
  800420914b:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004209152:	00 00 00 
  8004209155:	ff d0                	callq  *%rax
  8004209157:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420915e:	00 00 00 
  8004209161:	48 98                	cltq   
  8004209163:	48 c1 e0 03          	shl    $0x3,%rax
  8004209167:	48 89 c2             	mov    %rax,%rdx
  800420916a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420916e:	48 29 c2             	sub    %rax,%rdx
  8004209171:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004209175:	48 83 c0 08          	add    $0x8,%rax
  8004209179:	48 8b 00             	mov    (%rax),%rax
  800420917c:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004209183:	00 00 00 
	

	curenv = e;
  8004209186:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420918d:	00 00 00 
  8004209190:	ff d0                	callq  *%rax
  8004209192:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  8004209199:	00 00 00 
  800420919c:	48 98                	cltq   
  800420919e:	48 c1 e0 03          	shl    $0x3,%rax
  80042091a2:	48 89 c2             	mov    %rax,%rdx
  80042091a5:	48 c1 e2 04          	shl    $0x4,%rdx
  80042091a9:	48 29 c2             	sub    %rax,%rdx
  80042091ac:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042091b0:	48 8d 50 08          	lea    0x8(%rax),%rdx
  80042091b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042091b8:	48 89 02             	mov    %rax,(%rdx)
	curenv->env_status = ENV_RUNNING;
  80042091bb:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  80042091c2:	00 00 00 
  80042091c5:	ff d0                	callq  *%rax
  80042091c7:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  80042091ce:	00 00 00 
  80042091d1:	48 98                	cltq   
  80042091d3:	48 c1 e0 03          	shl    $0x3,%rax
  80042091d7:	48 89 c2             	mov    %rax,%rdx
  80042091da:	48 c1 e2 04          	shl    $0x4,%rdx
  80042091de:	48 29 c2             	sub    %rax,%rdx
  80042091e1:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042091e5:	48 83 c0 08          	add    $0x8,%rax
  80042091e9:	48 8b 00             	mov    (%rax),%rax
  80042091ec:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  80042091f3:	00 00 00 
	curenv->env_runs++;
  80042091f6:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  80042091fd:	00 00 00 
  8004209200:	ff d0                	callq  *%rax
  8004209202:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  8004209209:	00 00 00 
  800420920c:	48 98                	cltq   
  800420920e:	48 c1 e0 03          	shl    $0x3,%rax
  8004209212:	48 89 c2             	mov    %rax,%rdx
  8004209215:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209219:	48 29 c2             	sub    %rax,%rdx
  800420921c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004209220:	48 83 c0 08          	add    $0x8,%rax
  8004209224:	48 8b 00             	mov    (%rax),%rax
  8004209227:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  800420922d:	83 c2 01             	add    $0x1,%edx
  8004209230:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)

	unlock_kernel();
  8004209236:	48 b8 95 7d 20 04 80 	movabs $0x8004207d95,%rax
  800420923d:	00 00 00 
  8004209240:	ff d0                	callq  *%rax
	lcr3(curenv->env_cr3);
  8004209242:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004209249:	00 00 00 
  800420924c:	ff d0                	callq  *%rax
  800420924e:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  8004209255:	00 00 00 
  8004209258:	48 98                	cltq   
  800420925a:	48 c1 e0 03          	shl    $0x3,%rax
  800420925e:	48 89 c2             	mov    %rax,%rdx
  8004209261:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209265:	48 29 c2             	sub    %rax,%rdx
  8004209268:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420926c:	48 83 c0 08          	add    $0x8,%rax
  8004209270:	48 8b 00             	mov    (%rax),%rax
  8004209273:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  800420927a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420927e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209282:	0f 22 d8             	mov    %rax,%cr3
	env_pop_tf(&(curenv->env_tf));
  8004209285:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420928c:	00 00 00 
  800420928f:	ff d0                	callq  *%rax
  8004209291:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  8004209298:	00 00 00 
  800420929b:	48 98                	cltq   
  800420929d:	48 c1 e0 03          	shl    $0x3,%rax
  80042092a1:	48 89 c2             	mov    %rax,%rdx
  80042092a4:	48 c1 e2 04          	shl    $0x4,%rdx
  80042092a8:	48 29 c2             	sub    %rax,%rdx
  80042092ab:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042092af:	48 83 c0 08          	add    $0x8,%rax
  80042092b3:	48 8b 00             	mov    (%rax),%rax
  80042092b6:	48 89 c7             	mov    %rax,%rdi
  80042092b9:	48 b8 f0 8f 20 04 80 	movabs $0x8004208ff0,%rax
  80042092c0:	00 00 00 
  80042092c3:	ff d0                	callq  *%rax

00000080042092c5 <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  80042092c5:	55                   	push   %rbp
  80042092c6:	48 89 e5             	mov    %rsp,%rbp
  80042092c9:	48 83 ec 14          	sub    $0x14,%rsp
  80042092cd:	89 7d ec             	mov    %edi,-0x14(%rbp)
	outb(IO_RTC, reg);
  80042092d0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042092d3:	0f b6 c0             	movzbl %al,%eax
  80042092d6:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  80042092dd:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042092e0:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042092e4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042092e7:	ee                   	out    %al,(%dx)
  80042092e8:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042092ef:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042092f2:	89 c2                	mov    %eax,%edx
  80042092f4:	ec                   	in     (%dx),%al
  80042092f5:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  80042092f8:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(IO_RTC+1);
  80042092fc:	0f b6 c0             	movzbl %al,%eax
}
  80042092ff:	c9                   	leaveq 
  8004209300:	c3                   	retq   

0000008004209301 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  8004209301:	55                   	push   %rbp
  8004209302:	48 89 e5             	mov    %rsp,%rbp
  8004209305:	48 83 ec 18          	sub    $0x18,%rsp
  8004209309:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420930c:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  800420930f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209312:	0f b6 c0             	movzbl %al,%eax
  8004209315:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  800420931c:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800420931f:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004209323:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209326:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  8004209327:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420932a:	0f b6 c0             	movzbl %al,%eax
  800420932d:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)
  8004209334:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004209337:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  800420933b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420933e:	ee                   	out    %al,(%dx)
}
  800420933f:	c9                   	leaveq 
  8004209340:	c3                   	retq   

0000008004209341 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
  8004209341:	55                   	push   %rbp
  8004209342:	48 89 e5             	mov    %rsp,%rbp
  8004209345:	48 83 ec 70          	sub    $0x70,%rsp
	didinit = 1;
  8004209349:	48 b8 60 02 36 04 80 	movabs $0x8004360260,%rax
  8004209350:	00 00 00 
  8004209353:	c6 00 01             	movb   $0x1,(%rax)
  8004209356:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%rbp)
  800420935d:	c6 45 fb ff          	movb   $0xff,-0x5(%rbp)
  8004209361:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004209365:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209368:	ee                   	out    %al,(%dx)
  8004209369:	c7 45 f4 a1 00 00 00 	movl   $0xa1,-0xc(%rbp)
  8004209370:	c6 45 f3 ff          	movb   $0xff,-0xd(%rbp)
  8004209374:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004209378:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420937b:	ee                   	out    %al,(%dx)
  800420937c:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%rbp)
  8004209383:	c6 45 eb 11          	movb   $0x11,-0x15(%rbp)
  8004209387:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  800420938b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420938e:	ee                   	out    %al,(%dx)
  800420938f:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%rbp)
  8004209396:	c6 45 e3 20          	movb   $0x20,-0x1d(%rbp)
  800420939a:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  800420939e:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042093a1:	ee                   	out    %al,(%dx)
  80042093a2:	c7 45 dc 21 00 00 00 	movl   $0x21,-0x24(%rbp)
  80042093a9:	c6 45 db 04          	movb   $0x4,-0x25(%rbp)
  80042093ad:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  80042093b1:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042093b4:	ee                   	out    %al,(%dx)
  80042093b5:	c7 45 d4 21 00 00 00 	movl   $0x21,-0x2c(%rbp)
  80042093bc:	c6 45 d3 03          	movb   $0x3,-0x2d(%rbp)
  80042093c0:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  80042093c4:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042093c7:	ee                   	out    %al,(%dx)
  80042093c8:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%rbp)
  80042093cf:	c6 45 cb 11          	movb   $0x11,-0x35(%rbp)
  80042093d3:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  80042093d7:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042093da:	ee                   	out    %al,(%dx)
  80042093db:	c7 45 c4 a1 00 00 00 	movl   $0xa1,-0x3c(%rbp)
  80042093e2:	c6 45 c3 28          	movb   $0x28,-0x3d(%rbp)
  80042093e6:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  80042093ea:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042093ed:	ee                   	out    %al,(%dx)
  80042093ee:	c7 45 bc a1 00 00 00 	movl   $0xa1,-0x44(%rbp)
  80042093f5:	c6 45 bb 02          	movb   $0x2,-0x45(%rbp)
  80042093f9:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  80042093fd:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004209400:	ee                   	out    %al,(%dx)
  8004209401:	c7 45 b4 a1 00 00 00 	movl   $0xa1,-0x4c(%rbp)
  8004209408:	c6 45 b3 01          	movb   $0x1,-0x4d(%rbp)
  800420940c:	0f b6 45 b3          	movzbl -0x4d(%rbp),%eax
  8004209410:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004209413:	ee                   	out    %al,(%dx)
  8004209414:	c7 45 ac 20 00 00 00 	movl   $0x20,-0x54(%rbp)
  800420941b:	c6 45 ab 68          	movb   $0x68,-0x55(%rbp)
  800420941f:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  8004209423:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004209426:	ee                   	out    %al,(%dx)
  8004209427:	c7 45 a4 20 00 00 00 	movl   $0x20,-0x5c(%rbp)
  800420942e:	c6 45 a3 0a          	movb   $0xa,-0x5d(%rbp)
  8004209432:	0f b6 45 a3          	movzbl -0x5d(%rbp),%eax
  8004209436:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004209439:	ee                   	out    %al,(%dx)
  800420943a:	c7 45 9c a0 00 00 00 	movl   $0xa0,-0x64(%rbp)
  8004209441:	c6 45 9b 68          	movb   $0x68,-0x65(%rbp)
  8004209445:	0f b6 45 9b          	movzbl -0x65(%rbp),%eax
  8004209449:	8b 55 9c             	mov    -0x64(%rbp),%edx
  800420944c:	ee                   	out    %al,(%dx)
  800420944d:	c7 45 94 a0 00 00 00 	movl   $0xa0,-0x6c(%rbp)
  8004209454:	c6 45 93 0a          	movb   $0xa,-0x6d(%rbp)
  8004209458:	0f b6 45 93          	movzbl -0x6d(%rbp),%eax
  800420945c:	8b 55 94             	mov    -0x6c(%rbp),%edx
  800420945f:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
  8004209460:	48 b8 d2 a6 22 04 80 	movabs $0x800422a6d2,%rax
  8004209467:	00 00 00 
  800420946a:	0f b7 00             	movzwl (%rax),%eax
  800420946d:	66 83 f8 ff          	cmp    $0xffff,%ax
  8004209471:	74 1e                	je     8004209491 <pic_init+0x150>
		irq_setmask_8259A(irq_mask_8259A);
  8004209473:	48 b8 d2 a6 22 04 80 	movabs $0x800422a6d2,%rax
  800420947a:	00 00 00 
  800420947d:	0f b7 00             	movzwl (%rax),%eax
  8004209480:	0f b7 c0             	movzwl %ax,%eax
  8004209483:	89 c7                	mov    %eax,%edi
  8004209485:	48 b8 93 94 20 04 80 	movabs $0x8004209493,%rax
  800420948c:	00 00 00 
  800420948f:	ff d0                	callq  *%rax
}
  8004209491:	c9                   	leaveq 
  8004209492:	c3                   	retq   

0000008004209493 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16_t mask)
{
  8004209493:	55                   	push   %rbp
  8004209494:	48 89 e5             	mov    %rsp,%rbp
  8004209497:	48 83 ec 30          	sub    $0x30,%rsp
  800420949b:	89 f8                	mov    %edi,%eax
  800420949d:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
	int i;
	irq_mask_8259A = mask;
  80042094a1:	48 b8 d2 a6 22 04 80 	movabs $0x800422a6d2,%rax
  80042094a8:	00 00 00 
  80042094ab:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80042094af:	66 89 10             	mov    %dx,(%rax)
	if (!didinit)
  80042094b2:	48 b8 60 02 36 04 80 	movabs $0x8004360260,%rax
  80042094b9:	00 00 00 
  80042094bc:	0f b6 00             	movzbl (%rax),%eax
  80042094bf:	83 f0 01             	xor    $0x1,%eax
  80042094c2:	84 c0                	test   %al,%al
  80042094c4:	74 05                	je     80042094cb <irq_setmask_8259A+0x38>
		return;
  80042094c6:	e9 b7 00 00 00       	jmpq   8004209582 <irq_setmask_8259A+0xef>
	outb(IO_PIC1+1, (char)mask);
  80042094cb:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80042094cf:	0f b6 c0             	movzbl %al,%eax
  80042094d2:	c7 45 f8 21 00 00 00 	movl   $0x21,-0x8(%rbp)
  80042094d9:	88 45 f7             	mov    %al,-0x9(%rbp)
  80042094dc:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  80042094e0:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80042094e3:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
  80042094e4:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80042094e8:	66 c1 e8 08          	shr    $0x8,%ax
  80042094ec:	0f b6 c0             	movzbl %al,%eax
  80042094ef:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%rbp)
  80042094f6:	88 45 ef             	mov    %al,-0x11(%rbp)
  80042094f9:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042094fd:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004209500:	ee                   	out    %al,(%dx)
	cprintf("enabled interrupts:");
  8004209501:	48 bf 43 87 21 04 80 	movabs $0x8004218743,%rdi
  8004209508:	00 00 00 
  800420950b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209510:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004209517:	00 00 00 
  800420951a:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  800420951c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004209523:	eb 3c                	jmp    8004209561 <irq_setmask_8259A+0xce>
		if (~mask & (1<<i))
  8004209525:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004209529:	f7 d0                	not    %eax
  800420952b:	89 c2                	mov    %eax,%edx
  800420952d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209530:	89 c1                	mov    %eax,%ecx
  8004209532:	d3 fa                	sar    %cl,%edx
  8004209534:	89 d0                	mov    %edx,%eax
  8004209536:	83 e0 01             	and    $0x1,%eax
  8004209539:	85 c0                	test   %eax,%eax
  800420953b:	74 20                	je     800420955d <irq_setmask_8259A+0xca>
			cprintf(" %d", i);
  800420953d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209540:	89 c6                	mov    %eax,%esi
  8004209542:	48 bf 57 87 21 04 80 	movabs $0x8004218757,%rdi
  8004209549:	00 00 00 
  800420954c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209551:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004209558:	00 00 00 
  800420955b:	ff d2                	callq  *%rdx
	if (!didinit)
		return;
	outb(IO_PIC1+1, (char)mask);
	outb(IO_PIC2+1, (char)(mask >> 8));
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
  800420955d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004209561:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  8004209565:	7e be                	jle    8004209525 <irq_setmask_8259A+0x92>
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
  8004209567:	48 bf 5b 87 21 04 80 	movabs $0x800421875b,%rdi
  800420956e:	00 00 00 
  8004209571:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209576:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420957d:	00 00 00 
  8004209580:	ff d2                	callq  *%rdx
}
  8004209582:	c9                   	leaveq 
  8004209583:	c3                   	retq   

0000008004209584 <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  8004209584:	55                   	push   %rbp
  8004209585:	48 89 e5             	mov    %rsp,%rbp
  8004209588:	48 83 ec 10          	sub    $0x10,%rsp
  800420958c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420958f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  8004209593:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209596:	89 c7                	mov    %eax,%edi
  8004209598:	48 b8 01 12 20 04 80 	movabs $0x8004201201,%rax
  800420959f:	00 00 00 
  80042095a2:	ff d0                	callq  *%rax
	*cnt++;
  80042095a4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042095a8:	48 83 c0 04          	add    $0x4,%rax
  80042095ac:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  80042095b0:	c9                   	leaveq 
  80042095b1:	c3                   	retq   

00000080042095b2 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80042095b2:	55                   	push   %rbp
  80042095b3:	48 89 e5             	mov    %rsp,%rbp
  80042095b6:	48 83 ec 30          	sub    $0x30,%rsp
  80042095ba:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042095be:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  80042095c2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    va_list aq;
    va_copy(aq,ap);
  80042095c9:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80042095cd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042095d1:	48 8b 0a             	mov    (%rdx),%rcx
  80042095d4:	48 89 08             	mov    %rcx,(%rax)
  80042095d7:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042095db:	48 89 48 08          	mov    %rcx,0x8(%rax)
  80042095df:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80042095e3:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  80042095e7:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  80042095eb:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042095ef:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  80042095f3:	48 89 c6             	mov    %rax,%rsi
  80042095f6:	48 bf 84 95 20 04 80 	movabs $0x8004209584,%rdi
  80042095fd:	00 00 00 
  8004209600:	48 b8 c9 ef 20 04 80 	movabs $0x800420efc9,%rax
  8004209607:	00 00 00 
  800420960a:	ff d0                	callq  *%rax
    va_end(aq);
	return cnt;
  800420960c:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  800420960f:	c9                   	leaveq 
  8004209610:	c3                   	retq   

0000008004209611 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  8004209611:	55                   	push   %rbp
  8004209612:	48 89 e5             	mov    %rsp,%rbp
  8004209615:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  800420961c:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  8004209623:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  800420962a:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004209631:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004209638:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420963f:	84 c0                	test   %al,%al
  8004209641:	74 20                	je     8004209663 <cprintf+0x52>
  8004209643:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004209647:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420964b:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420964f:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004209653:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004209657:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420965b:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420965f:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004209663:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  800420966a:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  8004209671:	00 00 00 
  8004209674:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  800420967b:	00 00 00 
  800420967e:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004209682:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004209689:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004209690:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
        va_list aq;
        va_copy(aq,ap);
  8004209697:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420969e:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  80042096a5:	48 8b 0a             	mov    (%rdx),%rcx
  80042096a8:	48 89 08             	mov    %rcx,(%rax)
  80042096ab:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042096af:	48 89 48 08          	mov    %rcx,0x8(%rax)
  80042096b3:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80042096b7:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  80042096bb:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  80042096c2:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80042096c9:	48 89 d6             	mov    %rdx,%rsi
  80042096cc:	48 89 c7             	mov    %rax,%rdi
  80042096cf:	48 b8 b2 95 20 04 80 	movabs $0x80042095b2,%rax
  80042096d6:	00 00 00 
  80042096d9:	ff d0                	callq  *%rax
  80042096db:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  80042096e1:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  80042096e7:	c9                   	leaveq 
  80042096e8:	c3                   	retq   

00000080042096e9 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  80042096e9:	55                   	push   %rbp
  80042096ea:	48 89 e5             	mov    %rsp,%rbp
  80042096ed:	48 83 ec 1c          	sub    $0x1c,%rsp
  80042096f1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042096f5:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  80042096f8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042096fc:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042096ff:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004209703:	f0 87 02             	lock xchg %eax,(%rdx)
  8004209706:	89 45 fc             	mov    %eax,-0x4(%rbp)
	"+m" (*addr), "=a" (result):
	"1"(newval):
	"cc");
	return result;
  8004209709:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420970c:	c9                   	leaveq 
  800420970d:	c3                   	retq   

000000800420970e <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800420970e:	55                   	push   %rbp
  800420970f:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004209712:	48 bf c0 a7 22 04 80 	movabs $0x800422a7c0,%rdi
  8004209719:	00 00 00 
  800420971c:	48 b8 48 6e 21 04 80 	movabs $0x8004216e48,%rax
  8004209723:	00 00 00 
  8004209726:	ff d0                	callq  *%rax
}
  8004209728:	5d                   	pop    %rbp
  8004209729:	c3                   	retq   

000000800420972a <trapname>:
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {0,0};


static const char *trapname(int trapno)
{
  800420972a:	55                   	push   %rbp
  800420972b:	48 89 e5             	mov    %rsp,%rbp
  800420972e:	48 83 ec 04          	sub    $0x4,%rsp
  8004209732:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  8004209735:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209738:	83 f8 13             	cmp    $0x13,%eax
  800420973b:	77 16                	ja     8004209753 <trapname+0x29>
		return excnames[trapno];
  800420973d:	48 b8 c0 8b 21 04 80 	movabs $0x8004218bc0,%rax
  8004209744:	00 00 00 
  8004209747:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420974a:	48 63 d2             	movslq %edx,%rdx
  800420974d:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004209751:	eb 34                	jmp    8004209787 <trapname+0x5d>
	if (trapno == T_SYSCALL)
  8004209753:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  8004209757:	75 0c                	jne    8004209765 <trapname+0x3b>
		return "System call";
  8004209759:	48 b8 60 87 21 04 80 	movabs $0x8004218760,%rax
  8004209760:	00 00 00 
  8004209763:	eb 22                	jmp    8004209787 <trapname+0x5d>
	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
  8004209765:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8004209769:	7e 12                	jle    800420977d <trapname+0x53>
  800420976b:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  800420976f:	7f 0c                	jg     800420977d <trapname+0x53>
		return "Hardware Interrupt";
  8004209771:	48 b8 6c 87 21 04 80 	movabs $0x800421876c,%rax
  8004209778:	00 00 00 
  800420977b:	eb 0a                	jmp    8004209787 <trapname+0x5d>
	return "(unknown trap)";
  800420977d:	48 b8 7f 87 21 04 80 	movabs $0x800421877f,%rax
  8004209784:	00 00 00 
}
  8004209787:	c9                   	leaveq 
  8004209788:	c3                   	retq   

0000008004209789 <trap_init>:


void
trap_init(void)
{
  8004209789:	55                   	push   %rbp
  800420978a:	48 89 e5             	mov    %rsp,%rbp
        
	
    
    // LAB 3: Your code here.
	
    SETGATE(idt[T_DIVIDE],  0, GD_KT, jos64_divide, 0);
  800420978d:	48 b8 48 d0 20 04 80 	movabs $0x800420d048,%rax
  8004209794:	00 00 00 
  8004209797:	89 c2                	mov    %eax,%edx
  8004209799:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  80042097a0:	00 00 00 
  80042097a3:	66 89 10             	mov    %dx,(%rax)
  80042097a6:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  80042097ad:	00 00 00 
  80042097b0:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  80042097b6:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  80042097bd:	00 00 00 
  80042097c0:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  80042097c4:	83 e2 f8             	and    $0xfffffff8,%edx
  80042097c7:	88 50 04             	mov    %dl,0x4(%rax)
  80042097ca:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  80042097d1:	00 00 00 
  80042097d4:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  80042097d8:	83 e2 07             	and    $0x7,%edx
  80042097db:	88 50 04             	mov    %dl,0x4(%rax)
  80042097de:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  80042097e5:	00 00 00 
  80042097e8:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042097ec:	83 e2 f0             	and    $0xfffffff0,%edx
  80042097ef:	83 ca 0e             	or     $0xe,%edx
  80042097f2:	88 50 05             	mov    %dl,0x5(%rax)
  80042097f5:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  80042097fc:	00 00 00 
  80042097ff:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209803:	83 e2 ef             	and    $0xffffffef,%edx
  8004209806:	88 50 05             	mov    %dl,0x5(%rax)
  8004209809:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209810:	00 00 00 
  8004209813:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209817:	83 e2 9f             	and    $0xffffff9f,%edx
  800420981a:	88 50 05             	mov    %dl,0x5(%rax)
  800420981d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209824:	00 00 00 
  8004209827:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420982b:	83 ca 80             	or     $0xffffff80,%edx
  800420982e:	88 50 05             	mov    %dl,0x5(%rax)
  8004209831:	48 b8 48 d0 20 04 80 	movabs $0x800420d048,%rax
  8004209838:	00 00 00 
  800420983b:	48 c1 e8 10          	shr    $0x10,%rax
  800420983f:	89 c2                	mov    %eax,%edx
  8004209841:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209848:	00 00 00 
  800420984b:	66 89 50 06          	mov    %dx,0x6(%rax)
  800420984f:	48 b8 48 d0 20 04 80 	movabs $0x800420d048,%rax
  8004209856:	00 00 00 
  8004209859:	48 c1 e8 20          	shr    $0x20,%rax
  800420985d:	89 c2                	mov    %eax,%edx
  800420985f:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209866:	00 00 00 
  8004209869:	89 50 08             	mov    %edx,0x8(%rax)
  800420986c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209873:	00 00 00 
  8004209876:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
    SETGATE(idt[T_DEBUG],   0, GD_KT, jos64_debug,  0);
  800420987d:	48 b8 52 d0 20 04 80 	movabs $0x800420d052,%rax
  8004209884:	00 00 00 
  8004209887:	89 c2                	mov    %eax,%edx
  8004209889:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209890:	00 00 00 
  8004209893:	66 89 50 10          	mov    %dx,0x10(%rax)
  8004209897:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420989e:	00 00 00 
  80042098a1:	66 c7 40 12 08 00    	movw   $0x8,0x12(%rax)
  80042098a7:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  80042098ae:	00 00 00 
  80042098b1:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  80042098b5:	83 e2 f8             	and    $0xfffffff8,%edx
  80042098b8:	88 50 14             	mov    %dl,0x14(%rax)
  80042098bb:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  80042098c2:	00 00 00 
  80042098c5:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  80042098c9:	83 e2 07             	and    $0x7,%edx
  80042098cc:	88 50 14             	mov    %dl,0x14(%rax)
  80042098cf:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  80042098d6:	00 00 00 
  80042098d9:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042098dd:	83 e2 f0             	and    $0xfffffff0,%edx
  80042098e0:	83 ca 0e             	or     $0xe,%edx
  80042098e3:	88 50 15             	mov    %dl,0x15(%rax)
  80042098e6:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  80042098ed:	00 00 00 
  80042098f0:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042098f4:	83 e2 ef             	and    $0xffffffef,%edx
  80042098f7:	88 50 15             	mov    %dl,0x15(%rax)
  80042098fa:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209901:	00 00 00 
  8004209904:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004209908:	83 e2 9f             	and    $0xffffff9f,%edx
  800420990b:	88 50 15             	mov    %dl,0x15(%rax)
  800420990e:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209915:	00 00 00 
  8004209918:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  800420991c:	83 ca 80             	or     $0xffffff80,%edx
  800420991f:	88 50 15             	mov    %dl,0x15(%rax)
  8004209922:	48 b8 52 d0 20 04 80 	movabs $0x800420d052,%rax
  8004209929:	00 00 00 
  800420992c:	48 c1 e8 10          	shr    $0x10,%rax
  8004209930:	89 c2                	mov    %eax,%edx
  8004209932:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209939:	00 00 00 
  800420993c:	66 89 50 16          	mov    %dx,0x16(%rax)
  8004209940:	48 b8 52 d0 20 04 80 	movabs $0x800420d052,%rax
  8004209947:	00 00 00 
  800420994a:	48 c1 e8 20          	shr    $0x20,%rax
  800420994e:	89 c2                	mov    %eax,%edx
  8004209950:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209957:	00 00 00 
  800420995a:	89 50 18             	mov    %edx,0x18(%rax)
  800420995d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209964:	00 00 00 
  8004209967:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%rax)
    SETGATE(idt[T_NMI],     0, GD_KT, jos64_nmi,    0);
  800420996e:	48 b8 5c d0 20 04 80 	movabs $0x800420d05c,%rax
  8004209975:	00 00 00 
  8004209978:	89 c2                	mov    %eax,%edx
  800420997a:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209981:	00 00 00 
  8004209984:	66 89 50 20          	mov    %dx,0x20(%rax)
  8004209988:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420998f:	00 00 00 
  8004209992:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  8004209998:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420999f:	00 00 00 
  80042099a2:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  80042099a6:	83 e2 f8             	and    $0xfffffff8,%edx
  80042099a9:	88 50 24             	mov    %dl,0x24(%rax)
  80042099ac:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  80042099b3:	00 00 00 
  80042099b6:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  80042099ba:	83 e2 07             	and    $0x7,%edx
  80042099bd:	88 50 24             	mov    %dl,0x24(%rax)
  80042099c0:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  80042099c7:	00 00 00 
  80042099ca:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  80042099ce:	83 e2 f0             	and    $0xfffffff0,%edx
  80042099d1:	83 ca 0e             	or     $0xe,%edx
  80042099d4:	88 50 25             	mov    %dl,0x25(%rax)
  80042099d7:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  80042099de:	00 00 00 
  80042099e1:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  80042099e5:	83 e2 ef             	and    $0xffffffef,%edx
  80042099e8:	88 50 25             	mov    %dl,0x25(%rax)
  80042099eb:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  80042099f2:	00 00 00 
  80042099f5:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  80042099f9:	83 e2 9f             	and    $0xffffff9f,%edx
  80042099fc:	88 50 25             	mov    %dl,0x25(%rax)
  80042099ff:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209a06:	00 00 00 
  8004209a09:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004209a0d:	83 ca 80             	or     $0xffffff80,%edx
  8004209a10:	88 50 25             	mov    %dl,0x25(%rax)
  8004209a13:	48 b8 5c d0 20 04 80 	movabs $0x800420d05c,%rax
  8004209a1a:	00 00 00 
  8004209a1d:	48 c1 e8 10          	shr    $0x10,%rax
  8004209a21:	89 c2                	mov    %eax,%edx
  8004209a23:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209a2a:	00 00 00 
  8004209a2d:	66 89 50 26          	mov    %dx,0x26(%rax)
  8004209a31:	48 b8 5c d0 20 04 80 	movabs $0x800420d05c,%rax
  8004209a38:	00 00 00 
  8004209a3b:	48 c1 e8 20          	shr    $0x20,%rax
  8004209a3f:	89 c2                	mov    %eax,%edx
  8004209a41:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209a48:	00 00 00 
  8004209a4b:	89 50 28             	mov    %edx,0x28(%rax)
  8004209a4e:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209a55:	00 00 00 
  8004209a58:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
    SETGATE(idt[T_BRKPT],   0, GD_KT, jos64_breakpoint,  3);
  8004209a5f:	48 b8 66 d0 20 04 80 	movabs $0x800420d066,%rax
  8004209a66:	00 00 00 
  8004209a69:	89 c2                	mov    %eax,%edx
  8004209a6b:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209a72:	00 00 00 
  8004209a75:	66 89 50 30          	mov    %dx,0x30(%rax)
  8004209a79:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209a80:	00 00 00 
  8004209a83:	66 c7 40 32 08 00    	movw   $0x8,0x32(%rax)
  8004209a89:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209a90:	00 00 00 
  8004209a93:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004209a97:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209a9a:	88 50 34             	mov    %dl,0x34(%rax)
  8004209a9d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209aa4:	00 00 00 
  8004209aa7:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004209aab:	83 e2 07             	and    $0x7,%edx
  8004209aae:	88 50 34             	mov    %dl,0x34(%rax)
  8004209ab1:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209ab8:	00 00 00 
  8004209abb:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209abf:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209ac2:	83 ca 0e             	or     $0xe,%edx
  8004209ac5:	88 50 35             	mov    %dl,0x35(%rax)
  8004209ac8:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209acf:	00 00 00 
  8004209ad2:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209ad6:	83 e2 ef             	and    $0xffffffef,%edx
  8004209ad9:	88 50 35             	mov    %dl,0x35(%rax)
  8004209adc:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209ae3:	00 00 00 
  8004209ae6:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209aea:	83 ca 60             	or     $0x60,%edx
  8004209aed:	88 50 35             	mov    %dl,0x35(%rax)
  8004209af0:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209af7:	00 00 00 
  8004209afa:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209afe:	83 ca 80             	or     $0xffffff80,%edx
  8004209b01:	88 50 35             	mov    %dl,0x35(%rax)
  8004209b04:	48 b8 66 d0 20 04 80 	movabs $0x800420d066,%rax
  8004209b0b:	00 00 00 
  8004209b0e:	48 c1 e8 10          	shr    $0x10,%rax
  8004209b12:	89 c2                	mov    %eax,%edx
  8004209b14:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209b1b:	00 00 00 
  8004209b1e:	66 89 50 36          	mov    %dx,0x36(%rax)
  8004209b22:	48 b8 66 d0 20 04 80 	movabs $0x800420d066,%rax
  8004209b29:	00 00 00 
  8004209b2c:	48 c1 e8 20          	shr    $0x20,%rax
  8004209b30:	89 c2                	mov    %eax,%edx
  8004209b32:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209b39:	00 00 00 
  8004209b3c:	89 50 38             	mov    %edx,0x38(%rax)
  8004209b3f:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209b46:	00 00 00 
  8004209b49:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
    SETGATE(idt[T_OFLOW],   0, GD_KT, jos64_overflow,  0);
  8004209b50:	48 b8 70 d0 20 04 80 	movabs $0x800420d070,%rax
  8004209b57:	00 00 00 
  8004209b5a:	89 c2                	mov    %eax,%edx
  8004209b5c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209b63:	00 00 00 
  8004209b66:	66 89 50 40          	mov    %dx,0x40(%rax)
  8004209b6a:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209b71:	00 00 00 
  8004209b74:	66 c7 40 42 08 00    	movw   $0x8,0x42(%rax)
  8004209b7a:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209b81:	00 00 00 
  8004209b84:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004209b88:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209b8b:	88 50 44             	mov    %dl,0x44(%rax)
  8004209b8e:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209b95:	00 00 00 
  8004209b98:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004209b9c:	83 e2 07             	and    $0x7,%edx
  8004209b9f:	88 50 44             	mov    %dl,0x44(%rax)
  8004209ba2:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209ba9:	00 00 00 
  8004209bac:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209bb0:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209bb3:	83 ca 0e             	or     $0xe,%edx
  8004209bb6:	88 50 45             	mov    %dl,0x45(%rax)
  8004209bb9:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209bc0:	00 00 00 
  8004209bc3:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209bc7:	83 e2 ef             	and    $0xffffffef,%edx
  8004209bca:	88 50 45             	mov    %dl,0x45(%rax)
  8004209bcd:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209bd4:	00 00 00 
  8004209bd7:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209bdb:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209bde:	88 50 45             	mov    %dl,0x45(%rax)
  8004209be1:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209be8:	00 00 00 
  8004209beb:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209bef:	83 ca 80             	or     $0xffffff80,%edx
  8004209bf2:	88 50 45             	mov    %dl,0x45(%rax)
  8004209bf5:	48 b8 70 d0 20 04 80 	movabs $0x800420d070,%rax
  8004209bfc:	00 00 00 
  8004209bff:	48 c1 e8 10          	shr    $0x10,%rax
  8004209c03:	89 c2                	mov    %eax,%edx
  8004209c05:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209c0c:	00 00 00 
  8004209c0f:	66 89 50 46          	mov    %dx,0x46(%rax)
  8004209c13:	48 b8 70 d0 20 04 80 	movabs $0x800420d070,%rax
  8004209c1a:	00 00 00 
  8004209c1d:	48 c1 e8 20          	shr    $0x20,%rax
  8004209c21:	89 c2                	mov    %eax,%edx
  8004209c23:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209c2a:	00 00 00 
  8004209c2d:	89 50 48             	mov    %edx,0x48(%rax)
  8004209c30:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209c37:	00 00 00 
  8004209c3a:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
    SETGATE(idt[T_BOUND],   0, GD_KT, jos64_boundcheck,  0);
  8004209c41:	48 b8 7a d0 20 04 80 	movabs $0x800420d07a,%rax
  8004209c48:	00 00 00 
  8004209c4b:	89 c2                	mov    %eax,%edx
  8004209c4d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209c54:	00 00 00 
  8004209c57:	66 89 50 50          	mov    %dx,0x50(%rax)
  8004209c5b:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209c62:	00 00 00 
  8004209c65:	66 c7 40 52 08 00    	movw   $0x8,0x52(%rax)
  8004209c6b:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209c72:	00 00 00 
  8004209c75:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  8004209c79:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209c7c:	88 50 54             	mov    %dl,0x54(%rax)
  8004209c7f:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209c86:	00 00 00 
  8004209c89:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  8004209c8d:	83 e2 07             	and    $0x7,%edx
  8004209c90:	88 50 54             	mov    %dl,0x54(%rax)
  8004209c93:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209c9a:	00 00 00 
  8004209c9d:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209ca1:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209ca4:	83 ca 0e             	or     $0xe,%edx
  8004209ca7:	88 50 55             	mov    %dl,0x55(%rax)
  8004209caa:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209cb1:	00 00 00 
  8004209cb4:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209cb8:	83 e2 ef             	and    $0xffffffef,%edx
  8004209cbb:	88 50 55             	mov    %dl,0x55(%rax)
  8004209cbe:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209cc5:	00 00 00 
  8004209cc8:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209ccc:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209ccf:	88 50 55             	mov    %dl,0x55(%rax)
  8004209cd2:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209cd9:	00 00 00 
  8004209cdc:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209ce0:	83 ca 80             	or     $0xffffff80,%edx
  8004209ce3:	88 50 55             	mov    %dl,0x55(%rax)
  8004209ce6:	48 b8 7a d0 20 04 80 	movabs $0x800420d07a,%rax
  8004209ced:	00 00 00 
  8004209cf0:	48 c1 e8 10          	shr    $0x10,%rax
  8004209cf4:	89 c2                	mov    %eax,%edx
  8004209cf6:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209cfd:	00 00 00 
  8004209d00:	66 89 50 56          	mov    %dx,0x56(%rax)
  8004209d04:	48 b8 7a d0 20 04 80 	movabs $0x800420d07a,%rax
  8004209d0b:	00 00 00 
  8004209d0e:	48 c1 e8 20          	shr    $0x20,%rax
  8004209d12:	89 c2                	mov    %eax,%edx
  8004209d14:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209d1b:	00 00 00 
  8004209d1e:	89 50 58             	mov    %edx,0x58(%rax)
  8004209d21:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209d28:	00 00 00 
  8004209d2b:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
    SETGATE(idt[T_ILLOP],   0, GD_KT, jos64_ill_opcode,  0);
  8004209d32:	48 b8 84 d0 20 04 80 	movabs $0x800420d084,%rax
  8004209d39:	00 00 00 
  8004209d3c:	89 c2                	mov    %eax,%edx
  8004209d3e:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209d45:	00 00 00 
  8004209d48:	66 89 50 60          	mov    %dx,0x60(%rax)
  8004209d4c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209d53:	00 00 00 
  8004209d56:	66 c7 40 62 08 00    	movw   $0x8,0x62(%rax)
  8004209d5c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209d63:	00 00 00 
  8004209d66:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  8004209d6a:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209d6d:	88 50 64             	mov    %dl,0x64(%rax)
  8004209d70:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209d77:	00 00 00 
  8004209d7a:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  8004209d7e:	83 e2 07             	and    $0x7,%edx
  8004209d81:	88 50 64             	mov    %dl,0x64(%rax)
  8004209d84:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209d8b:	00 00 00 
  8004209d8e:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209d92:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209d95:	83 ca 0e             	or     $0xe,%edx
  8004209d98:	88 50 65             	mov    %dl,0x65(%rax)
  8004209d9b:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209da2:	00 00 00 
  8004209da5:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209da9:	83 e2 ef             	and    $0xffffffef,%edx
  8004209dac:	88 50 65             	mov    %dl,0x65(%rax)
  8004209daf:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209db6:	00 00 00 
  8004209db9:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209dbd:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209dc0:	88 50 65             	mov    %dl,0x65(%rax)
  8004209dc3:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209dca:	00 00 00 
  8004209dcd:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209dd1:	83 ca 80             	or     $0xffffff80,%edx
  8004209dd4:	88 50 65             	mov    %dl,0x65(%rax)
  8004209dd7:	48 b8 84 d0 20 04 80 	movabs $0x800420d084,%rax
  8004209dde:	00 00 00 
  8004209de1:	48 c1 e8 10          	shr    $0x10,%rax
  8004209de5:	89 c2                	mov    %eax,%edx
  8004209de7:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209dee:	00 00 00 
  8004209df1:	66 89 50 66          	mov    %dx,0x66(%rax)
  8004209df5:	48 b8 84 d0 20 04 80 	movabs $0x800420d084,%rax
  8004209dfc:	00 00 00 
  8004209dff:	48 c1 e8 20          	shr    $0x20,%rax
  8004209e03:	89 c2                	mov    %eax,%edx
  8004209e05:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209e0c:	00 00 00 
  8004209e0f:	89 50 68             	mov    %edx,0x68(%rax)
  8004209e12:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209e19:	00 00 00 
  8004209e1c:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%rax)
    SETGATE(idt[T_DEVICE],  0, GD_KT, jos64_device, 0);
  8004209e23:	48 b8 8e d0 20 04 80 	movabs $0x800420d08e,%rax
  8004209e2a:	00 00 00 
  8004209e2d:	89 c2                	mov    %eax,%edx
  8004209e2f:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209e36:	00 00 00 
  8004209e39:	66 89 50 70          	mov    %dx,0x70(%rax)
  8004209e3d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209e44:	00 00 00 
  8004209e47:	66 c7 40 72 08 00    	movw   $0x8,0x72(%rax)
  8004209e4d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209e54:	00 00 00 
  8004209e57:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  8004209e5b:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209e5e:	88 50 74             	mov    %dl,0x74(%rax)
  8004209e61:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209e68:	00 00 00 
  8004209e6b:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  8004209e6f:	83 e2 07             	and    $0x7,%edx
  8004209e72:	88 50 74             	mov    %dl,0x74(%rax)
  8004209e75:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209e7c:	00 00 00 
  8004209e7f:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209e83:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209e86:	83 ca 0e             	or     $0xe,%edx
  8004209e89:	88 50 75             	mov    %dl,0x75(%rax)
  8004209e8c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209e93:	00 00 00 
  8004209e96:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209e9a:	83 e2 ef             	and    $0xffffffef,%edx
  8004209e9d:	88 50 75             	mov    %dl,0x75(%rax)
  8004209ea0:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209ea7:	00 00 00 
  8004209eaa:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209eae:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209eb1:	88 50 75             	mov    %dl,0x75(%rax)
  8004209eb4:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209ebb:	00 00 00 
  8004209ebe:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209ec2:	83 ca 80             	or     $0xffffff80,%edx
  8004209ec5:	88 50 75             	mov    %dl,0x75(%rax)
  8004209ec8:	48 b8 8e d0 20 04 80 	movabs $0x800420d08e,%rax
  8004209ecf:	00 00 00 
  8004209ed2:	48 c1 e8 10          	shr    $0x10,%rax
  8004209ed6:	89 c2                	mov    %eax,%edx
  8004209ed8:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209edf:	00 00 00 
  8004209ee2:	66 89 50 76          	mov    %dx,0x76(%rax)
  8004209ee6:	48 b8 8e d0 20 04 80 	movabs $0x800420d08e,%rax
  8004209eed:	00 00 00 
  8004209ef0:	48 c1 e8 20          	shr    $0x20,%rax
  8004209ef4:	89 c2                	mov    %eax,%edx
  8004209ef6:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209efd:	00 00 00 
  8004209f00:	89 50 78             	mov    %edx,0x78(%rax)
  8004209f03:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209f0a:	00 00 00 
  8004209f0d:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
    SETGATE(idt[T_DBLFLT],  0, GD_KT, jos64_doublefault, 0);
  8004209f14:	48 b8 98 d0 20 04 80 	movabs $0x800420d098,%rax
  8004209f1b:	00 00 00 
  8004209f1e:	89 c2                	mov    %eax,%edx
  8004209f20:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209f27:	00 00 00 
  8004209f2a:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
  8004209f31:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209f38:	00 00 00 
  8004209f3b:	66 c7 80 82 00 00 00 	movw   $0x8,0x82(%rax)
  8004209f42:	08 00 
  8004209f44:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209f4b:	00 00 00 
  8004209f4e:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  8004209f55:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209f58:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  8004209f5e:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209f65:	00 00 00 
  8004209f68:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  8004209f6f:	83 e2 07             	and    $0x7,%edx
  8004209f72:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  8004209f78:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209f7f:	00 00 00 
  8004209f82:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209f89:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209f8c:	83 ca 0e             	or     $0xe,%edx
  8004209f8f:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209f95:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209f9c:	00 00 00 
  8004209f9f:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209fa6:	83 e2 ef             	and    $0xffffffef,%edx
  8004209fa9:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209faf:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209fb6:	00 00 00 
  8004209fb9:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209fc0:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209fc3:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209fc9:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209fd0:	00 00 00 
  8004209fd3:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209fda:	83 ca 80             	or     $0xffffff80,%edx
  8004209fdd:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209fe3:	48 b8 98 d0 20 04 80 	movabs $0x800420d098,%rax
  8004209fea:	00 00 00 
  8004209fed:	48 c1 e8 10          	shr    $0x10,%rax
  8004209ff1:	89 c2                	mov    %eax,%edx
  8004209ff3:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  8004209ffa:	00 00 00 
  8004209ffd:	66 89 90 86 00 00 00 	mov    %dx,0x86(%rax)
  800420a004:	48 b8 98 d0 20 04 80 	movabs $0x800420d098,%rax
  800420a00b:	00 00 00 
  800420a00e:	48 c1 e8 20          	shr    $0x20,%rax
  800420a012:	89 c2                	mov    %eax,%edx
  800420a014:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a01b:	00 00 00 
  800420a01e:	89 90 88 00 00 00    	mov    %edx,0x88(%rax)
  800420a024:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a02b:	00 00 00 
  800420a02e:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%rax)
  800420a035:	00 00 00 
    SETGATE(idt[T_TSS],     0, GD_KT, jos64_tss_segment,    0);
  800420a038:	48 b8 a0 d0 20 04 80 	movabs $0x800420d0a0,%rax
  800420a03f:	00 00 00 
  800420a042:	89 c2                	mov    %eax,%edx
  800420a044:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a04b:	00 00 00 
  800420a04e:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
  800420a055:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a05c:	00 00 00 
  800420a05f:	66 c7 80 a2 00 00 00 	movw   $0x8,0xa2(%rax)
  800420a066:	08 00 
  800420a068:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a06f:	00 00 00 
  800420a072:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  800420a079:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a07c:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  800420a082:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a089:	00 00 00 
  800420a08c:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  800420a093:	83 e2 07             	and    $0x7,%edx
  800420a096:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  800420a09c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a0a3:	00 00 00 
  800420a0a6:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a0ad:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a0b0:	83 ca 0e             	or     $0xe,%edx
  800420a0b3:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a0b9:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a0c0:	00 00 00 
  800420a0c3:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a0ca:	83 e2 ef             	and    $0xffffffef,%edx
  800420a0cd:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a0d3:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a0da:	00 00 00 
  800420a0dd:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a0e4:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a0e7:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a0ed:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a0f4:	00 00 00 
  800420a0f7:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a0fe:	83 ca 80             	or     $0xffffff80,%edx
  800420a101:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a107:	48 b8 a0 d0 20 04 80 	movabs $0x800420d0a0,%rax
  800420a10e:	00 00 00 
  800420a111:	48 c1 e8 10          	shr    $0x10,%rax
  800420a115:	89 c2                	mov    %eax,%edx
  800420a117:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a11e:	00 00 00 
  800420a121:	66 89 90 a6 00 00 00 	mov    %dx,0xa6(%rax)
  800420a128:	48 b8 a0 d0 20 04 80 	movabs $0x800420d0a0,%rax
  800420a12f:	00 00 00 
  800420a132:	48 c1 e8 20          	shr    $0x20,%rax
  800420a136:	89 c2                	mov    %eax,%edx
  800420a138:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a13f:	00 00 00 
  800420a142:	89 90 a8 00 00 00    	mov    %edx,0xa8(%rax)
  800420a148:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a14f:	00 00 00 
  800420a152:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%rax)
  800420a159:	00 00 00 
    SETGATE(idt[T_SEGNP],   0, GD_KT, jos64_stack,  0);
  800420a15c:	48 b8 a8 d0 20 04 80 	movabs $0x800420d0a8,%rax
  800420a163:	00 00 00 
  800420a166:	89 c2                	mov    %eax,%edx
  800420a168:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a16f:	00 00 00 
  800420a172:	66 89 90 b0 00 00 00 	mov    %dx,0xb0(%rax)
  800420a179:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a180:	00 00 00 
  800420a183:	66 c7 80 b2 00 00 00 	movw   $0x8,0xb2(%rax)
  800420a18a:	08 00 
  800420a18c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a193:	00 00 00 
  800420a196:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  800420a19d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a1a0:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  800420a1a6:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a1ad:	00 00 00 
  800420a1b0:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  800420a1b7:	83 e2 07             	and    $0x7,%edx
  800420a1ba:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  800420a1c0:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a1c7:	00 00 00 
  800420a1ca:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420a1d1:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a1d4:	83 ca 0e             	or     $0xe,%edx
  800420a1d7:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420a1dd:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a1e4:	00 00 00 
  800420a1e7:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420a1ee:	83 e2 ef             	and    $0xffffffef,%edx
  800420a1f1:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420a1f7:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a1fe:	00 00 00 
  800420a201:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420a208:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a20b:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420a211:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a218:	00 00 00 
  800420a21b:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420a222:	83 ca 80             	or     $0xffffff80,%edx
  800420a225:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420a22b:	48 b8 a8 d0 20 04 80 	movabs $0x800420d0a8,%rax
  800420a232:	00 00 00 
  800420a235:	48 c1 e8 10          	shr    $0x10,%rax
  800420a239:	89 c2                	mov    %eax,%edx
  800420a23b:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a242:	00 00 00 
  800420a245:	66 89 90 b6 00 00 00 	mov    %dx,0xb6(%rax)
  800420a24c:	48 b8 a8 d0 20 04 80 	movabs $0x800420d0a8,%rax
  800420a253:	00 00 00 
  800420a256:	48 c1 e8 20          	shr    $0x20,%rax
  800420a25a:	89 c2                	mov    %eax,%edx
  800420a25c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a263:	00 00 00 
  800420a266:	89 90 b8 00 00 00    	mov    %edx,0xb8(%rax)
  800420a26c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a273:	00 00 00 
  800420a276:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%rax)
  800420a27d:	00 00 00 
    SETGATE(idt[T_STACK],   0, GD_KT, jos64_stackexception,  0);
  800420a280:	48 b8 b0 d0 20 04 80 	movabs $0x800420d0b0,%rax
  800420a287:	00 00 00 
  800420a28a:	89 c2                	mov    %eax,%edx
  800420a28c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a293:	00 00 00 
  800420a296:	66 89 90 c0 00 00 00 	mov    %dx,0xc0(%rax)
  800420a29d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a2a4:	00 00 00 
  800420a2a7:	66 c7 80 c2 00 00 00 	movw   $0x8,0xc2(%rax)
  800420a2ae:	08 00 
  800420a2b0:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a2b7:	00 00 00 
  800420a2ba:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  800420a2c1:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a2c4:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  800420a2ca:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a2d1:	00 00 00 
  800420a2d4:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  800420a2db:	83 e2 07             	and    $0x7,%edx
  800420a2de:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  800420a2e4:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a2eb:	00 00 00 
  800420a2ee:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420a2f5:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a2f8:	83 ca 0e             	or     $0xe,%edx
  800420a2fb:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420a301:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a308:	00 00 00 
  800420a30b:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420a312:	83 e2 ef             	and    $0xffffffef,%edx
  800420a315:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420a31b:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a322:	00 00 00 
  800420a325:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420a32c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a32f:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420a335:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a33c:	00 00 00 
  800420a33f:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420a346:	83 ca 80             	or     $0xffffff80,%edx
  800420a349:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420a34f:	48 b8 b0 d0 20 04 80 	movabs $0x800420d0b0,%rax
  800420a356:	00 00 00 
  800420a359:	48 c1 e8 10          	shr    $0x10,%rax
  800420a35d:	89 c2                	mov    %eax,%edx
  800420a35f:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a366:	00 00 00 
  800420a369:	66 89 90 c6 00 00 00 	mov    %dx,0xc6(%rax)
  800420a370:	48 b8 b0 d0 20 04 80 	movabs $0x800420d0b0,%rax
  800420a377:	00 00 00 
  800420a37a:	48 c1 e8 20          	shr    $0x20,%rax
  800420a37e:	89 c2                	mov    %eax,%edx
  800420a380:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a387:	00 00 00 
  800420a38a:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
  800420a390:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a397:	00 00 00 
  800420a39a:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  800420a3a1:	00 00 00 
    SETGATE(idt[T_GPFLT],   0, GD_KT, jos64_protectionfault,  0);
  800420a3a4:	48 b8 b8 d0 20 04 80 	movabs $0x800420d0b8,%rax
  800420a3ab:	00 00 00 
  800420a3ae:	89 c2                	mov    %eax,%edx
  800420a3b0:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a3b7:	00 00 00 
  800420a3ba:	66 89 90 d0 00 00 00 	mov    %dx,0xd0(%rax)
  800420a3c1:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a3c8:	00 00 00 
  800420a3cb:	66 c7 80 d2 00 00 00 	movw   $0x8,0xd2(%rax)
  800420a3d2:	08 00 
  800420a3d4:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a3db:	00 00 00 
  800420a3de:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  800420a3e5:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a3e8:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  800420a3ee:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a3f5:	00 00 00 
  800420a3f8:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  800420a3ff:	83 e2 07             	and    $0x7,%edx
  800420a402:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  800420a408:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a40f:	00 00 00 
  800420a412:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420a419:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a41c:	83 ca 0e             	or     $0xe,%edx
  800420a41f:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420a425:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a42c:	00 00 00 
  800420a42f:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420a436:	83 e2 ef             	and    $0xffffffef,%edx
  800420a439:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420a43f:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a446:	00 00 00 
  800420a449:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420a450:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a453:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420a459:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a460:	00 00 00 
  800420a463:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420a46a:	83 ca 80             	or     $0xffffff80,%edx
  800420a46d:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420a473:	48 b8 b8 d0 20 04 80 	movabs $0x800420d0b8,%rax
  800420a47a:	00 00 00 
  800420a47d:	48 c1 e8 10          	shr    $0x10,%rax
  800420a481:	89 c2                	mov    %eax,%edx
  800420a483:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a48a:	00 00 00 
  800420a48d:	66 89 90 d6 00 00 00 	mov    %dx,0xd6(%rax)
  800420a494:	48 b8 b8 d0 20 04 80 	movabs $0x800420d0b8,%rax
  800420a49b:	00 00 00 
  800420a49e:	48 c1 e8 20          	shr    $0x20,%rax
  800420a4a2:	89 c2                	mov    %eax,%edx
  800420a4a4:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a4ab:	00 00 00 
  800420a4ae:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
  800420a4b4:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a4bb:	00 00 00 
  800420a4be:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%rax)
  800420a4c5:	00 00 00 
    SETGATE(idt[T_PGFLT],   0, GD_KT, jos64_pagefault,  0);
  800420a4c8:	48 b8 c0 d0 20 04 80 	movabs $0x800420d0c0,%rax
  800420a4cf:	00 00 00 
  800420a4d2:	89 c2                	mov    %eax,%edx
  800420a4d4:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a4db:	00 00 00 
  800420a4de:	66 89 90 e0 00 00 00 	mov    %dx,0xe0(%rax)
  800420a4e5:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a4ec:	00 00 00 
  800420a4ef:	66 c7 80 e2 00 00 00 	movw   $0x8,0xe2(%rax)
  800420a4f6:	08 00 
  800420a4f8:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a4ff:	00 00 00 
  800420a502:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  800420a509:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a50c:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  800420a512:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a519:	00 00 00 
  800420a51c:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  800420a523:	83 e2 07             	and    $0x7,%edx
  800420a526:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  800420a52c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a533:	00 00 00 
  800420a536:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420a53d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a540:	83 ca 0e             	or     $0xe,%edx
  800420a543:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420a549:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a550:	00 00 00 
  800420a553:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420a55a:	83 e2 ef             	and    $0xffffffef,%edx
  800420a55d:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420a563:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a56a:	00 00 00 
  800420a56d:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420a574:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a577:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420a57d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a584:	00 00 00 
  800420a587:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420a58e:	83 ca 80             	or     $0xffffff80,%edx
  800420a591:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420a597:	48 b8 c0 d0 20 04 80 	movabs $0x800420d0c0,%rax
  800420a59e:	00 00 00 
  800420a5a1:	48 c1 e8 10          	shr    $0x10,%rax
  800420a5a5:	89 c2                	mov    %eax,%edx
  800420a5a7:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a5ae:	00 00 00 
  800420a5b1:	66 89 90 e6 00 00 00 	mov    %dx,0xe6(%rax)
  800420a5b8:	48 b8 c0 d0 20 04 80 	movabs $0x800420d0c0,%rax
  800420a5bf:	00 00 00 
  800420a5c2:	48 c1 e8 20          	shr    $0x20,%rax
  800420a5c6:	89 c2                	mov    %eax,%edx
  800420a5c8:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a5cf:	00 00 00 
  800420a5d2:	89 90 e8 00 00 00    	mov    %edx,0xe8(%rax)
  800420a5d8:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a5df:	00 00 00 
  800420a5e2:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%rax)
  800420a5e9:	00 00 00 
    SETGATE(idt[T_FPERR],   0, GD_KT, jos64_fp_error,  0);
  800420a5ec:	48 b8 c4 d0 20 04 80 	movabs $0x800420d0c4,%rax
  800420a5f3:	00 00 00 
  800420a5f6:	89 c2                	mov    %eax,%edx
  800420a5f8:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a5ff:	00 00 00 
  800420a602:	66 89 90 00 01 00 00 	mov    %dx,0x100(%rax)
  800420a609:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a610:	00 00 00 
  800420a613:	66 c7 80 02 01 00 00 	movw   $0x8,0x102(%rax)
  800420a61a:	08 00 
  800420a61c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a623:	00 00 00 
  800420a626:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  800420a62d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a630:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  800420a636:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a63d:	00 00 00 
  800420a640:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  800420a647:	83 e2 07             	and    $0x7,%edx
  800420a64a:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  800420a650:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a657:	00 00 00 
  800420a65a:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420a661:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a664:	83 ca 0e             	or     $0xe,%edx
  800420a667:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420a66d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a674:	00 00 00 
  800420a677:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420a67e:	83 e2 ef             	and    $0xffffffef,%edx
  800420a681:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420a687:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a68e:	00 00 00 
  800420a691:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420a698:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a69b:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420a6a1:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a6a8:	00 00 00 
  800420a6ab:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420a6b2:	83 ca 80             	or     $0xffffff80,%edx
  800420a6b5:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420a6bb:	48 b8 c4 d0 20 04 80 	movabs $0x800420d0c4,%rax
  800420a6c2:	00 00 00 
  800420a6c5:	48 c1 e8 10          	shr    $0x10,%rax
  800420a6c9:	89 c2                	mov    %eax,%edx
  800420a6cb:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a6d2:	00 00 00 
  800420a6d5:	66 89 90 06 01 00 00 	mov    %dx,0x106(%rax)
  800420a6dc:	48 b8 c4 d0 20 04 80 	movabs $0x800420d0c4,%rax
  800420a6e3:	00 00 00 
  800420a6e6:	48 c1 e8 20          	shr    $0x20,%rax
  800420a6ea:	89 c2                	mov    %eax,%edx
  800420a6ec:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a6f3:	00 00 00 
  800420a6f6:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
  800420a6fc:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a703:	00 00 00 
  800420a706:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  800420a70d:	00 00 00 
    SETGATE(idt[T_ALIGN],   0, GD_KT, jos64_align,  0);
  800420a710:	48 b8 ca d0 20 04 80 	movabs $0x800420d0ca,%rax
  800420a717:	00 00 00 
  800420a71a:	89 c2                	mov    %eax,%edx
  800420a71c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a723:	00 00 00 
  800420a726:	66 89 90 10 01 00 00 	mov    %dx,0x110(%rax)
  800420a72d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a734:	00 00 00 
  800420a737:	66 c7 80 12 01 00 00 	movw   $0x8,0x112(%rax)
  800420a73e:	08 00 
  800420a740:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a747:	00 00 00 
  800420a74a:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  800420a751:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a754:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  800420a75a:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a761:	00 00 00 
  800420a764:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  800420a76b:	83 e2 07             	and    $0x7,%edx
  800420a76e:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  800420a774:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a77b:	00 00 00 
  800420a77e:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a785:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a788:	83 ca 0e             	or     $0xe,%edx
  800420a78b:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a791:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a798:	00 00 00 
  800420a79b:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a7a2:	83 e2 ef             	and    $0xffffffef,%edx
  800420a7a5:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a7ab:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a7b2:	00 00 00 
  800420a7b5:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a7bc:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a7bf:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a7c5:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a7cc:	00 00 00 
  800420a7cf:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a7d6:	83 ca 80             	or     $0xffffff80,%edx
  800420a7d9:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a7df:	48 b8 ca d0 20 04 80 	movabs $0x800420d0ca,%rax
  800420a7e6:	00 00 00 
  800420a7e9:	48 c1 e8 10          	shr    $0x10,%rax
  800420a7ed:	89 c2                	mov    %eax,%edx
  800420a7ef:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a7f6:	00 00 00 
  800420a7f9:	66 89 90 16 01 00 00 	mov    %dx,0x116(%rax)
  800420a800:	48 b8 ca d0 20 04 80 	movabs $0x800420d0ca,%rax
  800420a807:	00 00 00 
  800420a80a:	48 c1 e8 20          	shr    $0x20,%rax
  800420a80e:	89 c2                	mov    %eax,%edx
  800420a810:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a817:	00 00 00 
  800420a81a:	89 90 18 01 00 00    	mov    %edx,0x118(%rax)
  800420a820:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a827:	00 00 00 
  800420a82a:	c7 80 1c 01 00 00 00 	movl   $0x0,0x11c(%rax)
  800420a831:	00 00 00 
    SETGATE(idt[T_MCHK],   0, GD_KT, jos64_mcheck,  0);
  800420a834:	48 b8 d0 d0 20 04 80 	movabs $0x800420d0d0,%rax
  800420a83b:	00 00 00 
  800420a83e:	89 c2                	mov    %eax,%edx
  800420a840:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a847:	00 00 00 
  800420a84a:	66 89 90 20 01 00 00 	mov    %dx,0x120(%rax)
  800420a851:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a858:	00 00 00 
  800420a85b:	66 c7 80 22 01 00 00 	movw   $0x8,0x122(%rax)
  800420a862:	08 00 
  800420a864:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a86b:	00 00 00 
  800420a86e:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420a875:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a878:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420a87e:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a885:	00 00 00 
  800420a888:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420a88f:	83 e2 07             	and    $0x7,%edx
  800420a892:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420a898:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a89f:	00 00 00 
  800420a8a2:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a8a9:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a8ac:	83 ca 0e             	or     $0xe,%edx
  800420a8af:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a8b5:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a8bc:	00 00 00 
  800420a8bf:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a8c6:	83 e2 ef             	and    $0xffffffef,%edx
  800420a8c9:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a8cf:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a8d6:	00 00 00 
  800420a8d9:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a8e0:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a8e3:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a8e9:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a8f0:	00 00 00 
  800420a8f3:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a8fa:	83 ca 80             	or     $0xffffff80,%edx
  800420a8fd:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a903:	48 b8 d0 d0 20 04 80 	movabs $0x800420d0d0,%rax
  800420a90a:	00 00 00 
  800420a90d:	48 c1 e8 10          	shr    $0x10,%rax
  800420a911:	89 c2                	mov    %eax,%edx
  800420a913:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a91a:	00 00 00 
  800420a91d:	66 89 90 26 01 00 00 	mov    %dx,0x126(%rax)
  800420a924:	48 b8 d0 d0 20 04 80 	movabs $0x800420d0d0,%rax
  800420a92b:	00 00 00 
  800420a92e:	48 c1 e8 20          	shr    $0x20,%rax
  800420a932:	89 c2                	mov    %eax,%edx
  800420a934:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a93b:	00 00 00 
  800420a93e:	89 90 28 01 00 00    	mov    %edx,0x128(%rax)
  800420a944:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a94b:	00 00 00 
  800420a94e:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%rax)
  800420a955:	00 00 00 
    SETGATE(idt[T_SIMDERR],   0, GD_KT, jos64_simd_error,  0);
  800420a958:	48 b8 d6 d0 20 04 80 	movabs $0x800420d0d6,%rax
  800420a95f:	00 00 00 
  800420a962:	89 c2                	mov    %eax,%edx
  800420a964:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a96b:	00 00 00 
  800420a96e:	66 89 90 30 01 00 00 	mov    %dx,0x130(%rax)
  800420a975:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a97c:	00 00 00 
  800420a97f:	66 c7 80 32 01 00 00 	movw   $0x8,0x132(%rax)
  800420a986:	08 00 
  800420a988:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a98f:	00 00 00 
  800420a992:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  800420a999:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a99c:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  800420a9a2:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a9a9:	00 00 00 
  800420a9ac:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  800420a9b3:	83 e2 07             	and    $0x7,%edx
  800420a9b6:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  800420a9bc:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a9c3:	00 00 00 
  800420a9c6:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a9cd:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a9d0:	83 ca 0e             	or     $0xe,%edx
  800420a9d3:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a9d9:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a9e0:	00 00 00 
  800420a9e3:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a9ea:	83 e2 ef             	and    $0xffffffef,%edx
  800420a9ed:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a9f3:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420a9fa:	00 00 00 
  800420a9fd:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420aa04:	83 e2 9f             	and    $0xffffff9f,%edx
  800420aa07:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420aa0d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420aa14:	00 00 00 
  800420aa17:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420aa1e:	83 ca 80             	or     $0xffffff80,%edx
  800420aa21:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420aa27:	48 b8 d6 d0 20 04 80 	movabs $0x800420d0d6,%rax
  800420aa2e:	00 00 00 
  800420aa31:	48 c1 e8 10          	shr    $0x10,%rax
  800420aa35:	89 c2                	mov    %eax,%edx
  800420aa37:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420aa3e:	00 00 00 
  800420aa41:	66 89 90 36 01 00 00 	mov    %dx,0x136(%rax)
  800420aa48:	48 b8 d6 d0 20 04 80 	movabs $0x800420d0d6,%rax
  800420aa4f:	00 00 00 
  800420aa52:	48 c1 e8 20          	shr    $0x20,%rax
  800420aa56:	89 c2                	mov    %eax,%edx
  800420aa58:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420aa5f:	00 00 00 
  800420aa62:	89 90 38 01 00 00    	mov    %edx,0x138(%rax)
  800420aa68:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420aa6f:	00 00 00 
  800420aa72:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%rax)
  800420aa79:	00 00 00 
    SETGATE(idt[T_SYSCALL], 0, GD_KT, jos64_systemcall, 3);
  800420aa7c:	48 b8 dc d0 20 04 80 	movabs $0x800420d0dc,%rax
  800420aa83:	00 00 00 
  800420aa86:	89 c2                	mov    %eax,%edx
  800420aa88:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420aa8f:	00 00 00 
  800420aa92:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  800420aa99:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420aaa0:	00 00 00 
  800420aaa3:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  800420aaaa:	08 00 
  800420aaac:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420aab3:	00 00 00 
  800420aab6:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420aabd:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aac0:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420aac6:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420aacd:	00 00 00 
  800420aad0:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420aad7:	83 e2 07             	and    $0x7,%edx
  800420aada:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420aae0:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420aae7:	00 00 00 
  800420aaea:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420aaf1:	83 e2 f0             	and    $0xfffffff0,%edx
  800420aaf4:	83 ca 0e             	or     $0xe,%edx
  800420aaf7:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420aafd:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ab04:	00 00 00 
  800420ab07:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420ab0e:	83 e2 ef             	and    $0xffffffef,%edx
  800420ab11:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420ab17:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ab1e:	00 00 00 
  800420ab21:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420ab28:	83 ca 60             	or     $0x60,%edx
  800420ab2b:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420ab31:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ab38:	00 00 00 
  800420ab3b:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420ab42:	83 ca 80             	or     $0xffffff80,%edx
  800420ab45:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420ab4b:	48 b8 dc d0 20 04 80 	movabs $0x800420d0dc,%rax
  800420ab52:	00 00 00 
  800420ab55:	48 c1 e8 10          	shr    $0x10,%rax
  800420ab59:	89 c2                	mov    %eax,%edx
  800420ab5b:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ab62:	00 00 00 
  800420ab65:	66 89 90 06 03 00 00 	mov    %dx,0x306(%rax)
  800420ab6c:	48 b8 dc d0 20 04 80 	movabs $0x800420d0dc,%rax
  800420ab73:	00 00 00 
  800420ab76:	48 c1 e8 20          	shr    $0x20,%rax
  800420ab7a:	89 c2                	mov    %eax,%edx
  800420ab7c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ab83:	00 00 00 
  800420ab86:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  800420ab8c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ab93:	00 00 00 
  800420ab96:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  800420ab9d:	00 00 00 
 
   
    SETGATE(idt[32], 0, GD_KT, jos64_irq32, 0);
  800420aba0:	48 b8 e2 d0 20 04 80 	movabs $0x800420d0e2,%rax
  800420aba7:	00 00 00 
  800420abaa:	89 c2                	mov    %eax,%edx
  800420abac:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420abb3:	00 00 00 
  800420abb6:	66 89 90 00 02 00 00 	mov    %dx,0x200(%rax)
  800420abbd:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420abc4:	00 00 00 
  800420abc7:	66 c7 80 02 02 00 00 	movw   $0x8,0x202(%rax)
  800420abce:	08 00 
  800420abd0:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420abd7:	00 00 00 
  800420abda:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420abe1:	83 e2 f8             	and    $0xfffffff8,%edx
  800420abe4:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420abea:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420abf1:	00 00 00 
  800420abf4:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420abfb:	83 e2 07             	and    $0x7,%edx
  800420abfe:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420ac04:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ac0b:	00 00 00 
  800420ac0e:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420ac15:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ac18:	83 ca 0e             	or     $0xe,%edx
  800420ac1b:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420ac21:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ac28:	00 00 00 
  800420ac2b:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420ac32:	83 e2 ef             	and    $0xffffffef,%edx
  800420ac35:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420ac3b:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ac42:	00 00 00 
  800420ac45:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420ac4c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ac4f:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420ac55:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ac5c:	00 00 00 
  800420ac5f:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420ac66:	83 ca 80             	or     $0xffffff80,%edx
  800420ac69:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420ac6f:	48 b8 e2 d0 20 04 80 	movabs $0x800420d0e2,%rax
  800420ac76:	00 00 00 
  800420ac79:	48 c1 e8 10          	shr    $0x10,%rax
  800420ac7d:	89 c2                	mov    %eax,%edx
  800420ac7f:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ac86:	00 00 00 
  800420ac89:	66 89 90 06 02 00 00 	mov    %dx,0x206(%rax)
  800420ac90:	48 b8 e2 d0 20 04 80 	movabs $0x800420d0e2,%rax
  800420ac97:	00 00 00 
  800420ac9a:	48 c1 e8 20          	shr    $0x20,%rax
  800420ac9e:	89 c2                	mov    %eax,%edx
  800420aca0:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420aca7:	00 00 00 
  800420acaa:	89 90 08 02 00 00    	mov    %edx,0x208(%rax)
  800420acb0:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420acb7:	00 00 00 
  800420acba:	c7 80 0c 02 00 00 00 	movl   $0x0,0x20c(%rax)
  800420acc1:	00 00 00 
    SETGATE(idt[33], 0, GD_KT, jos64_irq33, 0);
  800420acc4:	48 b8 e8 d0 20 04 80 	movabs $0x800420d0e8,%rax
  800420accb:	00 00 00 
  800420acce:	89 c2                	mov    %eax,%edx
  800420acd0:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420acd7:	00 00 00 
  800420acda:	66 89 90 10 02 00 00 	mov    %dx,0x210(%rax)
  800420ace1:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ace8:	00 00 00 
  800420aceb:	66 c7 80 12 02 00 00 	movw   $0x8,0x212(%rax)
  800420acf2:	08 00 
  800420acf4:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420acfb:	00 00 00 
  800420acfe:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420ad05:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ad08:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420ad0e:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ad15:	00 00 00 
  800420ad18:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420ad1f:	83 e2 07             	and    $0x7,%edx
  800420ad22:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420ad28:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ad2f:	00 00 00 
  800420ad32:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420ad39:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ad3c:	83 ca 0e             	or     $0xe,%edx
  800420ad3f:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420ad45:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ad4c:	00 00 00 
  800420ad4f:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420ad56:	83 e2 ef             	and    $0xffffffef,%edx
  800420ad59:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420ad5f:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ad66:	00 00 00 
  800420ad69:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420ad70:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ad73:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420ad79:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ad80:	00 00 00 
  800420ad83:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420ad8a:	83 ca 80             	or     $0xffffff80,%edx
  800420ad8d:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420ad93:	48 b8 e8 d0 20 04 80 	movabs $0x800420d0e8,%rax
  800420ad9a:	00 00 00 
  800420ad9d:	48 c1 e8 10          	shr    $0x10,%rax
  800420ada1:	89 c2                	mov    %eax,%edx
  800420ada3:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420adaa:	00 00 00 
  800420adad:	66 89 90 16 02 00 00 	mov    %dx,0x216(%rax)
  800420adb4:	48 b8 e8 d0 20 04 80 	movabs $0x800420d0e8,%rax
  800420adbb:	00 00 00 
  800420adbe:	48 c1 e8 20          	shr    $0x20,%rax
  800420adc2:	89 c2                	mov    %eax,%edx
  800420adc4:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420adcb:	00 00 00 
  800420adce:	89 90 18 02 00 00    	mov    %edx,0x218(%rax)
  800420add4:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420addb:	00 00 00 
  800420adde:	c7 80 1c 02 00 00 00 	movl   $0x0,0x21c(%rax)
  800420ade5:	00 00 00 
    SETGATE(idt[34], 0, GD_KT, jos64_irq34, 0);
  800420ade8:	48 b8 ee d0 20 04 80 	movabs $0x800420d0ee,%rax
  800420adef:	00 00 00 
  800420adf2:	89 c2                	mov    %eax,%edx
  800420adf4:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420adfb:	00 00 00 
  800420adfe:	66 89 90 20 02 00 00 	mov    %dx,0x220(%rax)
  800420ae05:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ae0c:	00 00 00 
  800420ae0f:	66 c7 80 22 02 00 00 	movw   $0x8,0x222(%rax)
  800420ae16:	08 00 
  800420ae18:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ae1f:	00 00 00 
  800420ae22:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420ae29:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ae2c:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420ae32:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ae39:	00 00 00 
  800420ae3c:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420ae43:	83 e2 07             	and    $0x7,%edx
  800420ae46:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420ae4c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ae53:	00 00 00 
  800420ae56:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420ae5d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ae60:	83 ca 0e             	or     $0xe,%edx
  800420ae63:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420ae69:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ae70:	00 00 00 
  800420ae73:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420ae7a:	83 e2 ef             	and    $0xffffffef,%edx
  800420ae7d:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420ae83:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ae8a:	00 00 00 
  800420ae8d:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420ae94:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ae97:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420ae9d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420aea4:	00 00 00 
  800420aea7:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420aeae:	83 ca 80             	or     $0xffffff80,%edx
  800420aeb1:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420aeb7:	48 b8 ee d0 20 04 80 	movabs $0x800420d0ee,%rax
  800420aebe:	00 00 00 
  800420aec1:	48 c1 e8 10          	shr    $0x10,%rax
  800420aec5:	89 c2                	mov    %eax,%edx
  800420aec7:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420aece:	00 00 00 
  800420aed1:	66 89 90 26 02 00 00 	mov    %dx,0x226(%rax)
  800420aed8:	48 b8 ee d0 20 04 80 	movabs $0x800420d0ee,%rax
  800420aedf:	00 00 00 
  800420aee2:	48 c1 e8 20          	shr    $0x20,%rax
  800420aee6:	89 c2                	mov    %eax,%edx
  800420aee8:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420aeef:	00 00 00 
  800420aef2:	89 90 28 02 00 00    	mov    %edx,0x228(%rax)
  800420aef8:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420aeff:	00 00 00 
  800420af02:	c7 80 2c 02 00 00 00 	movl   $0x0,0x22c(%rax)
  800420af09:	00 00 00 
    SETGATE(idt[35], 0, GD_KT, jos64_irq35, 0);
  800420af0c:	48 b8 f4 d0 20 04 80 	movabs $0x800420d0f4,%rax
  800420af13:	00 00 00 
  800420af16:	89 c2                	mov    %eax,%edx
  800420af18:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420af1f:	00 00 00 
  800420af22:	66 89 90 30 02 00 00 	mov    %dx,0x230(%rax)
  800420af29:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420af30:	00 00 00 
  800420af33:	66 c7 80 32 02 00 00 	movw   $0x8,0x232(%rax)
  800420af3a:	08 00 
  800420af3c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420af43:	00 00 00 
  800420af46:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420af4d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420af50:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420af56:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420af5d:	00 00 00 
  800420af60:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420af67:	83 e2 07             	and    $0x7,%edx
  800420af6a:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420af70:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420af77:	00 00 00 
  800420af7a:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420af81:	83 e2 f0             	and    $0xfffffff0,%edx
  800420af84:	83 ca 0e             	or     $0xe,%edx
  800420af87:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420af8d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420af94:	00 00 00 
  800420af97:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420af9e:	83 e2 ef             	and    $0xffffffef,%edx
  800420afa1:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420afa7:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420afae:	00 00 00 
  800420afb1:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420afb8:	83 e2 9f             	and    $0xffffff9f,%edx
  800420afbb:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420afc1:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420afc8:	00 00 00 
  800420afcb:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420afd2:	83 ca 80             	or     $0xffffff80,%edx
  800420afd5:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420afdb:	48 b8 f4 d0 20 04 80 	movabs $0x800420d0f4,%rax
  800420afe2:	00 00 00 
  800420afe5:	48 c1 e8 10          	shr    $0x10,%rax
  800420afe9:	89 c2                	mov    %eax,%edx
  800420afeb:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420aff2:	00 00 00 
  800420aff5:	66 89 90 36 02 00 00 	mov    %dx,0x236(%rax)
  800420affc:	48 b8 f4 d0 20 04 80 	movabs $0x800420d0f4,%rax
  800420b003:	00 00 00 
  800420b006:	48 c1 e8 20          	shr    $0x20,%rax
  800420b00a:	89 c2                	mov    %eax,%edx
  800420b00c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b013:	00 00 00 
  800420b016:	89 90 38 02 00 00    	mov    %edx,0x238(%rax)
  800420b01c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b023:	00 00 00 
  800420b026:	c7 80 3c 02 00 00 00 	movl   $0x0,0x23c(%rax)
  800420b02d:	00 00 00 
    SETGATE(idt[36], 0, GD_KT, jos64_irq36, 0);
  800420b030:	48 b8 fa d0 20 04 80 	movabs $0x800420d0fa,%rax
  800420b037:	00 00 00 
  800420b03a:	89 c2                	mov    %eax,%edx
  800420b03c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b043:	00 00 00 
  800420b046:	66 89 90 40 02 00 00 	mov    %dx,0x240(%rax)
  800420b04d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b054:	00 00 00 
  800420b057:	66 c7 80 42 02 00 00 	movw   $0x8,0x242(%rax)
  800420b05e:	08 00 
  800420b060:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b067:	00 00 00 
  800420b06a:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420b071:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b074:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420b07a:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b081:	00 00 00 
  800420b084:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420b08b:	83 e2 07             	and    $0x7,%edx
  800420b08e:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420b094:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b09b:	00 00 00 
  800420b09e:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420b0a5:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b0a8:	83 ca 0e             	or     $0xe,%edx
  800420b0ab:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420b0b1:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b0b8:	00 00 00 
  800420b0bb:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420b0c2:	83 e2 ef             	and    $0xffffffef,%edx
  800420b0c5:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420b0cb:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b0d2:	00 00 00 
  800420b0d5:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420b0dc:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b0df:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420b0e5:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b0ec:	00 00 00 
  800420b0ef:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420b0f6:	83 ca 80             	or     $0xffffff80,%edx
  800420b0f9:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420b0ff:	48 b8 fa d0 20 04 80 	movabs $0x800420d0fa,%rax
  800420b106:	00 00 00 
  800420b109:	48 c1 e8 10          	shr    $0x10,%rax
  800420b10d:	89 c2                	mov    %eax,%edx
  800420b10f:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b116:	00 00 00 
  800420b119:	66 89 90 46 02 00 00 	mov    %dx,0x246(%rax)
  800420b120:	48 b8 fa d0 20 04 80 	movabs $0x800420d0fa,%rax
  800420b127:	00 00 00 
  800420b12a:	48 c1 e8 20          	shr    $0x20,%rax
  800420b12e:	89 c2                	mov    %eax,%edx
  800420b130:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b137:	00 00 00 
  800420b13a:	89 90 48 02 00 00    	mov    %edx,0x248(%rax)
  800420b140:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b147:	00 00 00 
  800420b14a:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%rax)
  800420b151:	00 00 00 
    SETGATE(idt[37], 0, GD_KT, jos64_irq37, 0);
  800420b154:	48 b8 00 d1 20 04 80 	movabs $0x800420d100,%rax
  800420b15b:	00 00 00 
  800420b15e:	89 c2                	mov    %eax,%edx
  800420b160:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b167:	00 00 00 
  800420b16a:	66 89 90 50 02 00 00 	mov    %dx,0x250(%rax)
  800420b171:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b178:	00 00 00 
  800420b17b:	66 c7 80 52 02 00 00 	movw   $0x8,0x252(%rax)
  800420b182:	08 00 
  800420b184:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b18b:	00 00 00 
  800420b18e:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420b195:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b198:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420b19e:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b1a5:	00 00 00 
  800420b1a8:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420b1af:	83 e2 07             	and    $0x7,%edx
  800420b1b2:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420b1b8:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b1bf:	00 00 00 
  800420b1c2:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b1c9:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b1cc:	83 ca 0e             	or     $0xe,%edx
  800420b1cf:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b1d5:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b1dc:	00 00 00 
  800420b1df:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b1e6:	83 e2 ef             	and    $0xffffffef,%edx
  800420b1e9:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b1ef:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b1f6:	00 00 00 
  800420b1f9:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b200:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b203:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b209:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b210:	00 00 00 
  800420b213:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b21a:	83 ca 80             	or     $0xffffff80,%edx
  800420b21d:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b223:	48 b8 00 d1 20 04 80 	movabs $0x800420d100,%rax
  800420b22a:	00 00 00 
  800420b22d:	48 c1 e8 10          	shr    $0x10,%rax
  800420b231:	89 c2                	mov    %eax,%edx
  800420b233:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b23a:	00 00 00 
  800420b23d:	66 89 90 56 02 00 00 	mov    %dx,0x256(%rax)
  800420b244:	48 b8 00 d1 20 04 80 	movabs $0x800420d100,%rax
  800420b24b:	00 00 00 
  800420b24e:	48 c1 e8 20          	shr    $0x20,%rax
  800420b252:	89 c2                	mov    %eax,%edx
  800420b254:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b25b:	00 00 00 
  800420b25e:	89 90 58 02 00 00    	mov    %edx,0x258(%rax)
  800420b264:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b26b:	00 00 00 
  800420b26e:	c7 80 5c 02 00 00 00 	movl   $0x0,0x25c(%rax)
  800420b275:	00 00 00 
    SETGATE(idt[38], 0, GD_KT, jos64_irq38, 0);
  800420b278:	48 b8 06 d1 20 04 80 	movabs $0x800420d106,%rax
  800420b27f:	00 00 00 
  800420b282:	89 c2                	mov    %eax,%edx
  800420b284:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b28b:	00 00 00 
  800420b28e:	66 89 90 60 02 00 00 	mov    %dx,0x260(%rax)
  800420b295:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b29c:	00 00 00 
  800420b29f:	66 c7 80 62 02 00 00 	movw   $0x8,0x262(%rax)
  800420b2a6:	08 00 
  800420b2a8:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b2af:	00 00 00 
  800420b2b2:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420b2b9:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b2bc:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420b2c2:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b2c9:	00 00 00 
  800420b2cc:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420b2d3:	83 e2 07             	and    $0x7,%edx
  800420b2d6:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420b2dc:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b2e3:	00 00 00 
  800420b2e6:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b2ed:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b2f0:	83 ca 0e             	or     $0xe,%edx
  800420b2f3:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b2f9:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b300:	00 00 00 
  800420b303:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b30a:	83 e2 ef             	and    $0xffffffef,%edx
  800420b30d:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b313:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b31a:	00 00 00 
  800420b31d:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b324:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b327:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b32d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b334:	00 00 00 
  800420b337:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b33e:	83 ca 80             	or     $0xffffff80,%edx
  800420b341:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b347:	48 b8 06 d1 20 04 80 	movabs $0x800420d106,%rax
  800420b34e:	00 00 00 
  800420b351:	48 c1 e8 10          	shr    $0x10,%rax
  800420b355:	89 c2                	mov    %eax,%edx
  800420b357:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b35e:	00 00 00 
  800420b361:	66 89 90 66 02 00 00 	mov    %dx,0x266(%rax)
  800420b368:	48 b8 06 d1 20 04 80 	movabs $0x800420d106,%rax
  800420b36f:	00 00 00 
  800420b372:	48 c1 e8 20          	shr    $0x20,%rax
  800420b376:	89 c2                	mov    %eax,%edx
  800420b378:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b37f:	00 00 00 
  800420b382:	89 90 68 02 00 00    	mov    %edx,0x268(%rax)
  800420b388:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b38f:	00 00 00 
  800420b392:	c7 80 6c 02 00 00 00 	movl   $0x0,0x26c(%rax)
  800420b399:	00 00 00 
    SETGATE(idt[39], 0, GD_KT, jos64_irq39, 0);
  800420b39c:	48 b8 0c d1 20 04 80 	movabs $0x800420d10c,%rax
  800420b3a3:	00 00 00 
  800420b3a6:	89 c2                	mov    %eax,%edx
  800420b3a8:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b3af:	00 00 00 
  800420b3b2:	66 89 90 70 02 00 00 	mov    %dx,0x270(%rax)
  800420b3b9:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b3c0:	00 00 00 
  800420b3c3:	66 c7 80 72 02 00 00 	movw   $0x8,0x272(%rax)
  800420b3ca:	08 00 
  800420b3cc:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b3d3:	00 00 00 
  800420b3d6:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420b3dd:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b3e0:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420b3e6:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b3ed:	00 00 00 
  800420b3f0:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420b3f7:	83 e2 07             	and    $0x7,%edx
  800420b3fa:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420b400:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b407:	00 00 00 
  800420b40a:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420b411:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b414:	83 ca 0e             	or     $0xe,%edx
  800420b417:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420b41d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b424:	00 00 00 
  800420b427:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420b42e:	83 e2 ef             	and    $0xffffffef,%edx
  800420b431:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420b437:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b43e:	00 00 00 
  800420b441:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420b448:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b44b:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420b451:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b458:	00 00 00 
  800420b45b:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420b462:	83 ca 80             	or     $0xffffff80,%edx
  800420b465:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420b46b:	48 b8 0c d1 20 04 80 	movabs $0x800420d10c,%rax
  800420b472:	00 00 00 
  800420b475:	48 c1 e8 10          	shr    $0x10,%rax
  800420b479:	89 c2                	mov    %eax,%edx
  800420b47b:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b482:	00 00 00 
  800420b485:	66 89 90 76 02 00 00 	mov    %dx,0x276(%rax)
  800420b48c:	48 b8 0c d1 20 04 80 	movabs $0x800420d10c,%rax
  800420b493:	00 00 00 
  800420b496:	48 c1 e8 20          	shr    $0x20,%rax
  800420b49a:	89 c2                	mov    %eax,%edx
  800420b49c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b4a3:	00 00 00 
  800420b4a6:	89 90 78 02 00 00    	mov    %edx,0x278(%rax)
  800420b4ac:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b4b3:	00 00 00 
  800420b4b6:	c7 80 7c 02 00 00 00 	movl   $0x0,0x27c(%rax)
  800420b4bd:	00 00 00 
    SETGATE(idt[40], 0, GD_KT, jos64_irq40, 0);
  800420b4c0:	48 b8 12 d1 20 04 80 	movabs $0x800420d112,%rax
  800420b4c7:	00 00 00 
  800420b4ca:	89 c2                	mov    %eax,%edx
  800420b4cc:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b4d3:	00 00 00 
  800420b4d6:	66 89 90 80 02 00 00 	mov    %dx,0x280(%rax)
  800420b4dd:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b4e4:	00 00 00 
  800420b4e7:	66 c7 80 82 02 00 00 	movw   $0x8,0x282(%rax)
  800420b4ee:	08 00 
  800420b4f0:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b4f7:	00 00 00 
  800420b4fa:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420b501:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b504:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420b50a:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b511:	00 00 00 
  800420b514:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420b51b:	83 e2 07             	and    $0x7,%edx
  800420b51e:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420b524:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b52b:	00 00 00 
  800420b52e:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420b535:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b538:	83 ca 0e             	or     $0xe,%edx
  800420b53b:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420b541:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b548:	00 00 00 
  800420b54b:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420b552:	83 e2 ef             	and    $0xffffffef,%edx
  800420b555:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420b55b:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b562:	00 00 00 
  800420b565:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420b56c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b56f:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420b575:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b57c:	00 00 00 
  800420b57f:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420b586:	83 ca 80             	or     $0xffffff80,%edx
  800420b589:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420b58f:	48 b8 12 d1 20 04 80 	movabs $0x800420d112,%rax
  800420b596:	00 00 00 
  800420b599:	48 c1 e8 10          	shr    $0x10,%rax
  800420b59d:	89 c2                	mov    %eax,%edx
  800420b59f:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b5a6:	00 00 00 
  800420b5a9:	66 89 90 86 02 00 00 	mov    %dx,0x286(%rax)
  800420b5b0:	48 b8 12 d1 20 04 80 	movabs $0x800420d112,%rax
  800420b5b7:	00 00 00 
  800420b5ba:	48 c1 e8 20          	shr    $0x20,%rax
  800420b5be:	89 c2                	mov    %eax,%edx
  800420b5c0:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b5c7:	00 00 00 
  800420b5ca:	89 90 88 02 00 00    	mov    %edx,0x288(%rax)
  800420b5d0:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b5d7:	00 00 00 
  800420b5da:	c7 80 8c 02 00 00 00 	movl   $0x0,0x28c(%rax)
  800420b5e1:	00 00 00 
    SETGATE(idt[41], 0, GD_KT, jos64_irq41, 0);
  800420b5e4:	48 b8 18 d1 20 04 80 	movabs $0x800420d118,%rax
  800420b5eb:	00 00 00 
  800420b5ee:	89 c2                	mov    %eax,%edx
  800420b5f0:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b5f7:	00 00 00 
  800420b5fa:	66 89 90 90 02 00 00 	mov    %dx,0x290(%rax)
  800420b601:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b608:	00 00 00 
  800420b60b:	66 c7 80 92 02 00 00 	movw   $0x8,0x292(%rax)
  800420b612:	08 00 
  800420b614:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b61b:	00 00 00 
  800420b61e:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420b625:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b628:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420b62e:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b635:	00 00 00 
  800420b638:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420b63f:	83 e2 07             	and    $0x7,%edx
  800420b642:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420b648:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b64f:	00 00 00 
  800420b652:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b659:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b65c:	83 ca 0e             	or     $0xe,%edx
  800420b65f:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b665:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b66c:	00 00 00 
  800420b66f:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b676:	83 e2 ef             	and    $0xffffffef,%edx
  800420b679:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b67f:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b686:	00 00 00 
  800420b689:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b690:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b693:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b699:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b6a0:	00 00 00 
  800420b6a3:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b6aa:	83 ca 80             	or     $0xffffff80,%edx
  800420b6ad:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b6b3:	48 b8 18 d1 20 04 80 	movabs $0x800420d118,%rax
  800420b6ba:	00 00 00 
  800420b6bd:	48 c1 e8 10          	shr    $0x10,%rax
  800420b6c1:	89 c2                	mov    %eax,%edx
  800420b6c3:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b6ca:	00 00 00 
  800420b6cd:	66 89 90 96 02 00 00 	mov    %dx,0x296(%rax)
  800420b6d4:	48 b8 18 d1 20 04 80 	movabs $0x800420d118,%rax
  800420b6db:	00 00 00 
  800420b6de:	48 c1 e8 20          	shr    $0x20,%rax
  800420b6e2:	89 c2                	mov    %eax,%edx
  800420b6e4:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b6eb:	00 00 00 
  800420b6ee:	89 90 98 02 00 00    	mov    %edx,0x298(%rax)
  800420b6f4:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b6fb:	00 00 00 
  800420b6fe:	c7 80 9c 02 00 00 00 	movl   $0x0,0x29c(%rax)
  800420b705:	00 00 00 
    SETGATE(idt[42], 0, GD_KT, jos64_irq42, 0);
  800420b708:	48 b8 1e d1 20 04 80 	movabs $0x800420d11e,%rax
  800420b70f:	00 00 00 
  800420b712:	89 c2                	mov    %eax,%edx
  800420b714:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b71b:	00 00 00 
  800420b71e:	66 89 90 a0 02 00 00 	mov    %dx,0x2a0(%rax)
  800420b725:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b72c:	00 00 00 
  800420b72f:	66 c7 80 a2 02 00 00 	movw   $0x8,0x2a2(%rax)
  800420b736:	08 00 
  800420b738:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b73f:	00 00 00 
  800420b742:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420b749:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b74c:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420b752:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b759:	00 00 00 
  800420b75c:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420b763:	83 e2 07             	and    $0x7,%edx
  800420b766:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420b76c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b773:	00 00 00 
  800420b776:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b77d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b780:	83 ca 0e             	or     $0xe,%edx
  800420b783:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b789:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b790:	00 00 00 
  800420b793:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b79a:	83 e2 ef             	and    $0xffffffef,%edx
  800420b79d:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b7a3:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b7aa:	00 00 00 
  800420b7ad:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b7b4:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b7b7:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b7bd:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b7c4:	00 00 00 
  800420b7c7:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b7ce:	83 ca 80             	or     $0xffffff80,%edx
  800420b7d1:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b7d7:	48 b8 1e d1 20 04 80 	movabs $0x800420d11e,%rax
  800420b7de:	00 00 00 
  800420b7e1:	48 c1 e8 10          	shr    $0x10,%rax
  800420b7e5:	89 c2                	mov    %eax,%edx
  800420b7e7:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b7ee:	00 00 00 
  800420b7f1:	66 89 90 a6 02 00 00 	mov    %dx,0x2a6(%rax)
  800420b7f8:	48 b8 1e d1 20 04 80 	movabs $0x800420d11e,%rax
  800420b7ff:	00 00 00 
  800420b802:	48 c1 e8 20          	shr    $0x20,%rax
  800420b806:	89 c2                	mov    %eax,%edx
  800420b808:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b80f:	00 00 00 
  800420b812:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%rax)
  800420b818:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b81f:	00 00 00 
  800420b822:	c7 80 ac 02 00 00 00 	movl   $0x0,0x2ac(%rax)
  800420b829:	00 00 00 
    SETGATE(idt[43], 0, GD_KT, jos64_irq43, 0);
  800420b82c:	48 b8 24 d1 20 04 80 	movabs $0x800420d124,%rax
  800420b833:	00 00 00 
  800420b836:	89 c2                	mov    %eax,%edx
  800420b838:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b83f:	00 00 00 
  800420b842:	66 89 90 b0 02 00 00 	mov    %dx,0x2b0(%rax)
  800420b849:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b850:	00 00 00 
  800420b853:	66 c7 80 b2 02 00 00 	movw   $0x8,0x2b2(%rax)
  800420b85a:	08 00 
  800420b85c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b863:	00 00 00 
  800420b866:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420b86d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b870:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420b876:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b87d:	00 00 00 
  800420b880:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420b887:	83 e2 07             	and    $0x7,%edx
  800420b88a:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420b890:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b897:	00 00 00 
  800420b89a:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b8a1:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b8a4:	83 ca 0e             	or     $0xe,%edx
  800420b8a7:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b8ad:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b8b4:	00 00 00 
  800420b8b7:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b8be:	83 e2 ef             	and    $0xffffffef,%edx
  800420b8c1:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b8c7:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b8ce:	00 00 00 
  800420b8d1:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b8d8:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b8db:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b8e1:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b8e8:	00 00 00 
  800420b8eb:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b8f2:	83 ca 80             	or     $0xffffff80,%edx
  800420b8f5:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b8fb:	48 b8 24 d1 20 04 80 	movabs $0x800420d124,%rax
  800420b902:	00 00 00 
  800420b905:	48 c1 e8 10          	shr    $0x10,%rax
  800420b909:	89 c2                	mov    %eax,%edx
  800420b90b:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b912:	00 00 00 
  800420b915:	66 89 90 b6 02 00 00 	mov    %dx,0x2b6(%rax)
  800420b91c:	48 b8 24 d1 20 04 80 	movabs $0x800420d124,%rax
  800420b923:	00 00 00 
  800420b926:	48 c1 e8 20          	shr    $0x20,%rax
  800420b92a:	89 c2                	mov    %eax,%edx
  800420b92c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b933:	00 00 00 
  800420b936:	89 90 b8 02 00 00    	mov    %edx,0x2b8(%rax)
  800420b93c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b943:	00 00 00 
  800420b946:	c7 80 bc 02 00 00 00 	movl   $0x0,0x2bc(%rax)
  800420b94d:	00 00 00 
    SETGATE(idt[44], 0, GD_KT, jos64_irq44, 0);
  800420b950:	48 b8 2a d1 20 04 80 	movabs $0x800420d12a,%rax
  800420b957:	00 00 00 
  800420b95a:	89 c2                	mov    %eax,%edx
  800420b95c:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b963:	00 00 00 
  800420b966:	66 89 90 c0 02 00 00 	mov    %dx,0x2c0(%rax)
  800420b96d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b974:	00 00 00 
  800420b977:	66 c7 80 c2 02 00 00 	movw   $0x8,0x2c2(%rax)
  800420b97e:	08 00 
  800420b980:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b987:	00 00 00 
  800420b98a:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420b991:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b994:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420b99a:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b9a1:	00 00 00 
  800420b9a4:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420b9ab:	83 e2 07             	and    $0x7,%edx
  800420b9ae:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420b9b4:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b9bb:	00 00 00 
  800420b9be:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b9c5:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b9c8:	83 ca 0e             	or     $0xe,%edx
  800420b9cb:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b9d1:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b9d8:	00 00 00 
  800420b9db:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b9e2:	83 e2 ef             	and    $0xffffffef,%edx
  800420b9e5:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b9eb:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420b9f2:	00 00 00 
  800420b9f5:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b9fc:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b9ff:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420ba05:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ba0c:	00 00 00 
  800420ba0f:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420ba16:	83 ca 80             	or     $0xffffff80,%edx
  800420ba19:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420ba1f:	48 b8 2a d1 20 04 80 	movabs $0x800420d12a,%rax
  800420ba26:	00 00 00 
  800420ba29:	48 c1 e8 10          	shr    $0x10,%rax
  800420ba2d:	89 c2                	mov    %eax,%edx
  800420ba2f:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ba36:	00 00 00 
  800420ba39:	66 89 90 c6 02 00 00 	mov    %dx,0x2c6(%rax)
  800420ba40:	48 b8 2a d1 20 04 80 	movabs $0x800420d12a,%rax
  800420ba47:	00 00 00 
  800420ba4a:	48 c1 e8 20          	shr    $0x20,%rax
  800420ba4e:	89 c2                	mov    %eax,%edx
  800420ba50:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ba57:	00 00 00 
  800420ba5a:	89 90 c8 02 00 00    	mov    %edx,0x2c8(%rax)
  800420ba60:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ba67:	00 00 00 
  800420ba6a:	c7 80 cc 02 00 00 00 	movl   $0x0,0x2cc(%rax)
  800420ba71:	00 00 00 
    SETGATE(idt[45], 0, GD_KT, jos64_irq45, 0);
  800420ba74:	48 b8 30 d1 20 04 80 	movabs $0x800420d130,%rax
  800420ba7b:	00 00 00 
  800420ba7e:	89 c2                	mov    %eax,%edx
  800420ba80:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ba87:	00 00 00 
  800420ba8a:	66 89 90 d0 02 00 00 	mov    %dx,0x2d0(%rax)
  800420ba91:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420ba98:	00 00 00 
  800420ba9b:	66 c7 80 d2 02 00 00 	movw   $0x8,0x2d2(%rax)
  800420baa2:	08 00 
  800420baa4:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420baab:	00 00 00 
  800420baae:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420bab5:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bab8:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420babe:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bac5:	00 00 00 
  800420bac8:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420bacf:	83 e2 07             	and    $0x7,%edx
  800420bad2:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420bad8:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420badf:	00 00 00 
  800420bae2:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420bae9:	83 e2 f0             	and    $0xfffffff0,%edx
  800420baec:	83 ca 0e             	or     $0xe,%edx
  800420baef:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420baf5:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bafc:	00 00 00 
  800420baff:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420bb06:	83 e2 ef             	and    $0xffffffef,%edx
  800420bb09:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420bb0f:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bb16:	00 00 00 
  800420bb19:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420bb20:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bb23:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420bb29:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bb30:	00 00 00 
  800420bb33:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420bb3a:	83 ca 80             	or     $0xffffff80,%edx
  800420bb3d:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420bb43:	48 b8 30 d1 20 04 80 	movabs $0x800420d130,%rax
  800420bb4a:	00 00 00 
  800420bb4d:	48 c1 e8 10          	shr    $0x10,%rax
  800420bb51:	89 c2                	mov    %eax,%edx
  800420bb53:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bb5a:	00 00 00 
  800420bb5d:	66 89 90 d6 02 00 00 	mov    %dx,0x2d6(%rax)
  800420bb64:	48 b8 30 d1 20 04 80 	movabs $0x800420d130,%rax
  800420bb6b:	00 00 00 
  800420bb6e:	48 c1 e8 20          	shr    $0x20,%rax
  800420bb72:	89 c2                	mov    %eax,%edx
  800420bb74:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bb7b:	00 00 00 
  800420bb7e:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%rax)
  800420bb84:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bb8b:	00 00 00 
  800420bb8e:	c7 80 dc 02 00 00 00 	movl   $0x0,0x2dc(%rax)
  800420bb95:	00 00 00 
    SETGATE(idt[46], 0, GD_KT, jos64_irq46, 0);
  800420bb98:	48 b8 36 d1 20 04 80 	movabs $0x800420d136,%rax
  800420bb9f:	00 00 00 
  800420bba2:	89 c2                	mov    %eax,%edx
  800420bba4:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bbab:	00 00 00 
  800420bbae:	66 89 90 e0 02 00 00 	mov    %dx,0x2e0(%rax)
  800420bbb5:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bbbc:	00 00 00 
  800420bbbf:	66 c7 80 e2 02 00 00 	movw   $0x8,0x2e2(%rax)
  800420bbc6:	08 00 
  800420bbc8:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bbcf:	00 00 00 
  800420bbd2:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420bbd9:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bbdc:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420bbe2:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bbe9:	00 00 00 
  800420bbec:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420bbf3:	83 e2 07             	and    $0x7,%edx
  800420bbf6:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420bbfc:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bc03:	00 00 00 
  800420bc06:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420bc0d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bc10:	83 ca 0e             	or     $0xe,%edx
  800420bc13:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420bc19:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bc20:	00 00 00 
  800420bc23:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420bc2a:	83 e2 ef             	and    $0xffffffef,%edx
  800420bc2d:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420bc33:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bc3a:	00 00 00 
  800420bc3d:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420bc44:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bc47:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420bc4d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bc54:	00 00 00 
  800420bc57:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420bc5e:	83 ca 80             	or     $0xffffff80,%edx
  800420bc61:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420bc67:	48 b8 36 d1 20 04 80 	movabs $0x800420d136,%rax
  800420bc6e:	00 00 00 
  800420bc71:	48 c1 e8 10          	shr    $0x10,%rax
  800420bc75:	89 c2                	mov    %eax,%edx
  800420bc77:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bc7e:	00 00 00 
  800420bc81:	66 89 90 e6 02 00 00 	mov    %dx,0x2e6(%rax)
  800420bc88:	48 b8 36 d1 20 04 80 	movabs $0x800420d136,%rax
  800420bc8f:	00 00 00 
  800420bc92:	48 c1 e8 20          	shr    $0x20,%rax
  800420bc96:	89 c2                	mov    %eax,%edx
  800420bc98:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bc9f:	00 00 00 
  800420bca2:	89 90 e8 02 00 00    	mov    %edx,0x2e8(%rax)
  800420bca8:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bcaf:	00 00 00 
  800420bcb2:	c7 80 ec 02 00 00 00 	movl   $0x0,0x2ec(%rax)
  800420bcb9:	00 00 00 
    SETGATE(idt[47], 0, GD_KT, jos64_irq47, 0);
  800420bcbc:	48 b8 3c d1 20 04 80 	movabs $0x800420d13c,%rax
  800420bcc3:	00 00 00 
  800420bcc6:	89 c2                	mov    %eax,%edx
  800420bcc8:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bccf:	00 00 00 
  800420bcd2:	66 89 90 f0 02 00 00 	mov    %dx,0x2f0(%rax)
  800420bcd9:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bce0:	00 00 00 
  800420bce3:	66 c7 80 f2 02 00 00 	movw   $0x8,0x2f2(%rax)
  800420bcea:	08 00 
  800420bcec:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bcf3:	00 00 00 
  800420bcf6:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420bcfd:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bd00:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420bd06:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bd0d:	00 00 00 
  800420bd10:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420bd17:	83 e2 07             	and    $0x7,%edx
  800420bd1a:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420bd20:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bd27:	00 00 00 
  800420bd2a:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420bd31:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bd34:	83 ca 0e             	or     $0xe,%edx
  800420bd37:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420bd3d:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bd44:	00 00 00 
  800420bd47:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420bd4e:	83 e2 ef             	and    $0xffffffef,%edx
  800420bd51:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420bd57:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bd5e:	00 00 00 
  800420bd61:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420bd68:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bd6b:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420bd71:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bd78:	00 00 00 
  800420bd7b:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420bd82:	83 ca 80             	or     $0xffffff80,%edx
  800420bd85:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420bd8b:	48 b8 3c d1 20 04 80 	movabs $0x800420d13c,%rax
  800420bd92:	00 00 00 
  800420bd95:	48 c1 e8 10          	shr    $0x10,%rax
  800420bd99:	89 c2                	mov    %eax,%edx
  800420bd9b:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bda2:	00 00 00 
  800420bda5:	66 89 90 f6 02 00 00 	mov    %dx,0x2f6(%rax)
  800420bdac:	48 b8 3c d1 20 04 80 	movabs $0x800420d13c,%rax
  800420bdb3:	00 00 00 
  800420bdb6:	48 c1 e8 20          	shr    $0x20,%rax
  800420bdba:	89 c2                	mov    %eax,%edx
  800420bdbc:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bdc3:	00 00 00 
  800420bdc6:	89 90 f8 02 00 00    	mov    %edx,0x2f8(%rax)
  800420bdcc:	48 b8 80 02 36 04 80 	movabs $0x8004360280,%rax
  800420bdd3:	00 00 00 
  800420bdd6:	c7 80 fc 02 00 00 00 	movl   $0x0,0x2fc(%rax)
  800420bddd:	00 00 00 

    idt_pd.pd_lim = sizeof(idt)-1;
  800420bde0:	48 b8 80 12 36 04 80 	movabs $0x8004361280,%rax
  800420bde7:	00 00 00 
  800420bdea:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)
    idt_pd.pd_base = (uint64_t)idt;
  800420bdef:	48 ba 80 02 36 04 80 	movabs $0x8004360280,%rdx
  800420bdf6:	00 00 00 
  800420bdf9:	48 b8 80 12 36 04 80 	movabs $0x8004361280,%rax
  800420be00:	00 00 00 
  800420be03:	48 89 50 02          	mov    %rdx,0x2(%rax)
	// Per-CPU setup
	trap_init_percpu();
  800420be07:	48 b8 15 be 20 04 80 	movabs $0x800420be15,%rax
  800420be0e:	00 00 00 
  800420be11:	ff d0                	callq  *%rax
}
  800420be13:	5d                   	pop    %rbp
  800420be14:	c3                   	retq   

000000800420be15 <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  800420be15:	55                   	push   %rbp
  800420be16:	48 89 e5             	mov    %rsp,%rbp
  800420be19:	53                   	push   %rbx
  800420be1a:	48 83 ec 28          	sub    $0x28,%rsp
	// get a triple fault.  If you set up an individual CPU's TSS
	// wrong, you may not get a fault until you try to return from
	// user space on that CPU.
	//
	// LAB 4: Your code here:
	int i = thiscpu->cpu_id;
  800420be1e:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420be25:	00 00 00 
  800420be28:	ff d0                	callq  *%rax
  800420be2a:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420be31:	00 00 00 
  800420be34:	48 98                	cltq   
  800420be36:	48 c1 e0 03          	shl    $0x3,%rax
  800420be3a:	48 89 c2             	mov    %rax,%rdx
  800420be3d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420be41:	48 29 c2             	sub    %rax,%rdx
  800420be44:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420be48:	0f b6 00             	movzbl (%rax),%eax
  800420be4b:	0f b6 c0             	movzbl %al,%eax
  800420be4e:	89 45 ec             	mov    %eax,-0x14(%rbp)
	int pos = i << 4;
  800420be51:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420be54:	c1 e0 04             	shl    $0x4,%eax
  800420be57:	89 45 e8             	mov    %eax,-0x18(%rbp)
	// Setup a TSS so that we get the right stack
	// when we trap to the kernel.
	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);
  800420be5a:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420be61:	00 00 00 
  800420be64:	ff d0                	callq  *%rax
  800420be66:	89 c6                	mov    %eax,%esi
  800420be68:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420be6b:	89 d0                	mov    %edx,%eax
  800420be6d:	01 c0                	add    %eax,%eax
  800420be6f:	01 d0                	add    %edx,%eax
  800420be71:	c1 e0 0f             	shl    $0xf,%eax
  800420be74:	48 98                	cltq   
  800420be76:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420be7d:	00 00 00 
  800420be80:	48 29 c2             	sub    %rax,%rdx
  800420be83:	48 89 d0             	mov    %rdx,%rax
  800420be86:	48 89 c1             	mov    %rax,%rcx
  800420be89:	48 bf 20 30 36 04 80 	movabs $0x8004363020,%rdi
  800420be90:	00 00 00 
  800420be93:	48 63 c6             	movslq %esi,%rax
  800420be96:	48 c1 e0 03          	shl    $0x3,%rax
  800420be9a:	48 89 c2             	mov    %rax,%rdx
  800420be9d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bea1:	48 29 c2             	sub    %rax,%rdx
  800420bea4:	48 8d 04 17          	lea    (%rdi,%rdx,1),%rax
  800420bea8:	48 83 c0 10          	add    $0x10,%rax
  800420beac:	48 89 48 04          	mov    %rcx,0x4(%rax)
	
	// Initialize the TSS slot of the gdt.
	SETTSS((struct SystemSegdesc64 *)((gdt_pd>>16)+40+ pos),STS_T64A, (uint64_t) (&thiscpu->cpu_ts),sizeof(struct Taskstate), 0);
  800420beb0:	48 b8 c8 a6 22 04 80 	movabs $0x800422a6c8,%rax
  800420beb7:	00 00 00 
  800420beba:	48 8b 00             	mov    (%rax),%rax
  800420bebd:	48 c1 f8 10          	sar    $0x10,%rax
  800420bec1:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420bec5:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420bec8:	48 98                	cltq   
  800420beca:	48 01 d0             	add    %rdx,%rax
  800420becd:	66 c7 00 68 00       	movw   $0x68,(%rax)
  800420bed2:	48 b8 c8 a6 22 04 80 	movabs $0x800422a6c8,%rax
  800420bed9:	00 00 00 
  800420bedc:	48 8b 00             	mov    (%rax),%rax
  800420bedf:	48 c1 f8 10          	sar    $0x10,%rax
  800420bee3:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420bee7:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420beea:	48 98                	cltq   
  800420beec:	48 01 d0             	add    %rdx,%rax
  800420beef:	48 89 c3             	mov    %rax,%rbx
  800420bef2:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420bef9:	00 00 00 
  800420befc:	ff d0                	callq  *%rax
  800420befe:	48 98                	cltq   
  800420bf00:	48 c1 e0 03          	shl    $0x3,%rax
  800420bf04:	48 89 c2             	mov    %rax,%rdx
  800420bf07:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bf0b:	48 29 c2             	sub    %rax,%rdx
  800420bf0e:	48 83 c2 10          	add    $0x10,%rdx
  800420bf12:	48 b8 20 30 36 04 80 	movabs $0x8004363020,%rax
  800420bf19:	00 00 00 
  800420bf1c:	48 01 d0             	add    %rdx,%rax
  800420bf1f:	66 89 43 02          	mov    %ax,0x2(%rbx)
  800420bf23:	48 b8 c8 a6 22 04 80 	movabs $0x800422a6c8,%rax
  800420bf2a:	00 00 00 
  800420bf2d:	48 8b 00             	mov    (%rax),%rax
  800420bf30:	48 c1 f8 10          	sar    $0x10,%rax
  800420bf34:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420bf38:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420bf3b:	48 98                	cltq   
  800420bf3d:	48 01 d0             	add    %rdx,%rax
  800420bf40:	48 89 c3             	mov    %rax,%rbx
  800420bf43:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420bf4a:	00 00 00 
  800420bf4d:	ff d0                	callq  *%rax
  800420bf4f:	48 98                	cltq   
  800420bf51:	48 c1 e0 03          	shl    $0x3,%rax
  800420bf55:	48 89 c2             	mov    %rax,%rdx
  800420bf58:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bf5c:	48 29 c2             	sub    %rax,%rdx
  800420bf5f:	48 83 c2 10          	add    $0x10,%rdx
  800420bf63:	48 b8 20 30 36 04 80 	movabs $0x8004363020,%rax
  800420bf6a:	00 00 00 
  800420bf6d:	48 01 d0             	add    %rdx,%rax
  800420bf70:	48 c1 e8 10          	shr    $0x10,%rax
  800420bf74:	88 43 04             	mov    %al,0x4(%rbx)
  800420bf77:	48 b8 c8 a6 22 04 80 	movabs $0x800422a6c8,%rax
  800420bf7e:	00 00 00 
  800420bf81:	48 8b 00             	mov    (%rax),%rax
  800420bf84:	48 c1 f8 10          	sar    $0x10,%rax
  800420bf88:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420bf8c:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420bf8f:	48 98                	cltq   
  800420bf91:	48 01 d0             	add    %rdx,%rax
  800420bf94:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420bf98:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bf9b:	83 ca 09             	or     $0x9,%edx
  800420bf9e:	88 50 05             	mov    %dl,0x5(%rax)
  800420bfa1:	48 b8 c8 a6 22 04 80 	movabs $0x800422a6c8,%rax
  800420bfa8:	00 00 00 
  800420bfab:	48 8b 00             	mov    (%rax),%rax
  800420bfae:	48 c1 f8 10          	sar    $0x10,%rax
  800420bfb2:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420bfb6:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420bfb9:	48 98                	cltq   
  800420bfbb:	48 01 d0             	add    %rdx,%rax
  800420bfbe:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420bfc2:	83 e2 ef             	and    $0xffffffef,%edx
  800420bfc5:	88 50 05             	mov    %dl,0x5(%rax)
  800420bfc8:	48 b8 c8 a6 22 04 80 	movabs $0x800422a6c8,%rax
  800420bfcf:	00 00 00 
  800420bfd2:	48 8b 00             	mov    (%rax),%rax
  800420bfd5:	48 c1 f8 10          	sar    $0x10,%rax
  800420bfd9:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420bfdd:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420bfe0:	48 98                	cltq   
  800420bfe2:	48 01 d0             	add    %rdx,%rax
  800420bfe5:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420bfe9:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bfec:	88 50 05             	mov    %dl,0x5(%rax)
  800420bfef:	48 b8 c8 a6 22 04 80 	movabs $0x800422a6c8,%rax
  800420bff6:	00 00 00 
  800420bff9:	48 8b 00             	mov    (%rax),%rax
  800420bffc:	48 c1 f8 10          	sar    $0x10,%rax
  800420c000:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c004:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420c007:	48 98                	cltq   
  800420c009:	48 01 d0             	add    %rdx,%rax
  800420c00c:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420c010:	83 ca 80             	or     $0xffffff80,%edx
  800420c013:	88 50 05             	mov    %dl,0x5(%rax)
  800420c016:	48 b8 c8 a6 22 04 80 	movabs $0x800422a6c8,%rax
  800420c01d:	00 00 00 
  800420c020:	48 8b 00             	mov    (%rax),%rax
  800420c023:	48 c1 f8 10          	sar    $0x10,%rax
  800420c027:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c02b:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420c02e:	48 98                	cltq   
  800420c030:	48 01 d0             	add    %rdx,%rax
  800420c033:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c037:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c03a:	88 50 06             	mov    %dl,0x6(%rax)
  800420c03d:	48 b8 c8 a6 22 04 80 	movabs $0x800422a6c8,%rax
  800420c044:	00 00 00 
  800420c047:	48 8b 00             	mov    (%rax),%rax
  800420c04a:	48 c1 f8 10          	sar    $0x10,%rax
  800420c04e:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c052:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420c055:	48 98                	cltq   
  800420c057:	48 01 d0             	add    %rdx,%rax
  800420c05a:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c05e:	83 e2 ef             	and    $0xffffffef,%edx
  800420c061:	88 50 06             	mov    %dl,0x6(%rax)
  800420c064:	48 b8 c8 a6 22 04 80 	movabs $0x800422a6c8,%rax
  800420c06b:	00 00 00 
  800420c06e:	48 8b 00             	mov    (%rax),%rax
  800420c071:	48 c1 f8 10          	sar    $0x10,%rax
  800420c075:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c079:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420c07c:	48 98                	cltq   
  800420c07e:	48 01 d0             	add    %rdx,%rax
  800420c081:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c085:	83 e2 9f             	and    $0xffffff9f,%edx
  800420c088:	88 50 06             	mov    %dl,0x6(%rax)
  800420c08b:	48 b8 c8 a6 22 04 80 	movabs $0x800422a6c8,%rax
  800420c092:	00 00 00 
  800420c095:	48 8b 00             	mov    (%rax),%rax
  800420c098:	48 c1 f8 10          	sar    $0x10,%rax
  800420c09c:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c0a0:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420c0a3:	48 98                	cltq   
  800420c0a5:	48 01 d0             	add    %rdx,%rax
  800420c0a8:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c0ac:	83 e2 7f             	and    $0x7f,%edx
  800420c0af:	88 50 06             	mov    %dl,0x6(%rax)
  800420c0b2:	48 b8 c8 a6 22 04 80 	movabs $0x800422a6c8,%rax
  800420c0b9:	00 00 00 
  800420c0bc:	48 8b 00             	mov    (%rax),%rax
  800420c0bf:	48 c1 f8 10          	sar    $0x10,%rax
  800420c0c3:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c0c7:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420c0ca:	48 98                	cltq   
  800420c0cc:	48 01 d0             	add    %rdx,%rax
  800420c0cf:	48 89 c3             	mov    %rax,%rbx
  800420c0d2:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420c0d9:	00 00 00 
  800420c0dc:	ff d0                	callq  *%rax
  800420c0de:	48 98                	cltq   
  800420c0e0:	48 c1 e0 03          	shl    $0x3,%rax
  800420c0e4:	48 89 c2             	mov    %rax,%rdx
  800420c0e7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c0eb:	48 29 c2             	sub    %rax,%rdx
  800420c0ee:	48 83 c2 10          	add    $0x10,%rdx
  800420c0f2:	48 b8 20 30 36 04 80 	movabs $0x8004363020,%rax
  800420c0f9:	00 00 00 
  800420c0fc:	48 01 d0             	add    %rdx,%rax
  800420c0ff:	48 c1 e8 18          	shr    $0x18,%rax
  800420c103:	88 43 07             	mov    %al,0x7(%rbx)
  800420c106:	48 b8 c8 a6 22 04 80 	movabs $0x800422a6c8,%rax
  800420c10d:	00 00 00 
  800420c110:	48 8b 00             	mov    (%rax),%rax
  800420c113:	48 c1 f8 10          	sar    $0x10,%rax
  800420c117:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c11b:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420c11e:	48 98                	cltq   
  800420c120:	48 01 d0             	add    %rdx,%rax
  800420c123:	48 89 c3             	mov    %rax,%rbx
  800420c126:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420c12d:	00 00 00 
  800420c130:	ff d0                	callq  *%rax
  800420c132:	48 98                	cltq   
  800420c134:	48 c1 e0 03          	shl    $0x3,%rax
  800420c138:	48 89 c2             	mov    %rax,%rdx
  800420c13b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c13f:	48 29 c2             	sub    %rax,%rdx
  800420c142:	48 83 c2 10          	add    $0x10,%rdx
  800420c146:	48 b8 20 30 36 04 80 	movabs $0x8004363020,%rax
  800420c14d:	00 00 00 
  800420c150:	48 01 d0             	add    %rdx,%rax
  800420c153:	48 c1 e8 20          	shr    $0x20,%rax
  800420c157:	89 43 08             	mov    %eax,0x8(%rbx)
  800420c15a:	48 b8 c8 a6 22 04 80 	movabs $0x800422a6c8,%rax
  800420c161:	00 00 00 
  800420c164:	48 8b 00             	mov    (%rax),%rax
  800420c167:	48 c1 f8 10          	sar    $0x10,%rax
  800420c16b:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c16f:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420c172:	48 98                	cltq   
  800420c174:	48 01 d0             	add    %rdx,%rax
  800420c177:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  800420c17b:	48 b8 c8 a6 22 04 80 	movabs $0x800422a6c8,%rax
  800420c182:	00 00 00 
  800420c185:	48 8b 00             	mov    (%rax),%rax
  800420c188:	48 c1 f8 10          	sar    $0x10,%rax
  800420c18c:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c190:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420c193:	48 98                	cltq   
  800420c195:	48 01 d0             	add    %rdx,%rax
  800420c198:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  800420c19c:	48 b8 c8 a6 22 04 80 	movabs $0x800422a6c8,%rax
  800420c1a3:	00 00 00 
  800420c1a6:	48 8b 00             	mov    (%rax),%rax
  800420c1a9:	48 c1 f8 10          	sar    $0x10,%rax
  800420c1ad:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c1b1:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420c1b4:	48 98                	cltq   
  800420c1b6:	48 01 d0             	add    %rdx,%rax
  800420c1b9:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)
	// Load the TSS selector (like other segment selectors, the
	// bottom three bits are special; we leave them 0)
	ltr(GD_TSS0 + pos);	
  800420c1bf:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420c1c2:	83 c0 28             	add    $0x28,%eax
  800420c1c5:	0f b7 c0             	movzwl %ax,%eax
  800420c1c8:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)
	__asm __volatile("lgdt (%0)" : : "r" (p));
}
static __inline void
ltr(uint16_t sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
  800420c1cc:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
  800420c1d0:	0f 00 d8             	ltr    %ax
  800420c1d3:	48 b8 80 12 36 04 80 	movabs $0x8004361280,%rax
  800420c1da:	00 00 00 
  800420c1dd:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
}  

static __inline void
lidt(void *p)
{
	__asm __volatile("lidt (%0)" : : "r" (p));
  800420c1e1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c1e5:	0f 01 18             	lidt   (%rax)

	// Load the IDT
	lidt(&idt_pd);
}
  800420c1e8:	48 83 c4 28          	add    $0x28,%rsp
  800420c1ec:	5b                   	pop    %rbx
  800420c1ed:	5d                   	pop    %rbp
  800420c1ee:	c3                   	retq   

000000800420c1ef <print_trapframe>:

void
print_trapframe(struct Trapframe *tf)
{
  800420c1ef:	55                   	push   %rbp
  800420c1f0:	48 89 e5             	mov    %rsp,%rbp
  800420c1f3:	48 83 ec 20          	sub    $0x20,%rsp
  800420c1f7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
  800420c1fb:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420c202:	00 00 00 
  800420c205:	ff d0                	callq  *%rax
  800420c207:	89 c2                	mov    %eax,%edx
  800420c209:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c20d:	48 89 c6             	mov    %rax,%rsi
  800420c210:	48 bf 8e 87 21 04 80 	movabs $0x800421878e,%rdi
  800420c217:	00 00 00 
  800420c21a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c21f:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  800420c226:	00 00 00 
  800420c229:	ff d1                	callq  *%rcx
	print_regs(&tf->tf_regs);
  800420c22b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c22f:	48 89 c7             	mov    %rax,%rdi
  800420c232:	48 b8 00 c5 20 04 80 	movabs $0x800420c500,%rax
  800420c239:	00 00 00 
  800420c23c:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  800420c23e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c242:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800420c246:	0f b7 c0             	movzwl %ax,%eax
  800420c249:	89 c6                	mov    %eax,%esi
  800420c24b:	48 bf ac 87 21 04 80 	movabs $0x80042187ac,%rdi
  800420c252:	00 00 00 
  800420c255:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c25a:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c261:	00 00 00 
  800420c264:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  800420c266:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c26a:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  800420c271:	0f b7 c0             	movzwl %ax,%eax
  800420c274:	89 c6                	mov    %eax,%esi
  800420c276:	48 bf bf 87 21 04 80 	movabs $0x80042187bf,%rdi
  800420c27d:	00 00 00 
  800420c280:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c285:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c28c:	00 00 00 
  800420c28f:	ff d2                	callq  *%rdx
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  800420c291:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c295:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c29c:	89 c7                	mov    %eax,%edi
  800420c29e:	48 b8 2a 97 20 04 80 	movabs $0x800420972a,%rax
  800420c2a5:	00 00 00 
  800420c2a8:	ff d0                	callq  *%rax
  800420c2aa:	48 89 c2             	mov    %rax,%rdx
  800420c2ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c2b1:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c2b8:	48 89 c6             	mov    %rax,%rsi
  800420c2bb:	48 bf d2 87 21 04 80 	movabs $0x80042187d2,%rdi
  800420c2c2:	00 00 00 
  800420c2c5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c2ca:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  800420c2d1:	00 00 00 
  800420c2d4:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  800420c2d6:	48 b8 08 13 36 04 80 	movabs $0x8004361308,%rax
  800420c2dd:	00 00 00 
  800420c2e0:	48 8b 00             	mov    (%rax),%rax
  800420c2e3:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420c2e7:	75 3a                	jne    800420c323 <print_trapframe+0x134>
  800420c2e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c2ed:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c2f4:	48 83 f8 0e          	cmp    $0xe,%rax
  800420c2f8:	75 29                	jne    800420c323 <print_trapframe+0x134>

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420c2fa:	0f 20 d0             	mov    %cr2,%rax
  800420c2fd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return val;
  800420c301:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  800420c305:	48 89 c6             	mov    %rax,%rsi
  800420c308:	48 bf e4 87 21 04 80 	movabs $0x80042187e4,%rdi
  800420c30f:	00 00 00 
  800420c312:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c317:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c31e:	00 00 00 
  800420c321:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  800420c323:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c327:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c32e:	48 89 c6             	mov    %rax,%rsi
  800420c331:	48 bf f3 87 21 04 80 	movabs $0x80042187f3,%rdi
  800420c338:	00 00 00 
  800420c33b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c340:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c347:	00 00 00 
  800420c34a:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  800420c34c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c350:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c357:	48 83 f8 0e          	cmp    $0xe,%rax
  800420c35b:	0f 85 9c 00 00 00    	jne    800420c3fd <print_trapframe+0x20e>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  800420c361:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c365:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c36c:	83 e0 01             	and    $0x1,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420c36f:	48 85 c0             	test   %rax,%rax
  800420c372:	74 0c                	je     800420c380 <print_trapframe+0x191>
  800420c374:	48 b9 01 88 21 04 80 	movabs $0x8004218801,%rcx
  800420c37b:	00 00 00 
  800420c37e:	eb 0a                	jmp    800420c38a <print_trapframe+0x19b>
  800420c380:	48 b9 0c 88 21 04 80 	movabs $0x800421880c,%rcx
  800420c387:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
  800420c38a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c38e:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c395:	83 e0 02             	and    $0x2,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420c398:	48 85 c0             	test   %rax,%rax
  800420c39b:	74 0c                	je     800420c3a9 <print_trapframe+0x1ba>
  800420c39d:	48 ba 18 88 21 04 80 	movabs $0x8004218818,%rdx
  800420c3a4:	00 00 00 
  800420c3a7:	eb 0a                	jmp    800420c3b3 <print_trapframe+0x1c4>
  800420c3a9:	48 ba 1e 88 21 04 80 	movabs $0x800421881e,%rdx
  800420c3b0:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  800420c3b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c3b7:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c3be:	83 e0 04             	and    $0x4,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420c3c1:	48 85 c0             	test   %rax,%rax
  800420c3c4:	74 0c                	je     800420c3d2 <print_trapframe+0x1e3>
  800420c3c6:	48 b8 23 88 21 04 80 	movabs $0x8004218823,%rax
  800420c3cd:	00 00 00 
  800420c3d0:	eb 0a                	jmp    800420c3dc <print_trapframe+0x1ed>
  800420c3d2:	48 b8 28 88 21 04 80 	movabs $0x8004218828,%rax
  800420c3d9:	00 00 00 
  800420c3dc:	48 89 c6             	mov    %rax,%rsi
  800420c3df:	48 bf 2f 88 21 04 80 	movabs $0x800421882f,%rdi
  800420c3e6:	00 00 00 
  800420c3e9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c3ee:	49 b8 11 96 20 04 80 	movabs $0x8004209611,%r8
  800420c3f5:	00 00 00 
  800420c3f8:	41 ff d0             	callq  *%r8
  800420c3fb:	eb 1b                	jmp    800420c418 <print_trapframe+0x229>
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
	else
		cprintf("\n");
  800420c3fd:	48 bf 3e 88 21 04 80 	movabs $0x800421883e,%rdi
  800420c404:	00 00 00 
  800420c407:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c40c:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c413:	00 00 00 
  800420c416:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  800420c418:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c41c:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800420c423:	48 89 c6             	mov    %rax,%rsi
  800420c426:	48 bf 40 88 21 04 80 	movabs $0x8004218840,%rdi
  800420c42d:	00 00 00 
  800420c430:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c435:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c43c:	00 00 00 
  800420c43f:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  800420c441:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c445:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c44c:	0f b7 c0             	movzwl %ax,%eax
  800420c44f:	89 c6                	mov    %eax,%esi
  800420c451:	48 bf 4f 88 21 04 80 	movabs $0x800421884f,%rdi
  800420c458:	00 00 00 
  800420c45b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c460:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c467:	00 00 00 
  800420c46a:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  800420c46c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c470:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420c477:	48 89 c6             	mov    %rax,%rsi
  800420c47a:	48 bf 62 88 21 04 80 	movabs $0x8004218862,%rdi
  800420c481:	00 00 00 
  800420c484:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c489:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c490:	00 00 00 
  800420c493:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  800420c495:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c499:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c4a0:	0f b7 c0             	movzwl %ax,%eax
  800420c4a3:	83 e0 03             	and    $0x3,%eax
  800420c4a6:	85 c0                	test   %eax,%eax
  800420c4a8:	74 54                	je     800420c4fe <print_trapframe+0x30f>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  800420c4aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c4ae:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420c4b5:	48 89 c6             	mov    %rax,%rsi
  800420c4b8:	48 bf 71 88 21 04 80 	movabs $0x8004218871,%rdi
  800420c4bf:	00 00 00 
  800420c4c2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c4c7:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c4ce:	00 00 00 
  800420c4d1:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  800420c4d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c4d7:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  800420c4de:	0f b7 c0             	movzwl %ax,%eax
  800420c4e1:	89 c6                	mov    %eax,%esi
  800420c4e3:	48 bf 80 88 21 04 80 	movabs $0x8004218880,%rdi
  800420c4ea:	00 00 00 
  800420c4ed:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c4f2:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c4f9:	00 00 00 
  800420c4fc:	ff d2                	callq  *%rdx
	}
}
  800420c4fe:	c9                   	leaveq 
  800420c4ff:	c3                   	retq   

000000800420c500 <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  800420c500:	55                   	push   %rbp
  800420c501:	48 89 e5             	mov    %rsp,%rbp
  800420c504:	48 83 ec 10          	sub    $0x10,%rsp
  800420c508:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  800420c50c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c510:	48 8b 00             	mov    (%rax),%rax
  800420c513:	48 89 c6             	mov    %rax,%rsi
  800420c516:	48 bf 93 88 21 04 80 	movabs $0x8004218893,%rdi
  800420c51d:	00 00 00 
  800420c520:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c525:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c52c:	00 00 00 
  800420c52f:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  800420c531:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c535:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420c539:	48 89 c6             	mov    %rax,%rsi
  800420c53c:	48 bf a2 88 21 04 80 	movabs $0x80042188a2,%rdi
  800420c543:	00 00 00 
  800420c546:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c54b:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c552:	00 00 00 
  800420c555:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  800420c557:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c55b:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420c55f:	48 89 c6             	mov    %rax,%rsi
  800420c562:	48 bf b1 88 21 04 80 	movabs $0x80042188b1,%rdi
  800420c569:	00 00 00 
  800420c56c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c571:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c578:	00 00 00 
  800420c57b:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  800420c57d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c581:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420c585:	48 89 c6             	mov    %rax,%rsi
  800420c588:	48 bf c0 88 21 04 80 	movabs $0x80042188c0,%rdi
  800420c58f:	00 00 00 
  800420c592:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c597:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c59e:	00 00 00 
  800420c5a1:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  800420c5a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c5a7:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420c5ab:	48 89 c6             	mov    %rax,%rsi
  800420c5ae:	48 bf cf 88 21 04 80 	movabs $0x80042188cf,%rdi
  800420c5b5:	00 00 00 
  800420c5b8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c5bd:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c5c4:	00 00 00 
  800420c5c7:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  800420c5c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c5cd:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420c5d1:	48 89 c6             	mov    %rax,%rsi
  800420c5d4:	48 bf de 88 21 04 80 	movabs $0x80042188de,%rdi
  800420c5db:	00 00 00 
  800420c5de:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c5e3:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c5ea:	00 00 00 
  800420c5ed:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  800420c5ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c5f3:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420c5f7:	48 89 c6             	mov    %rax,%rsi
  800420c5fa:	48 bf ed 88 21 04 80 	movabs $0x80042188ed,%rdi
  800420c601:	00 00 00 
  800420c604:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c609:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c610:	00 00 00 
  800420c613:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  800420c615:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c619:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420c61d:	48 89 c6             	mov    %rax,%rsi
  800420c620:	48 bf fb 88 21 04 80 	movabs $0x80042188fb,%rdi
  800420c627:	00 00 00 
  800420c62a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c62f:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c636:	00 00 00 
  800420c639:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  800420c63b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c63f:	48 8b 40 48          	mov    0x48(%rax),%rax
  800420c643:	48 89 c6             	mov    %rax,%rsi
  800420c646:	48 bf 09 89 21 04 80 	movabs $0x8004218909,%rdi
  800420c64d:	00 00 00 
  800420c650:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c655:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c65c:	00 00 00 
  800420c65f:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  800420c661:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c665:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420c669:	48 89 c6             	mov    %rax,%rsi
  800420c66c:	48 bf 18 89 21 04 80 	movabs $0x8004218918,%rdi
  800420c673:	00 00 00 
  800420c676:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c67b:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c682:	00 00 00 
  800420c685:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  800420c687:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c68b:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420c68f:	48 89 c6             	mov    %rax,%rsi
  800420c692:	48 bf 27 89 21 04 80 	movabs $0x8004218927,%rdi
  800420c699:	00 00 00 
  800420c69c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c6a1:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c6a8:	00 00 00 
  800420c6ab:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  800420c6ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c6b1:	48 8b 40 68          	mov    0x68(%rax),%rax
  800420c6b5:	48 89 c6             	mov    %rax,%rsi
  800420c6b8:	48 bf 36 89 21 04 80 	movabs $0x8004218936,%rdi
  800420c6bf:	00 00 00 
  800420c6c2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c6c7:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c6ce:	00 00 00 
  800420c6d1:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  800420c6d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c6d7:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420c6db:	48 89 c6             	mov    %rax,%rsi
  800420c6de:	48 bf 45 89 21 04 80 	movabs $0x8004218945,%rdi
  800420c6e5:	00 00 00 
  800420c6e8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c6ed:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c6f4:	00 00 00 
  800420c6f7:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  800420c6f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c6fd:	48 8b 40 60          	mov    0x60(%rax),%rax
  800420c701:	48 89 c6             	mov    %rax,%rsi
  800420c704:	48 bf 54 89 21 04 80 	movabs $0x8004218954,%rdi
  800420c70b:	00 00 00 
  800420c70e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c713:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c71a:	00 00 00 
  800420c71d:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  800420c71f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c723:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420c727:	48 89 c6             	mov    %rax,%rsi
  800420c72a:	48 bf 63 89 21 04 80 	movabs $0x8004218963,%rdi
  800420c731:	00 00 00 
  800420c734:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c739:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c740:	00 00 00 
  800420c743:	ff d2                	callq  *%rdx
}
  800420c745:	c9                   	leaveq 
  800420c746:	c3                   	retq   

000000800420c747 <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  800420c747:	55                   	push   %rbp
  800420c748:	48 89 e5             	mov    %rsp,%rbp
  800420c74b:	48 83 ec 10          	sub    $0x10,%rsp
  800420c74f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// LAB 3: Your code here.

	// Handle clock interrupts. Don't forget to acknowledge the
	// interrupt using lapic_eoi() before calling the scheduler!
	// LAB 4: Your code here.
	if (tf->tf_trapno == IRQ_OFFSET)
  800420c753:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c757:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c75e:	48 83 f8 20          	cmp    $0x20,%rax
  800420c762:	75 18                	jne    800420c77c <trap_dispatch+0x35>
	{
	   lapic_eoi();
  800420c764:	48 b8 f2 6a 21 04 80 	movabs $0x8004216af2,%rax
  800420c76b:	00 00 00 
  800420c76e:	ff d0                	callq  *%rax
	   sched_yield();
  800420c770:	48 b8 61 d2 20 04 80 	movabs $0x800420d261,%rax
  800420c777:	00 00 00 
  800420c77a:	ff d0                	callq  *%rax
	

	// Handle spurious interrupts
	// The hardware sometimes raises these because of noise on the
	// IRQ line or other reasons. We don't care.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
  800420c77c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c780:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c787:	48 83 f8 27          	cmp    $0x27,%rax
  800420c78b:	75 33                	jne    800420c7c0 <trap_dispatch+0x79>
		cprintf("Spurious interrupt on irq 7\n");
  800420c78d:	48 bf 72 89 21 04 80 	movabs $0x8004218972,%rdi
  800420c794:	00 00 00 
  800420c797:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c79c:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420c7a3:	00 00 00 
  800420c7a6:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420c7a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c7ac:	48 89 c7             	mov    %rax,%rdi
  800420c7af:	48 b8 ef c1 20 04 80 	movabs $0x800420c1ef,%rax
  800420c7b6:	00 00 00 
  800420c7b9:	ff d0                	callq  *%rax
		return;
  800420c7bb:	e9 44 01 00 00       	jmpq   800420c904 <trap_dispatch+0x1bd>
	}

        //cprintf("\nDispatch %d\n", tf->tf_trapno);

        if(tf->tf_trapno == T_PGFLT)
  800420c7c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c7c4:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c7cb:	48 83 f8 0e          	cmp    $0xe,%rax
  800420c7cf:	75 18                	jne    800420c7e9 <trap_dispatch+0xa2>
	  {
	   //cprintf("\nSending to page fault\n");
           page_fault_handler(tf);
  800420c7d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c7d5:	48 89 c7             	mov    %rax,%rdi
  800420c7d8:	48 b8 70 cc 20 04 80 	movabs $0x800420cc70,%rax
  800420c7df:	00 00 00 
  800420c7e2:	ff d0                	callq  *%rax
 	   return;
  800420c7e4:	e9 1b 01 00 00       	jmpq   800420c904 <trap_dispatch+0x1bd>
	  }

        else if(tf->tf_trapno == T_BRKPT)
  800420c7e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c7ed:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c7f4:	48 83 f8 03          	cmp    $0x3,%rax
  800420c7f8:	75 15                	jne    800420c80f <trap_dispatch+0xc8>
	{
	  //cprintf("\n \n in breakpoint \n");
	   monitor(tf);
  800420c7fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c7fe:	48 89 c7             	mov    %rax,%rdi
  800420c801:	48 b8 3c 22 20 04 80 	movabs $0x800420223c,%rax
  800420c808:	00 00 00 
  800420c80b:	ff d0                	callq  *%rax
  800420c80d:	eb 66                	jmp    800420c875 <trap_dispatch+0x12e>
	  // cprintf("\n \n return from monitor \n");
	   
	}
	else if(tf->tf_trapno == T_SYSCALL)
  800420c80f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c813:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c81a:	48 83 f8 30          	cmp    $0x30,%rax
  800420c81e:	75 55                	jne    800420c875 <trap_dispatch+0x12e>
	{
	  //cprintf("\nSending to sys call\n");
          tf->tf_regs.reg_rax = syscall(tf->tf_regs.reg_rax,tf->tf_regs.reg_rdx,tf->tf_regs.reg_rcx,tf->tf_regs.reg_rbx,tf->tf_regs.reg_rdi,tf->tf_regs.reg_rsi);
  800420c820:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c824:	4c 8b 40 40          	mov    0x40(%rax),%r8
  800420c828:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c82c:	48 8b 78 48          	mov    0x48(%rax),%rdi
  800420c830:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c834:	48 8b 48 68          	mov    0x68(%rax),%rcx
  800420c838:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c83c:	48 8b 50 60          	mov    0x60(%rax),%rdx
  800420c840:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c844:	48 8b 70 58          	mov    0x58(%rax),%rsi
  800420c848:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c84c:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420c850:	4d 89 c1             	mov    %r8,%r9
  800420c853:	49 89 f8             	mov    %rdi,%r8
  800420c856:	48 89 c7             	mov    %rax,%rdi
  800420c859:	48 b8 80 e1 20 04 80 	movabs $0x800420e180,%rax
  800420c860:	00 00 00 
  800420c863:	ff d0                	callq  *%rax
  800420c865:	48 89 c2             	mov    %rax,%rdx
  800420c868:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c86c:	48 89 50 70          	mov    %rdx,0x70(%rax)
          return;
  800420c870:	e9 8f 00 00 00       	jmpq   800420c904 <trap_dispatch+0x1bd>
	}	
	// Unexpected trap: The user process or the kernel has a bug.
	
         print_trapframe(tf);
  800420c875:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c879:	48 89 c7             	mov    %rax,%rdi
  800420c87c:	48 b8 ef c1 20 04 80 	movabs $0x800420c1ef,%rax
  800420c883:	00 00 00 
  800420c886:	ff d0                	callq  *%rax
	   
	 if (tf->tf_cs == GD_KT)
  800420c888:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c88c:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c893:	66 83 f8 08          	cmp    $0x8,%ax
  800420c897:	75 2a                	jne    800420c8c3 <trap_dispatch+0x17c>
	 	panic("unhandled trap in kernel");
  800420c899:	48 ba 8f 89 21 04 80 	movabs $0x800421898f,%rdx
  800420c8a0:	00 00 00 
  800420c8a3:	be 0f 01 00 00       	mov    $0x10f,%esi
  800420c8a8:	48 bf a8 89 21 04 80 	movabs $0x80042189a8,%rdi
  800420c8af:	00 00 00 
  800420c8b2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c8b7:	48 b9 0b 05 20 04 80 	movabs $0x800420050b,%rcx
  800420c8be:	00 00 00 
  800420c8c1:	ff d1                	callq  *%rcx
	 else {
	 	env_destroy(curenv);
  800420c8c3:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420c8ca:	00 00 00 
  800420c8cd:	ff d0                	callq  *%rax
  800420c8cf:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420c8d6:	00 00 00 
  800420c8d9:	48 98                	cltq   
  800420c8db:	48 c1 e0 03          	shl    $0x3,%rax
  800420c8df:	48 89 c2             	mov    %rax,%rdx
  800420c8e2:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c8e6:	48 29 c2             	sub    %rax,%rdx
  800420c8e9:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c8ed:	48 83 c0 08          	add    $0x8,%rax
  800420c8f1:	48 8b 00             	mov    (%rax),%rax
  800420c8f4:	48 89 c7             	mov    %rax,%rdi
  800420c8f7:	48 b8 fe 8e 20 04 80 	movabs $0x8004208efe,%rax
  800420c8fe:	00 00 00 
  800420c901:	ff d0                	callq  *%rax
		return;
  800420c903:	90                   	nop
	 }
	
	
}
  800420c904:	c9                   	leaveq 
  800420c905:	c3                   	retq   

000000800420c906 <trap>:

void
trap(struct Trapframe *tf)
{
  800420c906:	55                   	push   %rbp
  800420c907:	48 89 e5             	mov    %rsp,%rbp
  800420c90a:	48 83 ec 20          	sub    $0x20,%rsp
  800420c90e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    //struct Trapframe *tf = &tf_;
	// The environment may have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  800420c912:	fc                   	cld    

	// Halt the CPU if some other CPU has called panic()
	extern char *panicstr;
	if (panicstr)
  800420c913:	48 b8 90 17 36 04 80 	movabs $0x8004361790,%rax
  800420c91a:	00 00 00 
  800420c91d:	48 8b 00             	mov    (%rax),%rax
  800420c920:	48 85 c0             	test   %rax,%rax
  800420c923:	74 01                	je     800420c926 <trap+0x20>
		asm volatile("hlt");
  800420c925:	f4                   	hlt    

	// Re-acqurie the big kernel lock if we were halted in
	// sched_yield()
	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
  800420c926:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420c92d:	00 00 00 
  800420c930:	ff d0                	callq  *%rax
  800420c932:	48 98                	cltq   
  800420c934:	48 c1 e0 03          	shl    $0x3,%rax
  800420c938:	48 89 c2             	mov    %rax,%rdx
  800420c93b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c93f:	48 29 c2             	sub    %rax,%rdx
  800420c942:	48 b8 20 30 36 04 80 	movabs $0x8004363020,%rax
  800420c949:	00 00 00 
  800420c94c:	48 01 d0             	add    %rdx,%rax
  800420c94f:	48 83 c0 04          	add    $0x4,%rax
  800420c953:	be 01 00 00 00       	mov    $0x1,%esi
  800420c958:	48 89 c7             	mov    %rax,%rdi
  800420c95b:	48 b8 e9 96 20 04 80 	movabs $0x80042096e9,%rax
  800420c962:	00 00 00 
  800420c965:	ff d0                	callq  *%rax
  800420c967:	83 f8 02             	cmp    $0x2,%eax
  800420c96a:	75 0c                	jne    800420c978 <trap+0x72>
		lock_kernel();
  800420c96c:	48 b8 0e 97 20 04 80 	movabs $0x800420970e,%rax
  800420c973:	00 00 00 
  800420c976:	ff d0                	callq  *%rax

static __inline uint64_t
read_eflags(void)
{
        uint64_t rflags;
        __asm __volatile("pushfq; popq %0" : "=r" (rflags));
  800420c978:	9c                   	pushfq 
  800420c979:	58                   	pop    %rax
  800420c97a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        return rflags;
  800420c97e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  800420c982:	25 00 02 00 00       	and    $0x200,%eax
  800420c987:	48 85 c0             	test   %rax,%rax
  800420c98a:	74 35                	je     800420c9c1 <trap+0xbb>
  800420c98c:	48 b9 b4 89 21 04 80 	movabs $0x80042189b4,%rcx
  800420c993:	00 00 00 
  800420c996:	48 ba cd 89 21 04 80 	movabs $0x80042189cd,%rdx
  800420c99d:	00 00 00 
  800420c9a0:	be 2c 01 00 00       	mov    $0x12c,%esi
  800420c9a5:	48 bf a8 89 21 04 80 	movabs $0x80042189a8,%rdi
  800420c9ac:	00 00 00 
  800420c9af:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c9b4:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420c9bb:	00 00 00 
  800420c9be:	41 ff d0             	callq  *%r8

	if ((tf->tf_cs & 3) == 3) {
  800420c9c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c9c5:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c9cc:	0f b7 c0             	movzwl %ax,%eax
  800420c9cf:	83 e0 03             	and    $0x3,%eax
  800420c9d2:	83 f8 03             	cmp    $0x3,%eax
  800420c9d5:	0f 85 b3 01 00 00    	jne    800420cb8e <trap+0x288>
		// Trapped from user mode.
		// Acquire the big kernel lock before doing any
		// serious kernel work.
		// LAB 4: Your code here.
		lock_kernel();
  800420c9db:	48 b8 0e 97 20 04 80 	movabs $0x800420970e,%rax
  800420c9e2:	00 00 00 
  800420c9e5:	ff d0                	callq  *%rax
		//cprintf("\nIncoming TRAP frame at %p\n", tf);
		assert(curenv);
  800420c9e7:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420c9ee:	00 00 00 
  800420c9f1:	ff d0                	callq  *%rax
  800420c9f3:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420c9fa:	00 00 00 
  800420c9fd:	48 98                	cltq   
  800420c9ff:	48 c1 e0 03          	shl    $0x3,%rax
  800420ca03:	48 89 c2             	mov    %rax,%rdx
  800420ca06:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ca0a:	48 29 c2             	sub    %rax,%rdx
  800420ca0d:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ca11:	48 83 c0 08          	add    $0x8,%rax
  800420ca15:	48 8b 00             	mov    (%rax),%rax
  800420ca18:	48 85 c0             	test   %rax,%rax
  800420ca1b:	75 35                	jne    800420ca52 <trap+0x14c>
  800420ca1d:	48 b9 e2 89 21 04 80 	movabs $0x80042189e2,%rcx
  800420ca24:	00 00 00 
  800420ca27:	48 ba cd 89 21 04 80 	movabs $0x80042189cd,%rdx
  800420ca2e:	00 00 00 
  800420ca31:	be 35 01 00 00       	mov    $0x135,%esi
  800420ca36:	48 bf a8 89 21 04 80 	movabs $0x80042189a8,%rdi
  800420ca3d:	00 00 00 
  800420ca40:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ca45:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420ca4c:	00 00 00 
  800420ca4f:	41 ff d0             	callq  *%r8

		// Garbage collect if current enviroment is a zombie
		if (curenv->env_status == ENV_DYING) {
  800420ca52:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420ca59:	00 00 00 
  800420ca5c:	ff d0                	callq  *%rax
  800420ca5e:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420ca65:	00 00 00 
  800420ca68:	48 98                	cltq   
  800420ca6a:	48 c1 e0 03          	shl    $0x3,%rax
  800420ca6e:	48 89 c2             	mov    %rax,%rdx
  800420ca71:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ca75:	48 29 c2             	sub    %rax,%rdx
  800420ca78:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ca7c:	48 83 c0 08          	add    $0x8,%rax
  800420ca80:	48 8b 00             	mov    (%rax),%rax
  800420ca83:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420ca89:	83 f8 01             	cmp    $0x1,%eax
  800420ca8c:	0f 85 81 00 00 00    	jne    800420cb13 <trap+0x20d>
			env_free(curenv);
  800420ca92:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420ca99:	00 00 00 
  800420ca9c:	ff d0                	callq  *%rax
  800420ca9e:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420caa5:	00 00 00 
  800420caa8:	48 98                	cltq   
  800420caaa:	48 c1 e0 03          	shl    $0x3,%rax
  800420caae:	48 89 c2             	mov    %rax,%rdx
  800420cab1:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cab5:	48 29 c2             	sub    %rax,%rdx
  800420cab8:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cabc:	48 83 c0 08          	add    $0x8,%rax
  800420cac0:	48 8b 00             	mov    (%rax),%rax
  800420cac3:	48 89 c7             	mov    %rax,%rdi
  800420cac6:	48 b8 c2 89 20 04 80 	movabs $0x80042089c2,%rax
  800420cacd:	00 00 00 
  800420cad0:	ff d0                	callq  *%rax
			curenv = NULL;
  800420cad2:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420cad9:	00 00 00 
  800420cadc:	ff d0                	callq  *%rax
  800420cade:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420cae5:	00 00 00 
  800420cae8:	48 98                	cltq   
  800420caea:	48 c1 e0 03          	shl    $0x3,%rax
  800420caee:	48 89 c2             	mov    %rax,%rdx
  800420caf1:	48 c1 e2 04          	shl    $0x4,%rdx
  800420caf5:	48 29 c2             	sub    %rax,%rdx
  800420caf8:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cafc:	48 83 c0 08          	add    $0x8,%rax
  800420cb00:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			sched_yield();
  800420cb07:	48 b8 61 d2 20 04 80 	movabs $0x800420d261,%rax
  800420cb0e:	00 00 00 
  800420cb11:	ff d0                	callq  *%rax
		}

		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  800420cb13:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420cb1a:	00 00 00 
  800420cb1d:	ff d0                	callq  *%rax
  800420cb1f:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420cb26:	00 00 00 
  800420cb29:	48 98                	cltq   
  800420cb2b:	48 c1 e0 03          	shl    $0x3,%rax
  800420cb2f:	48 89 c2             	mov    %rax,%rdx
  800420cb32:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cb36:	48 29 c2             	sub    %rax,%rdx
  800420cb39:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cb3d:	48 83 c0 08          	add    $0x8,%rax
  800420cb41:	48 8b 10             	mov    (%rax),%rdx
  800420cb44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb48:	48 89 c6             	mov    %rax,%rsi
  800420cb4b:	b8 18 00 00 00       	mov    $0x18,%eax
  800420cb50:	48 89 d7             	mov    %rdx,%rdi
  800420cb53:	48 89 c1             	mov    %rax,%rcx
  800420cb56:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  800420cb59:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420cb60:	00 00 00 
  800420cb63:	ff d0                	callq  *%rax
  800420cb65:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420cb6c:	00 00 00 
  800420cb6f:	48 98                	cltq   
  800420cb71:	48 c1 e0 03          	shl    $0x3,%rax
  800420cb75:	48 89 c2             	mov    %rax,%rdx
  800420cb78:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cb7c:	48 29 c2             	sub    %rax,%rdx
  800420cb7f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cb83:	48 83 c0 08          	add    $0x8,%rax
  800420cb87:	48 8b 00             	mov    (%rax),%rax
  800420cb8a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}
	
	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  800420cb8e:	48 b8 08 13 36 04 80 	movabs $0x8004361308,%rax
  800420cb95:	00 00 00 
  800420cb98:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cb9c:	48 89 10             	mov    %rdx,(%rax)

	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  800420cb9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cba3:	48 89 c7             	mov    %rax,%rdi
  800420cba6:	48 b8 47 c7 20 04 80 	movabs $0x800420c747,%rax
  800420cbad:	00 00 00 
  800420cbb0:	ff d0                	callq  *%rax

	// If we made it to this point, then no other environment was
	// scheduled, so we should return to the current environment
	// if doing so makes sense.
	if (curenv && curenv->env_status == ENV_RUNNING)
  800420cbb2:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420cbb9:	00 00 00 
  800420cbbc:	ff d0                	callq  *%rax
  800420cbbe:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420cbc5:	00 00 00 
  800420cbc8:	48 98                	cltq   
  800420cbca:	48 c1 e0 03          	shl    $0x3,%rax
  800420cbce:	48 89 c2             	mov    %rax,%rdx
  800420cbd1:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cbd5:	48 29 c2             	sub    %rax,%rdx
  800420cbd8:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cbdc:	48 83 c0 08          	add    $0x8,%rax
  800420cbe0:	48 8b 00             	mov    (%rax),%rax
  800420cbe3:	48 85 c0             	test   %rax,%rax
  800420cbe6:	74 7c                	je     800420cc64 <trap+0x35e>
  800420cbe8:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420cbef:	00 00 00 
  800420cbf2:	ff d0                	callq  *%rax
  800420cbf4:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420cbfb:	00 00 00 
  800420cbfe:	48 98                	cltq   
  800420cc00:	48 c1 e0 03          	shl    $0x3,%rax
  800420cc04:	48 89 c2             	mov    %rax,%rdx
  800420cc07:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cc0b:	48 29 c2             	sub    %rax,%rdx
  800420cc0e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cc12:	48 83 c0 08          	add    $0x8,%rax
  800420cc16:	48 8b 00             	mov    (%rax),%rax
  800420cc19:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420cc1f:	83 f8 03             	cmp    $0x3,%eax
  800420cc22:	75 40                	jne    800420cc64 <trap+0x35e>
		env_run(curenv);
  800420cc24:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420cc2b:	00 00 00 
  800420cc2e:	ff d0                	callq  *%rax
  800420cc30:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420cc37:	00 00 00 
  800420cc3a:	48 98                	cltq   
  800420cc3c:	48 c1 e0 03          	shl    $0x3,%rax
  800420cc40:	48 89 c2             	mov    %rax,%rdx
  800420cc43:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cc47:	48 29 c2             	sub    %rax,%rdx
  800420cc4a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cc4e:	48 83 c0 08          	add    $0x8,%rax
  800420cc52:	48 8b 00             	mov    (%rax),%rax
  800420cc55:	48 89 c7             	mov    %rax,%rdi
  800420cc58:	48 b8 cd 90 20 04 80 	movabs $0x80042090cd,%rax
  800420cc5f:	00 00 00 
  800420cc62:	ff d0                	callq  *%rax
	else
		sched_yield();
  800420cc64:	48 b8 61 d2 20 04 80 	movabs $0x800420d261,%rax
  800420cc6b:	00 00 00 
  800420cc6e:	ff d0                	callq  *%rax

000000800420cc70 <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  800420cc70:	55                   	push   %rbp
  800420cc71:	48 89 e5             	mov    %rsp,%rbp
  800420cc74:	53                   	push   %rbx
  800420cc75:	48 83 ec 38          	sub    $0x38,%rsp
  800420cc79:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420cc7d:	0f 20 d0             	mov    %cr2,%rax
  800420cc80:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	return val;
  800420cc84:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
	uint64_t fault_va;
	//cprintf("\ninside page fault\n");
	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  800420cc88:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	// Handle kernel-mode page faults.

	// LAB 3: Your code here.
	if((tf->tf_cs & 0x3) == 0)
  800420cc8c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cc90:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420cc97:	0f b7 c0             	movzwl %ax,%eax
  800420cc9a:	83 e0 03             	and    $0x3,%eax
  800420cc9d:	85 c0                	test   %eax,%eax
  800420cc9f:	0f 85 91 00 00 00    	jne    800420cd36 <page_fault_handler+0xc6>
	{
	  //cprintf("\ninside kernel mode call read\n");
	  cprintf("[%08x] kernel page fault va %08x ip %08x\n", curenv->env_id, fault_va, tf->tf_rip);
  800420cca5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cca9:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
  800420ccb0:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420ccb7:	00 00 00 
  800420ccba:	ff d0                	callq  *%rax
  800420ccbc:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420ccc3:	00 00 00 
  800420ccc6:	48 98                	cltq   
  800420ccc8:	48 c1 e0 03          	shl    $0x3,%rax
  800420cccc:	48 89 c2             	mov    %rax,%rdx
  800420cccf:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ccd3:	48 29 c2             	sub    %rax,%rdx
  800420ccd6:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ccda:	48 83 c0 08          	add    $0x8,%rax
  800420ccde:	48 8b 00             	mov    (%rax),%rax
  800420cce1:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420cce7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cceb:	48 89 d9             	mov    %rbx,%rcx
  800420ccee:	89 c6                	mov    %eax,%esi
  800420ccf0:	48 bf f0 89 21 04 80 	movabs $0x80042189f0,%rdi
  800420ccf7:	00 00 00 
  800420ccfa:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ccff:	49 b8 11 96 20 04 80 	movabs $0x8004209611,%r8
  800420cd06:	00 00 00 
  800420cd09:	41 ff d0             	callq  *%r8
	  panic("Trap has been called at kernel level \n"); 
  800420cd0c:	48 ba 20 8a 21 04 80 	movabs $0x8004218a20,%rdx
  800420cd13:	00 00 00 
  800420cd16:	be 65 01 00 00       	mov    $0x165,%esi
  800420cd1b:	48 bf a8 89 21 04 80 	movabs $0x80042189a8,%rdi
  800420cd22:	00 00 00 
  800420cd25:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cd2a:	48 b9 0b 05 20 04 80 	movabs $0x800420050b,%rcx
  800420cd31:	00 00 00 
  800420cd34:	ff d1                	callq  *%rcx
	//   To change what the user environment runs, modify 'curenv->env_tf'
	//   (the 'tf' variable points at 'curenv->env_tf').

	// LAB 4: Your code here.
	 struct UTrapframe * uxtf;
	 if(curenv->env_pgfault_upcall)
  800420cd36:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420cd3d:	00 00 00 
  800420cd40:	ff d0                	callq  *%rax
  800420cd42:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420cd49:	00 00 00 
  800420cd4c:	48 98                	cltq   
  800420cd4e:	48 c1 e0 03          	shl    $0x3,%rax
  800420cd52:	48 89 c2             	mov    %rax,%rdx
  800420cd55:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cd59:	48 29 c2             	sub    %rax,%rdx
  800420cd5c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cd60:	48 83 c0 08          	add    $0x8,%rax
  800420cd64:	48 8b 00             	mov    (%rax),%rax
  800420cd67:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420cd6e:	48 85 c0             	test   %rax,%rax
  800420cd71:	0f 84 0f 02 00 00    	je     800420cf86 <page_fault_handler+0x316>
	 {
	   if(tf->tf_rsp < UXSTACKTOP && tf->tf_rsp >= UXSTACKTOP-PGSIZE)
  800420cd77:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cd7b:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420cd82:	b8 ff ff 7f ef       	mov    $0xef7fffff,%eax
  800420cd87:	48 39 c2             	cmp    %rax,%rdx
  800420cd8a:	77 2c                	ja     800420cdb8 <page_fault_handler+0x148>
  800420cd8c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cd90:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420cd97:	b8 ff ef 7f ef       	mov    $0xef7fefff,%eax
  800420cd9c:	48 39 c2             	cmp    %rax,%rdx
  800420cd9f:	76 17                	jbe    800420cdb8 <page_fault_handler+0x148>
	     uxtf = (struct UTrapframe *)(tf->tf_rsp - sizeof(struct UTrapframe)-8);
  800420cda1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cda5:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420cdac:	48 2d a8 00 00 00    	sub    $0xa8,%rax
  800420cdb2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420cdb6:	eb 09                	jmp    800420cdc1 <page_fault_handler+0x151>
	   else
	     uxtf = (struct UTrapframe *)(UXSTACKTOP - sizeof(struct UTrapframe));
  800420cdb8:	b8 60 ff 7f ef       	mov    $0xef7fff60,%eax
  800420cdbd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	   //Important
	  user_mem_assert(curenv,(void *)uxtf,sizeof(struct UTrapframe),PTE_W |PTE_U| PTE_P);
  800420cdc1:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420cdc8:	00 00 00 
  800420cdcb:	ff d0                	callq  *%rax
  800420cdcd:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420cdd4:	00 00 00 
  800420cdd7:	48 98                	cltq   
  800420cdd9:	48 c1 e0 03          	shl    $0x3,%rax
  800420cddd:	48 89 c2             	mov    %rax,%rdx
  800420cde0:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cde4:	48 29 c2             	sub    %rax,%rdx
  800420cde7:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cdeb:	48 83 c0 08          	add    $0x8,%rax
  800420cdef:	48 8b 00             	mov    (%rax),%rax
  800420cdf2:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420cdf6:	b9 07 00 00 00       	mov    $0x7,%ecx
  800420cdfb:	ba a0 00 00 00       	mov    $0xa0,%edx
  800420ce00:	48 89 c7             	mov    %rax,%rdi
  800420ce03:	48 b8 8d 42 20 04 80 	movabs $0x800420428d,%rax
  800420ce0a:	00 00 00 
  800420ce0d:	ff d0                	callq  *%rax

	  uxtf->utf_rsp = tf->tf_rsp;
  800420ce0f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ce13:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420ce1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ce1e:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	  uxtf->utf_eflags = tf->tf_eflags;
  800420ce25:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ce29:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  800420ce30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ce34:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
	  uxtf->utf_rip = tf->tf_rip;
  800420ce3b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ce3f:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800420ce46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ce4a:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
	  uxtf->utf_regs = tf->tf_regs;
  800420ce51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ce55:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420ce59:	48 8b 0a             	mov    (%rdx),%rcx
  800420ce5c:	48 89 48 10          	mov    %rcx,0x10(%rax)
  800420ce60:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420ce64:	48 89 48 18          	mov    %rcx,0x18(%rax)
  800420ce68:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  800420ce6c:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420ce70:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  800420ce74:	48 89 48 28          	mov    %rcx,0x28(%rax)
  800420ce78:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  800420ce7c:	48 89 48 30          	mov    %rcx,0x30(%rax)
  800420ce80:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
  800420ce84:	48 89 48 38          	mov    %rcx,0x38(%rax)
  800420ce88:	48 8b 4a 30          	mov    0x30(%rdx),%rcx
  800420ce8c:	48 89 48 40          	mov    %rcx,0x40(%rax)
  800420ce90:	48 8b 4a 38          	mov    0x38(%rdx),%rcx
  800420ce94:	48 89 48 48          	mov    %rcx,0x48(%rax)
  800420ce98:	48 8b 4a 40          	mov    0x40(%rdx),%rcx
  800420ce9c:	48 89 48 50          	mov    %rcx,0x50(%rax)
  800420cea0:	48 8b 4a 48          	mov    0x48(%rdx),%rcx
  800420cea4:	48 89 48 58          	mov    %rcx,0x58(%rax)
  800420cea8:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
  800420ceac:	48 89 48 60          	mov    %rcx,0x60(%rax)
  800420ceb0:	48 8b 4a 58          	mov    0x58(%rdx),%rcx
  800420ceb4:	48 89 48 68          	mov    %rcx,0x68(%rax)
  800420ceb8:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
  800420cebc:	48 89 48 70          	mov    %rcx,0x70(%rax)
  800420cec0:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
  800420cec4:	48 89 48 78          	mov    %rcx,0x78(%rax)
  800420cec8:	48 8b 52 70          	mov    0x70(%rdx),%rdx
  800420cecc:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
	  uxtf->utf_err = tf->tf_err;
  800420ced3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ced7:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
  800420cede:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cee2:	48 89 50 08          	mov    %rdx,0x8(%rax)
	  uxtf->utf_fault_va = fault_va;
  800420cee6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ceea:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420ceee:	48 89 10             	mov    %rdx,(%rax)

	  tf->tf_rsp = (uintptr_t)uxtf;
  800420cef1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cef5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cef9:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
	  tf->tf_rip = (uintptr_t)curenv->env_pgfault_upcall;	
  800420cf00:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420cf07:	00 00 00 
  800420cf0a:	ff d0                	callq  *%rax
  800420cf0c:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420cf13:	00 00 00 
  800420cf16:	48 98                	cltq   
  800420cf18:	48 c1 e0 03          	shl    $0x3,%rax
  800420cf1c:	48 89 c2             	mov    %rax,%rdx
  800420cf1f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cf23:	48 29 c2             	sub    %rax,%rdx
  800420cf26:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cf2a:	48 83 c0 08          	add    $0x8,%rax
  800420cf2e:	48 8b 00             	mov    (%rax),%rax
  800420cf31:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420cf38:	48 89 c2             	mov    %rax,%rdx
  800420cf3b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cf3f:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	  env_run(curenv);
  800420cf46:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420cf4d:	00 00 00 
  800420cf50:	ff d0                	callq  *%rax
  800420cf52:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420cf59:	00 00 00 
  800420cf5c:	48 98                	cltq   
  800420cf5e:	48 c1 e0 03          	shl    $0x3,%rax
  800420cf62:	48 89 c2             	mov    %rax,%rdx
  800420cf65:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cf69:	48 29 c2             	sub    %rax,%rdx
  800420cf6c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cf70:	48 83 c0 08          	add    $0x8,%rax
  800420cf74:	48 8b 00             	mov    (%rax),%rax
  800420cf77:	48 89 c7             	mov    %rax,%rdi
  800420cf7a:	48 b8 cd 90 20 04 80 	movabs $0x80042090cd,%rax
  800420cf81:	00 00 00 
  800420cf84:	ff d0                	callq  *%rax
	 }	
	else
	{
	  cprintf("[%08x] user fault va %08x ip %08x\n", curenv->env_id, fault_va, tf->tf_rip);
  800420cf86:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cf8a:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
  800420cf91:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420cf98:	00 00 00 
  800420cf9b:	ff d0                	callq  *%rax
  800420cf9d:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420cfa4:	00 00 00 
  800420cfa7:	48 98                	cltq   
  800420cfa9:	48 c1 e0 03          	shl    $0x3,%rax
  800420cfad:	48 89 c2             	mov    %rax,%rdx
  800420cfb0:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cfb4:	48 29 c2             	sub    %rax,%rdx
  800420cfb7:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cfbb:	48 83 c0 08          	add    $0x8,%rax
  800420cfbf:	48 8b 00             	mov    (%rax),%rax
  800420cfc2:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420cfc8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cfcc:	48 89 d9             	mov    %rbx,%rcx
  800420cfcf:	89 c6                	mov    %eax,%esi
  800420cfd1:	48 bf 48 8a 21 04 80 	movabs $0x8004218a48,%rdi
  800420cfd8:	00 00 00 
  800420cfdb:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cfe0:	49 b8 11 96 20 04 80 	movabs $0x8004209611,%r8
  800420cfe7:	00 00 00 
  800420cfea:	41 ff d0             	callq  *%r8
	  print_trapframe(tf);
  800420cfed:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cff1:	48 89 c7             	mov    %rax,%rdi
  800420cff4:	48 b8 ef c1 20 04 80 	movabs $0x800420c1ef,%rax
  800420cffb:	00 00 00 
  800420cffe:	ff d0                	callq  *%rax
	  env_destroy(curenv);
  800420d000:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420d007:	00 00 00 
  800420d00a:	ff d0                	callq  *%rax
  800420d00c:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420d013:	00 00 00 
  800420d016:	48 98                	cltq   
  800420d018:	48 c1 e0 03          	shl    $0x3,%rax
  800420d01c:	48 89 c2             	mov    %rax,%rdx
  800420d01f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d023:	48 29 c2             	sub    %rax,%rdx
  800420d026:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d02a:	48 83 c0 08          	add    $0x8,%rax
  800420d02e:	48 8b 00             	mov    (%rax),%rax
  800420d031:	48 89 c7             	mov    %rax,%rdi
  800420d034:	48 b8 fe 8e 20 04 80 	movabs $0x8004208efe,%rax
  800420d03b:	00 00 00 
  800420d03e:	ff d0                	callq  *%rax
	//Lab3 Manoj
	 //cprintf("[%08x] user fault va %08x ip %08x\n", curenv->env_id, fault_va, tf->tf_rip);
	 //print_trapframe(tf);
	 //env_destroy(curenv);
	
}
  800420d040:	48 83 c4 38          	add    $0x38,%rsp
  800420d044:	5b                   	pop    %rbx
  800420d045:	5d                   	pop    %rbp
  800420d046:	c3                   	retq   
  800420d047:	90                   	nop

000000800420d048 <jos64_divide>:
/*
 * Lab 3: Your code here for generating entry points for the different traps.
   Find the PUSHA,POPA macros in kern/macro.h. Since amd64 doesn't support
   pusha,popa so you will find these macros handy.
 */
  TRAPHANDLER_NOEC(jos64_divide, 0)
  800420d048:	6a 00                	pushq  $0x0
  800420d04a:	6a 00                	pushq  $0x0
  800420d04c:	e9 f1 00 00 00       	jmpq   800420d142 <_alltraps>
  800420d051:	90                   	nop

000000800420d052 <jos64_debug>:
  TRAPHANDLER_NOEC(jos64_debug, 1)
  800420d052:	6a 00                	pushq  $0x0
  800420d054:	6a 01                	pushq  $0x1
  800420d056:	e9 e7 00 00 00       	jmpq   800420d142 <_alltraps>
  800420d05b:	90                   	nop

000000800420d05c <jos64_nmi>:
  TRAPHANDLER_NOEC(jos64_nmi, 2)
  800420d05c:	6a 00                	pushq  $0x0
  800420d05e:	6a 02                	pushq  $0x2
  800420d060:	e9 dd 00 00 00       	jmpq   800420d142 <_alltraps>
  800420d065:	90                   	nop

000000800420d066 <jos64_breakpoint>:
  TRAPHANDLER_NOEC(jos64_breakpoint, 3)
  800420d066:	6a 00                	pushq  $0x0
  800420d068:	6a 03                	pushq  $0x3
  800420d06a:	e9 d3 00 00 00       	jmpq   800420d142 <_alltraps>
  800420d06f:	90                   	nop

000000800420d070 <jos64_overflow>:
  TRAPHANDLER_NOEC(jos64_overflow, 4)
  800420d070:	6a 00                	pushq  $0x0
  800420d072:	6a 04                	pushq  $0x4
  800420d074:	e9 c9 00 00 00       	jmpq   800420d142 <_alltraps>
  800420d079:	90                   	nop

000000800420d07a <jos64_boundcheck>:
  TRAPHANDLER_NOEC(jos64_boundcheck, 5)
  800420d07a:	6a 00                	pushq  $0x0
  800420d07c:	6a 05                	pushq  $0x5
  800420d07e:	e9 bf 00 00 00       	jmpq   800420d142 <_alltraps>
  800420d083:	90                   	nop

000000800420d084 <jos64_ill_opcode>:
  TRAPHANDLER_NOEC(jos64_ill_opcode, 6)
  800420d084:	6a 00                	pushq  $0x0
  800420d086:	6a 06                	pushq  $0x6
  800420d088:	e9 b5 00 00 00       	jmpq   800420d142 <_alltraps>
  800420d08d:	90                   	nop

000000800420d08e <jos64_device>:
  TRAPHANDLER_NOEC(jos64_device, 7)
  800420d08e:	6a 00                	pushq  $0x0
  800420d090:	6a 07                	pushq  $0x7
  800420d092:	e9 ab 00 00 00       	jmpq   800420d142 <_alltraps>
  800420d097:	90                   	nop

000000800420d098 <jos64_doublefault>:

  TRAPHANDLER(jos64_doublefault, 8)
  800420d098:	6a 08                	pushq  $0x8
  800420d09a:	e9 a3 00 00 00       	jmpq   800420d142 <_alltraps>
  800420d09f:	90                   	nop

000000800420d0a0 <jos64_tss_segment>:
  TRAPHANDLER(jos64_tss_segment, 10)
  800420d0a0:	6a 0a                	pushq  $0xa
  800420d0a2:	e9 9b 00 00 00       	jmpq   800420d142 <_alltraps>
  800420d0a7:	90                   	nop

000000800420d0a8 <jos64_stack>:
  TRAPHANDLER(jos64_stack, 11)
  800420d0a8:	6a 0b                	pushq  $0xb
  800420d0aa:	e9 93 00 00 00       	jmpq   800420d142 <_alltraps>
  800420d0af:	90                   	nop

000000800420d0b0 <jos64_stackexception>:
  TRAPHANDLER(jos64_stackexception, 12)
  800420d0b0:	6a 0c                	pushq  $0xc
  800420d0b2:	e9 8b 00 00 00       	jmpq   800420d142 <_alltraps>
  800420d0b7:	90                   	nop

000000800420d0b8 <jos64_protectionfault>:
  TRAPHANDLER(jos64_protectionfault, 13)
  800420d0b8:	6a 0d                	pushq  $0xd
  800420d0ba:	e9 83 00 00 00       	jmpq   800420d142 <_alltraps>
  800420d0bf:	90                   	nop

000000800420d0c0 <jos64_pagefault>:
  TRAPHANDLER(jos64_pagefault, 14)
  800420d0c0:	6a 0e                	pushq  $0xe
  800420d0c2:	eb 7e                	jmp    800420d142 <_alltraps>

000000800420d0c4 <jos64_fp_error>:

  TRAPHANDLER_NOEC(jos64_fp_error, 16)
  800420d0c4:	6a 00                	pushq  $0x0
  800420d0c6:	6a 10                	pushq  $0x10
  800420d0c8:	eb 78                	jmp    800420d142 <_alltraps>

000000800420d0ca <jos64_align>:
  TRAPHANDLER_NOEC(jos64_align, 17)
  800420d0ca:	6a 00                	pushq  $0x0
  800420d0cc:	6a 11                	pushq  $0x11
  800420d0ce:	eb 72                	jmp    800420d142 <_alltraps>

000000800420d0d0 <jos64_mcheck>:
  TRAPHANDLER_NOEC(jos64_mcheck, 18)
  800420d0d0:	6a 00                	pushq  $0x0
  800420d0d2:	6a 12                	pushq  $0x12
  800420d0d4:	eb 6c                	jmp    800420d142 <_alltraps>

000000800420d0d6 <jos64_simd_error>:
  TRAPHANDLER_NOEC(jos64_simd_error, 19)
  800420d0d6:	6a 00                	pushq  $0x0
  800420d0d8:	6a 13                	pushq  $0x13
  800420d0da:	eb 66                	jmp    800420d142 <_alltraps>

000000800420d0dc <jos64_systemcall>:
  TRAPHANDLER_NOEC(jos64_systemcall, 48)
  800420d0dc:	6a 00                	pushq  $0x0
  800420d0de:	6a 30                	pushq  $0x30
  800420d0e0:	eb 60                	jmp    800420d142 <_alltraps>

000000800420d0e2 <jos64_irq32>:
  
  TRAPHANDLER_NOEC(jos64_irq32, IRQ_OFFSET)
  800420d0e2:	6a 00                	pushq  $0x0
  800420d0e4:	6a 20                	pushq  $0x20
  800420d0e6:	eb 5a                	jmp    800420d142 <_alltraps>

000000800420d0e8 <jos64_irq33>:
  TRAPHANDLER_NOEC(jos64_irq33, IRQ_OFFSET+1)
  800420d0e8:	6a 00                	pushq  $0x0
  800420d0ea:	6a 21                	pushq  $0x21
  800420d0ec:	eb 54                	jmp    800420d142 <_alltraps>

000000800420d0ee <jos64_irq34>:
  TRAPHANDLER_NOEC(jos64_irq34, IRQ_OFFSET+2)
  800420d0ee:	6a 00                	pushq  $0x0
  800420d0f0:	6a 22                	pushq  $0x22
  800420d0f2:	eb 4e                	jmp    800420d142 <_alltraps>

000000800420d0f4 <jos64_irq35>:
  TRAPHANDLER_NOEC(jos64_irq35, IRQ_OFFSET+3)
  800420d0f4:	6a 00                	pushq  $0x0
  800420d0f6:	6a 23                	pushq  $0x23
  800420d0f8:	eb 48                	jmp    800420d142 <_alltraps>

000000800420d0fa <jos64_irq36>:
  TRAPHANDLER_NOEC(jos64_irq36, IRQ_OFFSET+4)
  800420d0fa:	6a 00                	pushq  $0x0
  800420d0fc:	6a 24                	pushq  $0x24
  800420d0fe:	eb 42                	jmp    800420d142 <_alltraps>

000000800420d100 <jos64_irq37>:
  TRAPHANDLER_NOEC(jos64_irq37, IRQ_OFFSET+5)
  800420d100:	6a 00                	pushq  $0x0
  800420d102:	6a 25                	pushq  $0x25
  800420d104:	eb 3c                	jmp    800420d142 <_alltraps>

000000800420d106 <jos64_irq38>:
  TRAPHANDLER_NOEC(jos64_irq38, IRQ_OFFSET+6)
  800420d106:	6a 00                	pushq  $0x0
  800420d108:	6a 26                	pushq  $0x26
  800420d10a:	eb 36                	jmp    800420d142 <_alltraps>

000000800420d10c <jos64_irq39>:
  TRAPHANDLER_NOEC(jos64_irq39, IRQ_OFFSET+7)
  800420d10c:	6a 00                	pushq  $0x0
  800420d10e:	6a 27                	pushq  $0x27
  800420d110:	eb 30                	jmp    800420d142 <_alltraps>

000000800420d112 <jos64_irq40>:
  TRAPHANDLER_NOEC(jos64_irq40, IRQ_OFFSET+8)
  800420d112:	6a 00                	pushq  $0x0
  800420d114:	6a 28                	pushq  $0x28
  800420d116:	eb 2a                	jmp    800420d142 <_alltraps>

000000800420d118 <jos64_irq41>:
  TRAPHANDLER_NOEC(jos64_irq41, IRQ_OFFSET+9)
  800420d118:	6a 00                	pushq  $0x0
  800420d11a:	6a 29                	pushq  $0x29
  800420d11c:	eb 24                	jmp    800420d142 <_alltraps>

000000800420d11e <jos64_irq42>:
  TRAPHANDLER_NOEC(jos64_irq42, IRQ_OFFSET+10)
  800420d11e:	6a 00                	pushq  $0x0
  800420d120:	6a 2a                	pushq  $0x2a
  800420d122:	eb 1e                	jmp    800420d142 <_alltraps>

000000800420d124 <jos64_irq43>:
  TRAPHANDLER_NOEC(jos64_irq43, IRQ_OFFSET+11)
  800420d124:	6a 00                	pushq  $0x0
  800420d126:	6a 2b                	pushq  $0x2b
  800420d128:	eb 18                	jmp    800420d142 <_alltraps>

000000800420d12a <jos64_irq44>:
  TRAPHANDLER_NOEC(jos64_irq44, IRQ_OFFSET+12)
  800420d12a:	6a 00                	pushq  $0x0
  800420d12c:	6a 2c                	pushq  $0x2c
  800420d12e:	eb 12                	jmp    800420d142 <_alltraps>

000000800420d130 <jos64_irq45>:
  TRAPHANDLER_NOEC(jos64_irq45, IRQ_OFFSET+13)
  800420d130:	6a 00                	pushq  $0x0
  800420d132:	6a 2d                	pushq  $0x2d
  800420d134:	eb 0c                	jmp    800420d142 <_alltraps>

000000800420d136 <jos64_irq46>:
  TRAPHANDLER_NOEC(jos64_irq46, IRQ_OFFSET+14)
  800420d136:	6a 00                	pushq  $0x0
  800420d138:	6a 2e                	pushq  $0x2e
  800420d13a:	eb 06                	jmp    800420d142 <_alltraps>

000000800420d13c <jos64_irq47>:
  TRAPHANDLER_NOEC(jos64_irq47, IRQ_OFFSET+15)
  800420d13c:	6a 00                	pushq  $0x0
  800420d13e:	6a 2f                	pushq  $0x2f
  800420d140:	eb 00                	jmp    800420d142 <_alltraps>

000000800420d142 <_alltraps>:
 *       for how to pass a pointer to the trapframe.
 */


 _alltraps:
        movq $0, %r8
  800420d142:	49 c7 c0 00 00 00 00 	mov    $0x0,%r8
        movw %ds,%r8
  800420d149:	66 41 8c d8          	mov    %ds,%r8w
        pushq %r8
  800420d14d:	41 50                	push   %r8
        movw %es, %r8
  800420d14f:	66 41 8c c0          	mov    %es,%r8w
        pushq %r8
  800420d153:	41 50                	push   %r8
        PUSHA
  800420d155:	48 83 ec 78          	sub    $0x78,%rsp
  800420d159:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  800420d15e:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  800420d163:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  800420d168:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  800420d16d:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  800420d172:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  800420d177:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  800420d17c:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  800420d181:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  800420d186:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  800420d18b:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  800420d190:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  800420d195:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  800420d19a:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  800420d19f:	4c 89 3c 24          	mov    %r15,(%rsp)
        mov %rsp, %rdi
  800420d1a3:	48 89 e7             	mov    %rsp,%rdi
        movq $0, %r8
  800420d1a6:	49 c7 c0 00 00 00 00 	mov    $0x0,%r8
        movw $(GD_KD), %r8
  800420d1ad:	66 41 c7 c0 10 00    	mov    $0x10,%r8w
        movw %r8, %es
  800420d1b3:	41 8e c0             	mov    %r8d,%es
        movw %r8, %ds
  800420d1b6:	41 8e d8             	mov    %r8d,%ds
        call trap
  800420d1b9:	e8 48 f7 ff ff       	callq  800420c906 <trap>
        POPA_
  800420d1be:	4c 8b 3c 24          	mov    (%rsp),%r15
  800420d1c2:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  800420d1c7:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  800420d1cc:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  800420d1d1:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  800420d1d6:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  800420d1db:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  800420d1e0:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  800420d1e5:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  800420d1ea:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  800420d1ef:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  800420d1f4:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  800420d1f9:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800420d1fe:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  800420d203:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800420d208:	48 83 c4 78          	add    $0x78,%rsp
	mov $0, %rax
  800420d20c:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
	popq %rax
  800420d213:	58                   	pop    %rax
	movw %rax, %es
  800420d214:	8e c0                	mov    %eax,%es
	popq %rax
  800420d216:	58                   	pop    %rax
	movw %rax, %ds
  800420d217:	8e d8                	mov    %eax,%ds
	addq $8, %rsp
  800420d219:	48 83 c4 08          	add    $0x8,%rsp
    	iret 
  800420d21d:	cf                   	iret   

000000800420d21e <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800420d21e:	55                   	push   %rbp
  800420d21f:	48 89 e5             	mov    %rsp,%rbp
  800420d222:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420d226:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d22a:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420d22d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d231:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420d234:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d238:	f0 87 02             	lock xchg %eax,(%rdx)
  800420d23b:	89 45 fc             	mov    %eax,-0x4(%rbp)
	"+m" (*addr), "=a" (result):
	"1"(newval):
	"cc");
	return result;
  800420d23e:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420d241:	c9                   	leaveq 
  800420d242:	c3                   	retq   

000000800420d243 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420d243:	55                   	push   %rbp
  800420d244:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420d247:	48 bf c0 a7 22 04 80 	movabs $0x800422a7c0,%rdi
  800420d24e:	00 00 00 
  800420d251:	48 b8 1f 6f 21 04 80 	movabs $0x8004216f1f,%rax
  800420d258:	00 00 00 
  800420d25b:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420d25d:	f3 90                	pause  
}
  800420d25f:	5d                   	pop    %rbp
  800420d260:	c3                   	retq   

000000800420d261 <sched_yield>:
void sched_halt(void);

// Choose a user environment to run and run it.
void
sched_yield(void)
{
  800420d261:	55                   	push   %rbp
  800420d262:	48 89 e5             	mov    %rsp,%rbp
  800420d265:	48 83 ec 20          	sub    $0x20,%rsp
	// another CPU (env_status == ENV_RUNNING). If there are
	// no runnable environments, simply drop through to the code
	// below to halt the cpu.
	int i, j, id;	
	
	idle = thiscpu->cpu_env;
  800420d269:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420d270:	00 00 00 
  800420d273:	ff d0                	callq  *%rax
  800420d275:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420d27c:	00 00 00 
  800420d27f:	48 98                	cltq   
  800420d281:	48 c1 e0 03          	shl    $0x3,%rax
  800420d285:	48 89 c2             	mov    %rax,%rdx
  800420d288:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d28c:	48 29 c2             	sub    %rax,%rdx
  800420d28f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d293:	48 83 c0 08          	add    $0x8,%rax
  800420d297:	48 8b 00             	mov    (%rax),%rax
  800420d29a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(idle == NULL)
  800420d29e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420d2a3:	75 7d                	jne    800420d322 <sched_yield+0xc1>
	{
	  for(i = 0; i < NENV; i++)
  800420d2a5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420d2ac:	eb 66                	jmp    800420d314 <sched_yield+0xb3>
	     if(envs[i].env_status == ENV_RUNNABLE)
  800420d2ae:	48 b8 50 02 36 04 80 	movabs $0x8004360250,%rax
  800420d2b5:	00 00 00 
  800420d2b8:	48 8b 08             	mov    (%rax),%rcx
  800420d2bb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d2be:	48 63 d0             	movslq %eax,%rdx
  800420d2c1:	48 89 d0             	mov    %rdx,%rax
  800420d2c4:	48 c1 e0 03          	shl    $0x3,%rax
  800420d2c8:	48 01 d0             	add    %rdx,%rax
  800420d2cb:	48 c1 e0 05          	shl    $0x5,%rax
  800420d2cf:	48 01 c8             	add    %rcx,%rax
  800420d2d2:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d2d8:	83 f8 02             	cmp    $0x2,%eax
  800420d2db:	75 33                	jne    800420d310 <sched_yield+0xaf>
	       {
		 env_run(&envs[i]);
  800420d2dd:	48 b8 50 02 36 04 80 	movabs $0x8004360250,%rax
  800420d2e4:	00 00 00 
  800420d2e7:	48 8b 08             	mov    (%rax),%rcx
  800420d2ea:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d2ed:	48 63 d0             	movslq %eax,%rdx
  800420d2f0:	48 89 d0             	mov    %rdx,%rax
  800420d2f3:	48 c1 e0 03          	shl    $0x3,%rax
  800420d2f7:	48 01 d0             	add    %rdx,%rax
  800420d2fa:	48 c1 e0 05          	shl    $0x5,%rax
  800420d2fe:	48 01 c8             	add    %rcx,%rax
  800420d301:	48 89 c7             	mov    %rax,%rdi
  800420d304:	48 b8 cd 90 20 04 80 	movabs $0x80042090cd,%rax
  800420d30b:	00 00 00 
  800420d30e:	ff d0                	callq  *%rax
	int i, j, id;	
	
	idle = thiscpu->cpu_env;
	if(idle == NULL)
	{
	  for(i = 0; i < NENV; i++)
  800420d310:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420d314:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420d31b:	7e 91                	jle    800420d2ae <sched_yield+0x4d>
  800420d31d:	e9 2b 01 00 00       	jmpq   800420d44d <sched_yield+0x1ec>
		 return;
	       }
	}
	else
	{
	 id = (int)ENVX(idle->env_id);
  800420d322:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d326:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420d32c:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420d331:	89 45 ec             	mov    %eax,-0x14(%rbp)
	 // LAB 4: Your code here.
	 j = (id + 1)%NENV;
  800420d334:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d337:	8d 50 01             	lea    0x1(%rax),%edx
  800420d33a:	89 d0                	mov    %edx,%eax
  800420d33c:	c1 f8 1f             	sar    $0x1f,%eax
  800420d33f:	c1 e8 16             	shr    $0x16,%eax
  800420d342:	01 c2                	add    %eax,%edx
  800420d344:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  800420d34a:	29 c2                	sub    %eax,%edx
  800420d34c:	89 d0                	mov    %edx,%eax
  800420d34e:	89 45 f8             	mov    %eax,-0x8(%rbp)
	 while(j != id)
  800420d351:	eb 7f                	jmp    800420d3d2 <sched_yield+0x171>
	 {
	  
	   if(envs[j].env_status == ENV_RUNNABLE)
  800420d353:	48 b8 50 02 36 04 80 	movabs $0x8004360250,%rax
  800420d35a:	00 00 00 
  800420d35d:	48 8b 08             	mov    (%rax),%rcx
  800420d360:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420d363:	48 63 d0             	movslq %eax,%rdx
  800420d366:	48 89 d0             	mov    %rdx,%rax
  800420d369:	48 c1 e0 03          	shl    $0x3,%rax
  800420d36d:	48 01 d0             	add    %rdx,%rax
  800420d370:	48 c1 e0 05          	shl    $0x5,%rax
  800420d374:	48 01 c8             	add    %rcx,%rax
  800420d377:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d37d:	83 f8 02             	cmp    $0x2,%eax
  800420d380:	75 33                	jne    800420d3b5 <sched_yield+0x154>
	    {
	       env_run(&envs[j]);
  800420d382:	48 b8 50 02 36 04 80 	movabs $0x8004360250,%rax
  800420d389:	00 00 00 
  800420d38c:	48 8b 08             	mov    (%rax),%rcx
  800420d38f:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420d392:	48 63 d0             	movslq %eax,%rdx
  800420d395:	48 89 d0             	mov    %rdx,%rax
  800420d398:	48 c1 e0 03          	shl    $0x3,%rax
  800420d39c:	48 01 d0             	add    %rdx,%rax
  800420d39f:	48 c1 e0 05          	shl    $0x5,%rax
  800420d3a3:	48 01 c8             	add    %rcx,%rax
  800420d3a6:	48 89 c7             	mov    %rax,%rdi
  800420d3a9:	48 b8 cd 90 20 04 80 	movabs $0x80042090cd,%rax
  800420d3b0:	00 00 00 
  800420d3b3:	ff d0                	callq  *%rax
	       return;
	    }
	   j = (j+1)%NENV;
  800420d3b5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420d3b8:	8d 50 01             	lea    0x1(%rax),%edx
  800420d3bb:	89 d0                	mov    %edx,%eax
  800420d3bd:	c1 f8 1f             	sar    $0x1f,%eax
  800420d3c0:	c1 e8 16             	shr    $0x16,%eax
  800420d3c3:	01 c2                	add    %eax,%edx
  800420d3c5:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  800420d3cb:	29 c2                	sub    %eax,%edx
  800420d3cd:	89 d0                	mov    %edx,%eax
  800420d3cf:	89 45 f8             	mov    %eax,-0x8(%rbp)
	else
	{
	 id = (int)ENVX(idle->env_id);
	 // LAB 4: Your code here.
	 j = (id + 1)%NENV;
	 while(j != id)
  800420d3d2:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420d3d5:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800420d3d8:	0f 85 75 ff ff ff    	jne    800420d353 <sched_yield+0xf2>
	       return;
	    }
	   j = (j+1)%NENV;
	 }
	
	  if(curenv->env_status == ENV_RUNNING)
  800420d3de:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420d3e5:	00 00 00 
  800420d3e8:	ff d0                	callq  *%rax
  800420d3ea:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420d3f1:	00 00 00 
  800420d3f4:	48 98                	cltq   
  800420d3f6:	48 c1 e0 03          	shl    $0x3,%rax
  800420d3fa:	48 89 c2             	mov    %rax,%rdx
  800420d3fd:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d401:	48 29 c2             	sub    %rax,%rdx
  800420d404:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d408:	48 83 c0 08          	add    $0x8,%rax
  800420d40c:	48 8b 00             	mov    (%rax),%rax
  800420d40f:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d415:	83 f8 03             	cmp    $0x3,%eax
  800420d418:	75 33                	jne    800420d44d <sched_yield+0x1ec>
	  {
	     env_run(&envs[id]);
  800420d41a:	48 b8 50 02 36 04 80 	movabs $0x8004360250,%rax
  800420d421:	00 00 00 
  800420d424:	48 8b 08             	mov    (%rax),%rcx
  800420d427:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d42a:	48 63 d0             	movslq %eax,%rdx
  800420d42d:	48 89 d0             	mov    %rdx,%rax
  800420d430:	48 c1 e0 03          	shl    $0x3,%rax
  800420d434:	48 01 d0             	add    %rdx,%rax
  800420d437:	48 c1 e0 05          	shl    $0x5,%rax
  800420d43b:	48 01 c8             	add    %rcx,%rax
  800420d43e:	48 89 c7             	mov    %rax,%rdi
  800420d441:	48 b8 cd 90 20 04 80 	movabs $0x80042090cd,%rax
  800420d448:	00 00 00 
  800420d44b:	ff d0                	callq  *%rax
	     return;
	  }
	}
	
	// sched_halt never returns	
	 sched_halt();
  800420d44d:	48 b8 5b d4 20 04 80 	movabs $0x800420d45b,%rax
  800420d454:	00 00 00 
  800420d457:	ff d0                	callq  *%rax
}
  800420d459:	c9                   	leaveq 
  800420d45a:	c3                   	retq   

000000800420d45b <sched_halt>:
// Halt this CPU when there is nothing to do. Wait until the
// timer interrupt wakes it up. This function never returns.
//
void
sched_halt(void)
{
  800420d45b:	55                   	push   %rbp
  800420d45c:	48 89 e5             	mov    %rsp,%rbp
  800420d45f:	48 83 ec 20          	sub    $0x20,%rsp
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420d463:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420d46a:	e9 91 00 00 00       	jmpq   800420d500 <sched_halt+0xa5>
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420d46f:	48 b8 50 02 36 04 80 	movabs $0x8004360250,%rax
  800420d476:	00 00 00 
  800420d479:	48 8b 08             	mov    (%rax),%rcx
  800420d47c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d47f:	48 63 d0             	movslq %eax,%rdx
  800420d482:	48 89 d0             	mov    %rdx,%rax
  800420d485:	48 c1 e0 03          	shl    $0x3,%rax
  800420d489:	48 01 d0             	add    %rdx,%rax
  800420d48c:	48 c1 e0 05          	shl    $0x5,%rax
  800420d490:	48 01 c8             	add    %rcx,%rax
  800420d493:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d499:	83 f8 02             	cmp    $0x2,%eax
  800420d49c:	74 6f                	je     800420d50d <sched_halt+0xb2>
		     envs[i].env_status == ENV_RUNNING ||
  800420d49e:	48 b8 50 02 36 04 80 	movabs $0x8004360250,%rax
  800420d4a5:	00 00 00 
  800420d4a8:	48 8b 08             	mov    (%rax),%rcx
  800420d4ab:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d4ae:	48 63 d0             	movslq %eax,%rdx
  800420d4b1:	48 89 d0             	mov    %rdx,%rax
  800420d4b4:	48 c1 e0 03          	shl    $0x3,%rax
  800420d4b8:	48 01 d0             	add    %rdx,%rax
  800420d4bb:	48 c1 e0 05          	shl    $0x5,%rax
  800420d4bf:	48 01 c8             	add    %rcx,%rax
  800420d4c2:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420d4c8:	83 f8 03             	cmp    $0x3,%eax
  800420d4cb:	74 40                	je     800420d50d <sched_halt+0xb2>
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
  800420d4cd:	48 b8 50 02 36 04 80 	movabs $0x8004360250,%rax
  800420d4d4:	00 00 00 
  800420d4d7:	48 8b 08             	mov    (%rax),%rcx
  800420d4da:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d4dd:	48 63 d0             	movslq %eax,%rdx
  800420d4e0:	48 89 d0             	mov    %rdx,%rax
  800420d4e3:	48 c1 e0 03          	shl    $0x3,%rax
  800420d4e7:	48 01 d0             	add    %rdx,%rax
  800420d4ea:	48 c1 e0 05          	shl    $0x5,%rax
  800420d4ee:	48 01 c8             	add    %rcx,%rax
  800420d4f1:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
  800420d4f7:	83 f8 01             	cmp    $0x1,%eax
  800420d4fa:	74 11                	je     800420d50d <sched_halt+0xb2>
{
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420d4fc:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420d500:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420d507:	0f 8e 62 ff ff ff    	jle    800420d46f <sched_halt+0x14>
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
			break;
	}
	if (i == NENV) {
  800420d50d:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420d514:	75 2e                	jne    800420d544 <sched_halt+0xe9>
		cprintf("No runnable environments in the system!\n");
  800420d516:	48 bf 60 8c 21 04 80 	movabs $0x8004218c60,%rdi
  800420d51d:	00 00 00 
  800420d520:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d525:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420d52c:	00 00 00 
  800420d52f:	ff d2                	callq  *%rdx
		while (1)
			monitor(NULL);
  800420d531:	bf 00 00 00 00       	mov    $0x0,%edi
  800420d536:	48 b8 3c 22 20 04 80 	movabs $0x800420223c,%rax
  800420d53d:	00 00 00 
  800420d540:	ff d0                	callq  *%rax
  800420d542:	eb ed                	jmp    800420d531 <sched_halt+0xd6>
	}

	// Mark that no environment is running on this CPU
	curenv = NULL;
  800420d544:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420d54b:	00 00 00 
  800420d54e:	ff d0                	callq  *%rax
  800420d550:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420d557:	00 00 00 
  800420d55a:	48 98                	cltq   
  800420d55c:	48 c1 e0 03          	shl    $0x3,%rax
  800420d560:	48 89 c2             	mov    %rax,%rdx
  800420d563:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d567:	48 29 c2             	sub    %rax,%rdx
  800420d56a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d56e:	48 83 c0 08          	add    $0x8,%rax
  800420d572:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	lcr3(PADDR(boot_pml4e));
  800420d579:	48 b8 a8 17 36 04 80 	movabs $0x80043617a8,%rax
  800420d580:	00 00 00 
  800420d583:	48 8b 00             	mov    (%rax),%rax
  800420d586:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420d58a:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420d591:	00 00 00 
  800420d594:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420d598:	77 32                	ja     800420d5cc <sched_halt+0x171>
  800420d59a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d59e:	48 89 c1             	mov    %rax,%rcx
  800420d5a1:	48 ba 90 8c 21 04 80 	movabs $0x8004218c90,%rdx
  800420d5a8:	00 00 00 
  800420d5ab:	be 5d 00 00 00       	mov    $0x5d,%esi
  800420d5b0:	48 bf b4 8c 21 04 80 	movabs $0x8004218cb4,%rdi
  800420d5b7:	00 00 00 
  800420d5ba:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d5bf:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420d5c6:	00 00 00 
  800420d5c9:	41 ff d0             	callq  *%r8
  800420d5cc:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420d5d3:	ff ff ff 
  800420d5d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d5da:	48 01 d0             	add    %rdx,%rax
  800420d5dd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420d5e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d5e5:	0f 22 d8             	mov    %rax,%cr3

	// Mark that this CPU is in the HALT state, so that when
	// timer interupts come in, we know we should re-acquire the
	// big kernel lock
	xchg(&thiscpu->cpu_status, CPU_HALTED);
  800420d5e8:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420d5ef:	00 00 00 
  800420d5f2:	ff d0                	callq  *%rax
  800420d5f4:	48 98                	cltq   
  800420d5f6:	48 c1 e0 03          	shl    $0x3,%rax
  800420d5fa:	48 89 c2             	mov    %rax,%rdx
  800420d5fd:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d601:	48 29 c2             	sub    %rax,%rdx
  800420d604:	48 b8 20 30 36 04 80 	movabs $0x8004363020,%rax
  800420d60b:	00 00 00 
  800420d60e:	48 01 d0             	add    %rdx,%rax
  800420d611:	48 83 c0 04          	add    $0x4,%rax
  800420d615:	be 02 00 00 00       	mov    $0x2,%esi
  800420d61a:	48 89 c7             	mov    %rax,%rdi
  800420d61d:	48 b8 1e d2 20 04 80 	movabs $0x800420d21e,%rax
  800420d624:	00 00 00 
  800420d627:	ff d0                	callq  *%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();
  800420d629:	48 b8 43 d2 20 04 80 	movabs $0x800420d243,%rax
  800420d630:	00 00 00 
  800420d633:	ff d0                	callq  *%rax
		"movq %0, %%rsp\n"
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
	: : "a" (thiscpu->cpu_ts.ts_esp0));
  800420d635:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420d63c:	00 00 00 
  800420d63f:	ff d0                	callq  *%rax
  800420d641:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420d648:	00 00 00 
  800420d64b:	48 98                	cltq   
  800420d64d:	48 c1 e0 03          	shl    $0x3,%rax
  800420d651:	48 89 c2             	mov    %rax,%rdx
  800420d654:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d658:	48 29 c2             	sub    %rax,%rdx
  800420d65b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d65f:	48 83 c0 10          	add    $0x10,%rax
  800420d663:	48 8b 40 04          	mov    0x4(%rax),%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();

	// Reset stack pointer, enable interrupts and then halt.
	asm volatile (
  800420d667:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  800420d66e:	48 89 c4             	mov    %rax,%rsp
  800420d671:	6a 00                	pushq  $0x0
  800420d673:	6a 00                	pushq  $0x0
  800420d675:	fb                   	sti    
  800420d676:	f4                   	hlt    
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
	: : "a" (thiscpu->cpu_ts.ts_esp0));
}
  800420d677:	c9                   	leaveq 
  800420d678:	c3                   	retq   

000000800420d679 <sys_cputs>:
// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  800420d679:	55                   	push   %rbp
  800420d67a:	48 89 e5             	mov    %rsp,%rbp
  800420d67d:	48 83 ec 10          	sub    $0x10,%rsp
  800420d681:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420d685:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.
	user_mem_assert(curenv, (const void *)s, len, PTE_U);
  800420d689:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420d690:	00 00 00 
  800420d693:	ff d0                	callq  *%rax
  800420d695:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420d69c:	00 00 00 
  800420d69f:	48 98                	cltq   
  800420d6a1:	48 c1 e0 03          	shl    $0x3,%rax
  800420d6a5:	48 89 c2             	mov    %rax,%rdx
  800420d6a8:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d6ac:	48 29 c2             	sub    %rax,%rdx
  800420d6af:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d6b3:	48 83 c0 08          	add    $0x8,%rax
  800420d6b7:	48 8b 00             	mov    (%rax),%rax
  800420d6ba:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d6be:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420d6c2:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420d6c7:	48 89 c7             	mov    %rax,%rdi
  800420d6ca:	48 b8 8d 42 20 04 80 	movabs $0x800420428d,%rax
  800420d6d1:	00 00 00 
  800420d6d4:	ff d0                	callq  *%rax
	// Print the string supplied by the user.
	cprintf("%.*s", len, s);
  800420d6d6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420d6da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d6de:	48 89 c6             	mov    %rax,%rsi
  800420d6e1:	48 bf c8 8c 21 04 80 	movabs $0x8004218cc8,%rdi
  800420d6e8:	00 00 00 
  800420d6eb:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d6f0:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  800420d6f7:	00 00 00 
  800420d6fa:	ff d1                	callq  *%rcx
}
  800420d6fc:	c9                   	leaveq 
  800420d6fd:	c3                   	retq   

000000800420d6fe <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  800420d6fe:	55                   	push   %rbp
  800420d6ff:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  800420d702:	48 b8 b4 10 20 04 80 	movabs $0x80042010b4,%rax
  800420d709:	00 00 00 
  800420d70c:	ff d0                	callq  *%rax
}
  800420d70e:	5d                   	pop    %rbp
  800420d70f:	c3                   	retq   

000000800420d710 <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  800420d710:	55                   	push   %rbp
  800420d711:	48 89 e5             	mov    %rsp,%rbp
    return curenv->env_id;
  800420d714:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420d71b:	00 00 00 
  800420d71e:	ff d0                	callq  *%rax
  800420d720:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420d727:	00 00 00 
  800420d72a:	48 98                	cltq   
  800420d72c:	48 c1 e0 03          	shl    $0x3,%rax
  800420d730:	48 89 c2             	mov    %rax,%rdx
  800420d733:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d737:	48 29 c2             	sub    %rax,%rdx
  800420d73a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d73e:	48 83 c0 08          	add    $0x8,%rax
  800420d742:	48 8b 00             	mov    (%rax),%rax
  800420d745:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420d74b:	5d                   	pop    %rbp
  800420d74c:	c3                   	retq   

000000800420d74d <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  800420d74d:	55                   	push   %rbp
  800420d74e:	48 89 e5             	mov    %rsp,%rbp
  800420d751:	53                   	push   %rbx
  800420d752:	48 83 ec 28          	sub    $0x28,%rsp
  800420d756:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420d759:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420d75d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420d760:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d765:	48 89 ce             	mov    %rcx,%rsi
  800420d768:	89 c7                	mov    %eax,%edi
  800420d76a:	48 b8 b3 7d 20 04 80 	movabs $0x8004207db3,%rax
  800420d771:	00 00 00 
  800420d774:	ff d0                	callq  *%rax
  800420d776:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420d779:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420d77d:	79 08                	jns    800420d787 <sys_env_destroy+0x3a>
		return r;
  800420d77f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d782:	e9 08 01 00 00       	jmpq   800420d88f <sys_env_destroy+0x142>
	if (e == curenv)
  800420d787:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420d78e:	00 00 00 
  800420d791:	ff d0                	callq  *%rax
  800420d793:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420d79a:	00 00 00 
  800420d79d:	48 98                	cltq   
  800420d79f:	48 c1 e0 03          	shl    $0x3,%rax
  800420d7a3:	48 89 c2             	mov    %rax,%rdx
  800420d7a6:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d7aa:	48 29 c2             	sub    %rax,%rdx
  800420d7ad:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d7b1:	48 83 c0 08          	add    $0x8,%rax
  800420d7b5:	48 8b 10             	mov    (%rax),%rdx
  800420d7b8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d7bc:	48 39 c2             	cmp    %rax,%rdx
  800420d7bf:	75 56                	jne    800420d817 <sys_env_destroy+0xca>
		cprintf("[%08x] exiting gracefully\n", curenv->env_id);
  800420d7c1:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420d7c8:	00 00 00 
  800420d7cb:	ff d0                	callq  *%rax
  800420d7cd:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420d7d4:	00 00 00 
  800420d7d7:	48 98                	cltq   
  800420d7d9:	48 c1 e0 03          	shl    $0x3,%rax
  800420d7dd:	48 89 c2             	mov    %rax,%rdx
  800420d7e0:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d7e4:	48 29 c2             	sub    %rax,%rdx
  800420d7e7:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d7eb:	48 83 c0 08          	add    $0x8,%rax
  800420d7ef:	48 8b 00             	mov    (%rax),%rax
  800420d7f2:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420d7f8:	89 c6                	mov    %eax,%esi
  800420d7fa:	48 bf cd 8c 21 04 80 	movabs $0x8004218ccd,%rdi
  800420d801:	00 00 00 
  800420d804:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d809:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420d810:	00 00 00 
  800420d813:	ff d2                	callq  *%rdx
  800420d815:	eb 60                	jmp    800420d877 <sys_env_destroy+0x12a>
	else
		cprintf("[%08x] destroying %08x\n", curenv->env_id, e->env_id);
  800420d817:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d81b:	8b 98 c8 00 00 00    	mov    0xc8(%rax),%ebx
  800420d821:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420d828:	00 00 00 
  800420d82b:	ff d0                	callq  *%rax
  800420d82d:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420d834:	00 00 00 
  800420d837:	48 98                	cltq   
  800420d839:	48 c1 e0 03          	shl    $0x3,%rax
  800420d83d:	48 89 c2             	mov    %rax,%rdx
  800420d840:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d844:	48 29 c2             	sub    %rax,%rdx
  800420d847:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d84b:	48 83 c0 08          	add    $0x8,%rax
  800420d84f:	48 8b 00             	mov    (%rax),%rax
  800420d852:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420d858:	89 da                	mov    %ebx,%edx
  800420d85a:	89 c6                	mov    %eax,%esi
  800420d85c:	48 bf e8 8c 21 04 80 	movabs $0x8004218ce8,%rdi
  800420d863:	00 00 00 
  800420d866:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d86b:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  800420d872:	00 00 00 
  800420d875:	ff d1                	callq  *%rcx
	env_destroy(e);
  800420d877:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d87b:	48 89 c7             	mov    %rax,%rdi
  800420d87e:	48 b8 fe 8e 20 04 80 	movabs $0x8004208efe,%rax
  800420d885:	00 00 00 
  800420d888:	ff d0                	callq  *%rax
	return 0;
  800420d88a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420d88f:	48 83 c4 28          	add    $0x28,%rsp
  800420d893:	5b                   	pop    %rbx
  800420d894:	5d                   	pop    %rbp
  800420d895:	c3                   	retq   

000000800420d896 <sys_yield>:

// Deschedule current environment and pick a different one to run.
static void
sys_yield(void)
{
  800420d896:	55                   	push   %rbp
  800420d897:	48 89 e5             	mov    %rsp,%rbp
    sched_yield();
  800420d89a:	48 b8 61 d2 20 04 80 	movabs $0x800420d261,%rax
  800420d8a1:	00 00 00 
  800420d8a4:	ff d0                	callq  *%rax

000000800420d8a6 <sys_exofork>:
// Returns envid of new environment, or < 0 on error.  Errors are:
//	-E_NO_FREE_ENV if no free environment is available.
//	-E_NO_MEM on memory exhaustion.
static envid_t
sys_exofork(void)
{
  800420d8a6:	55                   	push   %rbp
  800420d8a7:	48 89 e5             	mov    %rsp,%rbp
  800420d8aa:	53                   	push   %rbx
  800420d8ab:	48 83 ec 18          	sub    $0x18,%rsp
	// will appear to return 0.

	// LAB 4: Your code here.
	struct Env *new_env;
	
	if(env_alloc(&new_env, curenv->env_id)<0)
  800420d8af:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420d8b6:	00 00 00 
  800420d8b9:	ff d0                	callq  *%rax
  800420d8bb:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420d8c2:	00 00 00 
  800420d8c5:	48 98                	cltq   
  800420d8c7:	48 c1 e0 03          	shl    $0x3,%rax
  800420d8cb:	48 89 c2             	mov    %rax,%rdx
  800420d8ce:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d8d2:	48 29 c2             	sub    %rax,%rdx
  800420d8d5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d8d9:	48 83 c0 08          	add    $0x8,%rax
  800420d8dd:	48 8b 00             	mov    (%rax),%rax
  800420d8e0:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420d8e6:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420d8ea:	89 d6                	mov    %edx,%esi
  800420d8ec:	48 89 c7             	mov    %rax,%rdi
  800420d8ef:	48 b8 7d 84 20 04 80 	movabs $0x800420847d,%rax
  800420d8f6:	00 00 00 
  800420d8f9:	ff d0                	callq  *%rax
  800420d8fb:	85 c0                	test   %eax,%eax
  800420d8fd:	79 22                	jns    800420d921 <sys_exofork+0x7b>
	{
	  cprintf("\nNot able to create new env\n");
  800420d8ff:	48 bf 00 8d 21 04 80 	movabs $0x8004218d00,%rdi
  800420d906:	00 00 00 
  800420d909:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d90e:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420d915:	00 00 00 
  800420d918:	ff d2                	callq  *%rdx
	  return -E_NO_FREE_ENV;
  800420d91a:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  800420d91f:	eb 6d                	jmp    800420d98e <sys_exofork+0xe8>
	}
	else
	{
	 new_env->env_status = ENV_NOT_RUNNABLE;
  800420d921:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d925:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420d92c:	00 00 00 
	 new_env->env_tf = curenv->env_tf;
  800420d92f:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
  800420d933:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420d93a:	00 00 00 
  800420d93d:	ff d0                	callq  *%rax
  800420d93f:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420d946:	00 00 00 
  800420d949:	48 98                	cltq   
  800420d94b:	48 c1 e0 03          	shl    $0x3,%rax
  800420d94f:	48 89 c2             	mov    %rax,%rdx
  800420d952:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d956:	48 29 c2             	sub    %rax,%rdx
  800420d959:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d95d:	48 83 c0 08          	add    $0x8,%rax
  800420d961:	48 8b 00             	mov    (%rax),%rax
  800420d964:	48 89 da             	mov    %rbx,%rdx
  800420d967:	48 89 c6             	mov    %rax,%rsi
  800420d96a:	b8 18 00 00 00       	mov    $0x18,%eax
  800420d96f:	48 89 d7             	mov    %rdx,%rdi
  800420d972:	48 89 c1             	mov    %rax,%rcx
  800420d975:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	 //memcpy(&(new_env->env_tf), &(curenv->env_tf), sizeof(struct Trapframe));
	 new_env->env_tf.tf_regs.reg_rax = 0; 
  800420d978:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d97c:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420d983:	00 
         //new_env->env_pgfault_upcall = curenv->env_pgfault_upcall; // For challenge problem
	 return new_env->env_id;
  800420d984:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d988:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
	 //panic("sys_exofork not implemented");
	}
}
  800420d98e:	48 83 c4 18          	add    $0x18,%rsp
  800420d992:	5b                   	pop    %rbx
  800420d993:	5d                   	pop    %rbp
  800420d994:	c3                   	retq   

000000800420d995 <sys_env_set_status>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
  800420d995:	55                   	push   %rbp
  800420d996:	48 89 e5             	mov    %rsp,%rbp
  800420d999:	48 83 ec 20          	sub    $0x20,%rsp
  800420d99d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d9a0:	89 75 e8             	mov    %esi,-0x18(%rbp)
	// check whether the current environment has permission to set
	// envid's status.

	// LAB 4: Your code here.

	struct Env *env = NULL;
  800420d9a3:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420d9aa:	00 
	if(status !=ENV_RUNNABLE && status !=ENV_NOT_RUNNABLE)
  800420d9ab:	83 7d e8 02          	cmpl   $0x2,-0x18(%rbp)
  800420d9af:	74 0d                	je     800420d9be <sys_env_set_status+0x29>
  800420d9b1:	83 7d e8 04          	cmpl   $0x4,-0x18(%rbp)
  800420d9b5:	74 07                	je     800420d9be <sys_env_set_status+0x29>
	   return -E_INVAL;
  800420d9b7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d9bc:	eb 3d                	jmp    800420d9fb <sys_env_set_status+0x66>
	
	int i = envid2env(envid, &env, 1); 
  800420d9be:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d9c2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d9c5:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d9ca:	48 89 ce             	mov    %rcx,%rsi
  800420d9cd:	89 c7                	mov    %eax,%edi
  800420d9cf:	48 b8 b3 7d 20 04 80 	movabs $0x8004207db3,%rax
  800420d9d6:	00 00 00 
  800420d9d9:	ff d0                	callq  *%rax
  800420d9db:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(i == 0)
  800420d9de:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d9e2:	75 14                	jne    800420d9f8 <sys_env_set_status+0x63>
	{	
	  env->env_status = status;
  800420d9e4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d9e8:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420d9eb:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
	  return 0; 
  800420d9f1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d9f6:	eb 03                	jmp    800420d9fb <sys_env_set_status+0x66>
	}

	 return i;
  800420d9f8:	8b 45 fc             	mov    -0x4(%rbp),%eax
	
   		
	panic("sys_env_set_status not implemented");
}
  800420d9fb:	c9                   	leaveq 
  800420d9fc:	c3                   	retq   

000000800420d9fd <sys_env_set_pgfault_upcall>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
  800420d9fd:	55                   	push   %rbp
  800420d9fe:	48 89 e5             	mov    %rsp,%rbp
  800420da01:	48 83 ec 20          	sub    $0x20,%rsp
  800420da05:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420da08:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// LAB 4: Your code here.
	struct Env *env;
	if(envid2env(envid, &env, 1) < 0)
  800420da0c:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  800420da10:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420da13:	ba 01 00 00 00       	mov    $0x1,%edx
  800420da18:	48 89 ce             	mov    %rcx,%rsi
  800420da1b:	89 c7                	mov    %eax,%edi
  800420da1d:	48 b8 b3 7d 20 04 80 	movabs $0x8004207db3,%rax
  800420da24:	00 00 00 
  800420da27:	ff d0                	callq  *%rax
  800420da29:	85 c0                	test   %eax,%eax
  800420da2b:	79 07                	jns    800420da34 <sys_env_set_pgfault_upcall+0x37>
	  return -E_BAD_ENV;
  800420da2d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420da32:	eb 14                	jmp    800420da48 <sys_env_set_pgfault_upcall+0x4b>
	
	 env->env_pgfault_upcall = func;
  800420da34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420da38:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420da3c:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)
	 return 0;
  800420da43:	b8 00 00 00 00       	mov    $0x0,%eax
		

	//panic("sys_env_set_pgfault_upcall not implemented");
}
  800420da48:	c9                   	leaveq 
  800420da49:	c3                   	retq   

000000800420da4a <sys_page_alloc>:
//	-E_INVAL if perm is inappropriate (see above).
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  800420da4a:	55                   	push   %rbp
  800420da4b:	48 89 e5             	mov    %rsp,%rbp
  800420da4e:	48 83 ec 30          	sub    $0x30,%rsp
  800420da52:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420da55:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420da59:	89 55 d8             	mov    %edx,-0x28(%rbp)
	//   If page_insert() fails, remember to free the page you
	//   allocated!	
	
	// LAB 4: Your code here.
	struct Env *env;
	struct PageInfo *p = NULL;
  800420da5c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420da63:	00 
	int i;

	if((uintptr_t)va >= UTOP || ((uintptr_t)va)%PGSIZE!=0)
  800420da64:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420da68:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420da6f:	00 00 00 
  800420da72:	48 39 c2             	cmp    %rax,%rdx
  800420da75:	77 0e                	ja     800420da85 <sys_page_alloc+0x3b>
  800420da77:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420da7b:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420da80:	48 85 c0             	test   %rax,%rax
  800420da83:	74 0a                	je     800420da8f <sys_page_alloc+0x45>
	  return -E_INVAL;	
  800420da85:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420da8a:	e9 b6 00 00 00       	jmpq   800420db45 <sys_page_alloc+0xfb>
	
	if(!(perm & PTE_P) || !(perm & PTE_U))
  800420da8f:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420da92:	83 e0 01             	and    $0x1,%eax
  800420da95:	85 c0                	test   %eax,%eax
  800420da97:	74 0a                	je     800420daa3 <sys_page_alloc+0x59>
  800420da99:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420da9c:	83 e0 04             	and    $0x4,%eax
  800420da9f:	85 c0                	test   %eax,%eax
  800420daa1:	75 0a                	jne    800420daad <sys_page_alloc+0x63>
	   return -E_INVAL;
  800420daa3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420daa8:	e9 98 00 00 00       	jmpq   800420db45 <sys_page_alloc+0xfb>

	p = page_alloc(ALLOC_ZERO);
  800420daad:	bf 01 00 00 00       	mov    $0x1,%edi
  800420dab2:	48 b8 57 35 20 04 80 	movabs $0x8004203557,%rax
  800420dab9:	00 00 00 
  800420dabc:	ff d0                	callq  *%rax
  800420dabe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(p == NULL)
  800420dac2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420dac7:	75 07                	jne    800420dad0 <sys_page_alloc+0x86>
	  return -E_NO_MEM;
  800420dac9:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420dace:	eb 75                	jmp    800420db45 <sys_page_alloc+0xfb>

	i = envid2env(envid, &env, 1);
  800420dad0:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420dad4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420dad7:	ba 01 00 00 00       	mov    $0x1,%edx
  800420dadc:	48 89 ce             	mov    %rcx,%rsi
  800420dadf:	89 c7                	mov    %eax,%edi
  800420dae1:	48 b8 b3 7d 20 04 80 	movabs $0x8004207db3,%rax
  800420dae8:	00 00 00 
  800420daeb:	ff d0                	callq  *%rax
  800420daed:	89 45 f4             	mov    %eax,-0xc(%rbp)
	if(i != 0)
  800420daf0:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420daf4:	74 07                	je     800420dafd <sys_page_alloc+0xb3>
	  return -E_BAD_ENV;
  800420daf6:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420dafb:	eb 48                	jmp    800420db45 <sys_page_alloc+0xfb>
	else
	{
	  if(page_insert(env->env_pml4e, p, va,perm) < 0)
  800420dafd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420db01:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420db08:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  800420db0b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420db0f:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420db13:	48 89 c7             	mov    %rax,%rdi
  800420db16:	48 b8 1d 3d 20 04 80 	movabs $0x8004203d1d,%rax
  800420db1d:	00 00 00 
  800420db20:	ff d0                	callq  *%rax
  800420db22:	85 c0                	test   %eax,%eax
  800420db24:	79 1a                	jns    800420db40 <sys_page_alloc+0xf6>
	  {
	    page_free(p);
  800420db26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420db2a:	48 89 c7             	mov    %rax,%rdi
  800420db2d:	48 b8 1e 36 20 04 80 	movabs $0x800420361e,%rax
  800420db34:	00 00 00 
  800420db37:	ff d0                	callq  *%rax
	    return -E_NO_MEM;
  800420db39:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420db3e:	eb 05                	jmp    800420db45 <sys_page_alloc+0xfb>
	  }

	 return 0;
  800420db40:	b8 00 00 00 00       	mov    $0x0,%eax
	}
	
	
	//panic("sys_page_alloc not implemented");
}
  800420db45:	c9                   	leaveq 
  800420db46:	c3                   	retq   

000000800420db47 <sys_page_map>:
//		address space.
//	-E_NO_MEM if there's no memory to allocate any necessary page tables.
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
  800420db47:	55                   	push   %rbp
  800420db48:	48 89 e5             	mov    %rsp,%rbp
  800420db4b:	48 83 ec 40          	sub    $0x40,%rsp
  800420db4f:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420db52:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420db56:	89 55 d8             	mov    %edx,-0x28(%rbp)
  800420db59:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  800420db5d:	44 89 45 c4          	mov    %r8d,-0x3c(%rbp)
	//   Again, most of the new code you write should be to check the
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.
		
	if((uintptr_t)srcva >= UTOP || ((uintptr_t)srcva)%PGSIZE!=0 || (uintptr_t)dstva >= UTOP || ((uintptr_t)dstva)%PGSIZE!=0)
  800420db61:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420db65:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420db6c:	00 00 00 
  800420db6f:	48 39 c2             	cmp    %rax,%rdx
  800420db72:	77 2f                	ja     800420dba3 <sys_page_map+0x5c>
  800420db74:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420db78:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420db7d:	48 85 c0             	test   %rax,%rax
  800420db80:	75 21                	jne    800420dba3 <sys_page_map+0x5c>
  800420db82:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420db86:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420db8d:	00 00 00 
  800420db90:	48 39 c2             	cmp    %rax,%rdx
  800420db93:	77 0e                	ja     800420dba3 <sys_page_map+0x5c>
  800420db95:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420db99:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420db9e:	48 85 c0             	test   %rax,%rax
  800420dba1:	74 0a                	je     800420dbad <sys_page_map+0x66>
	  return -E_INVAL;
  800420dba3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420dba8:	e9 08 01 00 00       	jmpq   800420dcb5 <sys_page_map+0x16e>
	

	if(!(perm & PTE_P) || !(perm & PTE_U))
  800420dbad:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420dbb0:	83 e0 01             	and    $0x1,%eax
  800420dbb3:	85 c0                	test   %eax,%eax
  800420dbb5:	74 0a                	je     800420dbc1 <sys_page_map+0x7a>
  800420dbb7:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420dbba:	83 e0 04             	and    $0x4,%eax
  800420dbbd:	85 c0                	test   %eax,%eax
  800420dbbf:	75 0a                	jne    800420dbcb <sys_page_map+0x84>
	   return -E_INVAL;
  800420dbc1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420dbc6:	e9 ea 00 00 00       	jmpq   800420dcb5 <sys_page_map+0x16e>
	
	struct Env *env_src, *env_dst;

	if(envid2env(srcenvid, &env_src, 0) < 0)
  800420dbcb:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420dbcf:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420dbd2:	ba 00 00 00 00       	mov    $0x0,%edx
  800420dbd7:	48 89 ce             	mov    %rcx,%rsi
  800420dbda:	89 c7                	mov    %eax,%edi
  800420dbdc:	48 b8 b3 7d 20 04 80 	movabs $0x8004207db3,%rax
  800420dbe3:	00 00 00 
  800420dbe6:	ff d0                	callq  *%rax
  800420dbe8:	85 c0                	test   %eax,%eax
  800420dbea:	79 0a                	jns    800420dbf6 <sys_page_map+0xaf>
	  return -E_BAD_ENV;
  800420dbec:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420dbf1:	e9 bf 00 00 00       	jmpq   800420dcb5 <sys_page_map+0x16e>
	
	if(envid2env(dstenvid, &env_dst, 0) < 0)
  800420dbf6:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420dbfa:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420dbfd:	ba 00 00 00 00       	mov    $0x0,%edx
  800420dc02:	48 89 ce             	mov    %rcx,%rsi
  800420dc05:	89 c7                	mov    %eax,%edi
  800420dc07:	48 b8 b3 7d 20 04 80 	movabs $0x8004207db3,%rax
  800420dc0e:	00 00 00 
  800420dc11:	ff d0                	callq  *%rax
  800420dc13:	85 c0                	test   %eax,%eax
  800420dc15:	79 0a                	jns    800420dc21 <sys_page_map+0xda>
	  return -E_BAD_ENV;
  800420dc17:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420dc1c:	e9 94 00 00 00       	jmpq   800420dcb5 <sys_page_map+0x16e>

	struct PageInfo *p = NULL;
  800420dc21:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420dc28:	00 
	pte_t *pte;	
	p = page_lookup(env_src->env_pml4e, (void *)srcva, &pte);
  800420dc29:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dc2d:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420dc34:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  800420dc38:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420dc3c:	48 89 ce             	mov    %rcx,%rsi
  800420dc3f:	48 89 c7             	mov    %rax,%rdi
  800420dc42:	48 b8 43 3e 20 04 80 	movabs $0x8004203e43,%rax
  800420dc49:	00 00 00 
  800420dc4c:	ff d0                	callq  *%rax
  800420dc4e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if(p == NULL)
  800420dc52:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420dc57:	75 07                	jne    800420dc60 <sys_page_map+0x119>
	 return -E_NO_MEM;
  800420dc59:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420dc5e:	eb 55                	jmp    800420dcb5 <sys_page_map+0x16e>

	if((perm & PTE_W) && (!((*pte) & PTE_W)))
  800420dc60:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420dc63:	83 e0 02             	and    $0x2,%eax
  800420dc66:	85 c0                	test   %eax,%eax
  800420dc68:	74 16                	je     800420dc80 <sys_page_map+0x139>
  800420dc6a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dc6e:	48 8b 00             	mov    (%rax),%rax
  800420dc71:	83 e0 02             	and    $0x2,%eax
  800420dc74:	48 85 c0             	test   %rax,%rax
  800420dc77:	75 07                	jne    800420dc80 <sys_page_map+0x139>
	{
	    return -E_INVAL;
  800420dc79:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420dc7e:	eb 35                	jmp    800420dcb5 <sys_page_map+0x16e>
	}

	if(page_insert(env_dst->env_pml4e, p, dstva,perm) < 0)
  800420dc80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dc84:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420dc8b:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
  800420dc8e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420dc92:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420dc96:	48 89 c7             	mov    %rax,%rdi
  800420dc99:	48 b8 1d 3d 20 04 80 	movabs $0x8004203d1d,%rax
  800420dca0:	00 00 00 
  800420dca3:	ff d0                	callq  *%rax
  800420dca5:	85 c0                	test   %eax,%eax
  800420dca7:	79 07                	jns    800420dcb0 <sys_page_map+0x169>
	  return -E_NO_MEM;
  800420dca9:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420dcae:	eb 05                	jmp    800420dcb5 <sys_page_map+0x16e>
	 
	return 0;
  800420dcb0:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_page_map not implemented");
}
  800420dcb5:	c9                   	leaveq 
  800420dcb6:	c3                   	retq   

000000800420dcb7 <sys_page_unmap>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int
sys_page_unmap(envid_t envid, void *va)
{
  800420dcb7:	55                   	push   %rbp
  800420dcb8:	48 89 e5             	mov    %rsp,%rbp
  800420dcbb:	48 83 ec 30          	sub    $0x30,%rsp
  800420dcbf:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420dcc2:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	
	if((uintptr_t)va >= UTOP || ((uintptr_t)va)%PGSIZE!=0)
  800420dcc6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420dcca:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420dcd1:	00 00 00 
  800420dcd4:	48 39 c2             	cmp    %rax,%rdx
  800420dcd7:	77 0e                	ja     800420dce7 <sys_page_unmap+0x30>
  800420dcd9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420dcdd:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420dce2:	48 85 c0             	test   %rax,%rax
  800420dce5:	74 0a                	je     800420dcf1 <sys_page_unmap+0x3a>
	  return -E_INVAL;
  800420dce7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420dcec:	e9 8d 00 00 00       	jmpq   800420dd7e <sys_page_unmap+0xc7>
	
	struct Env *env;
	if(envid2env(envid, &env, 1) < 0)
  800420dcf1:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420dcf5:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420dcf8:	ba 01 00 00 00       	mov    $0x1,%edx
  800420dcfd:	48 89 ce             	mov    %rcx,%rsi
  800420dd00:	89 c7                	mov    %eax,%edi
  800420dd02:	48 b8 b3 7d 20 04 80 	movabs $0x8004207db3,%rax
  800420dd09:	00 00 00 
  800420dd0c:	ff d0                	callq  *%rax
  800420dd0e:	85 c0                	test   %eax,%eax
  800420dd10:	79 07                	jns    800420dd19 <sys_page_unmap+0x62>
	  return -E_BAD_ENV;
  800420dd12:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420dd17:	eb 65                	jmp    800420dd7e <sys_page_unmap+0xc7>

	//Silently succed situation
	struct PageInfo *p = NULL;
  800420dd19:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420dd20:	00 
	pte_t *pte;
	p = page_lookup(env->env_pml4e, (void *)va, &pte);
  800420dd21:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dd25:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420dd2c:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  800420dd30:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420dd34:	48 89 ce             	mov    %rcx,%rsi
  800420dd37:	48 89 c7             	mov    %rax,%rdi
  800420dd3a:	48 b8 43 3e 20 04 80 	movabs $0x8004203e43,%rax
  800420dd41:	00 00 00 
  800420dd44:	ff d0                	callq  *%rax
  800420dd46:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if(p == NULL)
  800420dd4a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420dd4f:	75 07                	jne    800420dd58 <sys_page_unmap+0xa1>
	 return 0;	
  800420dd51:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dd56:	eb 26                	jmp    800420dd7e <sys_page_unmap+0xc7>
		
	page_remove(env->env_pml4e, (void *)va);	
  800420dd58:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dd5c:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420dd63:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420dd67:	48 89 d6             	mov    %rdx,%rsi
  800420dd6a:	48 89 c7             	mov    %rax,%rdi
  800420dd6d:	48 b8 d8 3e 20 04 80 	movabs $0x8004203ed8,%rax
  800420dd74:	00 00 00 
  800420dd77:	ff d0                	callq  *%rax
	return 0;
  800420dd79:	b8 00 00 00 00       	mov    $0x0,%eax

	//panic("sys_page_unmap not implemented");
}
  800420dd7e:	c9                   	leaveq 
  800420dd7f:	c3                   	retq   

000000800420dd80 <sys_ipc_try_send>:
//		current environment's address space.
//	-E_NO_MEM if there's not enough memory to map srcva in envid's
//		address space.
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
  800420dd80:	55                   	push   %rbp
  800420dd81:	48 89 e5             	mov    %rsp,%rbp
  800420dd84:	53                   	push   %rbx
  800420dd85:	48 83 ec 48          	sub    $0x48,%rsp
  800420dd89:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420dd8c:	89 75 c8             	mov    %esi,-0x38(%rbp)
  800420dd8f:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420dd93:	89 4d bc             	mov    %ecx,-0x44(%rbp)

	struct Env *env; 
	
	if (envid2env(envid, &env, 0) < 0) 
  800420dd96:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420dd9a:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420dd9d:	ba 00 00 00 00       	mov    $0x0,%edx
  800420dda2:	48 89 ce             	mov    %rcx,%rsi
  800420dda5:	89 c7                	mov    %eax,%edi
  800420dda7:	48 b8 b3 7d 20 04 80 	movabs $0x8004207db3,%rax
  800420ddae:	00 00 00 
  800420ddb1:	ff d0                	callq  *%rax
  800420ddb3:	85 c0                	test   %eax,%eax
  800420ddb5:	79 0a                	jns    800420ddc1 <sys_ipc_try_send+0x41>
	  return -E_BAD_ENV;
  800420ddb7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420ddbc:	e9 4f 02 00 00       	jmpq   800420e010 <sys_ipc_try_send+0x290>

	if(env->env_ipc_recving != 1)
  800420ddc1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ddc5:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420ddcc:	83 f0 01             	xor    $0x1,%eax
  800420ddcf:	84 c0                	test   %al,%al
  800420ddd1:	74 0a                	je     800420dddd <sys_ipc_try_send+0x5d>
	    return -E_IPC_NOT_RECV;
  800420ddd3:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  800420ddd8:	e9 33 02 00 00       	jmpq   800420e010 <sys_ipc_try_send+0x290>
	
	pte_t *pte;
	struct PageInfo *p;
	
	if(srcva < (void *)UTOP && ((uintptr_t)srcva % PGSIZE != 0))
  800420dddd:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420dde4:	00 00 00 
  800420dde7:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  800420ddeb:	77 18                	ja     800420de05 <sys_ipc_try_send+0x85>
  800420dded:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420ddf1:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420ddf6:	48 85 c0             	test   %rax,%rax
  800420ddf9:	74 0a                	je     800420de05 <sys_ipc_try_send+0x85>
	  return -E_INVAL;
  800420ddfb:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420de00:	e9 0b 02 00 00       	jmpq   800420e010 <sys_ipc_try_send+0x290>

	if(srcva < (void *)UTOP)
  800420de05:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420de0c:	00 00 00 
  800420de0f:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  800420de13:	0f 87 7d 01 00 00    	ja     800420df96 <sys_ipc_try_send+0x216>
	{
	      
     	  if(!(perm & PTE_U) || !(perm & PTE_P)) 
  800420de19:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420de1c:	83 e0 04             	and    $0x4,%eax
  800420de1f:	85 c0                	test   %eax,%eax
  800420de21:	74 0a                	je     800420de2d <sys_ipc_try_send+0xad>
  800420de23:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420de26:	83 e0 01             	and    $0x1,%eax
  800420de29:	85 c0                	test   %eax,%eax
  800420de2b:	75 0a                	jne    800420de37 <sys_ipc_try_send+0xb7>
      	      return -E_INVAL;
  800420de2d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420de32:	e9 d9 01 00 00       	jmpq   800420e010 <sys_ipc_try_send+0x290>
   	
	  p = page_lookup(curenv->env_pml4e, srcva, &pte);
  800420de37:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420de3e:	00 00 00 
  800420de41:	ff d0                	callq  *%rax
  800420de43:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420de4a:	00 00 00 
  800420de4d:	48 98                	cltq   
  800420de4f:	48 c1 e0 03          	shl    $0x3,%rax
  800420de53:	48 89 c2             	mov    %rax,%rdx
  800420de56:	48 c1 e2 04          	shl    $0x4,%rdx
  800420de5a:	48 29 c2             	sub    %rax,%rdx
  800420de5d:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420de61:	48 83 c0 08          	add    $0x8,%rax
  800420de65:	48 8b 00             	mov    (%rax),%rax
  800420de68:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420de6f:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  800420de73:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420de77:	48 89 ce             	mov    %rcx,%rsi
  800420de7a:	48 89 c7             	mov    %rax,%rdi
  800420de7d:	48 b8 43 3e 20 04 80 	movabs $0x8004203e43,%rax
  800420de84:	00 00 00 
  800420de87:	ff d0                	callq  *%rax
  800420de89:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
   	  if(p == NULL)
  800420de8d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420de92:	75 2a                	jne    800420debe <sys_ipc_try_send+0x13e>
	    panic("page not present sys recevieve");
  800420de94:	48 ba 20 8d 21 04 80 	movabs $0x8004218d20,%rdx
  800420de9b:	00 00 00 
  800420de9e:	be 7f 01 00 00       	mov    $0x17f,%esi
  800420dea3:	48 bf 3f 8d 21 04 80 	movabs $0x8004218d3f,%rdi
  800420deaa:	00 00 00 
  800420dead:	b8 00 00 00 00       	mov    $0x0,%eax
  800420deb2:	48 b9 0b 05 20 04 80 	movabs $0x800420050b,%rcx
  800420deb9:	00 00 00 
  800420debc:	ff d1                	callq  *%rcx
   	
	  if(!pte || !((*pte) & PTE_P)) 
  800420debe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dec2:	48 85 c0             	test   %rax,%rax
  800420dec5:	74 0f                	je     800420ded6 <sys_ipc_try_send+0x156>
  800420dec7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420decb:	48 8b 00             	mov    (%rax),%rax
  800420dece:	83 e0 01             	and    $0x1,%eax
  800420ded1:	48 85 c0             	test   %rax,%rax
  800420ded4:	75 0a                	jne    800420dee0 <sys_ipc_try_send+0x160>
      	     return -E_INVAL;	   	
  800420ded6:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420dedb:	e9 30 01 00 00       	jmpq   800420e010 <sys_ipc_try_send+0x290>
	   	
   	  if(!((*pte) & PTE_W) && (perm & PTE_W)) 
  800420dee0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dee4:	48 8b 00             	mov    (%rax),%rax
  800420dee7:	83 e0 02             	and    $0x2,%eax
  800420deea:	48 85 c0             	test   %rax,%rax
  800420deed:	75 14                	jne    800420df03 <sys_ipc_try_send+0x183>
  800420deef:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420def2:	83 e0 02             	and    $0x2,%eax
  800420def5:	85 c0                	test   %eax,%eax
  800420def7:	74 0a                	je     800420df03 <sys_ipc_try_send+0x183>
      	     return -E_INVAL; 
  800420def9:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420defe:	e9 0d 01 00 00       	jmpq   800420e010 <sys_ipc_try_send+0x290>

	  if(env->env_ipc_dstva<(void*)UTOP)
  800420df03:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420df07:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420df0e:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420df15:	00 00 00 
  800420df18:	48 39 c2             	cmp    %rax,%rdx
  800420df1b:	77 69                	ja     800420df86 <sys_ipc_try_send+0x206>
           {
	    //if(sys_page_map(curenv->env_id,(void *)srcva,env->env_id,(void *)env->env_ipc_dstva, perm) < 0)
	    if(page_insert(env->env_pml4e, p, env->env_ipc_dstva, perm) < 0)
  800420df1d:	8b 4d bc             	mov    -0x44(%rbp),%ecx
  800420df20:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420df24:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420df2b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420df2f:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420df36:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420df3a:	48 89 c7             	mov    %rax,%rdi
  800420df3d:	48 b8 1d 3d 20 04 80 	movabs $0x8004203d1d,%rax
  800420df44:	00 00 00 
  800420df47:	ff d0                	callq  *%rax
  800420df49:	85 c0                	test   %eax,%eax
  800420df4b:	79 2a                	jns    800420df77 <sys_ipc_try_send+0x1f7>
	      panic("page map in send");	  
  800420df4d:	48 ba 4e 8d 21 04 80 	movabs $0x8004218d4e,%rdx
  800420df54:	00 00 00 
  800420df57:	be 8b 01 00 00       	mov    $0x18b,%esi
  800420df5c:	48 bf 3f 8d 21 04 80 	movabs $0x8004218d3f,%rdi
  800420df63:	00 00 00 
  800420df66:	b8 00 00 00 00       	mov    $0x0,%eax
  800420df6b:	48 b9 0b 05 20 04 80 	movabs $0x800420050b,%rcx
  800420df72:	00 00 00 
  800420df75:	ff d1                	callq  *%rcx
	  
	    env->env_ipc_perm = perm;
  800420df77:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420df7b:	8b 55 bc             	mov    -0x44(%rbp),%edx
  800420df7e:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
  800420df84:	eb 1e                	jmp    800420dfa4 <sys_ipc_try_send+0x224>
	  }
	  else
	   env->env_ipc_perm = 0;	 	  	
  800420df86:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420df8a:	c7 80 10 01 00 00 00 	movl   $0x0,0x110(%rax)
  800420df91:	00 00 00 
  800420df94:	eb 0e                	jmp    800420dfa4 <sys_ipc_try_send+0x224>
	}
	else
	 env->env_ipc_perm = 0;
  800420df96:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420df9a:	c7 80 10 01 00 00 00 	movl   $0x0,0x110(%rax)
  800420dfa1:	00 00 00 

	env->env_ipc_recving = 0;
  800420dfa4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dfa8:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)
	env->env_ipc_value = value;
  800420dfaf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dfb3:	8b 55 c8             	mov    -0x38(%rbp),%edx
  800420dfb6:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
	env->env_ipc_from = curenv->env_id;	
  800420dfbc:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420dfc0:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420dfc7:	00 00 00 
  800420dfca:	ff d0                	callq  *%rax
  800420dfcc:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420dfd3:	00 00 00 
  800420dfd6:	48 98                	cltq   
  800420dfd8:	48 c1 e0 03          	shl    $0x3,%rax
  800420dfdc:	48 89 c2             	mov    %rax,%rdx
  800420dfdf:	48 c1 e2 04          	shl    $0x4,%rdx
  800420dfe3:	48 29 c2             	sub    %rax,%rdx
  800420dfe6:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420dfea:	48 83 c0 08          	add    $0x8,%rax
  800420dfee:	48 8b 00             	mov    (%rax),%rax
  800420dff1:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420dff7:	89 83 0c 01 00 00    	mov    %eax,0x10c(%rbx)
	env->env_status = ENV_RUNNABLE;
  800420dffd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e001:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420e008:	00 00 00 
	return 0;
  800420e00b:	b8 00 00 00 00       	mov    $0x0,%eax

	//panic("sys_ipc_try_send not implemented");
	
}
  800420e010:	48 83 c4 48          	add    $0x48,%rsp
  800420e014:	5b                   	pop    %rbx
  800420e015:	5d                   	pop    %rbp
  800420e016:	c3                   	retq   

000000800420e017 <sys_ipc_recv>:
// return 0 on success.
// Return < 0 on error.  Errors are:
//	-E_INVAL if dstva < UTOP but dstva is not page-aligned.
static int
sys_ipc_recv(void *dstva)
{
  800420e017:	55                   	push   %rbp
  800420e018:	48 89 e5             	mov    %rsp,%rbp
  800420e01b:	48 83 ec 10          	sub    $0x10,%rsp
  800420e01f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// LAB 4: Your code here.
	 if(dstva<(void*)UTOP)
  800420e023:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e02a:	00 00 00 
  800420e02d:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800420e031:	0f 87 8f 00 00 00    	ja     800420e0c6 <sys_ipc_recv+0xaf>
        {
            if(((uintptr_t)dstva % PGSIZE) != 0)
  800420e037:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e03b:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420e040:	48 85 c0             	test   %rax,%rax
  800420e043:	74 0a                	je     800420e04f <sys_ipc_recv+0x38>
               return -E_INVAL;
  800420e045:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e04a:	e9 2f 01 00 00       	jmpq   800420e17e <sys_ipc_recv+0x167>

            curenv->env_ipc_dstva = dstva;
  800420e04f:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420e056:	00 00 00 
  800420e059:	ff d0                	callq  *%rax
  800420e05b:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420e062:	00 00 00 
  800420e065:	48 98                	cltq   
  800420e067:	48 c1 e0 03          	shl    $0x3,%rax
  800420e06b:	48 89 c2             	mov    %rax,%rdx
  800420e06e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e072:	48 29 c2             	sub    %rax,%rdx
  800420e075:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420e079:	48 83 c0 08          	add    $0x8,%rax
  800420e07d:	48 8b 00             	mov    (%rax),%rax
  800420e080:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420e084:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)
            curenv->env_ipc_perm = 0;
  800420e08b:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420e092:	00 00 00 
  800420e095:	ff d0                	callq  *%rax
  800420e097:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420e09e:	00 00 00 
  800420e0a1:	48 98                	cltq   
  800420e0a3:	48 c1 e0 03          	shl    $0x3,%rax
  800420e0a7:	48 89 c2             	mov    %rax,%rdx
  800420e0aa:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e0ae:	48 29 c2             	sub    %rax,%rdx
  800420e0b1:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420e0b5:	48 83 c0 08          	add    $0x8,%rax
  800420e0b9:	48 8b 00             	mov    (%rax),%rax
  800420e0bc:	c7 80 10 01 00 00 00 	movl   $0x0,0x110(%rax)
  800420e0c3:	00 00 00 
        }

        curenv->env_ipc_recving = 1;
  800420e0c6:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420e0cd:	00 00 00 
  800420e0d0:	ff d0                	callq  *%rax
  800420e0d2:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420e0d9:	00 00 00 
  800420e0dc:	48 98                	cltq   
  800420e0de:	48 c1 e0 03          	shl    $0x3,%rax
  800420e0e2:	48 89 c2             	mov    %rax,%rdx
  800420e0e5:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e0e9:	48 29 c2             	sub    %rax,%rdx
  800420e0ec:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420e0f0:	48 83 c0 08          	add    $0x8,%rax
  800420e0f4:	48 8b 00             	mov    (%rax),%rax
  800420e0f7:	c6 80 f8 00 00 00 01 	movb   $0x1,0xf8(%rax)
        curenv->env_status = ENV_NOT_RUNNABLE;
  800420e0fe:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420e105:	00 00 00 
  800420e108:	ff d0                	callq  *%rax
  800420e10a:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420e111:	00 00 00 
  800420e114:	48 98                	cltq   
  800420e116:	48 c1 e0 03          	shl    $0x3,%rax
  800420e11a:	48 89 c2             	mov    %rax,%rdx
  800420e11d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e121:	48 29 c2             	sub    %rax,%rdx
  800420e124:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420e128:	48 83 c0 08          	add    $0x8,%rax
  800420e12c:	48 8b 00             	mov    (%rax),%rax
  800420e12f:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420e136:	00 00 00 
        curenv->env_tf.tf_regs.reg_rax =  0;
  800420e139:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420e140:	00 00 00 
  800420e143:	ff d0                	callq  *%rax
  800420e145:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420e14c:	00 00 00 
  800420e14f:	48 98                	cltq   
  800420e151:	48 c1 e0 03          	shl    $0x3,%rax
  800420e155:	48 89 c2             	mov    %rax,%rdx
  800420e158:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e15c:	48 29 c2             	sub    %rax,%rdx
  800420e15f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420e163:	48 83 c0 08          	add    $0x8,%rax
  800420e167:	48 8b 00             	mov    (%rax),%rax
  800420e16a:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420e171:	00 
        sched_yield();
  800420e172:	48 b8 61 d2 20 04 80 	movabs $0x800420d261,%rax
  800420e179:	00 00 00 
  800420e17c:	ff d0                	callq  *%rax

        return 0;
}
  800420e17e:	c9                   	leaveq 
  800420e17f:	c3                   	retq   

000000800420e180 <syscall>:


// Dispatches to the correct kernel function, passing the arguments.
int64_t
syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420e180:	55                   	push   %rbp
  800420e181:	48 89 e5             	mov    %rsp,%rbp
  800420e184:	48 83 ec 40          	sub    $0x40,%rsp
  800420e188:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e18c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420e190:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420e194:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  800420e198:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
  800420e19c:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
	// Return any appropriate return value.
	// LAB 3: Your code here.
	
	//int64_t val = -E_INVAL;
	//cprintf("\n\n %16.x syscallno\n", syscallno);
	int64_t val = -E_INVAL;
  800420e1a0:	48 c7 45 f8 fd ff ff 	movq   $0xfffffffffffffffd,-0x8(%rbp)
  800420e1a7:	ff 

	if(syscallno == SYS_cputs)
  800420e1a8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e1ad:	75 22                	jne    800420e1d1 <syscall+0x51>
	{
	    sys_cputs((char *)a1,(size_t)a2);
  800420e1af:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e1b3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420e1b7:	48 89 d6             	mov    %rdx,%rsi
  800420e1ba:	48 89 c7             	mov    %rax,%rdi
  800420e1bd:	48 b8 79 d6 20 04 80 	movabs $0x800420d679,%rax
  800420e1c4:	00 00 00 
  800420e1c7:	ff d0                	callq  *%rax
	    val = 0;
  800420e1c9:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420e1d0:	00 
	}

	if(syscallno == SYS_cgetc)
  800420e1d1:	48 83 7d e8 01       	cmpq   $0x1,-0x18(%rbp)
  800420e1d6:	75 12                	jne    800420e1ea <syscall+0x6a>
	    val = (int64_t)sys_cgetc();
  800420e1d8:	48 b8 fe d6 20 04 80 	movabs $0x800420d6fe,%rax
  800420e1df:	00 00 00 
  800420e1e2:	ff d0                	callq  *%rax
  800420e1e4:	48 98                	cltq   
  800420e1e6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if(syscallno == SYS_getenvid)
  800420e1ea:	48 83 7d e8 02       	cmpq   $0x2,-0x18(%rbp)
  800420e1ef:	75 12                	jne    800420e203 <syscall+0x83>
	   val = (int64_t)sys_getenvid();
  800420e1f1:	48 b8 10 d7 20 04 80 	movabs $0x800420d710,%rax
  800420e1f8:	00 00 00 
  800420e1fb:	ff d0                	callq  *%rax
  800420e1fd:	48 98                	cltq   
  800420e1ff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if(syscallno == SYS_env_destroy)
  800420e203:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  800420e208:	75 18                	jne    800420e222 <syscall+0xa2>
	  val = (int64_t)sys_env_destroy((envid_t)a1);
  800420e20a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e20e:	89 c7                	mov    %eax,%edi
  800420e210:	48 b8 4d d7 20 04 80 	movabs $0x800420d74d,%rax
  800420e217:	00 00 00 
  800420e21a:	ff d0                	callq  *%rax
  800420e21c:	48 98                	cltq   
  800420e21e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if(syscallno == SYS_yield)
  800420e222:	48 83 7d e8 0a       	cmpq   $0xa,-0x18(%rbp)
  800420e227:	75 14                	jne    800420e23d <syscall+0xbd>
	{
	  sys_yield();
  800420e229:	48 b8 96 d8 20 04 80 	movabs $0x800420d896,%rax
  800420e230:	00 00 00 
  800420e233:	ff d0                	callq  *%rax
	  val = 0;
  800420e235:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420e23c:	00 
	} 

	if(syscallno == SYS_exofork)
  800420e23d:	48 83 7d e8 07       	cmpq   $0x7,-0x18(%rbp)
  800420e242:	75 12                	jne    800420e256 <syscall+0xd6>
	   val = (int64_t)sys_exofork();
  800420e244:	48 b8 a6 d8 20 04 80 	movabs $0x800420d8a6,%rax
  800420e24b:	00 00 00 
  800420e24e:	ff d0                	callq  *%rax
  800420e250:	48 98                	cltq   
  800420e252:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if(syscallno == SYS_env_set_status)
  800420e256:	48 83 7d e8 08       	cmpq   $0x8,-0x18(%rbp)
  800420e25b:	75 20                	jne    800420e27d <syscall+0xfd>
	   val = (int64_t)sys_env_set_status((envid_t)a1,(uint64_t)a2);
  800420e25d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e261:	89 c2                	mov    %eax,%edx
  800420e263:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e267:	89 d6                	mov    %edx,%esi
  800420e269:	89 c7                	mov    %eax,%edi
  800420e26b:	48 b8 95 d9 20 04 80 	movabs $0x800420d995,%rax
  800420e272:	00 00 00 
  800420e275:	ff d0                	callq  *%rax
  800420e277:	48 98                	cltq   
  800420e279:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if(syscallno == SYS_page_alloc)
  800420e27d:	48 83 7d e8 04       	cmpq   $0x4,-0x18(%rbp)
  800420e282:	75 25                	jne    800420e2a9 <syscall+0x129>
	   val = (int64_t)sys_page_alloc((envid_t)a1,(uint64_t *)a2,(int)a3);
  800420e284:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e288:	89 c2                	mov    %eax,%edx
  800420e28a:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420e28e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e292:	48 89 ce             	mov    %rcx,%rsi
  800420e295:	89 c7                	mov    %eax,%edi
  800420e297:	48 b8 4a da 20 04 80 	movabs $0x800420da4a,%rax
  800420e29e:	00 00 00 
  800420e2a1:	ff d0                	callq  *%rax
  800420e2a3:	48 98                	cltq   
  800420e2a5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if(syscallno == SYS_page_map)
  800420e2a9:	48 83 7d e8 05       	cmpq   $0x5,-0x18(%rbp)
  800420e2ae:	75 2f                	jne    800420e2df <syscall+0x15f>
	   val = (int64_t)sys_page_map((envid_t)a1,(uint64_t *)a2,(envid_t)a3,(uint64_t *)a4,(int)a5);
  800420e2b0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420e2b4:	89 c7                	mov    %eax,%edi
  800420e2b6:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800420e2ba:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e2be:	89 c2                	mov    %eax,%edx
  800420e2c0:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420e2c4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e2c8:	41 89 f8             	mov    %edi,%r8d
  800420e2cb:	89 c7                	mov    %eax,%edi
  800420e2cd:	48 b8 47 db 20 04 80 	movabs $0x800420db47,%rax
  800420e2d4:	00 00 00 
  800420e2d7:	ff d0                	callq  *%rax
  800420e2d9:	48 98                	cltq   
  800420e2db:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if(syscallno == SYS_page_unmap)
  800420e2df:	48 83 7d e8 06       	cmpq   $0x6,-0x18(%rbp)
  800420e2e4:	75 1f                	jne    800420e305 <syscall+0x185>
	   val = (int64_t)sys_page_unmap((envid_t)a1,(uint64_t *)a2);
  800420e2e6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420e2ea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e2ee:	48 89 d6             	mov    %rdx,%rsi
  800420e2f1:	89 c7                	mov    %eax,%edi
  800420e2f3:	48 b8 b7 dc 20 04 80 	movabs $0x800420dcb7,%rax
  800420e2fa:	00 00 00 
  800420e2fd:	ff d0                	callq  *%rax
  800420e2ff:	48 98                	cltq   
  800420e301:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if(syscallno == SYS_env_set_pgfault_upcall)
  800420e305:	48 83 7d e8 09       	cmpq   $0x9,-0x18(%rbp)
  800420e30a:	75 1f                	jne    800420e32b <syscall+0x1ab>
	    val = (int64_t)sys_env_set_pgfault_upcall((envid_t)a1,(void *)a2);
  800420e30c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420e310:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e314:	48 89 d6             	mov    %rdx,%rsi
  800420e317:	89 c7                	mov    %eax,%edi
  800420e319:	48 b8 fd d9 20 04 80 	movabs $0x800420d9fd,%rax
  800420e320:	00 00 00 
  800420e323:	ff d0                	callq  *%rax
  800420e325:	48 98                	cltq   
  800420e327:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if(syscallno == SYS_ipc_try_send)
  800420e32b:	48 83 7d e8 0b       	cmpq   $0xb,-0x18(%rbp)
  800420e330:	75 28                	jne    800420e35a <syscall+0x1da>
	    val = (int64_t)sys_ipc_try_send((envid_t)a1,(uint32_t)a2,(void *)a3,(unsigned)a4);
  800420e332:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e336:	89 c1                	mov    %eax,%ecx
  800420e338:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e33c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e340:	89 c6                	mov    %eax,%esi
  800420e342:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e346:	89 c7                	mov    %eax,%edi
  800420e348:	48 b8 80 dd 20 04 80 	movabs $0x800420dd80,%rax
  800420e34f:	00 00 00 
  800420e352:	ff d0                	callq  *%rax
  800420e354:	48 98                	cltq   
  800420e356:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if(syscallno == SYS_ipc_recv)
  800420e35a:	48 83 7d e8 0c       	cmpq   $0xc,-0x18(%rbp)
  800420e35f:	75 19                	jne    800420e37a <syscall+0x1fa>
	   val = (int64_t)sys_ipc_recv((void *)a1);
  800420e361:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e365:	48 89 c7             	mov    %rax,%rdi
  800420e368:	48 b8 17 e0 20 04 80 	movabs $0x800420e017,%rax
  800420e36f:	00 00 00 
  800420e372:	ff d0                	callq  *%rax
  800420e374:	48 98                	cltq   
  800420e376:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	
	return val;
  800420e37a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	default:
		val = -E_NO_SYS;
	}
	return val;*/

}
  800420e37e:	c9                   	leaveq 
  800420e37f:	c3                   	retq   

000000800420e380 <list_func_die>:
	const char *stabstr;
	const char *stabstr_end;
};

int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420e380:	55                   	push   %rbp
  800420e381:	48 89 e5             	mov    %rsp,%rbp
  800420e384:	48 81 ec a0 61 00 00 	sub    $0x61a0,%rsp
  800420e38b:	48 89 bd a8 9e ff ff 	mov    %rdi,-0x6158(%rbp)
  800420e392:	48 89 b5 a0 9e ff ff 	mov    %rsi,-0x6160(%rbp)
  800420e399:	48 89 95 98 9e ff ff 	mov    %rdx,-0x6168(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420e3a0:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420e3a7:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420e3ae:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420e3b2:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420e3b9:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420e3c0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420e3c4:	48 8b 95 a0 9e ff ff 	mov    -0x6160(%rbp),%rdx
  800420e3cb:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420e3d2:	48 89 d1             	mov    %rdx,%rcx
  800420e3d5:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420e3da:	48 89 ce             	mov    %rcx,%rsi
  800420e3dd:	48 89 c7             	mov    %rax,%rdi
  800420e3e0:	48 b8 55 fd 20 04 80 	movabs $0x800420fd55,%rax
  800420e3e7:	00 00 00 
  800420e3ea:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420e3ec:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420e3f3:	00 
	
	if(die->die_tag != DW_TAG_subprogram)
  800420e3f4:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420e3fb:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420e3ff:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420e403:	74 0a                	je     800420e40f <list_func_die+0x8f>
		return 0;
  800420e405:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e40a:	e9 da 04 00 00       	jmpq   800420e8e9 <list_func_die+0x569>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420e40f:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420e413:	ba 38 00 00 00       	mov    $0x38,%edx
  800420e418:	be 00 00 00 00       	mov    $0x0,%esi
  800420e41d:	48 89 c7             	mov    %rax,%rdi
  800420e420:	48 b8 b3 fb 20 04 80 	movabs $0x800420fbb3,%rax
  800420e427:	00 00 00 
  800420e42a:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420e42c:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420e433:	be 11 00 00 00       	mov    $0x11,%esi
  800420e438:	48 89 c7             	mov    %rax,%rdi
  800420e43b:	48 b8 e8 1a 21 04 80 	movabs $0x8004211ae8,%rax
  800420e442:	00 00 00 
  800420e445:	ff d0                	callq  *%rax
  800420e447:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420e44b:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420e452:	be 12 00 00 00       	mov    $0x12,%esi
  800420e457:	48 89 c7             	mov    %rax,%rdi
  800420e45a:	48 b8 e8 1a 21 04 80 	movabs $0x8004211ae8,%rax
  800420e461:	00 00 00 
  800420e464:	ff d0                	callq  *%rax
  800420e466:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	if((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420e46a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420e46f:	0f 84 6f 04 00 00    	je     800420e8e4 <list_func_die+0x564>
  800420e475:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e479:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e47d:	48 3b 85 98 9e ff ff 	cmp    -0x6168(%rbp),%rax
  800420e484:	0f 83 5a 04 00 00    	jae    800420e8e4 <list_func_die+0x564>
  800420e48a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420e48f:	0f 84 4f 04 00 00    	je     800420e8e4 <list_func_die+0x564>
  800420e495:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e499:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e49d:	48 3b 85 98 9e ff ff 	cmp    -0x6168(%rbp),%rax
  800420e4a4:	0f 86 3a 04 00 00    	jbe    800420e8e4 <list_func_die+0x564>
	{
		info->rip_file = die->cu_die->die_name;
  800420e4aa:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420e4b1:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420e4b8:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420e4bf:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420e4c6:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420e4c9:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420e4d0:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420e4d7:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420e4de:	48 89 50 10          	mov    %rdx,0x10(%rax)
        info->rip_fn_namelen = strlen(die->die_name);
  800420e4e2:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420e4e9:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420e4f0:	48 89 c7             	mov    %rax,%rdi
  800420e4f3:	48 b8 ae f8 20 04 80 	movabs $0x800420f8ae,%rax
  800420e4fa:	00 00 00 
  800420e4fd:	ff d0                	callq  *%rax
  800420e4ff:	48 8b 95 a8 9e ff ff 	mov    -0x6158(%rbp),%rdx
  800420e506:	89 42 18             	mov    %eax,0x18(%rdx)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420e509:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e50d:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420e511:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420e518:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420e51c:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420e523:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420e52a:	48 85 c0             	test   %rax,%rax
  800420e52d:	75 35                	jne    800420e564 <list_func_die+0x1e4>
  800420e52f:	48 b9 98 90 21 04 80 	movabs $0x8004219098,%rcx
  800420e536:	00 00 00 
  800420e539:	48 ba a4 90 21 04 80 	movabs $0x80042190a4,%rdx
  800420e540:	00 00 00 
  800420e543:	be 72 00 00 00       	mov    $0x72,%esi
  800420e548:	48 bf b9 90 21 04 80 	movabs $0x80042190b9,%rdi
  800420e54f:	00 00 00 
  800420e552:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e557:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420e55e:	00 00 00 
  800420e561:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420e564:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420e56b:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420e572:	48 8b 95 98 9e ff ff 	mov    -0x6168(%rbp),%rdx
  800420e579:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800420e57d:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420e582:	48 89 c7             	mov    %rax,%rdi
  800420e585:	48 b8 35 51 21 04 80 	movabs $0x8004215135,%rax
  800420e58c:	00 00 00 
  800420e58f:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420e591:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e595:	89 c2                	mov    %eax,%edx
  800420e597:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420e59e:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420e5a1:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420e5a8:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420e5af:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  800420e5b6:	00 00 00 
  800420e5b9:	48 8b 00             	mov    (%rax),%rax
  800420e5bc:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420e5c3:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420e5ca:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420e5ce:	48 89 c7             	mov    %rax,%rdi
  800420e5d1:	48 b8 bf 1d 21 04 80 	movabs $0x8004211dbf,%rax
  800420e5d8:	00 00 00 
  800420e5db:	ff d0                	callq  *%rax
  800420e5dd:	83 f8 04             	cmp    $0x4,%eax
  800420e5e0:	0f 84 f7 02 00 00    	je     800420e8dd <list_func_die+0x55d>
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
  800420e5e6:	48 8b 85 38 cf ff ff 	mov    -0x30c8(%rbp),%rax
  800420e5ed:	48 83 f8 05          	cmp    $0x5,%rax
  800420e5f1:	74 05                	je     800420e5f8 <list_func_die+0x278>
				goto last;
  800420e5f3:	e9 e5 02 00 00       	jmpq   800420e8dd <list_func_die+0x55d>

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420e5f8:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420e5ff:	be 49 00 00 00       	mov    $0x49,%esi
  800420e604:	48 89 c7             	mov    %rax,%rdi
  800420e607:	48 b8 e8 1a 21 04 80 	movabs $0x8004211ae8,%rax
  800420e60e:	00 00 00 
  800420e611:	ff d0                	callq  *%rax
  800420e613:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	
try_again:
			if(attr != NULL)
  800420e617:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420e61c:	0f 84 d7 00 00 00    	je     800420e6f9 <list_func_die+0x379>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420e622:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e626:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420e62a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e62e:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e632:	48 01 d0             	add    %rdx,%rax
  800420e635:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420e639:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  800420e640:	00 00 00 
  800420e643:	48 8b 08             	mov    (%rax),%rcx
  800420e646:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420e64d:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  800420e651:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e655:	48 8b 38             	mov    (%rax),%rdi
  800420e658:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420e65c:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420e660:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420e665:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420e669:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420e66e:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420e672:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420e677:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420e67b:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420e680:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420e684:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420e689:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420e68d:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420e692:	48 89 cf             	mov    %rcx,%rdi
  800420e695:	48 b8 e5 19 21 04 80 	movabs $0x80042119e5,%rax
  800420e69c:	00 00 00 
  800420e69f:	ff d0                	callq  *%rax
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420e6a1:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420e6a8:	be 0b 00 00 00       	mov    $0xb,%esi
  800420e6ad:	48 89 c7             	mov    %rax,%rdi
  800420e6b0:	48 b8 e8 1a 21 04 80 	movabs $0x8004211ae8,%rax
  800420e6b7:	00 00 00 
  800420e6ba:	ff d0                	callq  *%rax
  800420e6bc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		
				if(attr != NULL)
  800420e6c0:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420e6c5:	74 0e                	je     800420e6d5 <list_func_die+0x355>
				{
					ret_val = attr->u[0].u64;
  800420e6c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e6cb:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e6cf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e6d3:	eb 24                	jmp    800420e6f9 <list_func_die+0x379>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420e6d5:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420e6dc:	be 49 00 00 00       	mov    $0x49,%esi
  800420e6e1:	48 89 c7             	mov    %rax,%rdi
  800420e6e4:	48 b8 e8 1a 21 04 80 	movabs $0x8004211ae8,%rax
  800420e6eb:	00 00 00 
  800420e6ee:	ff d0                	callq  *%rax
  800420e6f0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
					goto try_again;
  800420e6f4:	e9 1e ff ff ff       	jmpq   800420e617 <list_func_die+0x297>
				}
			}
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420e6f9:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420e700:	8b 48 28             	mov    0x28(%rax),%ecx
  800420e703:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e707:	89 c2                	mov    %eax,%edx
  800420e709:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420e710:	48 63 c9             	movslq %ecx,%rcx
  800420e713:	48 83 c1 08          	add    $0x8,%rcx
  800420e717:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
			info->rip_fn_narg++;
  800420e71b:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420e722:	8b 40 28             	mov    0x28(%rax),%eax
  800420e725:	8d 50 01             	lea    0x1(%rax),%edx
  800420e728:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420e72f:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420e732:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420e739:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420e740:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420e745:	48 89 ce             	mov    %rcx,%rsi
  800420e748:	48 89 c7             	mov    %rax,%rdi
  800420e74b:	48 b8 55 fd 20 04 80 	movabs $0x800420fd55,%rax
  800420e752:	00 00 00 
  800420e755:	ff d0                	callq  *%rax

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420e757:	e9 4b 01 00 00       	jmpq   800420e8a7 <list_func_die+0x527>
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
  800420e75c:	48 8b 85 38 cf ff ff 	mov    -0x30c8(%rbp),%rax
  800420e763:	48 83 f8 05          	cmp    $0x5,%rax
  800420e767:	74 05                	je     800420e76e <list_func_die+0x3ee>
					break;
  800420e769:	e9 6f 01 00 00       	jmpq   800420e8dd <list_func_die+0x55d>

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420e76e:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420e775:	be 49 00 00 00       	mov    $0x49,%esi
  800420e77a:	48 89 c7             	mov    %rax,%rdi
  800420e77d:	48 b8 e8 1a 21 04 80 	movabs $0x8004211ae8,%rax
  800420e784:	00 00 00 
  800420e787:	ff d0                	callq  *%rax
  800420e789:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    
   		        if(attr != NULL)
  800420e78d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420e792:	0f 84 b1 00 00 00    	je     800420e849 <list_func_die+0x4c9>
            	{	   
                	offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420e798:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e79c:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420e7a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e7a4:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e7a8:	48 01 d0             	add    %rdx,%rax
  800420e7ab:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                	dwarf_offdie(dbg, offset, &sib, *cu);
  800420e7af:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  800420e7b6:	00 00 00 
  800420e7b9:	48 8b 08             	mov    (%rax),%rcx
  800420e7bc:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420e7c3:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  800420e7c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e7cb:	48 8b 38             	mov    (%rax),%rdi
  800420e7ce:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420e7d2:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420e7d6:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420e7db:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420e7df:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420e7e4:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420e7e8:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420e7ed:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420e7f1:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420e7f6:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420e7fa:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420e7ff:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420e803:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420e808:	48 89 cf             	mov    %rcx,%rdi
  800420e80b:	48 b8 e5 19 21 04 80 	movabs $0x80042119e5,%rax
  800420e812:	00 00 00 
  800420e815:	ff d0                	callq  *%rax
                	attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420e817:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420e81e:	be 0b 00 00 00       	mov    $0xb,%esi
  800420e823:	48 89 c7             	mov    %rax,%rdi
  800420e826:	48 b8 e8 1a 21 04 80 	movabs $0x8004211ae8,%rax
  800420e82d:	00 00 00 
  800420e830:	ff d0                	callq  *%rax
  800420e832:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        
       		        if(attr != NULL)
  800420e836:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420e83b:	74 0c                	je     800420e849 <list_func_die+0x4c9>
                	{
                    	ret_val = attr->u[0].u64;
  800420e83d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e841:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e845:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                	}
            	}
	
				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420e849:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420e850:	8b 48 28             	mov    0x28(%rax),%ecx
  800420e853:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e857:	89 c2                	mov    %eax,%edx
  800420e859:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420e860:	48 63 c9             	movslq %ecx,%rcx
  800420e863:	48 83 c1 08          	add    $0x8,%rcx
  800420e867:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
				info->rip_fn_narg++;
  800420e86b:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420e872:	8b 40 28             	mov    0x28(%rax),%eax
  800420e875:	8d 50 01             	lea    0x1(%rax),%edx
  800420e878:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420e87f:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420e882:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420e889:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420e890:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420e895:	48 89 ce             	mov    %rcx,%rsi
  800420e898:	48 89 c7             	mov    %rax,%rdi
  800420e89b:	48 b8 55 fd 20 04 80 	movabs $0x800420fd55,%rax
  800420e8a2:	00 00 00 
  800420e8a5:	ff d0                	callq  *%rax
			}
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
			info->rip_fn_narg++;
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420e8a7:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  800420e8ae:	00 00 00 
  800420e8b1:	48 8b 00             	mov    (%rax),%rax
  800420e8b4:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420e8b8:	48 8d 95 20 cf ff ff 	lea    -0x30e0(%rbp),%rdx
  800420e8bf:	48 8d b5 b0 9e ff ff 	lea    -0x6150(%rbp),%rsi
  800420e8c6:	48 89 c7             	mov    %rax,%rdi
  800420e8c9:	48 b8 7b 1b 21 04 80 	movabs $0x8004211b7b,%rax
  800420e8d0:	00 00 00 
  800420e8d3:	ff d0                	callq  *%rax
  800420e8d5:	85 c0                	test   %eax,%eax
  800420e8d7:	0f 84 7f fe ff ff    	je     800420e75c <list_func_die+0x3dc>
				info->rip_fn_narg++;
				sib = ret; 
			}
		}
last:	
		return 1;
  800420e8dd:	b8 01 00 00 00       	mov    $0x1,%eax
  800420e8e2:	eb 05                	jmp    800420e8e9 <list_func_die+0x569>
	}

	return 0;
  800420e8e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420e8e9:	c9                   	leaveq 
  800420e8ea:	c3                   	retq   

000000800420e8eb <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420e8eb:	55                   	push   %rbp
  800420e8ec:	48 89 e5             	mov    %rsp,%rbp
  800420e8ef:	53                   	push   %rbx
  800420e8f0:	48 81 ec c8 91 00 00 	sub    $0x91c8,%rsp
  800420e8f7:	48 89 bd 38 6e ff ff 	mov    %rdi,-0x91c8(%rbp)
  800420e8fe:	48 89 b5 30 6e ff ff 	mov    %rsi,-0x91d0(%rbp)
    static struct Env* lastenv = NULL;
    void* elf;    
    Dwarf_Section *sect;
    Dwarf_CU cu;
    Dwarf_Die die, cudie, die2;
    Dwarf_Regtable *rt = NULL;
  800420e905:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420e90c:	00 
    //Set up initial pc
    uint64_t pc  = (uintptr_t)addr;
  800420e90d:	48 8b 85 38 6e ff ff 	mov    -0x91c8(%rbp),%rax
  800420e914:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    
    // Initialize *info
    info->rip_file = "<unknown>";
  800420e918:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e91f:	48 bb c7 90 21 04 80 	movabs $0x80042190c7,%rbx
  800420e926:	00 00 00 
  800420e929:	48 89 18             	mov    %rbx,(%rax)
    info->rip_line = 0;
  800420e92c:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e933:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
    info->rip_fn_name = "<unknown>";
  800420e93a:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e941:	48 bb c7 90 21 04 80 	movabs $0x80042190c7,%rbx
  800420e948:	00 00 00 
  800420e94b:	48 89 58 10          	mov    %rbx,0x10(%rax)
    info->rip_fn_namelen = 9;
  800420e94f:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e956:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
    info->rip_fn_addr = addr;
  800420e95d:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e964:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420e96b:	48 89 50 20          	mov    %rdx,0x20(%rax)
    info->rip_fn_narg = 0;
  800420e96f:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e976:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
    // Find the relevant set of stabs
    if (addr >= ULIM) {
  800420e97d:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420e984:	00 00 00 
  800420e987:	48 39 85 38 6e ff ff 	cmp    %rax,-0x91c8(%rbp)
  800420e98e:	76 13                	jbe    800420e9a3 <debuginfo_rip+0xb8>
	    elf = (void *)0x10000 + KERNBASE;
  800420e990:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800420e997:	00 00 00 
  800420e99a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420e99e:	e9 08 01 00 00       	jmpq   800420eaab <debuginfo_rip+0x1c0>
    } else {
	    if(curenv != lastenv) {
  800420e9a3:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420e9aa:	00 00 00 
  800420e9ad:	ff d0                	callq  *%rax
  800420e9af:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420e9b6:	00 00 00 
  800420e9b9:	48 98                	cltq   
  800420e9bb:	48 c1 e0 03          	shl    $0x3,%rax
  800420e9bf:	48 89 c2             	mov    %rax,%rdx
  800420e9c2:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e9c6:	48 29 c2             	sub    %rax,%rdx
  800420e9c9:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420e9cd:	48 83 c0 08          	add    $0x8,%rax
  800420e9d1:	48 8b 10             	mov    (%rax),%rdx
  800420e9d4:	48 b8 10 13 36 04 80 	movabs $0x8004361310,%rax
  800420e9db:	00 00 00 
  800420e9de:	48 8b 00             	mov    (%rax),%rax
  800420e9e1:	48 39 c2             	cmp    %rax,%rdx
  800420e9e4:	0f 84 85 00 00 00    	je     800420ea6f <debuginfo_rip+0x184>
		    find_debug_sections((uintptr_t)curenv->elf);
  800420e9ea:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420e9f1:	00 00 00 
  800420e9f4:	ff d0                	callq  *%rax
  800420e9f6:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420e9fd:	00 00 00 
  800420ea00:	48 98                	cltq   
  800420ea02:	48 c1 e0 03          	shl    $0x3,%rax
  800420ea06:	48 89 c2             	mov    %rax,%rdx
  800420ea09:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ea0d:	48 29 c2             	sub    %rax,%rdx
  800420ea10:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ea14:	48 83 c0 08          	add    $0x8,%rax
  800420ea18:	48 8b 00             	mov    (%rax),%rax
  800420ea1b:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420ea22:	48 89 c7             	mov    %rax,%rdi
  800420ea25:	48 b8 30 53 21 04 80 	movabs $0x8004215330,%rax
  800420ea2c:	00 00 00 
  800420ea2f:	ff d0                	callq  *%rax
		    lastenv = curenv;
  800420ea31:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420ea38:	00 00 00 
  800420ea3b:	ff d0                	callq  *%rax
  800420ea3d:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420ea44:	00 00 00 
  800420ea47:	48 98                	cltq   
  800420ea49:	48 c1 e0 03          	shl    $0x3,%rax
  800420ea4d:	48 89 c2             	mov    %rax,%rdx
  800420ea50:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ea54:	48 29 c2             	sub    %rax,%rdx
  800420ea57:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ea5b:	48 83 c0 08          	add    $0x8,%rax
  800420ea5f:	48 8b 10             	mov    (%rax),%rdx
  800420ea62:	48 b8 10 13 36 04 80 	movabs $0x8004361310,%rax
  800420ea69:	00 00 00 
  800420ea6c:	48 89 10             	mov    %rdx,(%rax)
	    }
	    elf = curenv->elf;
  800420ea6f:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800420ea76:	00 00 00 
  800420ea79:	ff d0                	callq  *%rax
  800420ea7b:	48 b9 20 30 36 04 80 	movabs $0x8004363020,%rcx
  800420ea82:	00 00 00 
  800420ea85:	48 98                	cltq   
  800420ea87:	48 c1 e0 03          	shl    $0x3,%rax
  800420ea8b:	48 89 c2             	mov    %rax,%rdx
  800420ea8e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ea92:	48 29 c2             	sub    %rax,%rdx
  800420ea95:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ea99:	48 83 c0 08          	add    $0x8,%rax
  800420ea9d:	48 8b 00             	mov    (%rax),%rax
  800420eaa0:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420eaa7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    }
    
    
    _dwarf_init(dbg, elf);
  800420eaab:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  800420eab2:	00 00 00 
  800420eab5:	48 8b 00             	mov    (%rax),%rax
  800420eab8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eabc:	48 89 d6             	mov    %rdx,%rsi
  800420eabf:	48 89 c7             	mov    %rax,%rdi
  800420eac2:	48 b8 f3 09 21 04 80 	movabs $0x80042109f3,%rax
  800420eac9:	00 00 00 
  800420eacc:	ff d0                	callq  *%rax

    sect = _dwarf_find_section(".debug_info");	
  800420eace:	48 bf d1 90 21 04 80 	movabs $0x80042190d1,%rdi
  800420ead5:	00 00 00 
  800420ead8:	48 b8 b0 52 21 04 80 	movabs $0x80042152b0,%rax
  800420eadf:	00 00 00 
  800420eae2:	ff d0                	callq  *%rax
  800420eae4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800420eae8:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  800420eaef:	00 00 00 
  800420eaf2:	48 8b 00             	mov    (%rax),%rax
  800420eaf5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420eaf9:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420eafd:	48 89 50 08          	mov    %rdx,0x8(%rax)
    dbg->dbg_info_size = sect->ds_size;
  800420eb01:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  800420eb08:	00 00 00 
  800420eb0b:	48 8b 00             	mov    (%rax),%rax
  800420eb0e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420eb12:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800420eb16:	48 89 50 10          	mov    %rdx,0x10(%rax)
    
    assert(dbg->dbg_info_size);
  800420eb1a:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  800420eb21:	00 00 00 
  800420eb24:	48 8b 00             	mov    (%rax),%rax
  800420eb27:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420eb2b:	48 85 c0             	test   %rax,%rax
  800420eb2e:	75 35                	jne    800420eb65 <debuginfo_rip+0x27a>
  800420eb30:	48 b9 dd 90 21 04 80 	movabs $0x80042190dd,%rcx
  800420eb37:	00 00 00 
  800420eb3a:	48 ba a4 90 21 04 80 	movabs $0x80042190a4,%rdx
  800420eb41:	00 00 00 
  800420eb44:	be e3 00 00 00       	mov    $0xe3,%esi
  800420eb49:	48 bf b9 90 21 04 80 	movabs $0x80042190b9,%rdi
  800420eb50:	00 00 00 
  800420eb53:	b8 00 00 00 00       	mov    $0x0,%eax
  800420eb58:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800420eb5f:	00 00 00 
  800420eb62:	41 ff d0             	callq  *%r8
    while(_get_next_cu(dbg, &cu) == 0)
  800420eb65:	e9 4a 01 00 00       	jmpq   800420ecb4 <debuginfo_rip+0x3c9>
    {
	    if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  800420eb6a:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  800420eb71:	00 00 00 
  800420eb74:	48 8b 00             	mov    (%rax),%rax
  800420eb77:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420eb7b:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420eb82:	be 00 00 00 00       	mov    $0x0,%esi
  800420eb87:	48 89 c7             	mov    %rax,%rdi
  800420eb8a:	48 b8 7b 1b 21 04 80 	movabs $0x8004211b7b,%rax
  800420eb91:	00 00 00 
  800420eb94:	ff d0                	callq  *%rax
  800420eb96:	83 f8 04             	cmp    $0x4,%eax
  800420eb99:	75 05                	jne    800420eba0 <debuginfo_rip+0x2b5>
	    {
		    continue;
  800420eb9b:	e9 14 01 00 00       	jmpq   800420ecb4 <debuginfo_rip+0x3c9>
	    }	
	    cudie.cu_header = &cu;
  800420eba0:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420eba4:	48 89 85 10 a2 ff ff 	mov    %rax,-0x5df0(%rbp)
	    cudie.cu_die = NULL;
  800420ebab:	48 c7 85 18 a2 ff ff 	movq   $0x0,-0x5de8(%rbp)
  800420ebb2:	00 00 00 00 
	    
	    if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  800420ebb6:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  800420ebbd:	00 00 00 
  800420ebc0:	48 8b 00             	mov    (%rax),%rax
  800420ebc3:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420ebca:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420ebd1:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800420ebd5:	48 89 c7             	mov    %rax,%rdi
  800420ebd8:	48 b8 bf 1d 21 04 80 	movabs $0x8004211dbf,%rax
  800420ebdf:	00 00 00 
  800420ebe2:	ff d0                	callq  *%rax
  800420ebe4:	83 f8 04             	cmp    $0x4,%eax
  800420ebe7:	75 05                	jne    800420ebee <debuginfo_rip+0x303>
	    {
		    continue;
  800420ebe9:	e9 c6 00 00 00       	jmpq   800420ecb4 <debuginfo_rip+0x3c9>
	    }	
	    die.cu_header = &cu;
  800420ebee:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420ebf2:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
	    die.cu_die = &cudie;
  800420ebf9:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420ec00:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
	    while(1)
	    {
		    if(list_func_die(info, &die, addr))
  800420ec07:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420ec0e:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420ec15:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420ec1c:	48 89 ce             	mov    %rcx,%rsi
  800420ec1f:	48 89 c7             	mov    %rax,%rdi
  800420ec22:	48 b8 80 e3 20 04 80 	movabs $0x800420e380,%rax
  800420ec29:	00 00 00 
  800420ec2c:	ff d0                	callq  *%rax
  800420ec2e:	85 c0                	test   %eax,%eax
  800420ec30:	74 0b                	je     800420ec3d <debuginfo_rip+0x352>
			    goto find_done;
  800420ec32:	90                   	nop
    }
    
    return -1;

find_done:
    return 0;
  800420ec33:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ec38:	e9 a7 00 00 00       	jmpq   800420ece4 <debuginfo_rip+0x3f9>
	    die.cu_die = &cudie;
	    while(1)
	    {
		    if(list_func_die(info, &die, addr))
			    goto find_done;
		    if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  800420ec3d:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  800420ec44:	00 00 00 
  800420ec47:	48 8b 00             	mov    (%rax),%rax
  800420ec4a:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420ec4e:	48 8d 95 40 6e ff ff 	lea    -0x91c0(%rbp),%rdx
  800420ec55:	48 8d b5 20 cf ff ff 	lea    -0x30e0(%rbp),%rsi
  800420ec5c:	48 89 c7             	mov    %rax,%rdi
  800420ec5f:	48 b8 7b 1b 21 04 80 	movabs $0x8004211b7b,%rax
  800420ec66:	00 00 00 
  800420ec69:	ff d0                	callq  *%rax
  800420ec6b:	85 c0                	test   %eax,%eax
  800420ec6d:	79 02                	jns    800420ec71 <debuginfo_rip+0x386>
			    break; 
  800420ec6f:	eb 43                	jmp    800420ecb4 <debuginfo_rip+0x3c9>
		    die = die2;
  800420ec71:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420ec78:	48 8d 8d 40 6e ff ff 	lea    -0x91c0(%rbp),%rcx
  800420ec7f:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420ec84:	48 89 ce             	mov    %rcx,%rsi
  800420ec87:	48 89 c7             	mov    %rax,%rdi
  800420ec8a:	48 b8 55 fd 20 04 80 	movabs $0x800420fd55,%rax
  800420ec91:	00 00 00 
  800420ec94:	ff d0                	callq  *%rax
		    die.cu_header = &cu;
  800420ec96:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420ec9a:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
		    die.cu_die = &cudie;
  800420eca1:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420eca8:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
	    }
  800420ecaf:	e9 53 ff ff ff       	jmpq   800420ec07 <debuginfo_rip+0x31c>
    sect = _dwarf_find_section(".debug_info");	
    dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
    dbg->dbg_info_size = sect->ds_size;
    
    assert(dbg->dbg_info_size);
    while(_get_next_cu(dbg, &cu) == 0)
  800420ecb4:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  800420ecbb:	00 00 00 
  800420ecbe:	48 8b 00             	mov    (%rax),%rax
  800420ecc1:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  800420ecc5:	48 89 d6             	mov    %rdx,%rsi
  800420ecc8:	48 89 c7             	mov    %rax,%rdi
  800420eccb:	48 b8 d5 0a 21 04 80 	movabs $0x8004210ad5,%rax
  800420ecd2:	00 00 00 
  800420ecd5:	ff d0                	callq  *%rax
  800420ecd7:	85 c0                	test   %eax,%eax
  800420ecd9:	0f 84 8b fe ff ff    	je     800420eb6a <debuginfo_rip+0x27f>
		    die.cu_header = &cu;
		    die.cu_die = &cudie;
	    }
    }
    
    return -1;
  800420ecdf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

find_done:
    return 0;

}
  800420ece4:	48 81 c4 c8 91 00 00 	add    $0x91c8,%rsp
  800420eceb:	5b                   	pop    %rbx
  800420ecec:	5d                   	pop    %rbp
  800420eced:	c3                   	retq   

000000800420ecee <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800420ecee:	55                   	push   %rbp
  800420ecef:	48 89 e5             	mov    %rsp,%rbp
  800420ecf2:	53                   	push   %rbx
  800420ecf3:	48 83 ec 38          	sub    $0x38,%rsp
  800420ecf7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ecfb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420ecff:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420ed03:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  800420ed06:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
  800420ed0a:	44 89 4d cc          	mov    %r9d,-0x34(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800420ed0e:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420ed11:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420ed15:	77 3b                	ja     800420ed52 <printnum+0x64>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800420ed17:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800420ed1a:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  800420ed1e:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
  800420ed21:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ed25:	ba 00 00 00 00       	mov    $0x0,%edx
  800420ed2a:	48 f7 f3             	div    %rbx
  800420ed2d:	48 89 c2             	mov    %rax,%rdx
  800420ed30:	8b 7d cc             	mov    -0x34(%rbp),%edi
  800420ed33:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420ed36:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420ed3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed3e:	41 89 f9             	mov    %edi,%r9d
  800420ed41:	48 89 c7             	mov    %rax,%rdi
  800420ed44:	48 b8 ee ec 20 04 80 	movabs $0x800420ecee,%rax
  800420ed4b:	00 00 00 
  800420ed4e:	ff d0                	callq  *%rax
  800420ed50:	eb 1e                	jmp    800420ed70 <printnum+0x82>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420ed52:	eb 12                	jmp    800420ed66 <printnum+0x78>
			putch(padc, putdat);
  800420ed54:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420ed58:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420ed5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed5f:	48 89 ce             	mov    %rcx,%rsi
  800420ed62:	89 d7                	mov    %edx,%edi
  800420ed64:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420ed66:	83 6d d0 01          	subl   $0x1,-0x30(%rbp)
  800420ed6a:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  800420ed6e:	7f e4                	jg     800420ed54 <printnum+0x66>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800420ed70:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420ed73:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ed77:	ba 00 00 00 00       	mov    $0x0,%edx
  800420ed7c:	48 f7 f1             	div    %rcx
  800420ed7f:	48 89 d0             	mov    %rdx,%rax
  800420ed82:	48 ba f0 91 21 04 80 	movabs $0x80042191f0,%rdx
  800420ed89:	00 00 00 
  800420ed8c:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420ed90:	0f be d0             	movsbl %al,%edx
  800420ed93:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420ed97:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed9b:	48 89 ce             	mov    %rcx,%rsi
  800420ed9e:	89 d7                	mov    %edx,%edi
  800420eda0:	ff d0                	callq  *%rax
}
  800420eda2:	48 83 c4 38          	add    $0x38,%rsp
  800420eda6:	5b                   	pop    %rbx
  800420eda7:	5d                   	pop    %rbp
  800420eda8:	c3                   	retq   

000000800420eda9 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800420eda9:	55                   	push   %rbp
  800420edaa:	48 89 e5             	mov    %rsp,%rbp
  800420edad:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420edb1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420edb5:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  800420edb8:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420edbc:	7e 52                	jle    800420ee10 <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  800420edbe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420edc2:	8b 00                	mov    (%rax),%eax
  800420edc4:	83 f8 30             	cmp    $0x30,%eax
  800420edc7:	73 24                	jae    800420eded <getuint+0x44>
  800420edc9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420edcd:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420edd1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420edd5:	8b 00                	mov    (%rax),%eax
  800420edd7:	89 c0                	mov    %eax,%eax
  800420edd9:	48 01 d0             	add    %rdx,%rax
  800420eddc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ede0:	8b 12                	mov    (%rdx),%edx
  800420ede2:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ede5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ede9:	89 0a                	mov    %ecx,(%rdx)
  800420edeb:	eb 17                	jmp    800420ee04 <getuint+0x5b>
  800420eded:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420edf1:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420edf5:	48 89 d0             	mov    %rdx,%rax
  800420edf8:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420edfc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ee00:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ee04:	48 8b 00             	mov    (%rax),%rax
  800420ee07:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ee0b:	e9 a3 00 00 00       	jmpq   800420eeb3 <getuint+0x10a>
	else if (lflag)
  800420ee10:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420ee14:	74 4f                	je     800420ee65 <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  800420ee16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee1a:	8b 00                	mov    (%rax),%eax
  800420ee1c:	83 f8 30             	cmp    $0x30,%eax
  800420ee1f:	73 24                	jae    800420ee45 <getuint+0x9c>
  800420ee21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee25:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ee29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee2d:	8b 00                	mov    (%rax),%eax
  800420ee2f:	89 c0                	mov    %eax,%eax
  800420ee31:	48 01 d0             	add    %rdx,%rax
  800420ee34:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ee38:	8b 12                	mov    (%rdx),%edx
  800420ee3a:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ee3d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ee41:	89 0a                	mov    %ecx,(%rdx)
  800420ee43:	eb 17                	jmp    800420ee5c <getuint+0xb3>
  800420ee45:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee49:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ee4d:	48 89 d0             	mov    %rdx,%rax
  800420ee50:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ee54:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ee58:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ee5c:	48 8b 00             	mov    (%rax),%rax
  800420ee5f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ee63:	eb 4e                	jmp    800420eeb3 <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  800420ee65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee69:	8b 00                	mov    (%rax),%eax
  800420ee6b:	83 f8 30             	cmp    $0x30,%eax
  800420ee6e:	73 24                	jae    800420ee94 <getuint+0xeb>
  800420ee70:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee74:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ee78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee7c:	8b 00                	mov    (%rax),%eax
  800420ee7e:	89 c0                	mov    %eax,%eax
  800420ee80:	48 01 d0             	add    %rdx,%rax
  800420ee83:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ee87:	8b 12                	mov    (%rdx),%edx
  800420ee89:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ee8c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ee90:	89 0a                	mov    %ecx,(%rdx)
  800420ee92:	eb 17                	jmp    800420eeab <getuint+0x102>
  800420ee94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee98:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ee9c:	48 89 d0             	mov    %rdx,%rax
  800420ee9f:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420eea3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eea7:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420eeab:	8b 00                	mov    (%rax),%eax
  800420eead:	89 c0                	mov    %eax,%eax
  800420eeaf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420eeb3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420eeb7:	c9                   	leaveq 
  800420eeb8:	c3                   	retq   

000000800420eeb9 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800420eeb9:	55                   	push   %rbp
  800420eeba:	48 89 e5             	mov    %rsp,%rbp
  800420eebd:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420eec1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eec5:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  800420eec8:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420eecc:	7e 52                	jle    800420ef20 <getint+0x67>
		x=va_arg(*ap, long long);
  800420eece:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eed2:	8b 00                	mov    (%rax),%eax
  800420eed4:	83 f8 30             	cmp    $0x30,%eax
  800420eed7:	73 24                	jae    800420eefd <getint+0x44>
  800420eed9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eedd:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420eee1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eee5:	8b 00                	mov    (%rax),%eax
  800420eee7:	89 c0                	mov    %eax,%eax
  800420eee9:	48 01 d0             	add    %rdx,%rax
  800420eeec:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eef0:	8b 12                	mov    (%rdx),%edx
  800420eef2:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420eef5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eef9:	89 0a                	mov    %ecx,(%rdx)
  800420eefb:	eb 17                	jmp    800420ef14 <getint+0x5b>
  800420eefd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ef01:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ef05:	48 89 d0             	mov    %rdx,%rax
  800420ef08:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ef0c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ef10:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ef14:	48 8b 00             	mov    (%rax),%rax
  800420ef17:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ef1b:	e9 a3 00 00 00       	jmpq   800420efc3 <getint+0x10a>
	else if (lflag)
  800420ef20:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420ef24:	74 4f                	je     800420ef75 <getint+0xbc>
		x=va_arg(*ap, long);
  800420ef26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ef2a:	8b 00                	mov    (%rax),%eax
  800420ef2c:	83 f8 30             	cmp    $0x30,%eax
  800420ef2f:	73 24                	jae    800420ef55 <getint+0x9c>
  800420ef31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ef35:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ef39:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ef3d:	8b 00                	mov    (%rax),%eax
  800420ef3f:	89 c0                	mov    %eax,%eax
  800420ef41:	48 01 d0             	add    %rdx,%rax
  800420ef44:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ef48:	8b 12                	mov    (%rdx),%edx
  800420ef4a:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ef4d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ef51:	89 0a                	mov    %ecx,(%rdx)
  800420ef53:	eb 17                	jmp    800420ef6c <getint+0xb3>
  800420ef55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ef59:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ef5d:	48 89 d0             	mov    %rdx,%rax
  800420ef60:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ef64:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ef68:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ef6c:	48 8b 00             	mov    (%rax),%rax
  800420ef6f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ef73:	eb 4e                	jmp    800420efc3 <getint+0x10a>
	else
		x=va_arg(*ap, int);
  800420ef75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ef79:	8b 00                	mov    (%rax),%eax
  800420ef7b:	83 f8 30             	cmp    $0x30,%eax
  800420ef7e:	73 24                	jae    800420efa4 <getint+0xeb>
  800420ef80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ef84:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ef88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ef8c:	8b 00                	mov    (%rax),%eax
  800420ef8e:	89 c0                	mov    %eax,%eax
  800420ef90:	48 01 d0             	add    %rdx,%rax
  800420ef93:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ef97:	8b 12                	mov    (%rdx),%edx
  800420ef99:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ef9c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420efa0:	89 0a                	mov    %ecx,(%rdx)
  800420efa2:	eb 17                	jmp    800420efbb <getint+0x102>
  800420efa4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420efa8:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420efac:	48 89 d0             	mov    %rdx,%rax
  800420efaf:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420efb3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420efb7:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420efbb:	8b 00                	mov    (%rax),%eax
  800420efbd:	48 98                	cltq   
  800420efbf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420efc3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420efc7:	c9                   	leaveq 
  800420efc8:	c3                   	retq   

000000800420efc9 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800420efc9:	55                   	push   %rbp
  800420efca:	48 89 e5             	mov    %rsp,%rbp
  800420efcd:	41 54                	push   %r12
  800420efcf:	53                   	push   %rbx
  800420efd0:	48 83 ec 60          	sub    $0x60,%rsp
  800420efd4:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420efd8:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420efdc:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420efe0:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  800420efe4:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420efe8:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420efec:	48 8b 0a             	mov    (%rdx),%rcx
  800420efef:	48 89 08             	mov    %rcx,(%rax)
  800420eff2:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420eff6:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420effa:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420effe:	48 89 50 10          	mov    %rdx,0x10(%rax)
                  color++;
                  ch = *(unsigned char *) color;
                }
#endif
   
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420f002:	eb 17                	jmp    800420f01b <vprintfmt+0x52>
			if (ch == '\0')
  800420f004:	85 db                	test   %ebx,%ebx
  800420f006:	0f 84 cc 04 00 00    	je     800420f4d8 <vprintfmt+0x50f>
                }
#endif

			  return;
			}
			putch(ch, putdat);
  800420f00c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f010:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f014:	48 89 d6             	mov    %rdx,%rsi
  800420f017:	89 df                	mov    %ebx,%edi
  800420f019:	ff d0                	callq  *%rax
                  color++;
                  ch = *(unsigned char *) color;
                }
#endif
   
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420f01b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f01f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f023:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420f027:	0f b6 00             	movzbl (%rax),%eax
  800420f02a:	0f b6 d8             	movzbl %al,%ebx
  800420f02d:	83 fb 25             	cmp    $0x25,%ebx
  800420f030:	75 d2                	jne    800420f004 <vprintfmt+0x3b>
			  return;
			}
			putch(ch, putdat);
		}
		// Process a %-escape sequence
		padc = ' ';
  800420f032:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  800420f036:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  800420f03d:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  800420f044:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  800420f04b:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800420f052:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f056:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f05a:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420f05e:	0f b6 00             	movzbl (%rax),%eax
  800420f061:	0f b6 d8             	movzbl %al,%ebx
  800420f064:	8d 43 dd             	lea    -0x23(%rbx),%eax
  800420f067:	83 f8 55             	cmp    $0x55,%eax
  800420f06a:	0f 87 34 04 00 00    	ja     800420f4a4 <vprintfmt+0x4db>
  800420f070:	89 c0                	mov    %eax,%eax
  800420f072:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420f079:	00 
  800420f07a:	48 b8 18 92 21 04 80 	movabs $0x8004219218,%rax
  800420f081:	00 00 00 
  800420f084:	48 01 d0             	add    %rdx,%rax
  800420f087:	48 8b 00             	mov    (%rax),%rax
  800420f08a:	ff e0                	jmpq   *%rax

		// flag to pad on the right
		case '-':
			padc = '-';
  800420f08c:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  800420f090:	eb c0                	jmp    800420f052 <vprintfmt+0x89>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800420f092:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  800420f096:	eb ba                	jmp    800420f052 <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420f098:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  800420f09f:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420f0a2:	89 d0                	mov    %edx,%eax
  800420f0a4:	c1 e0 02             	shl    $0x2,%eax
  800420f0a7:	01 d0                	add    %edx,%eax
  800420f0a9:	01 c0                	add    %eax,%eax
  800420f0ab:	01 d8                	add    %ebx,%eax
  800420f0ad:	83 e8 30             	sub    $0x30,%eax
  800420f0b0:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  800420f0b3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f0b7:	0f b6 00             	movzbl (%rax),%eax
  800420f0ba:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  800420f0bd:	83 fb 2f             	cmp    $0x2f,%ebx
  800420f0c0:	7e 0c                	jle    800420f0ce <vprintfmt+0x105>
  800420f0c2:	83 fb 39             	cmp    $0x39,%ebx
  800420f0c5:	7f 07                	jg     800420f0ce <vprintfmt+0x105>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420f0c7:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  800420f0cc:	eb d1                	jmp    800420f09f <vprintfmt+0xd6>
			goto process_precision;
  800420f0ce:	eb 58                	jmp    800420f128 <vprintfmt+0x15f>

		case '*':
			precision = va_arg(aq, int);
  800420f0d0:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f0d3:	83 f8 30             	cmp    $0x30,%eax
  800420f0d6:	73 17                	jae    800420f0ef <vprintfmt+0x126>
  800420f0d8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f0dc:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f0df:	89 c0                	mov    %eax,%eax
  800420f0e1:	48 01 d0             	add    %rdx,%rax
  800420f0e4:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f0e7:	83 c2 08             	add    $0x8,%edx
  800420f0ea:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420f0ed:	eb 0f                	jmp    800420f0fe <vprintfmt+0x135>
  800420f0ef:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f0f3:	48 89 d0             	mov    %rdx,%rax
  800420f0f6:	48 83 c2 08          	add    $0x8,%rdx
  800420f0fa:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f0fe:	8b 00                	mov    (%rax),%eax
  800420f100:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  800420f103:	eb 23                	jmp    800420f128 <vprintfmt+0x15f>

		case '.':
			if (width < 0)
  800420f105:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f109:	79 0c                	jns    800420f117 <vprintfmt+0x14e>
				width = 0;
  800420f10b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  800420f112:	e9 3b ff ff ff       	jmpq   800420f052 <vprintfmt+0x89>
  800420f117:	e9 36 ff ff ff       	jmpq   800420f052 <vprintfmt+0x89>

		case '#':
			altflag = 1;
  800420f11c:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  800420f123:	e9 2a ff ff ff       	jmpq   800420f052 <vprintfmt+0x89>

		process_precision:
			if (width < 0)
  800420f128:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f12c:	79 12                	jns    800420f140 <vprintfmt+0x177>
				width = precision, precision = -1;
  800420f12e:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420f131:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420f134:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  800420f13b:	e9 12 ff ff ff       	jmpq   800420f052 <vprintfmt+0x89>
  800420f140:	e9 0d ff ff ff       	jmpq   800420f052 <vprintfmt+0x89>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  800420f145:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  800420f149:	e9 04 ff ff ff       	jmpq   800420f052 <vprintfmt+0x89>
	          putch(ch, putdat);
                  color++;
                  ch = *(unsigned char *) color;
                }
#endif
			putch(va_arg(aq, int), putdat);
  800420f14e:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f151:	83 f8 30             	cmp    $0x30,%eax
  800420f154:	73 17                	jae    800420f16d <vprintfmt+0x1a4>
  800420f156:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f15a:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f15d:	89 c0                	mov    %eax,%eax
  800420f15f:	48 01 d0             	add    %rdx,%rax
  800420f162:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f165:	83 c2 08             	add    $0x8,%edx
  800420f168:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420f16b:	eb 0f                	jmp    800420f17c <vprintfmt+0x1b3>
  800420f16d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f171:	48 89 d0             	mov    %rdx,%rax
  800420f174:	48 83 c2 08          	add    $0x8,%rdx
  800420f178:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f17c:	8b 10                	mov    (%rax),%edx
  800420f17e:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420f182:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f186:	48 89 ce             	mov    %rcx,%rsi
  800420f189:	89 d7                	mov    %edx,%edi
  800420f18b:	ff d0                	callq  *%rax
	          putch(ch, putdat);
                  color++;
                  ch = *(unsigned char *) color;
                }
#endif
			break;
  800420f18d:	e9 40 03 00 00       	jmpq   800420f4d2 <vprintfmt+0x509>

		// error message
		case 'e':
			err = va_arg(aq, int);
  800420f192:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f195:	83 f8 30             	cmp    $0x30,%eax
  800420f198:	73 17                	jae    800420f1b1 <vprintfmt+0x1e8>
  800420f19a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f19e:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f1a1:	89 c0                	mov    %eax,%eax
  800420f1a3:	48 01 d0             	add    %rdx,%rax
  800420f1a6:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f1a9:	83 c2 08             	add    $0x8,%edx
  800420f1ac:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420f1af:	eb 0f                	jmp    800420f1c0 <vprintfmt+0x1f7>
  800420f1b1:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f1b5:	48 89 d0             	mov    %rdx,%rax
  800420f1b8:	48 83 c2 08          	add    $0x8,%rdx
  800420f1bc:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f1c0:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  800420f1c2:	85 db                	test   %ebx,%ebx
  800420f1c4:	79 02                	jns    800420f1c8 <vprintfmt+0x1ff>
				err = -err;
  800420f1c6:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800420f1c8:	83 fb 09             	cmp    $0x9,%ebx
  800420f1cb:	7f 16                	jg     800420f1e3 <vprintfmt+0x21a>
  800420f1cd:	48 b8 a0 91 21 04 80 	movabs $0x80042191a0,%rax
  800420f1d4:	00 00 00 
  800420f1d7:	48 63 d3             	movslq %ebx,%rdx
  800420f1da:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  800420f1de:	4d 85 e4             	test   %r12,%r12
  800420f1e1:	75 2e                	jne    800420f211 <vprintfmt+0x248>
				printfmt(putch, putdat, "error %d", err);
  800420f1e3:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420f1e7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f1eb:	89 d9                	mov    %ebx,%ecx
  800420f1ed:	48 ba 01 92 21 04 80 	movabs $0x8004219201,%rdx
  800420f1f4:	00 00 00 
  800420f1f7:	48 89 c7             	mov    %rax,%rdi
  800420f1fa:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f1ff:	49 b8 e1 f4 20 04 80 	movabs $0x800420f4e1,%r8
  800420f206:	00 00 00 
  800420f209:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  800420f20c:	e9 c1 02 00 00       	jmpq   800420f4d2 <vprintfmt+0x509>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800420f211:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420f215:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f219:	4c 89 e1             	mov    %r12,%rcx
  800420f21c:	48 ba 0a 92 21 04 80 	movabs $0x800421920a,%rdx
  800420f223:	00 00 00 
  800420f226:	48 89 c7             	mov    %rax,%rdi
  800420f229:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f22e:	49 b8 e1 f4 20 04 80 	movabs $0x800420f4e1,%r8
  800420f235:	00 00 00 
  800420f238:	41 ff d0             	callq  *%r8
			break;
  800420f23b:	e9 92 02 00 00       	jmpq   800420f4d2 <vprintfmt+0x509>
	          putch(ch, putdat);
                  color++;
                  ch = *(unsigned char *) color;
                }
#endif
			if ((p = va_arg(aq, char *)) == NULL)
  800420f240:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f243:	83 f8 30             	cmp    $0x30,%eax
  800420f246:	73 17                	jae    800420f25f <vprintfmt+0x296>
  800420f248:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f24c:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f24f:	89 c0                	mov    %eax,%eax
  800420f251:	48 01 d0             	add    %rdx,%rax
  800420f254:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f257:	83 c2 08             	add    $0x8,%edx
  800420f25a:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420f25d:	eb 0f                	jmp    800420f26e <vprintfmt+0x2a5>
  800420f25f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f263:	48 89 d0             	mov    %rdx,%rax
  800420f266:	48 83 c2 08          	add    $0x8,%rdx
  800420f26a:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f26e:	4c 8b 20             	mov    (%rax),%r12
  800420f271:	4d 85 e4             	test   %r12,%r12
  800420f274:	75 0a                	jne    800420f280 <vprintfmt+0x2b7>
				p = "(null)";
  800420f276:	49 bc 0d 92 21 04 80 	movabs $0x800421920d,%r12
  800420f27d:	00 00 00 
			if (width > 0 && padc != '-')
  800420f280:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f284:	7e 3f                	jle    800420f2c5 <vprintfmt+0x2fc>
  800420f286:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  800420f28a:	74 39                	je     800420f2c5 <vprintfmt+0x2fc>
				for (width -= strnlen(p, precision); width > 0; width--)
  800420f28c:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420f28f:	48 98                	cltq   
  800420f291:	48 89 c6             	mov    %rax,%rsi
  800420f294:	4c 89 e7             	mov    %r12,%rdi
  800420f297:	48 b8 dc f8 20 04 80 	movabs $0x800420f8dc,%rax
  800420f29e:	00 00 00 
  800420f2a1:	ff d0                	callq  *%rax
  800420f2a3:	29 45 dc             	sub    %eax,-0x24(%rbp)
  800420f2a6:	eb 17                	jmp    800420f2bf <vprintfmt+0x2f6>
					putch(padc, putdat);
  800420f2a8:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  800420f2ac:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420f2b0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f2b4:	48 89 ce             	mov    %rcx,%rsi
  800420f2b7:	89 d7                	mov    %edx,%edi
  800420f2b9:	ff d0                	callq  *%rax
                }
#endif
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800420f2bb:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420f2bf:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f2c3:	7f e3                	jg     800420f2a8 <vprintfmt+0x2df>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420f2c5:	eb 37                	jmp    800420f2fe <vprintfmt+0x335>
				if (altflag && (ch < ' ' || ch > '~'))
  800420f2c7:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  800420f2cb:	74 1e                	je     800420f2eb <vprintfmt+0x322>
  800420f2cd:	83 fb 1f             	cmp    $0x1f,%ebx
  800420f2d0:	7e 05                	jle    800420f2d7 <vprintfmt+0x30e>
  800420f2d2:	83 fb 7e             	cmp    $0x7e,%ebx
  800420f2d5:	7e 14                	jle    800420f2eb <vprintfmt+0x322>
					putch('?', putdat);
  800420f2d7:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f2db:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f2df:	48 89 d6             	mov    %rdx,%rsi
  800420f2e2:	bf 3f 00 00 00       	mov    $0x3f,%edi
  800420f2e7:	ff d0                	callq  *%rax
  800420f2e9:	eb 0f                	jmp    800420f2fa <vprintfmt+0x331>
				else
					putch(ch, putdat);
  800420f2eb:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f2ef:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f2f3:	48 89 d6             	mov    %rdx,%rsi
  800420f2f6:	89 df                	mov    %ebx,%edi
  800420f2f8:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420f2fa:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420f2fe:	4c 89 e0             	mov    %r12,%rax
  800420f301:	4c 8d 60 01          	lea    0x1(%rax),%r12
  800420f305:	0f b6 00             	movzbl (%rax),%eax
  800420f308:	0f be d8             	movsbl %al,%ebx
  800420f30b:	85 db                	test   %ebx,%ebx
  800420f30d:	74 10                	je     800420f31f <vprintfmt+0x356>
  800420f30f:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420f313:	78 b2                	js     800420f2c7 <vprintfmt+0x2fe>
  800420f315:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  800420f319:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420f31d:	79 a8                	jns    800420f2c7 <vprintfmt+0x2fe>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420f31f:	eb 16                	jmp    800420f337 <vprintfmt+0x36e>
				putch(' ', putdat);
  800420f321:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f325:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f329:	48 89 d6             	mov    %rdx,%rsi
  800420f32c:	bf 20 00 00 00       	mov    $0x20,%edi
  800420f331:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420f333:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420f337:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f33b:	7f e4                	jg     800420f321 <vprintfmt+0x358>
	          putch(ch, putdat);
                  color++;
                  ch = *(unsigned char *) color;
                }
#endif
			break;
  800420f33d:	e9 90 01 00 00       	jmpq   800420f4d2 <vprintfmt+0x509>
                  color++;
                  ch = *(unsigned char *) color;
                }
#endif

			num = getint(&aq, 3);
  800420f342:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f346:	be 03 00 00 00       	mov    $0x3,%esi
  800420f34b:	48 89 c7             	mov    %rax,%rdi
  800420f34e:	48 b8 b9 ee 20 04 80 	movabs $0x800420eeb9,%rax
  800420f355:	00 00 00 
  800420f358:	ff d0                	callq  *%rax
  800420f35a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800420f35e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f362:	48 85 c0             	test   %rax,%rax
  800420f365:	79 1d                	jns    800420f384 <vprintfmt+0x3bb>
				putch('-', putdat);
  800420f367:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f36b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f36f:	48 89 d6             	mov    %rdx,%rsi
  800420f372:	bf 2d 00 00 00       	mov    $0x2d,%edi
  800420f377:	ff d0                	callq  *%rax
				num = -(long long) num;
  800420f379:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f37d:	48 f7 d8             	neg    %rax
  800420f380:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  800420f384:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420f38b:	e9 d5 00 00 00       	jmpq   800420f465 <vprintfmt+0x49c>
                  color++;
                  ch = *(unsigned char *) color;
                }
#endif
			
			num = getuint(&aq, 3);
  800420f390:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f394:	be 03 00 00 00       	mov    $0x3,%esi
  800420f399:	48 89 c7             	mov    %rax,%rdi
  800420f39c:	48 b8 a9 ed 20 04 80 	movabs $0x800420eda9,%rax
  800420f3a3:	00 00 00 
  800420f3a6:	ff d0                	callq  *%rax
  800420f3a8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  800420f3ac:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420f3b3:	e9 ad 00 00 00       	jmpq   800420f465 <vprintfmt+0x49c>
                  ch = *(unsigned char *) color;
                }
#endif

			// Replace this with your code.
		        num = getuint(&aq, 3);
  800420f3b8:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f3bc:	be 03 00 00 00       	mov    $0x3,%esi
  800420f3c1:	48 89 c7             	mov    %rax,%rdi
  800420f3c4:	48 b8 a9 ed 20 04 80 	movabs $0x800420eda9,%rax
  800420f3cb:	00 00 00 
  800420f3ce:	ff d0                	callq  *%rax
  800420f3d0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 8;
  800420f3d4:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  800420f3db:	e9 85 00 00 00       	jmpq   800420f465 <vprintfmt+0x49c>
                  color++;
                  ch = *(unsigned char *) color;
                }
#endif

			putch('0', putdat);
  800420f3e0:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f3e4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f3e8:	48 89 d6             	mov    %rdx,%rsi
  800420f3eb:	bf 30 00 00 00       	mov    $0x30,%edi
  800420f3f0:	ff d0                	callq  *%rax
			putch('x', putdat);
  800420f3f2:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f3f6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f3fa:	48 89 d6             	mov    %rdx,%rsi
  800420f3fd:	bf 78 00 00 00       	mov    $0x78,%edi
  800420f402:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  800420f404:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f407:	83 f8 30             	cmp    $0x30,%eax
  800420f40a:	73 17                	jae    800420f423 <vprintfmt+0x45a>
  800420f40c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f410:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f413:	89 c0                	mov    %eax,%eax
  800420f415:	48 01 d0             	add    %rdx,%rax
  800420f418:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f41b:	83 c2 08             	add    $0x8,%edx
  800420f41e:	89 55 b8             	mov    %edx,-0x48(%rbp)
                }
#endif

			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420f421:	eb 0f                	jmp    800420f432 <vprintfmt+0x469>
				(uintptr_t) va_arg(aq, void *);
  800420f423:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f427:	48 89 d0             	mov    %rdx,%rax
  800420f42a:	48 83 c2 08          	add    $0x8,%rdx
  800420f42e:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f432:	48 8b 00             	mov    (%rax),%rax
                }
#endif

			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420f435:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  800420f439:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  800420f440:	eb 23                	jmp    800420f465 <vprintfmt+0x49c>
                  color++;
                  ch = *(unsigned char *) color;
                }
#endif

			num = getuint(&aq, 3);
  800420f442:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f446:	be 03 00 00 00       	mov    $0x3,%esi
  800420f44b:	48 89 c7             	mov    %rax,%rdi
  800420f44e:	48 b8 a9 ed 20 04 80 	movabs $0x800420eda9,%rax
  800420f455:	00 00 00 
  800420f458:	ff d0                	callq  *%rax
  800420f45a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  800420f45e:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:

			printnum(putch, putdat, num, base, width, padc);
  800420f465:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  800420f46a:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420f46d:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800420f470:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f474:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420f478:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f47c:	45 89 c1             	mov    %r8d,%r9d
  800420f47f:	41 89 f8             	mov    %edi,%r8d
  800420f482:	48 89 c7             	mov    %rax,%rdi
  800420f485:	48 b8 ee ec 20 04 80 	movabs $0x800420ecee,%rax
  800420f48c:	00 00 00 
  800420f48f:	ff d0                	callq  *%rax
                  color++;
                  ch = *(unsigned char *) color;
                }
#endif

			break;
  800420f491:	eb 3f                	jmp    800420f4d2 <vprintfmt+0x509>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  800420f493:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f497:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f49b:	48 89 d6             	mov    %rdx,%rsi
  800420f49e:	89 df                	mov    %ebx,%edi
  800420f4a0:	ff d0                	callq  *%rax
			break;
  800420f4a2:	eb 2e                	jmp    800420f4d2 <vprintfmt+0x509>

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800420f4a4:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f4a8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f4ac:	48 89 d6             	mov    %rdx,%rsi
  800420f4af:	bf 25 00 00 00       	mov    $0x25,%edi
  800420f4b4:	ff d0                	callq  *%rax

			for (fmt--; fmt[-1] != '%'; fmt--)
  800420f4b6:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420f4bb:	eb 05                	jmp    800420f4c2 <vprintfmt+0x4f9>
  800420f4bd:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420f4c2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f4c6:	48 83 e8 01          	sub    $0x1,%rax
  800420f4ca:	0f b6 00             	movzbl (%rax),%eax
  800420f4cd:	3c 25                	cmp    $0x25,%al
  800420f4cf:	75 ec                	jne    800420f4bd <vprintfmt+0x4f4>
				/* do nothing */;
			break;
  800420f4d1:	90                   	nop
		}
	}
  800420f4d2:	90                   	nop
                  color++;
                  ch = *(unsigned char *) color;
                }
#endif
   
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420f4d3:	e9 43 fb ff ff       	jmpq   800420f01b <vprintfmt+0x52>
			break;
		}
	}
    
va_end(aq);
}
  800420f4d8:	48 83 c4 60          	add    $0x60,%rsp
  800420f4dc:	5b                   	pop    %rbx
  800420f4dd:	41 5c                	pop    %r12
  800420f4df:	5d                   	pop    %rbp
  800420f4e0:	c3                   	retq   

000000800420f4e1 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800420f4e1:	55                   	push   %rbp
  800420f4e2:	48 89 e5             	mov    %rsp,%rbp
  800420f4e5:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420f4ec:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420f4f3:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  800420f4fa:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420f501:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420f508:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420f50f:	84 c0                	test   %al,%al
  800420f511:	74 20                	je     800420f533 <printfmt+0x52>
  800420f513:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420f517:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420f51b:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420f51f:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420f523:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420f527:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420f52b:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420f52f:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420f533:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420f53a:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420f541:	00 00 00 
  800420f544:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420f54b:	00 00 00 
  800420f54e:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420f552:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420f559:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420f560:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  800420f567:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  800420f56e:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420f575:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420f57c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420f583:	48 89 c7             	mov    %rax,%rdi
  800420f586:	48 b8 c9 ef 20 04 80 	movabs $0x800420efc9,%rax
  800420f58d:	00 00 00 
  800420f590:	ff d0                	callq  *%rax
	va_end(ap);
}
  800420f592:	c9                   	leaveq 
  800420f593:	c3                   	retq   

000000800420f594 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800420f594:	55                   	push   %rbp
  800420f595:	48 89 e5             	mov    %rsp,%rbp
  800420f598:	48 83 ec 10          	sub    $0x10,%rsp
  800420f59c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420f59f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  800420f5a3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f5a7:	8b 40 10             	mov    0x10(%rax),%eax
  800420f5aa:	8d 50 01             	lea    0x1(%rax),%edx
  800420f5ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f5b1:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  800420f5b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f5b8:	48 8b 10             	mov    (%rax),%rdx
  800420f5bb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f5bf:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f5c3:	48 39 c2             	cmp    %rax,%rdx
  800420f5c6:	73 17                	jae    800420f5df <sprintputch+0x4b>
		*b->buf++ = ch;
  800420f5c8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f5cc:	48 8b 00             	mov    (%rax),%rax
  800420f5cf:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800420f5d3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f5d7:	48 89 0a             	mov    %rcx,(%rdx)
  800420f5da:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420f5dd:	88 10                	mov    %dl,(%rax)
}
  800420f5df:	c9                   	leaveq 
  800420f5e0:	c3                   	retq   

000000800420f5e1 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  800420f5e1:	55                   	push   %rbp
  800420f5e2:	48 89 e5             	mov    %rsp,%rbp
  800420f5e5:	48 83 ec 50          	sub    $0x50,%rsp
  800420f5e9:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420f5ed:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800420f5f0:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420f5f4:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  800420f5f8:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420f5fc:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420f600:	48 8b 0a             	mov    (%rdx),%rcx
  800420f603:	48 89 08             	mov    %rcx,(%rax)
  800420f606:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420f60a:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420f60e:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420f612:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  800420f616:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f61a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420f61e:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420f621:	48 98                	cltq   
  800420f623:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420f627:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f62b:	48 01 d0             	add    %rdx,%rax
  800420f62e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420f632:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  800420f639:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420f63e:	74 06                	je     800420f646 <vsnprintf+0x65>
  800420f640:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800420f644:	7f 07                	jg     800420f64d <vsnprintf+0x6c>
		return -E_INVAL;
  800420f646:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420f64b:	eb 2f                	jmp    800420f67c <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  800420f64d:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420f651:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420f655:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800420f659:	48 89 c6             	mov    %rax,%rsi
  800420f65c:	48 bf 94 f5 20 04 80 	movabs $0x800420f594,%rdi
  800420f663:	00 00 00 
  800420f666:	48 b8 c9 ef 20 04 80 	movabs $0x800420efc9,%rax
  800420f66d:	00 00 00 
  800420f670:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  800420f672:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f676:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  800420f679:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  800420f67c:	c9                   	leaveq 
  800420f67d:	c3                   	retq   

000000800420f67e <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  800420f67e:	55                   	push   %rbp
  800420f67f:	48 89 e5             	mov    %rsp,%rbp
  800420f682:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800420f689:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  800420f690:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  800420f696:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420f69d:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420f6a4:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420f6ab:	84 c0                	test   %al,%al
  800420f6ad:	74 20                	je     800420f6cf <snprintf+0x51>
  800420f6af:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420f6b3:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420f6b7:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420f6bb:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420f6bf:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420f6c3:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420f6c7:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420f6cb:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420f6cf:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  800420f6d6:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  800420f6dd:	00 00 00 
  800420f6e0:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  800420f6e7:	00 00 00 
  800420f6ea:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420f6ee:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  800420f6f5:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420f6fc:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  800420f703:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420f70a:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420f711:	48 8b 0a             	mov    (%rdx),%rcx
  800420f714:	48 89 08             	mov    %rcx,(%rax)
  800420f717:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420f71b:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420f71f:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420f723:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  800420f727:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  800420f72e:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  800420f735:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  800420f73b:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420f742:	48 89 c7             	mov    %rax,%rdi
  800420f745:	48 b8 e1 f5 20 04 80 	movabs $0x800420f5e1,%rax
  800420f74c:	00 00 00 
  800420f74f:	ff d0                	callq  *%rax
  800420f751:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  800420f757:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  800420f75d:	c9                   	leaveq 
  800420f75e:	c3                   	retq   

000000800420f75f <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  800420f75f:	55                   	push   %rbp
  800420f760:	48 89 e5             	mov    %rsp,%rbp
  800420f763:	48 83 ec 20          	sub    $0x20,%rsp
  800420f767:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;

	if (prompt != NULL)
  800420f76b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f770:	74 22                	je     800420f794 <readline+0x35>
		cprintf("%s", prompt);
  800420f772:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f776:	48 89 c6             	mov    %rax,%rsi
  800420f779:	48 bf c8 94 21 04 80 	movabs $0x80042194c8,%rdi
  800420f780:	00 00 00 
  800420f783:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f788:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420f78f:	00 00 00 
  800420f792:	ff d2                	callq  *%rdx

	i = 0;
  800420f794:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  800420f79b:	bf 00 00 00 00       	mov    $0x0,%edi
  800420f7a0:	48 b8 41 12 20 04 80 	movabs $0x8004201241,%rax
  800420f7a7:	00 00 00 
  800420f7aa:	ff d0                	callq  *%rax
  800420f7ac:	89 45 f8             	mov    %eax,-0x8(%rbp)
	while (1) {
		c = getchar();
  800420f7af:	48 b8 1f 12 20 04 80 	movabs $0x800420121f,%rax
  800420f7b6:	00 00 00 
  800420f7b9:	ff d0                	callq  *%rax
  800420f7bb:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  800420f7be:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420f7c2:	79 2a                	jns    800420f7ee <readline+0x8f>
			cprintf("read error: %e\n", c);
  800420f7c4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f7c7:	89 c6                	mov    %eax,%esi
  800420f7c9:	48 bf cb 94 21 04 80 	movabs $0x80042194cb,%rdi
  800420f7d0:	00 00 00 
  800420f7d3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f7d8:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800420f7df:	00 00 00 
  800420f7e2:	ff d2                	callq  *%rdx
			return NULL;
  800420f7e4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f7e9:	e9 be 00 00 00       	jmpq   800420f8ac <readline+0x14d>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  800420f7ee:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  800420f7f2:	74 06                	je     800420f7fa <readline+0x9b>
  800420f7f4:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  800420f7f8:	75 26                	jne    800420f820 <readline+0xc1>
  800420f7fa:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420f7fe:	7e 20                	jle    800420f820 <readline+0xc1>
			if (echoing)
  800420f800:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420f804:	74 11                	je     800420f817 <readline+0xb8>
				cputchar('\b');
  800420f806:	bf 08 00 00 00       	mov    $0x8,%edi
  800420f80b:	48 b8 01 12 20 04 80 	movabs $0x8004201201,%rax
  800420f812:	00 00 00 
  800420f815:	ff d0                	callq  *%rax
			i--;
  800420f817:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  800420f81b:	e9 87 00 00 00       	jmpq   800420f8a7 <readline+0x148>
		} else if (c >= ' ' && i < BUFLEN-1) {
  800420f820:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420f824:	7e 3f                	jle    800420f865 <readline+0x106>
  800420f826:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  800420f82d:	7f 36                	jg     800420f865 <readline+0x106>
			if (echoing)
  800420f82f:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420f833:	74 11                	je     800420f846 <readline+0xe7>
				cputchar(c);
  800420f835:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f838:	89 c7                	mov    %eax,%edi
  800420f83a:	48 b8 01 12 20 04 80 	movabs $0x8004201201,%rax
  800420f841:	00 00 00 
  800420f844:	ff d0                	callq  *%rax
			buf[i++] = c;
  800420f846:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f849:	8d 50 01             	lea    0x1(%rax),%edx
  800420f84c:	89 55 fc             	mov    %edx,-0x4(%rbp)
  800420f84f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420f852:	89 d1                	mov    %edx,%ecx
  800420f854:	48 ba 20 13 36 04 80 	movabs $0x8004361320,%rdx
  800420f85b:	00 00 00 
  800420f85e:	48 98                	cltq   
  800420f860:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  800420f863:	eb 42                	jmp    800420f8a7 <readline+0x148>
		} else if (c == '\n' || c == '\r') {
  800420f865:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  800420f869:	74 06                	je     800420f871 <readline+0x112>
  800420f86b:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  800420f86f:	75 36                	jne    800420f8a7 <readline+0x148>
			if (echoing)
  800420f871:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420f875:	74 11                	je     800420f888 <readline+0x129>
				cputchar('\n');
  800420f877:	bf 0a 00 00 00       	mov    $0xa,%edi
  800420f87c:	48 b8 01 12 20 04 80 	movabs $0x8004201201,%rax
  800420f883:	00 00 00 
  800420f886:	ff d0                	callq  *%rax
			buf[i] = 0;
  800420f888:	48 ba 20 13 36 04 80 	movabs $0x8004361320,%rdx
  800420f88f:	00 00 00 
  800420f892:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f895:	48 98                	cltq   
  800420f897:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  800420f89b:	48 b8 20 13 36 04 80 	movabs $0x8004361320,%rax
  800420f8a2:	00 00 00 
  800420f8a5:	eb 05                	jmp    800420f8ac <readline+0x14d>
		}
	}
  800420f8a7:	e9 03 ff ff ff       	jmpq   800420f7af <readline+0x50>
}
  800420f8ac:	c9                   	leaveq 
  800420f8ad:	c3                   	retq   

000000800420f8ae <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  800420f8ae:	55                   	push   %rbp
  800420f8af:	48 89 e5             	mov    %rsp,%rbp
  800420f8b2:	48 83 ec 18          	sub    $0x18,%rsp
  800420f8b6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  800420f8ba:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420f8c1:	eb 09                	jmp    800420f8cc <strlen+0x1e>
		n++;
  800420f8c3:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  800420f8c7:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420f8cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8d0:	0f b6 00             	movzbl (%rax),%eax
  800420f8d3:	84 c0                	test   %al,%al
  800420f8d5:	75 ec                	jne    800420f8c3 <strlen+0x15>
		n++;
	return n;
  800420f8d7:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420f8da:	c9                   	leaveq 
  800420f8db:	c3                   	retq   

000000800420f8dc <strnlen>:

int
strnlen(const char *s, size_t size)
{
  800420f8dc:	55                   	push   %rbp
  800420f8dd:	48 89 e5             	mov    %rsp,%rbp
  800420f8e0:	48 83 ec 20          	sub    $0x20,%rsp
  800420f8e4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f8e8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420f8ec:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420f8f3:	eb 0e                	jmp    800420f903 <strnlen+0x27>
		n++;
  800420f8f5:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420f8f9:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420f8fe:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  800420f903:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420f908:	74 0b                	je     800420f915 <strnlen+0x39>
  800420f90a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f90e:	0f b6 00             	movzbl (%rax),%eax
  800420f911:	84 c0                	test   %al,%al
  800420f913:	75 e0                	jne    800420f8f5 <strnlen+0x19>
		n++;
	return n;
  800420f915:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420f918:	c9                   	leaveq 
  800420f919:	c3                   	retq   

000000800420f91a <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  800420f91a:	55                   	push   %rbp
  800420f91b:	48 89 e5             	mov    %rsp,%rbp
  800420f91e:	48 83 ec 20          	sub    $0x20,%rsp
  800420f922:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f926:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  800420f92a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f92e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  800420f932:	90                   	nop
  800420f933:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f937:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f93b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f93f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f943:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420f947:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420f94b:	0f b6 12             	movzbl (%rdx),%edx
  800420f94e:	88 10                	mov    %dl,(%rax)
  800420f950:	0f b6 00             	movzbl (%rax),%eax
  800420f953:	84 c0                	test   %al,%al
  800420f955:	75 dc                	jne    800420f933 <strcpy+0x19>
		/* do nothing */;
	return ret;
  800420f957:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f95b:	c9                   	leaveq 
  800420f95c:	c3                   	retq   

000000800420f95d <strcat>:

char *
strcat(char *dst, const char *src)
{
  800420f95d:	55                   	push   %rbp
  800420f95e:	48 89 e5             	mov    %rsp,%rbp
  800420f961:	48 83 ec 20          	sub    $0x20,%rsp
  800420f965:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f969:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  800420f96d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f971:	48 89 c7             	mov    %rax,%rdi
  800420f974:	48 b8 ae f8 20 04 80 	movabs $0x800420f8ae,%rax
  800420f97b:	00 00 00 
  800420f97e:	ff d0                	callq  *%rax
  800420f980:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  800420f983:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f986:	48 63 d0             	movslq %eax,%rdx
  800420f989:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f98d:	48 01 c2             	add    %rax,%rdx
  800420f990:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f994:	48 89 c6             	mov    %rax,%rsi
  800420f997:	48 89 d7             	mov    %rdx,%rdi
  800420f99a:	48 b8 1a f9 20 04 80 	movabs $0x800420f91a,%rax
  800420f9a1:	00 00 00 
  800420f9a4:	ff d0                	callq  *%rax
	return dst;
  800420f9a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420f9aa:	c9                   	leaveq 
  800420f9ab:	c3                   	retq   

000000800420f9ac <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  800420f9ac:	55                   	push   %rbp
  800420f9ad:	48 89 e5             	mov    %rsp,%rbp
  800420f9b0:	48 83 ec 28          	sub    $0x28,%rsp
  800420f9b4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f9b8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f9bc:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  800420f9c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f9c4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  800420f9c8:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f9cf:	00 
  800420f9d0:	eb 2a                	jmp    800420f9fc <strncpy+0x50>
		*dst++ = *src;
  800420f9d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f9d6:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f9da:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f9de:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f9e2:	0f b6 12             	movzbl (%rdx),%edx
  800420f9e5:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  800420f9e7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f9eb:	0f b6 00             	movzbl (%rax),%eax
  800420f9ee:	84 c0                	test   %al,%al
  800420f9f0:	74 05                	je     800420f9f7 <strncpy+0x4b>
			src++;
  800420f9f2:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  800420f9f7:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f9fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa00:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420fa04:	72 cc                	jb     800420f9d2 <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  800420fa06:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420fa0a:	c9                   	leaveq 
  800420fa0b:	c3                   	retq   

000000800420fa0c <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  800420fa0c:	55                   	push   %rbp
  800420fa0d:	48 89 e5             	mov    %rsp,%rbp
  800420fa10:	48 83 ec 28          	sub    $0x28,%rsp
  800420fa14:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fa18:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420fa1c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  800420fa20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa24:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  800420fa28:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420fa2d:	74 3d                	je     800420fa6c <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  800420fa2f:	eb 1d                	jmp    800420fa4e <strlcpy+0x42>
			*dst++ = *src++;
  800420fa31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa35:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420fa39:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420fa3d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420fa41:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420fa45:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420fa49:	0f b6 12             	movzbl (%rdx),%edx
  800420fa4c:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  800420fa4e:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  800420fa53:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420fa58:	74 0b                	je     800420fa65 <strlcpy+0x59>
  800420fa5a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fa5e:	0f b6 00             	movzbl (%rax),%eax
  800420fa61:	84 c0                	test   %al,%al
  800420fa63:	75 cc                	jne    800420fa31 <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  800420fa65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa69:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  800420fa6c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fa70:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa74:	48 29 c2             	sub    %rax,%rdx
  800420fa77:	48 89 d0             	mov    %rdx,%rax
}
  800420fa7a:	c9                   	leaveq 
  800420fa7b:	c3                   	retq   

000000800420fa7c <strcmp>:

int
strcmp(const char *p, const char *q)
{
  800420fa7c:	55                   	push   %rbp
  800420fa7d:	48 89 e5             	mov    %rsp,%rbp
  800420fa80:	48 83 ec 10          	sub    $0x10,%rsp
  800420fa84:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420fa88:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  800420fa8c:	eb 0a                	jmp    800420fa98 <strcmp+0x1c>
		p++, q++;
  800420fa8e:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420fa93:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  800420fa98:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa9c:	0f b6 00             	movzbl (%rax),%eax
  800420fa9f:	84 c0                	test   %al,%al
  800420faa1:	74 12                	je     800420fab5 <strcmp+0x39>
  800420faa3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420faa7:	0f b6 10             	movzbl (%rax),%edx
  800420faaa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420faae:	0f b6 00             	movzbl (%rax),%eax
  800420fab1:	38 c2                	cmp    %al,%dl
  800420fab3:	74 d9                	je     800420fa8e <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  800420fab5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fab9:	0f b6 00             	movzbl (%rax),%eax
  800420fabc:	0f b6 d0             	movzbl %al,%edx
  800420fabf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fac3:	0f b6 00             	movzbl (%rax),%eax
  800420fac6:	0f b6 c0             	movzbl %al,%eax
  800420fac9:	29 c2                	sub    %eax,%edx
  800420facb:	89 d0                	mov    %edx,%eax
}
  800420facd:	c9                   	leaveq 
  800420face:	c3                   	retq   

000000800420facf <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  800420facf:	55                   	push   %rbp
  800420fad0:	48 89 e5             	mov    %rsp,%rbp
  800420fad3:	48 83 ec 18          	sub    $0x18,%rsp
  800420fad7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420fadb:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420fadf:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  800420fae3:	eb 0f                	jmp    800420faf4 <strncmp+0x25>
		n--, p++, q++;
  800420fae5:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  800420faea:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420faef:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  800420faf4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420faf9:	74 1d                	je     800420fb18 <strncmp+0x49>
  800420fafb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420faff:	0f b6 00             	movzbl (%rax),%eax
  800420fb02:	84 c0                	test   %al,%al
  800420fb04:	74 12                	je     800420fb18 <strncmp+0x49>
  800420fb06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb0a:	0f b6 10             	movzbl (%rax),%edx
  800420fb0d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fb11:	0f b6 00             	movzbl (%rax),%eax
  800420fb14:	38 c2                	cmp    %al,%dl
  800420fb16:	74 cd                	je     800420fae5 <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  800420fb18:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420fb1d:	75 07                	jne    800420fb26 <strncmp+0x57>
		return 0;
  800420fb1f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fb24:	eb 18                	jmp    800420fb3e <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  800420fb26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb2a:	0f b6 00             	movzbl (%rax),%eax
  800420fb2d:	0f b6 d0             	movzbl %al,%edx
  800420fb30:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fb34:	0f b6 00             	movzbl (%rax),%eax
  800420fb37:	0f b6 c0             	movzbl %al,%eax
  800420fb3a:	29 c2                	sub    %eax,%edx
  800420fb3c:	89 d0                	mov    %edx,%eax
}
  800420fb3e:	c9                   	leaveq 
  800420fb3f:	c3                   	retq   

000000800420fb40 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  800420fb40:	55                   	push   %rbp
  800420fb41:	48 89 e5             	mov    %rsp,%rbp
  800420fb44:	48 83 ec 0c          	sub    $0xc,%rsp
  800420fb48:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420fb4c:	89 f0                	mov    %esi,%eax
  800420fb4e:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420fb51:	eb 17                	jmp    800420fb6a <strchr+0x2a>
		if (*s == c)
  800420fb53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb57:	0f b6 00             	movzbl (%rax),%eax
  800420fb5a:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420fb5d:	75 06                	jne    800420fb65 <strchr+0x25>
			return (char *) s;
  800420fb5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb63:	eb 15                	jmp    800420fb7a <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  800420fb65:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420fb6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb6e:	0f b6 00             	movzbl (%rax),%eax
  800420fb71:	84 c0                	test   %al,%al
  800420fb73:	75 de                	jne    800420fb53 <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  800420fb75:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fb7a:	c9                   	leaveq 
  800420fb7b:	c3                   	retq   

000000800420fb7c <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  800420fb7c:	55                   	push   %rbp
  800420fb7d:	48 89 e5             	mov    %rsp,%rbp
  800420fb80:	48 83 ec 0c          	sub    $0xc,%rsp
  800420fb84:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420fb88:	89 f0                	mov    %esi,%eax
  800420fb8a:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420fb8d:	eb 13                	jmp    800420fba2 <strfind+0x26>
		if (*s == c)
  800420fb8f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb93:	0f b6 00             	movzbl (%rax),%eax
  800420fb96:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420fb99:	75 02                	jne    800420fb9d <strfind+0x21>
			break;
  800420fb9b:	eb 10                	jmp    800420fbad <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  800420fb9d:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420fba2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fba6:	0f b6 00             	movzbl (%rax),%eax
  800420fba9:	84 c0                	test   %al,%al
  800420fbab:	75 e2                	jne    800420fb8f <strfind+0x13>
		if (*s == c)
			break;
	return (char *) s;
  800420fbad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420fbb1:	c9                   	leaveq 
  800420fbb2:	c3                   	retq   

000000800420fbb3 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  800420fbb3:	55                   	push   %rbp
  800420fbb4:	48 89 e5             	mov    %rsp,%rbp
  800420fbb7:	48 83 ec 18          	sub    $0x18,%rsp
  800420fbbb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420fbbf:	89 75 f4             	mov    %esi,-0xc(%rbp)
  800420fbc2:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  800420fbc6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420fbcb:	75 06                	jne    800420fbd3 <memset+0x20>
		return v;
  800420fbcd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fbd1:	eb 69                	jmp    800420fc3c <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  800420fbd3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fbd7:	83 e0 03             	and    $0x3,%eax
  800420fbda:	48 85 c0             	test   %rax,%rax
  800420fbdd:	75 48                	jne    800420fc27 <memset+0x74>
  800420fbdf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fbe3:	83 e0 03             	and    $0x3,%eax
  800420fbe6:	48 85 c0             	test   %rax,%rax
  800420fbe9:	75 3c                	jne    800420fc27 <memset+0x74>
		c &= 0xFF;
  800420fbeb:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  800420fbf2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fbf5:	c1 e0 18             	shl    $0x18,%eax
  800420fbf8:	89 c2                	mov    %eax,%edx
  800420fbfa:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fbfd:	c1 e0 10             	shl    $0x10,%eax
  800420fc00:	09 c2                	or     %eax,%edx
  800420fc02:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fc05:	c1 e0 08             	shl    $0x8,%eax
  800420fc08:	09 d0                	or     %edx,%eax
  800420fc0a:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  800420fc0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc11:	48 c1 e8 02          	shr    $0x2,%rax
  800420fc15:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  800420fc18:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fc1c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fc1f:	48 89 d7             	mov    %rdx,%rdi
  800420fc22:	fc                   	cld    
  800420fc23:	f3 ab                	rep stos %eax,%es:(%rdi)
  800420fc25:	eb 11                	jmp    800420fc38 <memset+0x85>
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  800420fc27:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fc2b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fc2e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420fc32:	48 89 d7             	mov    %rdx,%rdi
  800420fc35:	fc                   	cld    
  800420fc36:	f3 aa                	rep stos %al,%es:(%rdi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
  800420fc38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420fc3c:	c9                   	leaveq 
  800420fc3d:	c3                   	retq   

000000800420fc3e <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  800420fc3e:	55                   	push   %rbp
  800420fc3f:	48 89 e5             	mov    %rsp,%rbp
  800420fc42:	48 83 ec 28          	sub    $0x28,%rsp
  800420fc46:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fc4a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420fc4e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  800420fc52:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fc56:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  800420fc5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc5e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  800420fc62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fc66:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420fc6a:	0f 83 88 00 00 00    	jae    800420fcf8 <memmove+0xba>
  800420fc70:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc74:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fc78:	48 01 d0             	add    %rdx,%rax
  800420fc7b:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420fc7f:	76 77                	jbe    800420fcf8 <memmove+0xba>
		s += n;
  800420fc81:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc85:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  800420fc89:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc8d:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420fc91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fc95:	83 e0 03             	and    $0x3,%eax
  800420fc98:	48 85 c0             	test   %rax,%rax
  800420fc9b:	75 3b                	jne    800420fcd8 <memmove+0x9a>
  800420fc9d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fca1:	83 e0 03             	and    $0x3,%eax
  800420fca4:	48 85 c0             	test   %rax,%rax
  800420fca7:	75 2f                	jne    800420fcd8 <memmove+0x9a>
  800420fca9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fcad:	83 e0 03             	and    $0x3,%eax
  800420fcb0:	48 85 c0             	test   %rax,%rax
  800420fcb3:	75 23                	jne    800420fcd8 <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  800420fcb5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fcb9:	48 83 e8 04          	sub    $0x4,%rax
  800420fcbd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fcc1:	48 83 ea 04          	sub    $0x4,%rdx
  800420fcc5:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420fcc9:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  800420fccd:	48 89 c7             	mov    %rax,%rdi
  800420fcd0:	48 89 d6             	mov    %rdx,%rsi
  800420fcd3:	fd                   	std    
  800420fcd4:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420fcd6:	eb 1d                	jmp    800420fcf5 <memmove+0xb7>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  800420fcd8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fcdc:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420fce0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fce4:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  800420fce8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fcec:	48 89 d7             	mov    %rdx,%rdi
  800420fcef:	48 89 c1             	mov    %rax,%rcx
  800420fcf2:	fd                   	std    
  800420fcf3:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  800420fcf5:	fc                   	cld    
  800420fcf6:	eb 57                	jmp    800420fd4f <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420fcf8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fcfc:	83 e0 03             	and    $0x3,%eax
  800420fcff:	48 85 c0             	test   %rax,%rax
  800420fd02:	75 36                	jne    800420fd3a <memmove+0xfc>
  800420fd04:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fd08:	83 e0 03             	and    $0x3,%eax
  800420fd0b:	48 85 c0             	test   %rax,%rax
  800420fd0e:	75 2a                	jne    800420fd3a <memmove+0xfc>
  800420fd10:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd14:	83 e0 03             	and    $0x3,%eax
  800420fd17:	48 85 c0             	test   %rax,%rax
  800420fd1a:	75 1e                	jne    800420fd3a <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  800420fd1c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd20:	48 c1 e8 02          	shr    $0x2,%rax
  800420fd24:	48 89 c1             	mov    %rax,%rcx
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  800420fd27:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fd2b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fd2f:	48 89 c7             	mov    %rax,%rdi
  800420fd32:	48 89 d6             	mov    %rdx,%rsi
  800420fd35:	fc                   	cld    
  800420fd36:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420fd38:	eb 15                	jmp    800420fd4f <memmove+0x111>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  800420fd3a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fd3e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fd42:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420fd46:	48 89 c7             	mov    %rax,%rdi
  800420fd49:	48 89 d6             	mov    %rdx,%rsi
  800420fd4c:	fc                   	cld    
  800420fd4d:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  800420fd4f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420fd53:	c9                   	leaveq 
  800420fd54:	c3                   	retq   

000000800420fd55 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  800420fd55:	55                   	push   %rbp
  800420fd56:	48 89 e5             	mov    %rsp,%rbp
  800420fd59:	48 83 ec 18          	sub    $0x18,%rsp
  800420fd5d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420fd61:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420fd65:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  800420fd69:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fd6d:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420fd71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fd75:	48 89 ce             	mov    %rcx,%rsi
  800420fd78:	48 89 c7             	mov    %rax,%rdi
  800420fd7b:	48 b8 3e fc 20 04 80 	movabs $0x800420fc3e,%rax
  800420fd82:	00 00 00 
  800420fd85:	ff d0                	callq  *%rax
}
  800420fd87:	c9                   	leaveq 
  800420fd88:	c3                   	retq   

000000800420fd89 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  800420fd89:	55                   	push   %rbp
  800420fd8a:	48 89 e5             	mov    %rsp,%rbp
  800420fd8d:	48 83 ec 28          	sub    $0x28,%rsp
  800420fd91:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fd95:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420fd99:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  800420fd9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fda1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  800420fda5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fda9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  800420fdad:	eb 36                	jmp    800420fde5 <memcmp+0x5c>
		if (*s1 != *s2)
  800420fdaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fdb3:	0f b6 10             	movzbl (%rax),%edx
  800420fdb6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fdba:	0f b6 00             	movzbl (%rax),%eax
  800420fdbd:	38 c2                	cmp    %al,%dl
  800420fdbf:	74 1a                	je     800420fddb <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  800420fdc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fdc5:	0f b6 00             	movzbl (%rax),%eax
  800420fdc8:	0f b6 d0             	movzbl %al,%edx
  800420fdcb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fdcf:	0f b6 00             	movzbl (%rax),%eax
  800420fdd2:	0f b6 c0             	movzbl %al,%eax
  800420fdd5:	29 c2                	sub    %eax,%edx
  800420fdd7:	89 d0                	mov    %edx,%eax
  800420fdd9:	eb 20                	jmp    800420fdfb <memcmp+0x72>
		s1++, s2++;
  800420fddb:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420fde0:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  800420fde5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fde9:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420fded:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420fdf1:	48 85 c0             	test   %rax,%rax
  800420fdf4:	75 b9                	jne    800420fdaf <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  800420fdf6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fdfb:	c9                   	leaveq 
  800420fdfc:	c3                   	retq   

000000800420fdfd <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  800420fdfd:	55                   	push   %rbp
  800420fdfe:	48 89 e5             	mov    %rsp,%rbp
  800420fe01:	48 83 ec 28          	sub    $0x28,%rsp
  800420fe05:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fe09:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  800420fe0c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  800420fe10:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe14:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fe18:	48 01 d0             	add    %rdx,%rax
  800420fe1b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  800420fe1f:	eb 15                	jmp    800420fe36 <memfind+0x39>
		if (*(const unsigned char *) s == (unsigned char) c)
  800420fe21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe25:	0f b6 10             	movzbl (%rax),%edx
  800420fe28:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420fe2b:	38 c2                	cmp    %al,%dl
  800420fe2d:	75 02                	jne    800420fe31 <memfind+0x34>
			break;
  800420fe2f:	eb 0f                	jmp    800420fe40 <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  800420fe31:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420fe36:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe3a:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420fe3e:	72 e1                	jb     800420fe21 <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
  800420fe40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420fe44:	c9                   	leaveq 
  800420fe45:	c3                   	retq   

000000800420fe46 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  800420fe46:	55                   	push   %rbp
  800420fe47:	48 89 e5             	mov    %rsp,%rbp
  800420fe4a:	48 83 ec 34          	sub    $0x34,%rsp
  800420fe4e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420fe52:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420fe56:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  800420fe59:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  800420fe60:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420fe67:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420fe68:	eb 05                	jmp    800420fe6f <strtol+0x29>
		s++;
  800420fe6a:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420fe6f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe73:	0f b6 00             	movzbl (%rax),%eax
  800420fe76:	3c 20                	cmp    $0x20,%al
  800420fe78:	74 f0                	je     800420fe6a <strtol+0x24>
  800420fe7a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe7e:	0f b6 00             	movzbl (%rax),%eax
  800420fe81:	3c 09                	cmp    $0x9,%al
  800420fe83:	74 e5                	je     800420fe6a <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  800420fe85:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe89:	0f b6 00             	movzbl (%rax),%eax
  800420fe8c:	3c 2b                	cmp    $0x2b,%al
  800420fe8e:	75 07                	jne    800420fe97 <strtol+0x51>
		s++;
  800420fe90:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fe95:	eb 17                	jmp    800420feae <strtol+0x68>
	else if (*s == '-')
  800420fe97:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe9b:	0f b6 00             	movzbl (%rax),%eax
  800420fe9e:	3c 2d                	cmp    $0x2d,%al
  800420fea0:	75 0c                	jne    800420feae <strtol+0x68>
		s++, neg = 1;
  800420fea2:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fea7:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  800420feae:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420feb2:	74 06                	je     800420feba <strtol+0x74>
  800420feb4:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  800420feb8:	75 28                	jne    800420fee2 <strtol+0x9c>
  800420feba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420febe:	0f b6 00             	movzbl (%rax),%eax
  800420fec1:	3c 30                	cmp    $0x30,%al
  800420fec3:	75 1d                	jne    800420fee2 <strtol+0x9c>
  800420fec5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fec9:	48 83 c0 01          	add    $0x1,%rax
  800420fecd:	0f b6 00             	movzbl (%rax),%eax
  800420fed0:	3c 78                	cmp    $0x78,%al
  800420fed2:	75 0e                	jne    800420fee2 <strtol+0x9c>
		s += 2, base = 16;
  800420fed4:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  800420fed9:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  800420fee0:	eb 2c                	jmp    800420ff0e <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  800420fee2:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420fee6:	75 19                	jne    800420ff01 <strtol+0xbb>
  800420fee8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420feec:	0f b6 00             	movzbl (%rax),%eax
  800420feef:	3c 30                	cmp    $0x30,%al
  800420fef1:	75 0e                	jne    800420ff01 <strtol+0xbb>
		s++, base = 8;
  800420fef3:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fef8:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  800420feff:	eb 0d                	jmp    800420ff0e <strtol+0xc8>
	else if (base == 0)
  800420ff01:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420ff05:	75 07                	jne    800420ff0e <strtol+0xc8>
		base = 10;
  800420ff07:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  800420ff0e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ff12:	0f b6 00             	movzbl (%rax),%eax
  800420ff15:	3c 2f                	cmp    $0x2f,%al
  800420ff17:	7e 1d                	jle    800420ff36 <strtol+0xf0>
  800420ff19:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ff1d:	0f b6 00             	movzbl (%rax),%eax
  800420ff20:	3c 39                	cmp    $0x39,%al
  800420ff22:	7f 12                	jg     800420ff36 <strtol+0xf0>
			dig = *s - '0';
  800420ff24:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ff28:	0f b6 00             	movzbl (%rax),%eax
  800420ff2b:	0f be c0             	movsbl %al,%eax
  800420ff2e:	83 e8 30             	sub    $0x30,%eax
  800420ff31:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420ff34:	eb 4e                	jmp    800420ff84 <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  800420ff36:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ff3a:	0f b6 00             	movzbl (%rax),%eax
  800420ff3d:	3c 60                	cmp    $0x60,%al
  800420ff3f:	7e 1d                	jle    800420ff5e <strtol+0x118>
  800420ff41:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ff45:	0f b6 00             	movzbl (%rax),%eax
  800420ff48:	3c 7a                	cmp    $0x7a,%al
  800420ff4a:	7f 12                	jg     800420ff5e <strtol+0x118>
			dig = *s - 'a' + 10;
  800420ff4c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ff50:	0f b6 00             	movzbl (%rax),%eax
  800420ff53:	0f be c0             	movsbl %al,%eax
  800420ff56:	83 e8 57             	sub    $0x57,%eax
  800420ff59:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420ff5c:	eb 26                	jmp    800420ff84 <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  800420ff5e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ff62:	0f b6 00             	movzbl (%rax),%eax
  800420ff65:	3c 40                	cmp    $0x40,%al
  800420ff67:	7e 48                	jle    800420ffb1 <strtol+0x16b>
  800420ff69:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ff6d:	0f b6 00             	movzbl (%rax),%eax
  800420ff70:	3c 5a                	cmp    $0x5a,%al
  800420ff72:	7f 3d                	jg     800420ffb1 <strtol+0x16b>
			dig = *s - 'A' + 10;
  800420ff74:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ff78:	0f b6 00             	movzbl (%rax),%eax
  800420ff7b:	0f be c0             	movsbl %al,%eax
  800420ff7e:	83 e8 37             	sub    $0x37,%eax
  800420ff81:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  800420ff84:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ff87:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  800420ff8a:	7c 02                	jl     800420ff8e <strtol+0x148>
			break;
  800420ff8c:	eb 23                	jmp    800420ffb1 <strtol+0x16b>
		s++, val = (val * base) + dig;
  800420ff8e:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420ff93:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420ff96:	48 98                	cltq   
  800420ff98:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  800420ff9d:	48 89 c2             	mov    %rax,%rdx
  800420ffa0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ffa3:	48 98                	cltq   
  800420ffa5:	48 01 d0             	add    %rdx,%rax
  800420ffa8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  800420ffac:	e9 5d ff ff ff       	jmpq   800420ff0e <strtol+0xc8>

	if (endptr)
  800420ffb1:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420ffb6:	74 0b                	je     800420ffc3 <strtol+0x17d>
		*endptr = (char *) s;
  800420ffb8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ffbc:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420ffc0:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  800420ffc3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420ffc7:	74 09                	je     800420ffd2 <strtol+0x18c>
  800420ffc9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ffcd:	48 f7 d8             	neg    %rax
  800420ffd0:	eb 04                	jmp    800420ffd6 <strtol+0x190>
  800420ffd2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420ffd6:	c9                   	leaveq 
  800420ffd7:	c3                   	retq   

000000800420ffd8 <strstr>:

char * strstr(const char *in, const char *str)
{
  800420ffd8:	55                   	push   %rbp
  800420ffd9:	48 89 e5             	mov    %rsp,%rbp
  800420ffdc:	48 83 ec 30          	sub    $0x30,%rsp
  800420ffe0:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420ffe4:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    char c;
    size_t len;

    c = *str++;
  800420ffe8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ffec:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420fff0:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420fff4:	0f b6 00             	movzbl (%rax),%eax
  800420fff7:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (!c)
  800420fffa:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800420fffe:	75 06                	jne    8004210006 <strstr+0x2e>
        return (char *) in;	// Trivial empty string case
  8004210000:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210004:	eb 6b                	jmp    8004210071 <strstr+0x99>

    len = strlen(str);
  8004210006:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421000a:	48 89 c7             	mov    %rax,%rdi
  800421000d:	48 b8 ae f8 20 04 80 	movabs $0x800420f8ae,%rax
  8004210014:	00 00 00 
  8004210017:	ff d0                	callq  *%rax
  8004210019:	48 98                	cltq   
  800421001b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    do {
        char sc;

        do {
            sc = *in++;
  800421001f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210023:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210027:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800421002b:	0f b6 00             	movzbl (%rax),%eax
  800421002e:	88 45 ef             	mov    %al,-0x11(%rbp)
            if (!sc)
  8004210031:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8004210035:	75 07                	jne    800421003e <strstr+0x66>
                return (char *) 0;
  8004210037:	b8 00 00 00 00       	mov    $0x0,%eax
  800421003c:	eb 33                	jmp    8004210071 <strstr+0x99>
        } while (sc != c);
  800421003e:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004210042:	3a 45 ff             	cmp    -0x1(%rbp),%al
  8004210045:	75 d8                	jne    800421001f <strstr+0x47>
    } while (strncmp(in, str, len) != 0);
  8004210047:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421004b:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800421004f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210053:	48 89 ce             	mov    %rcx,%rsi
  8004210056:	48 89 c7             	mov    %rax,%rdi
  8004210059:	48 b8 cf fa 20 04 80 	movabs $0x800420facf,%rax
  8004210060:	00 00 00 
  8004210063:	ff d0                	callq  *%rax
  8004210065:	85 c0                	test   %eax,%eax
  8004210067:	75 b6                	jne    800421001f <strstr+0x47>

    return (char *) (in - 1);
  8004210069:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421006d:	48 83 e8 01          	sub    $0x1,%rax
}
  8004210071:	c9                   	leaveq 
  8004210072:	c3                   	retq   

0000008004210073 <_dwarf_read_lsb>:

int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  8004210073:	55                   	push   %rbp
  8004210074:	48 89 e5             	mov    %rsp,%rbp
  8004210077:	48 83 ec 24          	sub    $0x24,%rsp
  800421007b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421007f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210083:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  8004210086:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421008a:	48 8b 10             	mov    (%rax),%rdx
  800421008d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210091:	48 01 d0             	add    %rdx,%rax
  8004210094:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  8004210098:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800421009f:	00 
	switch (bytes_to_read) {
  80042100a0:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042100a3:	83 f8 02             	cmp    $0x2,%eax
  80042100a6:	0f 84 ab 00 00 00    	je     8004210157 <_dwarf_read_lsb+0xe4>
  80042100ac:	83 f8 02             	cmp    $0x2,%eax
  80042100af:	7f 0e                	jg     80042100bf <_dwarf_read_lsb+0x4c>
  80042100b1:	83 f8 01             	cmp    $0x1,%eax
  80042100b4:	0f 84 b3 00 00 00    	je     800421016d <_dwarf_read_lsb+0xfa>
  80042100ba:	e9 d9 00 00 00       	jmpq   8004210198 <_dwarf_read_lsb+0x125>
  80042100bf:	83 f8 04             	cmp    $0x4,%eax
  80042100c2:	74 65                	je     8004210129 <_dwarf_read_lsb+0xb6>
  80042100c4:	83 f8 08             	cmp    $0x8,%eax
  80042100c7:	0f 85 cb 00 00 00    	jne    8004210198 <_dwarf_read_lsb+0x125>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  80042100cd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042100d1:	48 83 c0 04          	add    $0x4,%rax
  80042100d5:	0f b6 00             	movzbl (%rax),%eax
  80042100d8:	0f b6 c0             	movzbl %al,%eax
  80042100db:	48 c1 e0 20          	shl    $0x20,%rax
  80042100df:	48 89 c2             	mov    %rax,%rdx
  80042100e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042100e6:	48 83 c0 05          	add    $0x5,%rax
  80042100ea:	0f b6 00             	movzbl (%rax),%eax
  80042100ed:	0f b6 c0             	movzbl %al,%eax
  80042100f0:	48 c1 e0 28          	shl    $0x28,%rax
  80042100f4:	48 09 d0             	or     %rdx,%rax
  80042100f7:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  80042100fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042100ff:	48 83 c0 06          	add    $0x6,%rax
  8004210103:	0f b6 00             	movzbl (%rax),%eax
  8004210106:	0f b6 c0             	movzbl %al,%eax
  8004210109:	48 c1 e0 30          	shl    $0x30,%rax
  800421010d:	48 89 c2             	mov    %rax,%rdx
  8004210110:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210114:	48 83 c0 07          	add    $0x7,%rax
  8004210118:	0f b6 00             	movzbl (%rax),%eax
  800421011b:	0f b6 c0             	movzbl %al,%eax
  800421011e:	48 c1 e0 38          	shl    $0x38,%rax
  8004210122:	48 09 d0             	or     %rdx,%rax
  8004210125:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  8004210129:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421012d:	48 83 c0 02          	add    $0x2,%rax
  8004210131:	0f b6 00             	movzbl (%rax),%eax
  8004210134:	0f b6 c0             	movzbl %al,%eax
  8004210137:	48 c1 e0 10          	shl    $0x10,%rax
  800421013b:	48 89 c2             	mov    %rax,%rdx
  800421013e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210142:	48 83 c0 03          	add    $0x3,%rax
  8004210146:	0f b6 00             	movzbl (%rax),%eax
  8004210149:	0f b6 c0             	movzbl %al,%eax
  800421014c:	48 c1 e0 18          	shl    $0x18,%rax
  8004210150:	48 09 d0             	or     %rdx,%rax
  8004210153:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  8004210157:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421015b:	48 83 c0 01          	add    $0x1,%rax
  800421015f:	0f b6 00             	movzbl (%rax),%eax
  8004210162:	0f b6 c0             	movzbl %al,%eax
  8004210165:	48 c1 e0 08          	shl    $0x8,%rax
  8004210169:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800421016d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210171:	0f b6 00             	movzbl (%rax),%eax
  8004210174:	0f b6 c0             	movzbl %al,%eax
  8004210177:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800421017b:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  800421017c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210180:	48 8b 10             	mov    (%rax),%rdx
  8004210183:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004210186:	48 98                	cltq   
  8004210188:	48 01 c2             	add    %rax,%rdx
  800421018b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421018f:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210192:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210196:	eb 05                	jmp    800421019d <_dwarf_read_lsb+0x12a>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  8004210198:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*offsetp += bytes_to_read;

	return (ret);
}
  800421019d:	c9                   	leaveq 
  800421019e:	c3                   	retq   

000000800421019f <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  800421019f:	55                   	push   %rbp
  80042101a0:	48 89 e5             	mov    %rsp,%rbp
  80042101a3:	48 83 ec 1c          	sub    $0x1c,%rsp
  80042101a7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042101ab:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  80042101ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042101b2:	48 8b 00             	mov    (%rax),%rax
  80042101b5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  80042101b9:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042101c0:	00 
	switch (bytes_to_read) {
  80042101c1:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042101c4:	83 f8 02             	cmp    $0x2,%eax
  80042101c7:	0f 84 ab 00 00 00    	je     8004210278 <_dwarf_decode_lsb+0xd9>
  80042101cd:	83 f8 02             	cmp    $0x2,%eax
  80042101d0:	7f 0e                	jg     80042101e0 <_dwarf_decode_lsb+0x41>
  80042101d2:	83 f8 01             	cmp    $0x1,%eax
  80042101d5:	0f 84 b3 00 00 00    	je     800421028e <_dwarf_decode_lsb+0xef>
  80042101db:	e9 d9 00 00 00       	jmpq   80042102b9 <_dwarf_decode_lsb+0x11a>
  80042101e0:	83 f8 04             	cmp    $0x4,%eax
  80042101e3:	74 65                	je     800421024a <_dwarf_decode_lsb+0xab>
  80042101e5:	83 f8 08             	cmp    $0x8,%eax
  80042101e8:	0f 85 cb 00 00 00    	jne    80042102b9 <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  80042101ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101f2:	48 83 c0 04          	add    $0x4,%rax
  80042101f6:	0f b6 00             	movzbl (%rax),%eax
  80042101f9:	0f b6 c0             	movzbl %al,%eax
  80042101fc:	48 c1 e0 20          	shl    $0x20,%rax
  8004210200:	48 89 c2             	mov    %rax,%rdx
  8004210203:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210207:	48 83 c0 05          	add    $0x5,%rax
  800421020b:	0f b6 00             	movzbl (%rax),%eax
  800421020e:	0f b6 c0             	movzbl %al,%eax
  8004210211:	48 c1 e0 28          	shl    $0x28,%rax
  8004210215:	48 09 d0             	or     %rdx,%rax
  8004210218:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800421021c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210220:	48 83 c0 06          	add    $0x6,%rax
  8004210224:	0f b6 00             	movzbl (%rax),%eax
  8004210227:	0f b6 c0             	movzbl %al,%eax
  800421022a:	48 c1 e0 30          	shl    $0x30,%rax
  800421022e:	48 89 c2             	mov    %rax,%rdx
  8004210231:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210235:	48 83 c0 07          	add    $0x7,%rax
  8004210239:	0f b6 00             	movzbl (%rax),%eax
  800421023c:	0f b6 c0             	movzbl %al,%eax
  800421023f:	48 c1 e0 38          	shl    $0x38,%rax
  8004210243:	48 09 d0             	or     %rdx,%rax
  8004210246:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800421024a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421024e:	48 83 c0 02          	add    $0x2,%rax
  8004210252:	0f b6 00             	movzbl (%rax),%eax
  8004210255:	0f b6 c0             	movzbl %al,%eax
  8004210258:	48 c1 e0 10          	shl    $0x10,%rax
  800421025c:	48 89 c2             	mov    %rax,%rdx
  800421025f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210263:	48 83 c0 03          	add    $0x3,%rax
  8004210267:	0f b6 00             	movzbl (%rax),%eax
  800421026a:	0f b6 c0             	movzbl %al,%eax
  800421026d:	48 c1 e0 18          	shl    $0x18,%rax
  8004210271:	48 09 d0             	or     %rdx,%rax
  8004210274:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  8004210278:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421027c:	48 83 c0 01          	add    $0x1,%rax
  8004210280:	0f b6 00             	movzbl (%rax),%eax
  8004210283:	0f b6 c0             	movzbl %al,%eax
  8004210286:	48 c1 e0 08          	shl    $0x8,%rax
  800421028a:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800421028e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210292:	0f b6 00             	movzbl (%rax),%eax
  8004210295:	0f b6 c0             	movzbl %al,%eax
  8004210298:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800421029c:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  800421029d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042102a1:	48 8b 10             	mov    (%rax),%rdx
  80042102a4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042102a7:	48 98                	cltq   
  80042102a9:	48 01 c2             	add    %rax,%rdx
  80042102ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042102b0:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042102b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042102b7:	eb 05                	jmp    80042102be <_dwarf_decode_lsb+0x11f>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  80042102b9:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*data += bytes_to_read;

	return (ret);
}
  80042102be:	c9                   	leaveq 
  80042102bf:	c3                   	retq   

00000080042102c0 <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  80042102c0:	55                   	push   %rbp
  80042102c1:	48 89 e5             	mov    %rsp,%rbp
  80042102c4:	48 83 ec 24          	sub    $0x24,%rsp
  80042102c8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042102cc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042102d0:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  80042102d3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042102d7:	48 8b 10             	mov    (%rax),%rdx
  80042102da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042102de:	48 01 d0             	add    %rdx,%rax
  80042102e1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  80042102e5:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042102e8:	83 f8 02             	cmp    $0x2,%eax
  80042102eb:	74 35                	je     8004210322 <_dwarf_read_msb+0x62>
  80042102ed:	83 f8 02             	cmp    $0x2,%eax
  80042102f0:	7f 0a                	jg     80042102fc <_dwarf_read_msb+0x3c>
  80042102f2:	83 f8 01             	cmp    $0x1,%eax
  80042102f5:	74 18                	je     800421030f <_dwarf_read_msb+0x4f>
  80042102f7:	e9 53 01 00 00       	jmpq   800421044f <_dwarf_read_msb+0x18f>
  80042102fc:	83 f8 04             	cmp    $0x4,%eax
  80042102ff:	74 49                	je     800421034a <_dwarf_read_msb+0x8a>
  8004210301:	83 f8 08             	cmp    $0x8,%eax
  8004210304:	0f 84 96 00 00 00    	je     80042103a0 <_dwarf_read_msb+0xe0>
  800421030a:	e9 40 01 00 00       	jmpq   800421044f <_dwarf_read_msb+0x18f>
	case 1:
		ret = src[0];
  800421030f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210313:	0f b6 00             	movzbl (%rax),%eax
  8004210316:	0f b6 c0             	movzbl %al,%eax
  8004210319:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800421031d:	e9 34 01 00 00       	jmpq   8004210456 <_dwarf_read_msb+0x196>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  8004210322:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210326:	48 83 c0 01          	add    $0x1,%rax
  800421032a:	0f b6 00             	movzbl (%rax),%eax
  800421032d:	0f b6 d0             	movzbl %al,%edx
  8004210330:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210334:	0f b6 00             	movzbl (%rax),%eax
  8004210337:	0f b6 c0             	movzbl %al,%eax
  800421033a:	48 c1 e0 08          	shl    $0x8,%rax
  800421033e:	48 09 d0             	or     %rdx,%rax
  8004210341:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  8004210345:	e9 0c 01 00 00       	jmpq   8004210456 <_dwarf_read_msb+0x196>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800421034a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421034e:	48 83 c0 03          	add    $0x3,%rax
  8004210352:	0f b6 00             	movzbl (%rax),%eax
  8004210355:	0f b6 c0             	movzbl %al,%eax
  8004210358:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421035c:	48 83 c2 02          	add    $0x2,%rdx
  8004210360:	0f b6 12             	movzbl (%rdx),%edx
  8004210363:	0f b6 d2             	movzbl %dl,%edx
  8004210366:	48 c1 e2 08          	shl    $0x8,%rdx
  800421036a:	48 09 d0             	or     %rdx,%rax
  800421036d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  8004210371:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210375:	48 83 c0 01          	add    $0x1,%rax
  8004210379:	0f b6 00             	movzbl (%rax),%eax
  800421037c:	0f b6 c0             	movzbl %al,%eax
  800421037f:	48 c1 e0 10          	shl    $0x10,%rax
  8004210383:	48 89 c2             	mov    %rax,%rdx
  8004210386:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421038a:	0f b6 00             	movzbl (%rax),%eax
  800421038d:	0f b6 c0             	movzbl %al,%eax
  8004210390:	48 c1 e0 18          	shl    $0x18,%rax
  8004210394:	48 09 d0             	or     %rdx,%rax
  8004210397:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800421039b:	e9 b6 00 00 00       	jmpq   8004210456 <_dwarf_read_msb+0x196>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  80042103a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042103a4:	48 83 c0 07          	add    $0x7,%rax
  80042103a8:	0f b6 00             	movzbl (%rax),%eax
  80042103ab:	0f b6 c0             	movzbl %al,%eax
  80042103ae:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042103b2:	48 83 c2 06          	add    $0x6,%rdx
  80042103b6:	0f b6 12             	movzbl (%rdx),%edx
  80042103b9:	0f b6 d2             	movzbl %dl,%edx
  80042103bc:	48 c1 e2 08          	shl    $0x8,%rdx
  80042103c0:	48 09 d0             	or     %rdx,%rax
  80042103c3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  80042103c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042103cb:	48 83 c0 05          	add    $0x5,%rax
  80042103cf:	0f b6 00             	movzbl (%rax),%eax
  80042103d2:	0f b6 c0             	movzbl %al,%eax
  80042103d5:	48 c1 e0 10          	shl    $0x10,%rax
  80042103d9:	48 89 c2             	mov    %rax,%rdx
  80042103dc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042103e0:	48 83 c0 04          	add    $0x4,%rax
  80042103e4:	0f b6 00             	movzbl (%rax),%eax
  80042103e7:	0f b6 c0             	movzbl %al,%eax
  80042103ea:	48 c1 e0 18          	shl    $0x18,%rax
  80042103ee:	48 09 d0             	or     %rdx,%rax
  80042103f1:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  80042103f5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042103f9:	48 83 c0 03          	add    $0x3,%rax
  80042103fd:	0f b6 00             	movzbl (%rax),%eax
  8004210400:	0f b6 c0             	movzbl %al,%eax
  8004210403:	48 c1 e0 20          	shl    $0x20,%rax
  8004210407:	48 89 c2             	mov    %rax,%rdx
  800421040a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421040e:	48 83 c0 02          	add    $0x2,%rax
  8004210412:	0f b6 00             	movzbl (%rax),%eax
  8004210415:	0f b6 c0             	movzbl %al,%eax
  8004210418:	48 c1 e0 28          	shl    $0x28,%rax
  800421041c:	48 09 d0             	or     %rdx,%rax
  800421041f:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  8004210423:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210427:	48 83 c0 01          	add    $0x1,%rax
  800421042b:	0f b6 00             	movzbl (%rax),%eax
  800421042e:	0f b6 c0             	movzbl %al,%eax
  8004210431:	48 c1 e0 30          	shl    $0x30,%rax
  8004210435:	48 89 c2             	mov    %rax,%rdx
  8004210438:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421043c:	0f b6 00             	movzbl (%rax),%eax
  800421043f:	0f b6 c0             	movzbl %al,%eax
  8004210442:	48 c1 e0 38          	shl    $0x38,%rax
  8004210446:	48 09 d0             	or     %rdx,%rax
  8004210449:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800421044d:	eb 07                	jmp    8004210456 <_dwarf_read_msb+0x196>
	default:
		return (0);
  800421044f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210454:	eb 1a                	jmp    8004210470 <_dwarf_read_msb+0x1b0>
	}

	*offsetp += bytes_to_read;
  8004210456:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421045a:	48 8b 10             	mov    (%rax),%rdx
  800421045d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004210460:	48 98                	cltq   
  8004210462:	48 01 c2             	add    %rax,%rdx
  8004210465:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210469:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800421046c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210470:	c9                   	leaveq 
  8004210471:	c3                   	retq   

0000008004210472 <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  8004210472:	55                   	push   %rbp
  8004210473:	48 89 e5             	mov    %rsp,%rbp
  8004210476:	48 83 ec 1c          	sub    $0x1c,%rsp
  800421047a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421047e:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  8004210481:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210485:	48 8b 00             	mov    (%rax),%rax
  8004210488:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800421048c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210493:	00 
	switch (bytes_to_read) {
  8004210494:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210497:	83 f8 02             	cmp    $0x2,%eax
  800421049a:	74 35                	je     80042104d1 <_dwarf_decode_msb+0x5f>
  800421049c:	83 f8 02             	cmp    $0x2,%eax
  800421049f:	7f 0a                	jg     80042104ab <_dwarf_decode_msb+0x39>
  80042104a1:	83 f8 01             	cmp    $0x1,%eax
  80042104a4:	74 18                	je     80042104be <_dwarf_decode_msb+0x4c>
  80042104a6:	e9 53 01 00 00       	jmpq   80042105fe <_dwarf_decode_msb+0x18c>
  80042104ab:	83 f8 04             	cmp    $0x4,%eax
  80042104ae:	74 49                	je     80042104f9 <_dwarf_decode_msb+0x87>
  80042104b0:	83 f8 08             	cmp    $0x8,%eax
  80042104b3:	0f 84 96 00 00 00    	je     800421054f <_dwarf_decode_msb+0xdd>
  80042104b9:	e9 40 01 00 00       	jmpq   80042105fe <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  80042104be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042104c2:	0f b6 00             	movzbl (%rax),%eax
  80042104c5:	0f b6 c0             	movzbl %al,%eax
  80042104c8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  80042104cc:	e9 34 01 00 00       	jmpq   8004210605 <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  80042104d1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042104d5:	48 83 c0 01          	add    $0x1,%rax
  80042104d9:	0f b6 00             	movzbl (%rax),%eax
  80042104dc:	0f b6 d0             	movzbl %al,%edx
  80042104df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042104e3:	0f b6 00             	movzbl (%rax),%eax
  80042104e6:	0f b6 c0             	movzbl %al,%eax
  80042104e9:	48 c1 e0 08          	shl    $0x8,%rax
  80042104ed:	48 09 d0             	or     %rdx,%rax
  80042104f0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  80042104f4:	e9 0c 01 00 00       	jmpq   8004210605 <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  80042104f9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042104fd:	48 83 c0 03          	add    $0x3,%rax
  8004210501:	0f b6 00             	movzbl (%rax),%eax
  8004210504:	0f b6 c0             	movzbl %al,%eax
  8004210507:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421050b:	48 83 c2 02          	add    $0x2,%rdx
  800421050f:	0f b6 12             	movzbl (%rdx),%edx
  8004210512:	0f b6 d2             	movzbl %dl,%edx
  8004210515:	48 c1 e2 08          	shl    $0x8,%rdx
  8004210519:	48 09 d0             	or     %rdx,%rax
  800421051c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  8004210520:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210524:	48 83 c0 01          	add    $0x1,%rax
  8004210528:	0f b6 00             	movzbl (%rax),%eax
  800421052b:	0f b6 c0             	movzbl %al,%eax
  800421052e:	48 c1 e0 10          	shl    $0x10,%rax
  8004210532:	48 89 c2             	mov    %rax,%rdx
  8004210535:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210539:	0f b6 00             	movzbl (%rax),%eax
  800421053c:	0f b6 c0             	movzbl %al,%eax
  800421053f:	48 c1 e0 18          	shl    $0x18,%rax
  8004210543:	48 09 d0             	or     %rdx,%rax
  8004210546:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800421054a:	e9 b6 00 00 00       	jmpq   8004210605 <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800421054f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210553:	48 83 c0 07          	add    $0x7,%rax
  8004210557:	0f b6 00             	movzbl (%rax),%eax
  800421055a:	0f b6 c0             	movzbl %al,%eax
  800421055d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210561:	48 83 c2 06          	add    $0x6,%rdx
  8004210565:	0f b6 12             	movzbl (%rdx),%edx
  8004210568:	0f b6 d2             	movzbl %dl,%edx
  800421056b:	48 c1 e2 08          	shl    $0x8,%rdx
  800421056f:	48 09 d0             	or     %rdx,%rax
  8004210572:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  8004210576:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421057a:	48 83 c0 05          	add    $0x5,%rax
  800421057e:	0f b6 00             	movzbl (%rax),%eax
  8004210581:	0f b6 c0             	movzbl %al,%eax
  8004210584:	48 c1 e0 10          	shl    $0x10,%rax
  8004210588:	48 89 c2             	mov    %rax,%rdx
  800421058b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421058f:	48 83 c0 04          	add    $0x4,%rax
  8004210593:	0f b6 00             	movzbl (%rax),%eax
  8004210596:	0f b6 c0             	movzbl %al,%eax
  8004210599:	48 c1 e0 18          	shl    $0x18,%rax
  800421059d:	48 09 d0             	or     %rdx,%rax
  80042105a0:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  80042105a4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042105a8:	48 83 c0 03          	add    $0x3,%rax
  80042105ac:	0f b6 00             	movzbl (%rax),%eax
  80042105af:	0f b6 c0             	movzbl %al,%eax
  80042105b2:	48 c1 e0 20          	shl    $0x20,%rax
  80042105b6:	48 89 c2             	mov    %rax,%rdx
  80042105b9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042105bd:	48 83 c0 02          	add    $0x2,%rax
  80042105c1:	0f b6 00             	movzbl (%rax),%eax
  80042105c4:	0f b6 c0             	movzbl %al,%eax
  80042105c7:	48 c1 e0 28          	shl    $0x28,%rax
  80042105cb:	48 09 d0             	or     %rdx,%rax
  80042105ce:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  80042105d2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042105d6:	48 83 c0 01          	add    $0x1,%rax
  80042105da:	0f b6 00             	movzbl (%rax),%eax
  80042105dd:	0f b6 c0             	movzbl %al,%eax
  80042105e0:	48 c1 e0 30          	shl    $0x30,%rax
  80042105e4:	48 89 c2             	mov    %rax,%rdx
  80042105e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042105eb:	0f b6 00             	movzbl (%rax),%eax
  80042105ee:	0f b6 c0             	movzbl %al,%eax
  80042105f1:	48 c1 e0 38          	shl    $0x38,%rax
  80042105f5:	48 09 d0             	or     %rdx,%rax
  80042105f8:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  80042105fc:	eb 07                	jmp    8004210605 <_dwarf_decode_msb+0x193>
	default:
		return (0);
  80042105fe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210603:	eb 1a                	jmp    800421061f <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  8004210605:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210609:	48 8b 10             	mov    (%rax),%rdx
  800421060c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421060f:	48 98                	cltq   
  8004210611:	48 01 c2             	add    %rax,%rdx
  8004210614:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210618:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800421061b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421061f:	c9                   	leaveq 
  8004210620:	c3                   	retq   

0000008004210621 <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  8004210621:	55                   	push   %rbp
  8004210622:	48 89 e5             	mov    %rsp,%rbp
  8004210625:	48 83 ec 30          	sub    $0x30,%rsp
  8004210629:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421062d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int64_t ret = 0;
  8004210631:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210638:	00 
	uint8_t b;
	int shift = 0;
  8004210639:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  8004210640:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210644:	48 8b 10             	mov    (%rax),%rdx
  8004210647:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421064b:	48 01 d0             	add    %rdx,%rax
  800421064e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  8004210652:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210656:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421065a:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800421065e:	0f b6 00             	movzbl (%rax),%eax
  8004210661:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004210664:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210668:	83 e0 7f             	and    $0x7f,%eax
  800421066b:	89 c2                	mov    %eax,%edx
  800421066d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210670:	89 c1                	mov    %eax,%ecx
  8004210672:	d3 e2                	shl    %cl,%edx
  8004210674:	89 d0                	mov    %edx,%eax
  8004210676:	48 98                	cltq   
  8004210678:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800421067c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210680:	48 8b 00             	mov    (%rax),%rax
  8004210683:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210687:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421068b:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800421068e:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004210692:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210696:	84 c0                	test   %al,%al
  8004210698:	78 b8                	js     8004210652 <_dwarf_read_sleb128+0x31>

	if (shift < 32 && (b & 0x40) != 0)
  800421069a:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800421069e:	7f 1f                	jg     80042106bf <_dwarf_read_sleb128+0x9e>
  80042106a0:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042106a4:	83 e0 40             	and    $0x40,%eax
  80042106a7:	85 c0                	test   %eax,%eax
  80042106a9:	74 14                	je     80042106bf <_dwarf_read_sleb128+0x9e>
		ret |= (-1 << shift);
  80042106ab:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042106ae:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80042106b3:	89 c1                	mov    %eax,%ecx
  80042106b5:	d3 e2                	shl    %cl,%edx
  80042106b7:	89 d0                	mov    %edx,%eax
  80042106b9:	48 98                	cltq   
  80042106bb:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	return (ret);
  80042106bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042106c3:	c9                   	leaveq 
  80042106c4:	c3                   	retq   

00000080042106c5 <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  80042106c5:	55                   	push   %rbp
  80042106c6:	48 89 e5             	mov    %rsp,%rbp
  80042106c9:	48 83 ec 30          	sub    $0x30,%rsp
  80042106cd:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042106d1:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t ret = 0;
  80042106d5:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042106dc:	00 
	uint8_t b;
	int shift = 0;
  80042106dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  80042106e4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042106e8:	48 8b 10             	mov    (%rax),%rdx
  80042106eb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042106ef:	48 01 d0             	add    %rdx,%rax
  80042106f2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  80042106f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042106fa:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042106fe:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210702:	0f b6 00             	movzbl (%rax),%eax
  8004210705:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004210708:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421070c:	83 e0 7f             	and    $0x7f,%eax
  800421070f:	89 c2                	mov    %eax,%edx
  8004210711:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210714:	89 c1                	mov    %eax,%ecx
  8004210716:	d3 e2                	shl    %cl,%edx
  8004210718:	89 d0                	mov    %edx,%eax
  800421071a:	48 98                	cltq   
  800421071c:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  8004210720:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210724:	48 8b 00             	mov    (%rax),%rax
  8004210727:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421072b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421072f:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  8004210732:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004210736:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421073a:	84 c0                	test   %al,%al
  800421073c:	78 b8                	js     80042106f6 <_dwarf_read_uleb128+0x31>

	return (ret);
  800421073e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210742:	c9                   	leaveq 
  8004210743:	c3                   	retq   

0000008004210744 <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  8004210744:	55                   	push   %rbp
  8004210745:	48 89 e5             	mov    %rsp,%rbp
  8004210748:	48 83 ec 28          	sub    $0x28,%rsp
  800421074c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int64_t ret = 0;
  8004210750:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210757:	00 
	uint8_t b;
	int shift = 0;
  8004210758:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  800421075f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210763:	48 8b 00             	mov    (%rax),%rax
  8004210766:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800421076a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421076e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210772:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210776:	0f b6 00             	movzbl (%rax),%eax
  8004210779:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800421077c:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210780:	83 e0 7f             	and    $0x7f,%eax
  8004210783:	89 c2                	mov    %eax,%edx
  8004210785:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210788:	89 c1                	mov    %eax,%ecx
  800421078a:	d3 e2                	shl    %cl,%edx
  800421078c:	89 d0                	mov    %edx,%eax
  800421078e:	48 98                	cltq   
  8004210790:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  8004210794:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004210798:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421079c:	84 c0                	test   %al,%al
  800421079e:	78 ca                	js     800421076a <_dwarf_decode_sleb128+0x26>

	if (shift < 32 && (b & 0x40) != 0)
  80042107a0:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  80042107a4:	7f 1f                	jg     80042107c5 <_dwarf_decode_sleb128+0x81>
  80042107a6:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042107aa:	83 e0 40             	and    $0x40,%eax
  80042107ad:	85 c0                	test   %eax,%eax
  80042107af:	74 14                	je     80042107c5 <_dwarf_decode_sleb128+0x81>
		ret |= (-1 << shift);
  80042107b1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042107b4:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80042107b9:	89 c1                	mov    %eax,%ecx
  80042107bb:	d3 e2                	shl    %cl,%edx
  80042107bd:	89 d0                	mov    %edx,%eax
  80042107bf:	48 98                	cltq   
  80042107c1:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	*dp = src;
  80042107c5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042107c9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042107cd:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042107d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042107d4:	c9                   	leaveq 
  80042107d5:	c3                   	retq   

00000080042107d6 <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  80042107d6:	55                   	push   %rbp
  80042107d7:	48 89 e5             	mov    %rsp,%rbp
  80042107da:	48 83 ec 28          	sub    $0x28,%rsp
  80042107de:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint64_t ret = 0;
  80042107e2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042107e9:	00 
	uint8_t b;
	int shift = 0;
  80042107ea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  80042107f1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042107f5:	48 8b 00             	mov    (%rax),%rax
  80042107f8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  80042107fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210800:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210804:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210808:	0f b6 00             	movzbl (%rax),%eax
  800421080b:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800421080e:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210812:	83 e0 7f             	and    $0x7f,%eax
  8004210815:	89 c2                	mov    %eax,%edx
  8004210817:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421081a:	89 c1                	mov    %eax,%ecx
  800421081c:	d3 e2                	shl    %cl,%edx
  800421081e:	89 d0                	mov    %edx,%eax
  8004210820:	48 98                	cltq   
  8004210822:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  8004210826:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800421082a:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421082e:	84 c0                	test   %al,%al
  8004210830:	78 ca                	js     80042107fc <_dwarf_decode_uleb128+0x26>

	*dp = src;
  8004210832:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210836:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421083a:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800421083d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210841:	c9                   	leaveq 
  8004210842:	c3                   	retq   

0000008004210843 <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  8004210843:	55                   	push   %rbp
  8004210844:	48 89 e5             	mov    %rsp,%rbp
  8004210847:	48 83 ec 28          	sub    $0x28,%rsp
  800421084b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421084f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210853:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  8004210857:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421085b:	48 8b 10             	mov    (%rax),%rdx
  800421085e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210862:	48 01 d0             	add    %rdx,%rax
  8004210865:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210869:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421086d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  8004210871:	eb 17                	jmp    800421088a <_dwarf_read_string+0x47>
		src++;
  8004210873:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  8004210878:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421087c:	48 8b 00             	mov    (%rax),%rax
  800421087f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210883:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210887:	48 89 10             	mov    %rdx,(%rax)
{
	char *ret, *src;

	ret = src = (char *) data + *offsetp;

	while (*src != '\0' && *offsetp < size) {
  800421088a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421088e:	0f b6 00             	movzbl (%rax),%eax
  8004210891:	84 c0                	test   %al,%al
  8004210893:	74 0d                	je     80042108a2 <_dwarf_read_string+0x5f>
  8004210895:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210899:	48 8b 00             	mov    (%rax),%rax
  800421089c:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042108a0:	72 d1                	jb     8004210873 <_dwarf_read_string+0x30>
		src++;
		(*offsetp)++;
	}

	if (*src == '\0' && *offsetp < size)
  80042108a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042108a6:	0f b6 00             	movzbl (%rax),%eax
  80042108a9:	84 c0                	test   %al,%al
  80042108ab:	75 1f                	jne    80042108cc <_dwarf_read_string+0x89>
  80042108ad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042108b1:	48 8b 00             	mov    (%rax),%rax
  80042108b4:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042108b8:	73 12                	jae    80042108cc <_dwarf_read_string+0x89>
		(*offsetp)++;
  80042108ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042108be:	48 8b 00             	mov    (%rax),%rax
  80042108c1:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042108c5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042108c9:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042108cc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80042108d0:	c9                   	leaveq 
  80042108d1:	c3                   	retq   

00000080042108d2 <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  80042108d2:	55                   	push   %rbp
  80042108d3:	48 89 e5             	mov    %rsp,%rbp
  80042108d6:	48 83 ec 28          	sub    $0x28,%rsp
  80042108da:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042108de:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042108e2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  80042108e6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042108ea:	48 8b 10             	mov    (%rax),%rdx
  80042108ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042108f1:	48 01 d0             	add    %rdx,%rax
  80042108f4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042108f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042108fc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  8004210900:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210904:	48 8b 10             	mov    (%rax),%rdx
  8004210907:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421090b:	48 01 c2             	add    %rax,%rdx
  800421090e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210912:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210915:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  8004210919:	c9                   	leaveq 
  800421091a:	c3                   	retq   

000000800421091b <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  800421091b:	55                   	push   %rbp
  800421091c:	48 89 e5             	mov    %rsp,%rbp
  800421091f:	48 83 ec 20          	sub    $0x20,%rsp
  8004210923:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    Elf *e;

    e = (Elf *)obj;
  8004210927:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421092b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    assert(e != NULL);
  800421092f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004210934:	75 35                	jne    800421096b <_dwarf_elf_get_byte_order+0x50>
  8004210936:	48 b9 e0 94 21 04 80 	movabs $0x80042194e0,%rcx
  800421093d:	00 00 00 
  8004210940:	48 ba ea 94 21 04 80 	movabs $0x80042194ea,%rdx
  8004210947:	00 00 00 
  800421094a:	be 2b 01 00 00       	mov    $0x12b,%esi
  800421094f:	48 bf ff 94 21 04 80 	movabs $0x80042194ff,%rdi
  8004210956:	00 00 00 
  8004210959:	b8 00 00 00 00       	mov    $0x0,%eax
  800421095e:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004210965:	00 00 00 
  8004210968:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
    switch (e->e_ident[EI_DATA]) {
  800421096b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421096f:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  8004210973:	0f b6 c0             	movzbl %al,%eax
  8004210976:	83 f8 02             	cmp    $0x2,%eax
  8004210979:	75 07                	jne    8004210982 <_dwarf_elf_get_byte_order+0x67>
    case ELFDATA2MSB:
        return (DW_OBJECT_MSB);
  800421097b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210980:	eb 05                	jmp    8004210987 <_dwarf_elf_get_byte_order+0x6c>

    case ELFDATA2LSB:
    case ELFDATANONE:
    default:
        return (DW_OBJECT_LSB);
  8004210982:	b8 01 00 00 00       	mov    $0x1,%eax
    }
}
  8004210987:	c9                   	leaveq 
  8004210988:	c3                   	retq   

0000008004210989 <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  8004210989:	55                   	push   %rbp
  800421098a:	48 89 e5             	mov    %rsp,%rbp
  800421098d:	48 83 ec 20          	sub    $0x20,%rsp
  8004210991:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    Elf *e;

    e = (Elf *) obj;
  8004210995:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210999:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    assert(e != NULL);
  800421099d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042109a2:	75 35                	jne    80042109d9 <_dwarf_elf_get_pointer_size+0x50>
  80042109a4:	48 b9 e0 94 21 04 80 	movabs $0x80042194e0,%rcx
  80042109ab:	00 00 00 
  80042109ae:	48 ba ea 94 21 04 80 	movabs $0x80042194ea,%rdx
  80042109b5:	00 00 00 
  80042109b8:	be 41 01 00 00       	mov    $0x141,%esi
  80042109bd:	48 bf ff 94 21 04 80 	movabs $0x80042194ff,%rdi
  80042109c4:	00 00 00 
  80042109c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042109cc:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042109d3:	00 00 00 
  80042109d6:	41 ff d0             	callq  *%r8

    if (e->e_ident[4] == ELFCLASS32)
  80042109d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042109dd:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  80042109e1:	3c 01                	cmp    $0x1,%al
  80042109e3:	75 07                	jne    80042109ec <_dwarf_elf_get_pointer_size+0x63>
        return (4);
  80042109e5:	b8 04 00 00 00       	mov    $0x4,%eax
  80042109ea:	eb 05                	jmp    80042109f1 <_dwarf_elf_get_pointer_size+0x68>
    else
        return (8);
  80042109ec:	b8 08 00 00 00       	mov    $0x8,%eax
}
  80042109f1:	c9                   	leaveq 
  80042109f2:	c3                   	retq   

00000080042109f3 <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  80042109f3:	55                   	push   %rbp
  80042109f4:	48 89 e5             	mov    %rsp,%rbp
  80042109f7:	53                   	push   %rbx
  80042109f8:	48 83 ec 18          	sub    $0x18,%rsp
  80042109fc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210a00:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  8004210a04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a08:	ba 58 00 00 00       	mov    $0x58,%edx
  8004210a0d:	be 00 00 00 00       	mov    $0x0,%esi
  8004210a12:	48 89 c7             	mov    %rax,%rdi
  8004210a15:	48 b8 b3 fb 20 04 80 	movabs $0x800420fbb3,%rax
  8004210a1c:	00 00 00 
  8004210a1f:	ff d0                	callq  *%rax
    dbg->curr_off_dbginfo = 0;
  8004210a21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a25:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    dbg->dbg_info_size = 0;
  8004210a2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a30:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004210a37:	00 
    dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  8004210a38:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210a3c:	48 89 c7             	mov    %rax,%rdi
  8004210a3f:	48 b8 89 09 21 04 80 	movabs $0x8004210989,%rax
  8004210a46:	00 00 00 
  8004210a49:	ff d0                	callq  *%rax
  8004210a4b:	0f b6 d0             	movzbl %al,%edx
  8004210a4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a52:	89 50 28             	mov    %edx,0x28(%rax)

    if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  8004210a55:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210a59:	48 89 c7             	mov    %rax,%rdi
  8004210a5c:	48 b8 1b 09 21 04 80 	movabs $0x800421091b,%rax
  8004210a63:	00 00 00 
  8004210a66:	ff d0                	callq  *%rax
  8004210a68:	85 c0                	test   %eax,%eax
  8004210a6a:	75 26                	jne    8004210a92 <_dwarf_init+0x9f>
        dbg->read = _dwarf_read_msb;
  8004210a6c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a70:	48 b9 c0 02 21 04 80 	movabs $0x80042102c0,%rcx
  8004210a77:	00 00 00 
  8004210a7a:	48 89 48 18          	mov    %rcx,0x18(%rax)
        dbg->decode = _dwarf_decode_msb;
  8004210a7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a82:	48 bb 72 04 21 04 80 	movabs $0x8004210472,%rbx
  8004210a89:	00 00 00 
  8004210a8c:	48 89 58 20          	mov    %rbx,0x20(%rax)
  8004210a90:	eb 24                	jmp    8004210ab6 <_dwarf_init+0xc3>
    } else {
        dbg->read = _dwarf_read_lsb;
  8004210a92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a96:	48 b9 73 00 21 04 80 	movabs $0x8004210073,%rcx
  8004210a9d:	00 00 00 
  8004210aa0:	48 89 48 18          	mov    %rcx,0x18(%rax)
        dbg->decode = _dwarf_decode_lsb;
  8004210aa4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210aa8:	48 be 9f 01 21 04 80 	movabs $0x800421019f,%rsi
  8004210aaf:	00 00 00 
  8004210ab2:	48 89 70 20          	mov    %rsi,0x20(%rax)
    }
   _dwarf_frame_params_init(dbg);
  8004210ab6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210aba:	48 89 c7             	mov    %rax,%rdi
  8004210abd:	48 b8 c0 1f 21 04 80 	movabs $0x8004211fc0,%rax
  8004210ac4:	00 00 00 
  8004210ac7:	ff d0                	callq  *%rax
   return 0;
  8004210ac9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210ace:	48 83 c4 18          	add    $0x18,%rsp
  8004210ad2:	5b                   	pop    %rbx
  8004210ad3:	5d                   	pop    %rbp
  8004210ad4:	c3                   	retq   

0000008004210ad5 <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  8004210ad5:	55                   	push   %rbp
  8004210ad6:	48 89 e5             	mov    %rsp,%rbp
  8004210ad9:	48 83 ec 20          	sub    $0x20,%rsp
  8004210add:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210ae1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    uint32_t length;
    uint64_t offset;
    uint8_t dwarf_size;

    if(dbg->curr_off_dbginfo > dbg->dbg_info_size)
  8004210ae5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210ae9:	48 8b 10             	mov    (%rax),%rdx
  8004210aec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210af0:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004210af4:	48 39 c2             	cmp    %rax,%rdx
  8004210af7:	76 0a                	jbe    8004210b03 <_get_next_cu+0x2e>
        return -1;
  8004210af9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210afe:	e9 6b 01 00 00       	jmpq   8004210c6e <_get_next_cu+0x199>

    offset = dbg->curr_off_dbginfo;
  8004210b03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210b07:	48 8b 00             	mov    (%rax),%rax
  8004210b0a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  8004210b0e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210b12:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210b16:	48 89 50 30          	mov    %rdx,0x30(%rax)

    length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  8004210b1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210b1e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210b22:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210b26:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004210b2a:	48 89 d1             	mov    %rdx,%rcx
  8004210b2d:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004210b31:	ba 04 00 00 00       	mov    $0x4,%edx
  8004210b36:	48 89 cf             	mov    %rcx,%rdi
  8004210b39:	ff d0                	callq  *%rax
  8004210b3b:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (length == 0xffffffff) {
  8004210b3e:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  8004210b42:	75 2a                	jne    8004210b6e <_get_next_cu+0x99>
        length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  8004210b44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210b48:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210b4c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210b50:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004210b54:	48 89 d1             	mov    %rdx,%rcx
  8004210b57:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004210b5b:	ba 08 00 00 00       	mov    $0x8,%edx
  8004210b60:	48 89 cf             	mov    %rcx,%rdi
  8004210b63:	ff d0                	callq  *%rax
  8004210b65:	89 45 fc             	mov    %eax,-0x4(%rbp)
        dwarf_size = 8;
  8004210b68:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  8004210b6c:	eb 04                	jmp    8004210b72 <_get_next_cu+0x9d>
    } else {
        dwarf_size = 4;
  8004210b6e:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
    }

    cu->cu_dwarf_size = dwarf_size;
  8004210b72:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210b76:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  8004210b7a:	88 50 19             	mov    %dl,0x19(%rax)
	if (length > ds->ds_size - offset) {
		return (DW_DLE_CU_LENGTH_ERROR);
	}*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  8004210b7d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004210b80:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210b84:	48 01 c2             	add    %rax,%rdx
  8004210b87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210b8b:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  8004210b8e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210b92:	48 8b 10             	mov    (%rax),%rdx
  8004210b95:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210b99:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  8004210b9d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004210ba0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210ba4:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  8004210ba7:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  8004210bab:	75 07                	jne    8004210bb4 <_get_next_cu+0xdf>
  8004210bad:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210bb2:	eb 05                	jmp    8004210bb9 <_get_next_cu+0xe4>
  8004210bb4:	b8 0c 00 00 00       	mov    $0xc,%eax
  8004210bb9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210bbd:	88 42 18             	mov    %al,0x18(%rdx)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  8004210bc0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210bc4:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210bc8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210bcc:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004210bd0:	48 89 d1             	mov    %rdx,%rcx
  8004210bd3:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004210bd7:	ba 02 00 00 00       	mov    $0x2,%edx
  8004210bdc:	48 89 cf             	mov    %rcx,%rdi
  8004210bdf:	ff d0                	callq  *%rax
  8004210be1:	89 c2                	mov    %eax,%edx
  8004210be3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210be7:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  8004210beb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210bef:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210bf3:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  8004210bf7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210bfb:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  8004210bff:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004210c03:	48 89 cf             	mov    %rcx,%rdi
  8004210c06:	ff d0                	callq  *%rax
  8004210c08:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210c0c:	48 89 42 10          	mov    %rax,0x10(%rdx)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  8004210c10:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210c14:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210c18:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210c1c:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004210c20:	48 89 d1             	mov    %rdx,%rcx
  8004210c23:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004210c27:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210c2c:	48 89 cf             	mov    %rcx,%rdi
  8004210c2f:	ff d0                	callq  *%rax
  8004210c31:	89 c2                	mov    %eax,%edx
  8004210c33:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210c37:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  8004210c3a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210c3e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004210c42:	66 83 f8 01          	cmp    $0x1,%ax
  8004210c46:	76 0e                	jbe    8004210c56 <_get_next_cu+0x181>
  8004210c48:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210c4c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004210c50:	66 83 f8 04          	cmp    $0x4,%ax
  8004210c54:	76 07                	jbe    8004210c5d <_get_next_cu+0x188>
		return -1;
  8004210c56:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210c5b:	eb 11                	jmp    8004210c6e <_get_next_cu+0x199>
	}

	cu->cu_die_offset = offset;
  8004210c5d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210c61:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210c65:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  8004210c69:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210c6e:	c9                   	leaveq 
  8004210c6f:	c3                   	retq   

0000008004210c70 <print_cu>:

void print_cu(Dwarf_CU cu)
{
  8004210c70:	55                   	push   %rbp
  8004210c71:	48 89 e5             	mov    %rsp,%rbp
    cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  8004210c74:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  8004210c78:	0f b6 c8             	movzbl %al,%ecx
  8004210c7b:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  8004210c7f:	0f b7 d0             	movzwl %ax,%edx
  8004210c82:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8004210c86:	48 89 c6             	mov    %rax,%rsi
  8004210c89:	48 bf 12 95 21 04 80 	movabs $0x8004219512,%rdi
  8004210c90:	00 00 00 
  8004210c93:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210c98:	49 b8 11 96 20 04 80 	movabs $0x8004209611,%r8
  8004210c9f:	00 00 00 
  8004210ca2:	41 ff d0             	callq  *%r8
}
  8004210ca5:	5d                   	pop    %rbp
  8004210ca6:	c3                   	retq   

0000008004210ca7 <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  8004210ca7:	55                   	push   %rbp
  8004210ca8:	48 89 e5             	mov    %rsp,%rbp
  8004210cab:	48 83 ec 60          	sub    $0x60,%rsp
  8004210caf:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004210cb3:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004210cb7:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  8004210cbb:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    uint64_t tag;
    uint8_t children;
    uint64_t abbr_addr;
    int ret;

    assert(abp != NULL);
  8004210cbf:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8004210cc4:	75 35                	jne    8004210cfb <_dwarf_abbrev_parse+0x54>
  8004210cc6:	48 b9 21 95 21 04 80 	movabs $0x8004219521,%rcx
  8004210ccd:	00 00 00 
  8004210cd0:	48 ba ea 94 21 04 80 	movabs $0x80042194ea,%rdx
  8004210cd7:	00 00 00 
  8004210cda:	be a6 01 00 00       	mov    $0x1a6,%esi
  8004210cdf:	48 bf ff 94 21 04 80 	movabs $0x80042194ff,%rdi
  8004210ce6:	00 00 00 
  8004210ce9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210cee:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004210cf5:	00 00 00 
  8004210cf8:	41 ff d0             	callq  *%r8
    assert(ds != NULL);
  8004210cfb:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8004210d00:	75 35                	jne    8004210d37 <_dwarf_abbrev_parse+0x90>
  8004210d02:	48 b9 2d 95 21 04 80 	movabs $0x800421952d,%rcx
  8004210d09:	00 00 00 
  8004210d0c:	48 ba ea 94 21 04 80 	movabs $0x80042194ea,%rdx
  8004210d13:	00 00 00 
  8004210d16:	be a7 01 00 00       	mov    $0x1a7,%esi
  8004210d1b:	48 bf ff 94 21 04 80 	movabs $0x80042194ff,%rdi
  8004210d22:	00 00 00 
  8004210d25:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210d2a:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004210d31:	00 00 00 
  8004210d34:	41 ff d0             	callq  *%r8

    if (*offset >= ds->ds_size)
  8004210d37:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210d3b:	48 8b 10             	mov    (%rax),%rdx
  8004210d3e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210d42:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210d46:	48 39 c2             	cmp    %rax,%rdx
  8004210d49:	72 0a                	jb     8004210d55 <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  8004210d4b:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210d50:	e9 d3 01 00 00       	jmpq   8004210f28 <_dwarf_abbrev_parse+0x281>

    aboff = *offset;
  8004210d55:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210d59:	48 8b 00             	mov    (%rax),%rax
  8004210d5c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  8004210d60:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210d64:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210d68:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210d6c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210d70:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210d74:	48 89 d6             	mov    %rdx,%rsi
  8004210d77:	48 89 c7             	mov    %rax,%rdi
  8004210d7a:	48 b8 c5 06 21 04 80 	movabs $0x80042106c5,%rax
  8004210d81:	00 00 00 
  8004210d84:	ff d0                	callq  *%rax
  8004210d86:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    if (entry == 0) {
  8004210d8a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210d8f:	75 15                	jne    8004210da6 <_dwarf_abbrev_parse+0xff>
        /* Last entry. */
        //Need to make connection from below function
        abp->ab_entry = 0;
  8004210d91:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210d95:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        return DW_DLE_NONE;
  8004210d9c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210da1:	e9 82 01 00 00       	jmpq   8004210f28 <_dwarf_abbrev_parse+0x281>
    }

    tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210da6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210daa:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210dae:	48 89 d6             	mov    %rdx,%rsi
  8004210db1:	48 89 c7             	mov    %rax,%rdi
  8004210db4:	48 b8 c5 06 21 04 80 	movabs $0x80042106c5,%rax
  8004210dbb:	00 00 00 
  8004210dbe:	ff d0                	callq  *%rax
  8004210dc0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  8004210dc4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210dc8:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210dcc:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8004210dd0:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004210dd4:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210dd9:	48 89 cf             	mov    %rcx,%rdi
  8004210ddc:	ff d0                	callq  *%rax
  8004210dde:	88 45 df             	mov    %al,-0x21(%rbp)

    abp->ab_entry    = entry;
  8004210de1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210de5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210de9:	48 89 10             	mov    %rdx,(%rax)
    abp->ab_tag      = tag;
  8004210dec:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210df0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210df4:	48 89 50 08          	mov    %rdx,0x8(%rax)
    abp->ab_children = children;
  8004210df8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210dfc:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  8004210e00:	88 50 10             	mov    %dl,0x10(%rax)
    abp->ab_offset   = aboff;
  8004210e03:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210e07:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210e0b:	48 89 50 18          	mov    %rdx,0x18(%rax)
    abp->ab_length   = 0;    /* fill in later. */
  8004210e0f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210e13:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  8004210e1a:	00 
    abp->ab_atnum    = 0;
  8004210e1b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210e1f:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  8004210e26:	00 

    /* Parse attribute definitions. */
    do {
        adoff = *offset;
  8004210e27:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210e2b:	48 8b 00             	mov    (%rax),%rax
  8004210e2e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210e32:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210e36:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210e3a:	48 89 d6             	mov    %rdx,%rsi
  8004210e3d:	48 89 c7             	mov    %rax,%rdi
  8004210e40:	48 b8 c5 06 21 04 80 	movabs $0x80042106c5,%rax
  8004210e47:	00 00 00 
  8004210e4a:	ff d0                	callq  *%rax
  8004210e4c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210e50:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210e54:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210e58:	48 89 d6             	mov    %rdx,%rsi
  8004210e5b:	48 89 c7             	mov    %rax,%rdi
  8004210e5e:	48 b8 c5 06 21 04 80 	movabs $0x80042106c5,%rax
  8004210e65:	00 00 00 
  8004210e68:	ff d0                	callq  *%rax
  8004210e6a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        if (attr != 0)
  8004210e6e:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210e73:	0f 84 89 00 00 00    	je     8004210f02 <_dwarf_abbrev_parse+0x25b>
        {
            /* Initialise the attribute definition structure. */
            abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  8004210e79:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210e7d:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210e81:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210e85:	48 89 d0             	mov    %rdx,%rax
  8004210e88:	48 01 c0             	add    %rax,%rax
  8004210e8b:	48 01 d0             	add    %rdx,%rax
  8004210e8e:	48 c1 e0 03          	shl    $0x3,%rax
  8004210e92:	48 01 c8             	add    %rcx,%rax
  8004210e95:	48 8d 50 30          	lea    0x30(%rax),%rdx
  8004210e99:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210e9d:	48 89 02             	mov    %rax,(%rdx)
            abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  8004210ea0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210ea4:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210ea8:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210eac:	48 89 d0             	mov    %rdx,%rax
  8004210eaf:	48 01 c0             	add    %rax,%rax
  8004210eb2:	48 01 d0             	add    %rdx,%rax
  8004210eb5:	48 c1 e0 03          	shl    $0x3,%rax
  8004210eb9:	48 01 c8             	add    %rcx,%rax
  8004210ebc:	48 8d 50 38          	lea    0x38(%rax),%rdx
  8004210ec0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210ec4:	48 89 02             	mov    %rax,(%rdx)
            abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  8004210ec7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210ecb:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210ecf:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210ed3:	48 89 d0             	mov    %rdx,%rax
  8004210ed6:	48 01 c0             	add    %rax,%rax
  8004210ed9:	48 01 d0             	add    %rdx,%rax
  8004210edc:	48 c1 e0 03          	shl    $0x3,%rax
  8004210ee0:	48 01 c8             	add    %rcx,%rax
  8004210ee3:	48 8d 50 40          	lea    0x40(%rax),%rdx
  8004210ee7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210eeb:	48 89 02             	mov    %rax,(%rdx)
            abp->ab_atnum++;
  8004210eee:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210ef2:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004210ef6:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210efa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210efe:	48 89 50 28          	mov    %rdx,0x28(%rax)
        }
    } while (attr != 0);
  8004210f02:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210f07:	0f 85 1a ff ff ff    	jne    8004210e27 <_dwarf_abbrev_parse+0x180>

    //(*abp)->ab_length = *offset - aboff;
    abp->ab_length = (uint64_t)(*offset - aboff);
  8004210f0d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210f11:	48 8b 00             	mov    (%rax),%rax
  8004210f14:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  8004210f18:	48 89 c2             	mov    %rax,%rdx
  8004210f1b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210f1f:	48 89 50 20          	mov    %rdx,0x20(%rax)

    return DW_DLV_OK;
  8004210f23:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210f28:	c9                   	leaveq 
  8004210f29:	c3                   	retq   

0000008004210f2a <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  8004210f2a:	55                   	push   %rbp
  8004210f2b:	48 89 e5             	mov    %rsp,%rbp
  8004210f2e:	48 83 ec 70          	sub    $0x70,%rsp
  8004210f32:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210f36:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004210f3a:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    Dwarf_Section *ds;
    uint64_t offset;
    int ret;

    if (entry == 0)
  8004210f3e:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004210f43:	75 0a                	jne    8004210f4f <_dwarf_abbrev_find+0x25>
    {
		return (DW_DLE_NO_ENTRY);
  8004210f45:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210f4a:	e9 0a 01 00 00       	jmpq   8004211059 <_dwarf_abbrev_find+0x12f>
    }

    /* Load and search the abbrev table. */
    ds = _dwarf_find_section(".debug_abbrev");
  8004210f4f:	48 bf 38 95 21 04 80 	movabs $0x8004219538,%rdi
  8004210f56:	00 00 00 
  8004210f59:	48 b8 b0 52 21 04 80 	movabs $0x80042152b0,%rax
  8004210f60:	00 00 00 
  8004210f63:	ff d0                	callq  *%rax
  8004210f65:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    assert(ds != NULL);
  8004210f69:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004210f6e:	75 35                	jne    8004210fa5 <_dwarf_abbrev_find+0x7b>
  8004210f70:	48 b9 2d 95 21 04 80 	movabs $0x800421952d,%rcx
  8004210f77:	00 00 00 
  8004210f7a:	48 ba ea 94 21 04 80 	movabs $0x80042194ea,%rdx
  8004210f81:	00 00 00 
  8004210f84:	be e7 01 00 00       	mov    $0x1e7,%esi
  8004210f89:	48 bf ff 94 21 04 80 	movabs $0x80042194ff,%rdi
  8004210f90:	00 00 00 
  8004210f93:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210f98:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004210f9f:	00 00 00 
  8004210fa2:	41 ff d0             	callq  *%r8

    //TODO: We are starting offset from 0, however libdwarf logic
    //      is keeping a counter for current offset. Ok. let use
    //      that. I relent, but this will be done in Phase 2. :)
    //offset = 0; //cu->cu_abbrev_offset_cur;
    offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  8004210fa5:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210fa9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    while (offset < ds->ds_size) {
  8004210fad:	e9 8d 00 00 00       	jmpq   800421103f <_dwarf_abbrev_find+0x115>
        ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  8004210fb2:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004210fb6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210fba:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  8004210fbe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210fc2:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004210fc6:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004210fca:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
  8004210fce:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004210fd3:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  8004210fd7:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004210fdc:	48 8b 7d 28          	mov    0x28(%rbp),%rdi
  8004210fe0:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004210fe5:	48 8b 7d 30          	mov    0x30(%rbp),%rdi
  8004210fe9:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  8004210fee:	48 8b 7d 38          	mov    0x38(%rbp),%rdi
  8004210ff2:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004210ff7:	48 8b 7d 40          	mov    0x40(%rbp),%rdi
  8004210ffb:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
  8004211000:	48 89 c7             	mov    %rax,%rdi
  8004211003:	48 b8 a7 0c 21 04 80 	movabs $0x8004210ca7,%rax
  800421100a:	00 00 00 
  800421100d:	ff d0                	callq  *%rax
  800421100f:	89 45 f4             	mov    %eax,-0xc(%rbp)
        if (ret != DW_DLE_NONE)
  8004211012:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004211016:	74 05                	je     800421101d <_dwarf_abbrev_find+0xf3>
            return (ret);
  8004211018:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421101b:	eb 3c                	jmp    8004211059 <_dwarf_abbrev_find+0x12f>
        if (abp->ab_entry == entry) {
  800421101d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211021:	48 8b 00             	mov    (%rax),%rax
  8004211024:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211028:	75 07                	jne    8004211031 <_dwarf_abbrev_find+0x107>
            //cu->cu_abbrev_offset_cur = offset;
            return DW_DLE_NONE;
  800421102a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421102f:	eb 28                	jmp    8004211059 <_dwarf_abbrev_find+0x12f>
        }
        if (abp->ab_entry == 0) {
  8004211031:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211035:	48 8b 00             	mov    (%rax),%rax
  8004211038:	48 85 c0             	test   %rax,%rax
  800421103b:	75 02                	jne    800421103f <_dwarf_abbrev_find+0x115>
            //cu->cu_abbrev_offset_cur = offset;
            //cu->cu_abbrev_loaded = 1;
            break;
  800421103d:	eb 15                	jmp    8004211054 <_dwarf_abbrev_find+0x12a>
    //TODO: We are starting offset from 0, however libdwarf logic
    //      is keeping a counter for current offset. Ok. let use
    //      that. I relent, but this will be done in Phase 2. :)
    //offset = 0; //cu->cu_abbrev_offset_cur;
    offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
    while (offset < ds->ds_size) {
  800421103f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211043:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004211047:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421104b:	48 39 c2             	cmp    %rax,%rdx
  800421104e:	0f 87 5e ff ff ff    	ja     8004210fb2 <_dwarf_abbrev_find+0x88>
            //cu->cu_abbrev_loaded = 1;
            break;
        }
    }

    return DW_DLE_NO_ENTRY;
  8004211054:	b8 04 00 00 00       	mov    $0x4,%eax
}
  8004211059:	c9                   	leaveq 
  800421105a:	c3                   	retq   

000000800421105b <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
    uint64_t form, int indirect)
{
  800421105b:	55                   	push   %rbp
  800421105c:	48 89 e5             	mov    %rsp,%rbp
  800421105f:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  8004211066:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  800421106d:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004211074:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  800421107b:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  8004211082:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  8004211089:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
    struct _Dwarf_Attribute atref;
    Dwarf_Section *str;
    int ret;
    Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  8004211090:	48 bf 46 95 21 04 80 	movabs $0x8004219546,%rdi
  8004211097:	00 00 00 
  800421109a:	48 b8 b0 52 21 04 80 	movabs $0x80042152b0,%rax
  80042110a1:	00 00 00 
  80042110a4:	ff d0                	callq  *%rax
  80042110a6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  80042110aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042110ae:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042110b2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    uint8_t dwarf_size = cu->cu_dwarf_size;
  80042110b6:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042110bd:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  80042110c1:	88 45 e7             	mov    %al,-0x19(%rbp)

    ret = DW_DLE_NONE;
  80042110c4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    memset(&atref, 0, sizeof(atref));
  80042110cb:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  80042110d2:	ba 60 00 00 00       	mov    $0x60,%edx
  80042110d7:	be 00 00 00 00       	mov    $0x0,%esi
  80042110dc:	48 89 c7             	mov    %rax,%rdi
  80042110df:	48 b8 b3 fb 20 04 80 	movabs $0x800420fbb3,%rax
  80042110e6:	00 00 00 
  80042110e9:	ff d0                	callq  *%rax
    atref.at_die = ret_die;
  80042110eb:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042110f2:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
    atref.at_attrib = ad->ad_attrib;
  80042110f9:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004211100:	48 8b 00             	mov    (%rax),%rax
  8004211103:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    atref.at_form = ad->ad_form;
  8004211107:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800421110e:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211112:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    atref.at_indirect = indirect;
  8004211116:	8b 45 10             	mov    0x10(%rbp),%eax
  8004211119:	89 45 90             	mov    %eax,-0x70(%rbp)
    atref.at_ld = NULL;
  800421111c:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004211123:	00 

    switch (form) {
  8004211124:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  800421112b:	20 
  800421112c:	0f 87 82 04 00 00    	ja     80042115b4 <_dwarf_attr_init+0x559>
  8004211132:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004211139:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004211140:	00 
  8004211141:	48 b8 70 95 21 04 80 	movabs $0x8004219570,%rax
  8004211148:	00 00 00 
  800421114b:	48 01 d0             	add    %rdx,%rax
  800421114e:	48 8b 00             	mov    (%rax),%rax
  8004211151:	ff e0                	jmpq   *%rax
    case DW_FORM_addr:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  8004211153:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421115a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421115e:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004211165:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004211169:	0f b6 d2             	movzbl %dl,%edx
  800421116c:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211173:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211177:	48 89 cf             	mov    %rcx,%rdi
  800421117a:	ff d0                	callq  *%rax
  800421117c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  8004211180:	e9 37 04 00 00       	jmpq   80042115bc <_dwarf_attr_init+0x561>
    case DW_FORM_block:
    case DW_FORM_exprloc:
        atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  8004211185:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421118c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211190:	48 89 d6             	mov    %rdx,%rsi
  8004211193:	48 89 c7             	mov    %rax,%rdi
  8004211196:	48 b8 c5 06 21 04 80 	movabs $0x80042106c5,%rax
  800421119d:	00 00 00 
  80042111a0:	ff d0                	callq  *%rax
  80042111a2:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  80042111a6:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042111aa:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042111b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042111b5:	48 89 ce             	mov    %rcx,%rsi
  80042111b8:	48 89 c7             	mov    %rax,%rdi
  80042111bb:	48 b8 d2 08 21 04 80 	movabs $0x80042108d2,%rax
  80042111c2:	00 00 00 
  80042111c5:	ff d0                	callq  *%rax
  80042111c7:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  80042111cb:	e9 ec 03 00 00       	jmpq   80042115bc <_dwarf_attr_init+0x561>
    case DW_FORM_block1:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  80042111d0:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042111d7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042111db:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042111e2:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042111e6:	ba 01 00 00 00       	mov    $0x1,%edx
  80042111eb:	48 89 cf             	mov    %rcx,%rdi
  80042111ee:	ff d0                	callq  *%rax
  80042111f0:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  80042111f4:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042111f8:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042111ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211203:	48 89 ce             	mov    %rcx,%rsi
  8004211206:	48 89 c7             	mov    %rax,%rdi
  8004211209:	48 b8 d2 08 21 04 80 	movabs $0x80042108d2,%rax
  8004211210:	00 00 00 
  8004211213:	ff d0                	callq  *%rax
  8004211215:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  8004211219:	e9 9e 03 00 00       	jmpq   80042115bc <_dwarf_attr_init+0x561>
    case DW_FORM_block2:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  800421121e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211225:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211229:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211230:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211234:	ba 02 00 00 00       	mov    $0x2,%edx
  8004211239:	48 89 cf             	mov    %rcx,%rdi
  800421123c:	ff d0                	callq  *%rax
  800421123e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004211242:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211246:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800421124d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211251:	48 89 ce             	mov    %rcx,%rsi
  8004211254:	48 89 c7             	mov    %rax,%rdi
  8004211257:	48 b8 d2 08 21 04 80 	movabs $0x80042108d2,%rax
  800421125e:	00 00 00 
  8004211261:	ff d0                	callq  *%rax
  8004211263:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  8004211267:	e9 50 03 00 00       	jmpq   80042115bc <_dwarf_attr_init+0x561>
   case DW_FORM_block4:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  800421126c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211273:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211277:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421127e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211282:	ba 04 00 00 00       	mov    $0x4,%edx
  8004211287:	48 89 cf             	mov    %rcx,%rdi
  800421128a:	ff d0                	callq  *%rax
  800421128c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004211290:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211294:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800421129b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421129f:	48 89 ce             	mov    %rcx,%rsi
  80042112a2:	48 89 c7             	mov    %rax,%rdi
  80042112a5:	48 b8 d2 08 21 04 80 	movabs $0x80042108d2,%rax
  80042112ac:	00 00 00 
  80042112af:	ff d0                	callq  *%rax
  80042112b1:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  80042112b5:	e9 02 03 00 00       	jmpq   80042115bc <_dwarf_attr_init+0x561>
    case DW_FORM_data1:
    case DW_FORM_flag:
    case DW_FORM_ref1:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  80042112ba:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042112c1:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042112c5:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042112cc:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042112d0:	ba 01 00 00 00       	mov    $0x1,%edx
  80042112d5:	48 89 cf             	mov    %rcx,%rdi
  80042112d8:	ff d0                	callq  *%rax
  80042112da:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  80042112de:	e9 d9 02 00 00       	jmpq   80042115bc <_dwarf_attr_init+0x561>
    case DW_FORM_data2:
    case DW_FORM_ref2:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  80042112e3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042112ea:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042112ee:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042112f5:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042112f9:	ba 02 00 00 00       	mov    $0x2,%edx
  80042112fe:	48 89 cf             	mov    %rcx,%rdi
  8004211301:	ff d0                	callq  *%rax
  8004211303:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  8004211307:	e9 b0 02 00 00       	jmpq   80042115bc <_dwarf_attr_init+0x561>
    case DW_FORM_data4:
    case DW_FORM_ref4:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  800421130c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211313:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211317:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421131e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211322:	ba 04 00 00 00       	mov    $0x4,%edx
  8004211327:	48 89 cf             	mov    %rcx,%rdi
  800421132a:	ff d0                	callq  *%rax
  800421132c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  8004211330:	e9 87 02 00 00       	jmpq   80042115bc <_dwarf_attr_init+0x561>
    case DW_FORM_data8:
    case DW_FORM_ref8:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  8004211335:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421133c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211340:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211347:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421134b:	ba 08 00 00 00       	mov    $0x8,%edx
  8004211350:	48 89 cf             	mov    %rcx,%rdi
  8004211353:	ff d0                	callq  *%rax
  8004211355:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  8004211359:	e9 5e 02 00 00       	jmpq   80042115bc <_dwarf_attr_init+0x561>
    case DW_FORM_indirect:
        form = _dwarf_read_uleb128(ds_data, offsetp);
  800421135e:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211365:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211369:	48 89 d6             	mov    %rdx,%rsi
  800421136c:	48 89 c7             	mov    %rax,%rdi
  800421136f:	48 b8 c5 06 21 04 80 	movabs $0x80042106c5,%rax
  8004211376:	00 00 00 
  8004211379:	ff d0                	callq  *%rax
  800421137b:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
        return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  8004211382:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  8004211389:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  8004211390:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  8004211397:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800421139e:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042113a5:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042113ac:	c7 04 24 01 00 00 00 	movl   $0x1,(%rsp)
  80042113b3:	4d 89 c1             	mov    %r8,%r9
  80042113b6:	49 89 f8             	mov    %rdi,%r8
  80042113b9:	48 89 c7             	mov    %rax,%rdi
  80042113bc:	48 b8 5b 10 21 04 80 	movabs $0x800421105b,%rax
  80042113c3:	00 00 00 
  80042113c6:	ff d0                	callq  *%rax
  80042113c8:	e9 1d 03 00 00       	jmpq   80042116ea <_dwarf_attr_init+0x68f>
    case DW_FORM_ref_addr:
        if (cu->version == 2)
  80042113cd:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042113d4:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042113d8:	66 83 f8 02          	cmp    $0x2,%ax
  80042113dc:	75 2f                	jne    800421140d <_dwarf_attr_init+0x3b2>
            atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  80042113de:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042113e5:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042113e9:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  80042113f0:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  80042113f4:	0f b6 d2             	movzbl %dl,%edx
  80042113f7:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042113fe:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211402:	48 89 cf             	mov    %rcx,%rdi
  8004211405:	ff d0                	callq  *%rax
  8004211407:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  800421140b:	eb 39                	jmp    8004211446 <_dwarf_attr_init+0x3eb>
        else if (cu->version == 3)
  800421140d:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004211414:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004211418:	66 83 f8 03          	cmp    $0x3,%ax
  800421141c:	75 28                	jne    8004211446 <_dwarf_attr_init+0x3eb>
            atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  800421141e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211425:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211429:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  800421142d:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211434:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211438:	48 89 cf             	mov    %rcx,%rdi
  800421143b:	ff d0                	callq  *%rax
  800421143d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  8004211441:	e9 76 01 00 00       	jmpq   80042115bc <_dwarf_attr_init+0x561>
  8004211446:	e9 71 01 00 00       	jmpq   80042115bc <_dwarf_attr_init+0x561>
    case DW_FORM_ref_udata:
    case DW_FORM_udata:
        atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  800421144b:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211452:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211456:	48 89 d6             	mov    %rdx,%rsi
  8004211459:	48 89 c7             	mov    %rax,%rdi
  800421145c:	48 b8 c5 06 21 04 80 	movabs $0x80042106c5,%rax
  8004211463:	00 00 00 
  8004211466:	ff d0                	callq  *%rax
  8004211468:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  800421146c:	e9 4b 01 00 00       	jmpq   80042115bc <_dwarf_attr_init+0x561>
    case DW_FORM_sdata:
        atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  8004211471:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211478:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421147c:	48 89 d6             	mov    %rdx,%rsi
  800421147f:	48 89 c7             	mov    %rax,%rdi
  8004211482:	48 b8 21 06 21 04 80 	movabs $0x8004210621,%rax
  8004211489:	00 00 00 
  800421148c:	ff d0                	callq  *%rax
  800421148e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  8004211492:	e9 25 01 00 00       	jmpq   80042115bc <_dwarf_attr_init+0x561>
    case DW_FORM_sec_offset:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004211497:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421149e:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042114a2:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  80042114a6:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042114ad:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042114b1:	48 89 cf             	mov    %rcx,%rdi
  80042114b4:	ff d0                	callq  *%rax
  80042114b6:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  80042114ba:	e9 fd 00 00 00       	jmpq   80042115bc <_dwarf_attr_init+0x561>
    case DW_FORM_string:
        atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  80042114bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042114c3:	48 8b 48 18          	mov    0x18(%rax),%rcx
  80042114c7:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042114ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042114d2:	48 89 ce             	mov    %rcx,%rsi
  80042114d5:	48 89 c7             	mov    %rax,%rdi
  80042114d8:	48 b8 43 08 21 04 80 	movabs $0x8004210843,%rax
  80042114df:	00 00 00 
  80042114e2:	ff d0                	callq  *%rax
  80042114e4:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  80042114e8:	e9 cf 00 00 00       	jmpq   80042115bc <_dwarf_attr_init+0x561>
    case DW_FORM_strp:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  80042114ed:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042114f4:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042114f8:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  80042114fc:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211503:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211507:	48 89 cf             	mov    %rcx,%rdi
  800421150a:	ff d0                	callq  *%rax
  800421150c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        str = _dwarf_find_section(".debug_str");
  8004211510:	48 bf 52 95 21 04 80 	movabs $0x8004219552,%rdi
  8004211517:	00 00 00 
  800421151a:	48 b8 b0 52 21 04 80 	movabs $0x80042152b0,%rax
  8004211521:	00 00 00 
  8004211524:	ff d0                	callq  *%rax
  8004211526:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        assert(str != NULL);
  800421152a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421152f:	75 35                	jne    8004211566 <_dwarf_attr_init+0x50b>
  8004211531:	48 b9 5d 95 21 04 80 	movabs $0x800421955d,%rcx
  8004211538:	00 00 00 
  800421153b:	48 ba ea 94 21 04 80 	movabs $0x80042194ea,%rdx
  8004211542:	00 00 00 
  8004211545:	be 53 02 00 00       	mov    $0x253,%esi
  800421154a:	48 bf ff 94 21 04 80 	movabs $0x80042194ff,%rdi
  8004211551:	00 00 00 
  8004211554:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211559:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004211560:	00 00 00 
  8004211563:	41 ff d0             	callq  *%r8
        //atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
        atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  8004211566:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421156a:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421156e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211572:	48 01 d0             	add    %rdx,%rax
  8004211575:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  8004211579:	eb 41                	jmp    80042115bc <_dwarf_attr_init+0x561>
    case DW_FORM_ref_sig8:
        atref.u[0].u64 = 8;
  800421157b:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  8004211582:	00 
        atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  8004211583:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211587:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800421158e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211592:	48 89 ce             	mov    %rcx,%rsi
  8004211595:	48 89 c7             	mov    %rax,%rdi
  8004211598:	48 b8 d2 08 21 04 80 	movabs $0x80042108d2,%rax
  800421159f:	00 00 00 
  80042115a2:	ff d0                	callq  *%rax
  80042115a4:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  80042115a8:	eb 12                	jmp    80042115bc <_dwarf_attr_init+0x561>
    case DW_FORM_flag_present:
        /* This form has no value encoded in the DIE. */
        atref.u[0].u64 = 1;
  80042115aa:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  80042115b1:	00 
        break;
  80042115b2:	eb 08                	jmp    80042115bc <_dwarf_attr_init+0x561>
    default:
        //DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
        ret = DW_DLE_ATTR_FORM_BAD;
  80042115b4:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
        break;
  80042115bb:	90                   	nop
    }

    if (ret == DW_DLE_NONE) {
  80042115bc:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042115c0:	0f 85 21 01 00 00    	jne    80042116e7 <_dwarf_attr_init+0x68c>
        if (form == DW_FORM_block || form == DW_FORM_block1 ||
  80042115c6:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  80042115cd:	09 
  80042115ce:	74 1e                	je     80042115ee <_dwarf_attr_init+0x593>
  80042115d0:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  80042115d7:	0a 
  80042115d8:	74 14                	je     80042115ee <_dwarf_attr_init+0x593>
  80042115da:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  80042115e1:	03 
  80042115e2:	74 0a                	je     80042115ee <_dwarf_attr_init+0x593>
            form == DW_FORM_block2 || form == DW_FORM_block4) {
  80042115e4:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  80042115eb:	04 
  80042115ec:	75 10                	jne    80042115fe <_dwarf_attr_init+0x5a3>
            atref.at_block.bl_len = atref.u[0].u64;
  80042115ee:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042115f2:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
            atref.at_block.bl_data = atref.u[1].u8p;
  80042115f6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042115fa:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        }
        //ret = _dwarf_attr_add(die, &atref, NULL, error);
        if (atref.at_attrib == DW_AT_name) {
  80042115fe:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004211602:	48 83 f8 03          	cmp    $0x3,%rax
  8004211606:	75 39                	jne    8004211641 <_dwarf_attr_init+0x5e6>
                switch (atref.at_form) {
  8004211608:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421160c:	48 83 f8 08          	cmp    $0x8,%rax
  8004211610:	74 1c                	je     800421162e <_dwarf_attr_init+0x5d3>
  8004211612:	48 83 f8 0e          	cmp    $0xe,%rax
  8004211616:	74 02                	je     800421161a <_dwarf_attr_init+0x5bf>
                    break;
                case DW_FORM_string:
                    ret_die->die_name = atref.u[0].s;
                    break;
                default:
                    break;
  8004211618:	eb 27                	jmp    8004211641 <_dwarf_attr_init+0x5e6>
        }
        //ret = _dwarf_attr_add(die, &atref, NULL, error);
        if (atref.at_attrib == DW_AT_name) {
                switch (atref.at_form) {
                case DW_FORM_strp:
                    ret_die->die_name = atref.u[1].s;
  800421161a:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800421161e:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004211625:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
                    break;
  800421162c:	eb 13                	jmp    8004211641 <_dwarf_attr_init+0x5e6>
                case DW_FORM_string:
                    ret_die->die_name = atref.u[0].s;
  800421162e:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211632:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004211639:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
                    break;
  8004211640:	90                   	nop
                default:
                    break;
                }
        }
        ret_die->die_attr[ret_die->die_attr_count++] = atref;
  8004211641:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004211648:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  800421164f:	8d 48 01             	lea    0x1(%rax),%ecx
  8004211652:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  8004211659:	88 8a 58 03 00 00    	mov    %cl,0x358(%rdx)
  800421165f:	0f b6 c0             	movzbl %al,%eax
  8004211662:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  8004211669:	48 63 d0             	movslq %eax,%rdx
  800421166c:	48 89 d0             	mov    %rdx,%rax
  800421166f:	48 01 c0             	add    %rax,%rax
  8004211672:	48 01 d0             	add    %rdx,%rax
  8004211675:	48 c1 e0 05          	shl    $0x5,%rax
  8004211679:	48 01 c8             	add    %rcx,%rax
  800421167c:	48 05 70 03 00 00    	add    $0x370,%rax
  8004211682:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004211689:	48 89 10             	mov    %rdx,(%rax)
  800421168c:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004211693:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004211697:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  800421169b:	48 89 50 10          	mov    %rdx,0x10(%rax)
  800421169f:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  80042116a3:	48 89 50 18          	mov    %rdx,0x18(%rax)
  80042116a7:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042116ab:	48 89 50 20          	mov    %rdx,0x20(%rax)
  80042116af:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042116b3:	48 89 50 28          	mov    %rdx,0x28(%rax)
  80042116b7:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042116bb:	48 89 50 30          	mov    %rdx,0x30(%rax)
  80042116bf:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80042116c3:	48 89 50 38          	mov    %rdx,0x38(%rax)
  80042116c7:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042116cb:	48 89 50 40          	mov    %rdx,0x40(%rax)
  80042116cf:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042116d3:	48 89 50 48          	mov    %rdx,0x48(%rax)
  80042116d7:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042116db:	48 89 50 50          	mov    %rdx,0x50(%rax)
  80042116df:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042116e3:	48 89 50 58          	mov    %rdx,0x58(%rax)
    }

    return (ret);
  80042116e7:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042116ea:	c9                   	leaveq 
  80042116eb:	c3                   	retq   

00000080042116ec <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  80042116ec:	55                   	push   %rbp
  80042116ed:	48 89 e5             	mov    %rsp,%rbp
  80042116f0:	48 81 ec d0 03 00 00 	sub    $0x3d0,%rsp
  80042116f7:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  80042116fe:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  8004211705:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  800421170c:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
    uint64_t abnum;
    uint64_t die_offset;
    int ret, level;
    int i;

    assert(dbg);
  8004211712:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  8004211719:	00 
  800421171a:	75 35                	jne    8004211751 <dwarf_search_die_within_cu+0x65>
  800421171c:	48 b9 78 96 21 04 80 	movabs $0x8004219678,%rcx
  8004211723:	00 00 00 
  8004211726:	48 ba ea 94 21 04 80 	movabs $0x80042194ea,%rdx
  800421172d:	00 00 00 
  8004211730:	be 88 02 00 00       	mov    $0x288,%esi
  8004211735:	48 bf ff 94 21 04 80 	movabs $0x80042194ff,%rdi
  800421173c:	00 00 00 
  800421173f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211744:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800421174b:	00 00 00 
  800421174e:	41 ff d0             	callq  *%r8
    //assert(cu);
    assert(ret_die);
  8004211751:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  8004211758:	00 
  8004211759:	75 35                	jne    8004211790 <dwarf_search_die_within_cu+0xa4>
  800421175b:	48 b9 7c 96 21 04 80 	movabs $0x800421967c,%rcx
  8004211762:	00 00 00 
  8004211765:	48 ba ea 94 21 04 80 	movabs $0x80042194ea,%rdx
  800421176c:	00 00 00 
  800421176f:	be 8a 02 00 00       	mov    $0x28a,%esi
  8004211774:	48 bf ff 94 21 04 80 	movabs $0x80042194ff,%rdi
  800421177b:	00 00 00 
  800421177e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211783:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800421178a:	00 00 00 
  800421178d:	41 ff d0             	callq  *%r8

    level = 1;
  8004211790:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

    while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004211797:	e9 17 02 00 00       	jmpq   80042119b3 <dwarf_search_die_within_cu+0x2c7>

        die_offset = offset;
  800421179c:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  80042117a3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

        abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  80042117a7:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042117ae:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042117b2:	48 8d 95 80 fc ff ff 	lea    -0x380(%rbp),%rdx
  80042117b9:	48 89 d6             	mov    %rdx,%rsi
  80042117bc:	48 89 c7             	mov    %rax,%rdi
  80042117bf:	48 b8 c5 06 21 04 80 	movabs $0x80042106c5,%rax
  80042117c6:	00 00 00 
  80042117c9:	ff d0                	callq  *%rax
  80042117cb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

        if (abnum == 0) {
  80042117cf:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042117d4:	75 22                	jne    80042117f8 <dwarf_search_die_within_cu+0x10c>
            if (level == 0 || !search_sibling) {
  80042117d6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042117da:	74 09                	je     80042117e5 <dwarf_search_die_within_cu+0xf9>
  80042117dc:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  80042117e3:	75 0a                	jne    80042117ef <dwarf_search_die_within_cu+0x103>
                //No more entry
                return (DW_DLE_NO_ENTRY);
  80042117e5:	b8 04 00 00 00       	mov    $0x4,%eax
  80042117ea:	e9 f4 01 00 00       	jmpq   80042119e3 <dwarf_search_die_within_cu+0x2f7>
            }
            /*
             * Return to previous DIE level.
             */
            level--;
  80042117ef:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
            continue;
  80042117f3:	e9 bb 01 00 00       	jmpq   80042119b3 <dwarf_search_die_within_cu+0x2c7>
        }

        if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  80042117f8:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  80042117ff:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211803:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800421180a:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  800421180e:	48 89 34 24          	mov    %rsi,(%rsp)
  8004211812:	48 8b 75 18          	mov    0x18(%rbp),%rsi
  8004211816:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  800421181b:	48 8b 75 20          	mov    0x20(%rbp),%rsi
  800421181f:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  8004211824:	48 8b 75 28          	mov    0x28(%rbp),%rsi
  8004211828:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  800421182d:	48 8b 75 30          	mov    0x30(%rbp),%rsi
  8004211831:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
  8004211836:	48 8b 75 38          	mov    0x38(%rbp),%rsi
  800421183a:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  800421183f:	48 8b 75 40          	mov    0x40(%rbp),%rsi
  8004211843:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
  8004211848:	48 89 ce             	mov    %rcx,%rsi
  800421184b:	48 89 c7             	mov    %rax,%rdi
  800421184e:	48 b8 2a 0f 21 04 80 	movabs $0x8004210f2a,%rax
  8004211855:	00 00 00 
  8004211858:	ff d0                	callq  *%rax
  800421185a:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  800421185d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004211861:	74 08                	je     800421186b <dwarf_search_die_within_cu+0x17f>
            return (ret);
  8004211863:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004211866:	e9 78 01 00 00       	jmpq   80042119e3 <dwarf_search_die_within_cu+0x2f7>
        ret_die->die_offset = die_offset;
  800421186b:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211872:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211876:	48 89 10             	mov    %rdx,(%rax)
        ret_die->die_abnum  = abnum;
  8004211879:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211880:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211884:	48 89 50 10          	mov    %rdx,0x10(%rax)
        ret_die->die_ab  = ab;
  8004211888:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800421188f:	48 8d 78 20          	lea    0x20(%rax),%rdi
  8004211893:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  800421189a:	b8 66 00 00 00       	mov    $0x66,%eax
  800421189f:	48 89 d6             	mov    %rdx,%rsi
  80042118a2:	48 89 c1             	mov    %rax,%rcx
  80042118a5:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
        ret_die->die_attr_count = 0;
  80042118a8:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  80042118af:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
        ret_die->die_tag = ab.ab_tag;
  80042118b6:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  80042118bd:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  80042118c4:	48 89 50 18          	mov    %rdx,0x18(%rax)
        //ret_die->die_cu  = cu;
        //ret_die->die_dbg = cu->cu_dbg;

        for(i=0; i < ab.ab_atnum; i++)
  80042118c8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  80042118cf:	e9 8e 00 00 00       	jmpq   8004211962 <dwarf_search_die_within_cu+0x276>
        {
            if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  80042118d4:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042118d7:	48 63 d0             	movslq %eax,%rdx
  80042118da:	48 89 d0             	mov    %rdx,%rax
  80042118dd:	48 01 c0             	add    %rax,%rax
  80042118e0:	48 01 d0             	add    %rdx,%rax
  80042118e3:	48 c1 e0 03          	shl    $0x3,%rax
  80042118e7:	48 01 e8             	add    %rbp,%rax
  80042118ea:	48 2d 18 03 00 00    	sub    $0x318,%rax
  80042118f0:	48 8b 08             	mov    (%rax),%rcx
  80042118f3:	48 8d b5 b0 fc ff ff 	lea    -0x350(%rbp),%rsi
  80042118fa:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042118fd:	48 63 d0             	movslq %eax,%rdx
  8004211900:	48 89 d0             	mov    %rdx,%rax
  8004211903:	48 01 c0             	add    %rax,%rax
  8004211906:	48 01 d0             	add    %rdx,%rax
  8004211909:	48 c1 e0 03          	shl    $0x3,%rax
  800421190d:	48 83 c0 30          	add    $0x30,%rax
  8004211911:	48 8d 3c 06          	lea    (%rsi,%rax,1),%rdi
  8004211915:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  800421191c:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  8004211923:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800421192a:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  8004211931:	49 89 c9             	mov    %rcx,%r9
  8004211934:	49 89 f8             	mov    %rdi,%r8
  8004211937:	48 89 d1             	mov    %rdx,%rcx
  800421193a:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  800421193e:	48 89 c7             	mov    %rax,%rdi
  8004211941:	48 b8 5b 10 21 04 80 	movabs $0x800421105b,%rax
  8004211948:	00 00 00 
  800421194b:	ff d0                	callq  *%rax
  800421194d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004211950:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004211954:	74 08                	je     800421195e <dwarf_search_die_within_cu+0x272>
                return (ret);
  8004211956:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004211959:	e9 85 00 00 00       	jmpq   80042119e3 <dwarf_search_die_within_cu+0x2f7>
        ret_die->die_attr_count = 0;
        ret_die->die_tag = ab.ab_tag;
        //ret_die->die_cu  = cu;
        //ret_die->die_dbg = cu->cu_dbg;

        for(i=0; i < ab.ab_atnum; i++)
  800421195e:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004211962:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004211965:	48 63 d0             	movslq %eax,%rdx
  8004211968:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  800421196f:	48 39 c2             	cmp    %rax,%rdx
  8004211972:	0f 82 5c ff ff ff    	jb     80042118d4 <dwarf_search_die_within_cu+0x1e8>
        {
            if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
                return (ret);
        }

        ret_die->die_next_off = offset;
  8004211978:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  800421197f:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211986:	48 89 50 08          	mov    %rdx,0x8(%rax)
        if (search_sibling && level > 0) {
  800421198a:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004211991:	74 19                	je     80042119ac <dwarf_search_die_within_cu+0x2c0>
  8004211993:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004211997:	7e 13                	jle    80042119ac <dwarf_search_die_within_cu+0x2c0>
            //dwarf_dealloc(dbg, die, DW_DLA_DIE);
            if (ab.ab_children == DW_CHILDREN_yes) {
  8004211999:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  80042119a0:	3c 01                	cmp    $0x1,%al
  80042119a2:	75 06                	jne    80042119aa <dwarf_search_die_within_cu+0x2be>
                /* Advance to next DIE level. */
                level++;
  80042119a4:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
        }

        ret_die->die_next_off = offset;
        if (search_sibling && level > 0) {
            //dwarf_dealloc(dbg, die, DW_DLA_DIE);
            if (ab.ab_children == DW_CHILDREN_yes) {
  80042119a8:	eb 09                	jmp    80042119b3 <dwarf_search_die_within_cu+0x2c7>
  80042119aa:	eb 07                	jmp    80042119b3 <dwarf_search_die_within_cu+0x2c7>
                /* Advance to next DIE level. */
                level++;
            }
        } else {
            //*ret_die = die;
            return (DW_DLE_NONE);
  80042119ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80042119b1:	eb 30                	jmp    80042119e3 <dwarf_search_die_within_cu+0x2f7>
    //assert(cu);
    assert(ret_die);

    level = 1;

    while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  80042119b3:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  80042119b7:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  80042119be:	48 39 c2             	cmp    %rax,%rdx
  80042119c1:	76 1b                	jbe    80042119de <dwarf_search_die_within_cu+0x2f2>
  80042119c3:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042119ca:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042119ce:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  80042119d5:	48 39 c2             	cmp    %rax,%rdx
  80042119d8:	0f 87 be fd ff ff    	ja     800421179c <dwarf_search_die_within_cu+0xb0>
            //*ret_die = die;
            return (DW_DLE_NONE);
        }
    }

    return (DW_DLE_NO_ENTRY);
  80042119de:	b8 04 00 00 00       	mov    $0x4,%eax
}
  80042119e3:	c9                   	leaveq 
  80042119e4:	c3                   	retq   

00000080042119e5 <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  80042119e5:	55                   	push   %rbp
  80042119e6:	48 89 e5             	mov    %rsp,%rbp
  80042119e9:	48 83 ec 60          	sub    $0x60,%rsp
  80042119ed:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042119f1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042119f5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
    int ret;

    assert(dbg);
  80042119f9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042119fe:	75 35                	jne    8004211a35 <dwarf_offdie+0x50>
  8004211a00:	48 b9 78 96 21 04 80 	movabs $0x8004219678,%rcx
  8004211a07:	00 00 00 
  8004211a0a:	48 ba ea 94 21 04 80 	movabs $0x80042194ea,%rdx
  8004211a11:	00 00 00 
  8004211a14:	be c6 02 00 00       	mov    $0x2c6,%esi
  8004211a19:	48 bf ff 94 21 04 80 	movabs $0x80042194ff,%rdi
  8004211a20:	00 00 00 
  8004211a23:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211a28:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004211a2f:	00 00 00 
  8004211a32:	41 ff d0             	callq  *%r8
    assert(ret_die);
  8004211a35:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211a3a:	75 35                	jne    8004211a71 <dwarf_offdie+0x8c>
  8004211a3c:	48 b9 7c 96 21 04 80 	movabs $0x800421967c,%rcx
  8004211a43:	00 00 00 
  8004211a46:	48 ba ea 94 21 04 80 	movabs $0x80042194ea,%rdx
  8004211a4d:	00 00 00 
  8004211a50:	be c7 02 00 00       	mov    $0x2c7,%esi
  8004211a55:	48 bf ff 94 21 04 80 	movabs $0x80042194ff,%rdi
  8004211a5c:	00 00 00 
  8004211a5f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211a64:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004211a6b:	00 00 00 
  8004211a6e:	41 ff d0             	callq  *%r8

    /* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  8004211a71:	48 8b 45 30          	mov    0x30(%rbp),%rax
  8004211a75:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211a79:	76 66                	jbe    8004211ae1 <dwarf_offdie+0xfc>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  8004211a7b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004211a7f:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8004211a83:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a87:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  8004211a8b:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004211a8f:	48 8b 4d 18          	mov    0x18(%rbp),%rcx
  8004211a93:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  8004211a98:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
  8004211a9c:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  8004211aa1:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004211aa5:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  8004211aaa:	48 8b 4d 30          	mov    0x30(%rbp),%rcx
  8004211aae:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  8004211ab3:	48 8b 4d 38          	mov    0x38(%rbp),%rcx
  8004211ab7:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  8004211abc:	48 8b 4d 40          	mov    0x40(%rbp),%rcx
  8004211ac0:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
  8004211ac5:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004211aca:	48 89 c7             	mov    %rax,%rdi
  8004211acd:	48 b8 ec 16 21 04 80 	movabs $0x80042116ec,%rax
  8004211ad4:	00 00 00 
  8004211ad7:	ff d0                	callq  *%rax
  8004211ad9:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  8004211adc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004211adf:	eb 05                	jmp    8004211ae6 <dwarf_offdie+0x101>
	}

    /*TODO: Search other CU*/
    return DW_DLV_OK;
  8004211ae1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211ae6:	c9                   	leaveq 
  8004211ae7:	c3                   	retq   

0000008004211ae8 <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  8004211ae8:	55                   	push   %rbp
  8004211ae9:	48 89 e5             	mov    %rsp,%rbp
  8004211aec:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004211af0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211af4:	89 f0                	mov    %esi,%eax
  8004211af6:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
    Dwarf_Attribute *myat = NULL;
  8004211afa:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004211b01:	00 
    int i;
    
    for(i=0; i < die->die_attr_count; i++)
  8004211b02:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004211b09:	eb 57                	jmp    8004211b62 <_dwarf_attr_find+0x7a>
    {
        if (die->die_attr[i].at_attrib == attr)
  8004211b0b:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211b0f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211b12:	48 63 d0             	movslq %eax,%rdx
  8004211b15:	48 89 d0             	mov    %rdx,%rax
  8004211b18:	48 01 c0             	add    %rax,%rax
  8004211b1b:	48 01 d0             	add    %rdx,%rax
  8004211b1e:	48 c1 e0 05          	shl    $0x5,%rax
  8004211b22:	48 01 c8             	add    %rcx,%rax
  8004211b25:	48 05 80 03 00 00    	add    $0x380,%rax
  8004211b2b:	48 8b 10             	mov    (%rax),%rdx
  8004211b2e:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  8004211b32:	48 39 c2             	cmp    %rax,%rdx
  8004211b35:	75 27                	jne    8004211b5e <_dwarf_attr_find+0x76>
        {
            myat = &(die->die_attr[i]);
  8004211b37:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211b3a:	48 63 d0             	movslq %eax,%rdx
  8004211b3d:	48 89 d0             	mov    %rdx,%rax
  8004211b40:	48 01 c0             	add    %rax,%rax
  8004211b43:	48 01 d0             	add    %rdx,%rax
  8004211b46:	48 c1 e0 05          	shl    $0x5,%rax
  8004211b4a:	48 8d 90 70 03 00 00 	lea    0x370(%rax),%rdx
  8004211b51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211b55:	48 01 d0             	add    %rdx,%rax
  8004211b58:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
            break;
  8004211b5c:	eb 17                	jmp    8004211b75 <_dwarf_attr_find+0x8d>
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
    Dwarf_Attribute *myat = NULL;
    int i;
    
    for(i=0; i < die->die_attr_count; i++)
  8004211b5e:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004211b62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211b66:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004211b6d:	0f b6 c0             	movzbl %al,%eax
  8004211b70:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8004211b73:	7f 96                	jg     8004211b0b <_dwarf_attr_find+0x23>
            myat = &(die->die_attr[i]);
            break;
        }
    }

    return myat;
  8004211b75:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004211b79:	c9                   	leaveq 
  8004211b7a:	c3                   	retq   

0000008004211b7b <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
    Dwarf_CU *cu)
{
  8004211b7b:	55                   	push   %rbp
  8004211b7c:	48 89 e5             	mov    %rsp,%rbp
  8004211b7f:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004211b83:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211b87:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004211b8b:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004211b8f:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
    Dwarf_Attribute *at;
    uint64_t offset;
    int ret, search_sibling;

    assert(dbg);
  8004211b93:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211b98:	75 35                	jne    8004211bcf <dwarf_siblingof+0x54>
  8004211b9a:	48 b9 78 96 21 04 80 	movabs $0x8004219678,%rcx
  8004211ba1:	00 00 00 
  8004211ba4:	48 ba ea 94 21 04 80 	movabs $0x80042194ea,%rdx
  8004211bab:	00 00 00 
  8004211bae:	be ee 02 00 00       	mov    $0x2ee,%esi
  8004211bb3:	48 bf ff 94 21 04 80 	movabs $0x80042194ff,%rdi
  8004211bba:	00 00 00 
  8004211bbd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211bc2:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004211bc9:	00 00 00 
  8004211bcc:	41 ff d0             	callq  *%r8
    assert(ret_die);
  8004211bcf:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004211bd4:	75 35                	jne    8004211c0b <dwarf_siblingof+0x90>
  8004211bd6:	48 b9 7c 96 21 04 80 	movabs $0x800421967c,%rcx
  8004211bdd:	00 00 00 
  8004211be0:	48 ba ea 94 21 04 80 	movabs $0x80042194ea,%rdx
  8004211be7:	00 00 00 
  8004211bea:	be ef 02 00 00       	mov    $0x2ef,%esi
  8004211bef:	48 bf ff 94 21 04 80 	movabs $0x80042194ff,%rdi
  8004211bf6:	00 00 00 
  8004211bf9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211bfe:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004211c05:	00 00 00 
  8004211c08:	41 ff d0             	callq  *%r8
    assert(cu);
  8004211c0b:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004211c10:	75 35                	jne    8004211c47 <dwarf_siblingof+0xcc>
  8004211c12:	48 b9 84 96 21 04 80 	movabs $0x8004219684,%rcx
  8004211c19:	00 00 00 
  8004211c1c:	48 ba ea 94 21 04 80 	movabs $0x80042194ea,%rdx
  8004211c23:	00 00 00 
  8004211c26:	be f0 02 00 00       	mov    $0x2f0,%esi
  8004211c2b:	48 bf ff 94 21 04 80 	movabs $0x80042194ff,%rdi
  8004211c32:	00 00 00 
  8004211c35:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211c3a:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004211c41:	00 00 00 
  8004211c44:	41 ff d0             	callq  *%r8

    /* Application requests the first DIE in this CU. */
    if (die == NULL)
  8004211c47:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211c4c:	75 65                	jne    8004211cb3 <dwarf_siblingof+0x138>
        return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  8004211c4e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211c52:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004211c56:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211c5a:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004211c5e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211c62:	48 8b 38             	mov    (%rax),%rdi
  8004211c65:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004211c69:	48 8b 78 08          	mov    0x8(%rax),%rdi
  8004211c6d:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004211c72:	48 8b 78 10          	mov    0x10(%rax),%rdi
  8004211c76:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004211c7b:	48 8b 78 18          	mov    0x18(%rax),%rdi
  8004211c7f:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004211c84:	48 8b 78 20          	mov    0x20(%rax),%rdi
  8004211c88:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  8004211c8d:	48 8b 78 28          	mov    0x28(%rax),%rdi
  8004211c91:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004211c96:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211c9a:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004211c9f:	48 89 cf             	mov    %rcx,%rdi
  8004211ca2:	48 b8 e5 19 21 04 80 	movabs $0x80042119e5,%rax
  8004211ca9:	00 00 00 
  8004211cac:	ff d0                	callq  *%rax
  8004211cae:	e9 0a 01 00 00       	jmpq   8004211dbd <dwarf_siblingof+0x242>

    /*
     * If the DIE doesn't have any children, its sibling sits next
     * right to it.
     */
    search_sibling = 0;
  8004211cb3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004211cba:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211cbe:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004211cc2:	84 c0                	test   %al,%al
  8004211cc4:	75 0e                	jne    8004211cd4 <dwarf_siblingof+0x159>
        offset = die->die_next_off;
  8004211cc6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211cca:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211cce:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211cd2:	eb 6b                	jmp    8004211d3f <dwarf_siblingof+0x1c4>
    else {
        /*
         * Look for DW_AT_sibling attribute for the offset of
         * its sibling.
         */
        if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  8004211cd4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211cd8:	be 01 00 00 00       	mov    $0x1,%esi
  8004211cdd:	48 89 c7             	mov    %rax,%rdi
  8004211ce0:	48 b8 e8 1a 21 04 80 	movabs $0x8004211ae8,%rax
  8004211ce7:	00 00 00 
  8004211cea:	ff d0                	callq  *%rax
  8004211cec:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004211cf0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004211cf5:	74 35                	je     8004211d2c <dwarf_siblingof+0x1b1>
            if (at->at_form != DW_FORM_ref_addr)
  8004211cf7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211cfb:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211cff:	48 83 f8 10          	cmp    $0x10,%rax
  8004211d03:	74 19                	je     8004211d1e <dwarf_siblingof+0x1a3>
                offset = at->u[0].u64 + cu->cu_offset;
  8004211d05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211d09:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004211d0d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211d11:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211d15:	48 01 d0             	add    %rdx,%rax
  8004211d18:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211d1c:	eb 21                	jmp    8004211d3f <dwarf_siblingof+0x1c4>
            else
                offset = at->u[0].u64;
  8004211d1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211d22:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004211d26:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211d2a:	eb 13                	jmp    8004211d3f <dwarf_siblingof+0x1c4>
        } else {
            offset = die->die_next_off;
  8004211d2c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211d30:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211d34:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
            search_sibling = 1;
  8004211d38:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
        }
    }

    ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  8004211d3f:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004211d42:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211d46:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8004211d4a:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  8004211d4e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211d52:	4c 8b 00             	mov    (%rax),%r8
  8004211d55:	4c 89 04 24          	mov    %r8,(%rsp)
  8004211d59:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004211d5d:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004211d62:	4c 8b 40 10          	mov    0x10(%rax),%r8
  8004211d66:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004211d6b:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004211d6f:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004211d74:	4c 8b 40 20          	mov    0x20(%rax),%r8
  8004211d78:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
  8004211d7d:	4c 8b 40 28          	mov    0x28(%rax),%r8
  8004211d81:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
  8004211d86:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211d8a:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004211d8f:	48 b8 ec 16 21 04 80 	movabs $0x80042116ec,%rax
  8004211d96:	00 00 00 
  8004211d99:	ff d0                	callq  *%rax
  8004211d9b:	89 45 e4             	mov    %eax,-0x1c(%rbp)


    if (ret == DW_DLE_NO_ENTRY) {
  8004211d9e:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  8004211da2:	75 07                	jne    8004211dab <dwarf_siblingof+0x230>
        return (DW_DLV_NO_ENTRY);
  8004211da4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211da9:	eb 12                	jmp    8004211dbd <dwarf_siblingof+0x242>
    } else if (ret != DW_DLE_NONE)
  8004211dab:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004211daf:	74 07                	je     8004211db8 <dwarf_siblingof+0x23d>
        return (DW_DLV_ERROR);
  8004211db1:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211db6:	eb 05                	jmp    8004211dbd <dwarf_siblingof+0x242>


    return (DW_DLV_OK);
  8004211db8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211dbd:	c9                   	leaveq 
  8004211dbe:	c3                   	retq   

0000008004211dbf <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  8004211dbf:	55                   	push   %rbp
  8004211dc0:	48 89 e5             	mov    %rsp,%rbp
  8004211dc3:	48 83 ec 70          	sub    $0x70,%rsp
  8004211dc7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211dcb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211dcf:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004211dd3:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    int ret;

    assert(die);
  8004211dd7:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211ddc:	75 35                	jne    8004211e13 <dwarf_child+0x54>
  8004211dde:	48 b9 87 96 21 04 80 	movabs $0x8004219687,%rcx
  8004211de5:	00 00 00 
  8004211de8:	48 ba ea 94 21 04 80 	movabs $0x80042194ea,%rdx
  8004211def:	00 00 00 
  8004211df2:	be 1e 03 00 00       	mov    $0x31e,%esi
  8004211df7:	48 bf ff 94 21 04 80 	movabs $0x80042194ff,%rdi
  8004211dfe:	00 00 00 
  8004211e01:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211e06:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004211e0d:	00 00 00 
  8004211e10:	41 ff d0             	callq  *%r8
    assert(ret_die);
  8004211e13:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211e18:	75 35                	jne    8004211e4f <dwarf_child+0x90>
  8004211e1a:	48 b9 7c 96 21 04 80 	movabs $0x800421967c,%rcx
  8004211e21:	00 00 00 
  8004211e24:	48 ba ea 94 21 04 80 	movabs $0x80042194ea,%rdx
  8004211e2b:	00 00 00 
  8004211e2e:	be 1f 03 00 00       	mov    $0x31f,%esi
  8004211e33:	48 bf ff 94 21 04 80 	movabs $0x80042194ff,%rdi
  8004211e3a:	00 00 00 
  8004211e3d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211e42:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004211e49:	00 00 00 
  8004211e4c:	41 ff d0             	callq  *%r8
    assert(dbg);
  8004211e4f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004211e54:	75 35                	jne    8004211e8b <dwarf_child+0xcc>
  8004211e56:	48 b9 78 96 21 04 80 	movabs $0x8004219678,%rcx
  8004211e5d:	00 00 00 
  8004211e60:	48 ba ea 94 21 04 80 	movabs $0x80042194ea,%rdx
  8004211e67:	00 00 00 
  8004211e6a:	be 20 03 00 00       	mov    $0x320,%esi
  8004211e6f:	48 bf ff 94 21 04 80 	movabs $0x80042194ff,%rdi
  8004211e76:	00 00 00 
  8004211e79:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211e7e:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004211e85:	00 00 00 
  8004211e88:	41 ff d0             	callq  *%r8
    assert(cu);
  8004211e8b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004211e90:	75 35                	jne    8004211ec7 <dwarf_child+0x108>
  8004211e92:	48 b9 84 96 21 04 80 	movabs $0x8004219684,%rcx
  8004211e99:	00 00 00 
  8004211e9c:	48 ba ea 94 21 04 80 	movabs $0x80042194ea,%rdx
  8004211ea3:	00 00 00 
  8004211ea6:	be 21 03 00 00       	mov    $0x321,%esi
  8004211eab:	48 bf ff 94 21 04 80 	movabs $0x80042194ff,%rdi
  8004211eb2:	00 00 00 
  8004211eb5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211eba:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004211ec1:	00 00 00 
  8004211ec4:	41 ff d0             	callq  *%r8

    if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004211ec7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211ecb:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004211ecf:	84 c0                	test   %al,%al
  8004211ed1:	75 0a                	jne    8004211edd <dwarf_child+0x11e>
        return (DW_DLE_NO_ENTRY);
  8004211ed3:	b8 04 00 00 00       	mov    $0x4,%eax
  8004211ed8:	e9 84 00 00 00       	jmpq   8004211f61 <dwarf_child+0x1a2>

    ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  8004211edd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211ee1:	48 8b 70 08          	mov    0x8(%rax),%rsi
  8004211ee5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211ee9:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  8004211eed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211ef1:	48 8b 08             	mov    (%rax),%rcx
  8004211ef4:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004211ef8:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004211efc:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  8004211f01:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004211f05:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  8004211f0a:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004211f0e:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  8004211f13:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211f17:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  8004211f1c:	48 8b 48 28          	mov    0x28(%rax),%rcx
  8004211f20:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  8004211f25:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211f29:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004211f2e:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004211f33:	48 b8 ec 16 21 04 80 	movabs $0x80042116ec,%rax
  8004211f3a:	00 00 00 
  8004211f3d:	ff d0                	callq  *%rax
  8004211f3f:	89 45 fc             	mov    %eax,-0x4(%rbp)

    if (ret == DW_DLE_NO_ENTRY) {
  8004211f42:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004211f46:	75 07                	jne    8004211f4f <dwarf_child+0x190>
        DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
        return (DW_DLV_NO_ENTRY);
  8004211f48:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211f4d:	eb 12                	jmp    8004211f61 <dwarf_child+0x1a2>
    } else if (ret != DW_DLE_NONE)
  8004211f4f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004211f53:	74 07                	je     8004211f5c <dwarf_child+0x19d>
        return (DW_DLV_ERROR);
  8004211f55:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211f5a:	eb 05                	jmp    8004211f61 <dwarf_child+0x1a2>

    return (DW_DLV_OK);
  8004211f5c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211f61:	c9                   	leaveq 
  8004211f62:	c3                   	retq   

0000008004211f63 <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  8004211f63:	55                   	push   %rbp
  8004211f64:	48 89 e5             	mov    %rsp,%rbp
  8004211f67:	48 83 ec 20          	sub    $0x20,%rsp
  8004211f6b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  8004211f6f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211f73:	48 8b 00             	mov    (%rax),%rax
  8004211f76:	48 89 c7             	mov    %rax,%rdi
  8004211f79:	48 b8 b0 52 21 04 80 	movabs $0x80042152b0,%rax
  8004211f80:	00 00 00 
  8004211f83:	ff d0                	callq  *%rax
  8004211f85:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  8004211f89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211f8d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004211f91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211f95:	48 89 50 08          	mov    %rdx,0x8(%rax)
    ds->ds_addr = secthdr->ds_addr;
  8004211f99:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211f9d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004211fa1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211fa5:	48 89 50 10          	mov    %rdx,0x10(%rax)
    ds->ds_size = secthdr->ds_size;
  8004211fa9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211fad:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004211fb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211fb5:	48 89 50 18          	mov    %rdx,0x18(%rax)
    return 0;
  8004211fb9:	b8 00 00 00 00       	mov    $0x0,%eax

}
  8004211fbe:	c9                   	leaveq 
  8004211fbf:	c3                   	retq   

0000008004211fc0 <_dwarf_frame_params_init>:
int  _dwarf_find_section_enhanced(Dwarf_Section *ds);


void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  8004211fc0:	55                   	push   %rbp
  8004211fc1:	48 89 e5             	mov    %rsp,%rbp
  8004211fc4:	48 83 ec 08          	sub    $0x8,%rsp
  8004211fc8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

        /* Initialise call frame related parameters. */
        dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  8004211fcc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211fd0:	66 c7 40 40 42 00    	movw   $0x42,0x40(%rax)
        dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  8004211fd6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211fda:	66 c7 40 42 0b 04    	movw   $0x40b,0x42(%rax)
        dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  8004211fe0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211fe4:	66 c7 40 44 9c 05    	movw   $0x59c,0x44(%rax)
        dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  8004211fea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211fee:	66 c7 40 46 0b 04    	movw   $0x40b,0x46(%rax)
        dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  8004211ff4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211ff8:	66 c7 40 48 0a 04    	movw   $0x40a,0x48(%rax)
}
  8004211ffe:	c9                   	leaveq 
  8004211fff:	c3                   	retq   

0000008004212000 <dwarf_get_fde_at_pc>:


int
dwarf_get_fde_at_pc(Dwarf_Addr pc,
    Dwarf_Addr *lopc, Dwarf_Addr *hipc, struct _Dwarf_Fde *ret_fde, Dwarf_Cie cie, Dwarf_Error *error)
{
  8004212000:	55                   	push   %rbp
  8004212001:	48 89 e5             	mov    %rsp,%rbp
  8004212004:	48 83 ec 40          	sub    $0x40,%rsp
  8004212008:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421200c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004212010:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004212014:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004212018:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
  800421201c:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
    Dwarf_Fde fde = ret_fde;
  8004212020:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212024:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(fde, 0, sizeof(struct _Dwarf_Fde));
  8004212028:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421202c:	ba 80 00 00 00       	mov    $0x80,%edx
  8004212031:	be 00 00 00 00       	mov    $0x0,%esi
  8004212036:	48 89 c7             	mov    %rax,%rdi
  8004212039:	48 b8 b3 fb 20 04 80 	movabs $0x800420fbb3,%rax
  8004212040:	00 00 00 
  8004212043:	ff d0                	callq  *%rax
	fde->fde_cie = cie;
  8004212045:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212049:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421204d:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
        if (ret_fde == NULL || lopc == NULL || hipc == NULL) {
  8004212051:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004212056:	74 0e                	je     8004212066 <dwarf_get_fde_at_pc+0x66>
  8004212058:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800421205d:	74 07                	je     8004212066 <dwarf_get_fde_at_pc+0x66>
  800421205f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004212064:	75 0a                	jne    8004212070 <dwarf_get_fde_at_pc+0x70>
                return (DW_DLV_ERROR);
  8004212066:	b8 01 00 00 00       	mov    $0x1,%eax
  800421206b:	e9 ce 00 00 00       	jmpq   800421213e <dwarf_get_fde_at_pc+0x13e>
        }

        while(dbg->dbg_eh_offset < dbg->dbg_eh_size) {
  8004212070:	e9 99 00 00 00       	jmpq   800421210e <dwarf_get_fde_at_pc+0x10e>
                if (_dwarf_get_next_fde(dbg, is_eh_frame, error, fde) < 0)
  8004212075:	48 b8 00 a7 22 04 80 	movabs $0x800422a700,%rax
  800421207c:	00 00 00 
  800421207f:	8b 30                	mov    (%rax),%esi
  8004212081:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004212088:	00 00 00 
  800421208b:	48 8b 00             	mov    (%rax),%rax
  800421208e:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004212092:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212096:	48 89 c7             	mov    %rax,%rdi
  8004212099:	48 b8 10 42 21 04 80 	movabs $0x8004214210,%rax
  80042120a0:	00 00 00 
  80042120a3:	ff d0                	callq  *%rax
  80042120a5:	85 c0                	test   %eax,%eax
  80042120a7:	79 0a                	jns    80042120b3 <dwarf_get_fde_at_pc+0xb3>
				{
		    		return DW_DLV_NO_ENTRY;
  80042120a9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042120ae:	e9 8b 00 00 00       	jmpq   800421213e <dwarf_get_fde_at_pc+0x13e>
				}
                if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  80042120b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042120b7:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042120bb:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042120bf:	77 4d                	ja     800421210e <dwarf_get_fde_at_pc+0x10e>
  80042120c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042120c5:	48 8b 50 30          	mov    0x30(%rax),%rdx
                    fde->fde_adrange) {
  80042120c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042120cd:	48 8b 40 38          	mov    0x38(%rax),%rax
        while(dbg->dbg_eh_offset < dbg->dbg_eh_size) {
                if (_dwarf_get_next_fde(dbg, is_eh_frame, error, fde) < 0)
				{
		    		return DW_DLV_NO_ENTRY;
				}
                if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  80042120d1:	48 01 d0             	add    %rdx,%rax
  80042120d4:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042120d8:	76 34                	jbe    800421210e <dwarf_get_fde_at_pc+0x10e>
                    fde->fde_adrange) {
                        *lopc = fde->fde_initloc;
  80042120da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042120de:	48 8b 50 30          	mov    0x30(%rax),%rdx
  80042120e2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042120e6:	48 89 10             	mov    %rdx,(%rax)
                        *hipc = fde->fde_initloc + fde->fde_adrange - 1;
  80042120e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042120ed:	48 8b 50 30          	mov    0x30(%rax),%rdx
  80042120f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042120f5:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042120f9:	48 01 d0             	add    %rdx,%rax
  80042120fc:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  8004212100:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212104:	48 89 10             	mov    %rdx,(%rax)

                        return (DW_DLV_OK);
  8004212107:	b8 00 00 00 00       	mov    $0x0,%eax
  800421210c:	eb 30                	jmp    800421213e <dwarf_get_fde_at_pc+0x13e>
	
        if (ret_fde == NULL || lopc == NULL || hipc == NULL) {
                return (DW_DLV_ERROR);
        }

        while(dbg->dbg_eh_offset < dbg->dbg_eh_size) {
  800421210e:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004212115:	00 00 00 
  8004212118:	48 8b 00             	mov    (%rax),%rax
  800421211b:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800421211f:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004212126:	00 00 00 
  8004212129:	48 8b 00             	mov    (%rax),%rax
  800421212c:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212130:	48 39 c2             	cmp    %rax,%rdx
  8004212133:	0f 82 3c ff ff ff    	jb     8004212075 <dwarf_get_fde_at_pc+0x75>
                        return (DW_DLV_OK);
                }
        }

        DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
        return (DW_DLV_NO_ENTRY);
  8004212139:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  800421213e:	c9                   	leaveq 
  800421213f:	c3                   	retq   

0000008004212140 <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
    Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  8004212140:	55                   	push   %rbp
  8004212141:	48 89 e5             	mov    %rsp,%rbp
  8004212144:	53                   	push   %rbx
  8004212145:	48 83 ec 38          	sub    $0x38,%rsp
  8004212149:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421214d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004212151:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004212155:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
        int i;

        assert(dest != NULL);
  8004212159:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800421215e:	75 35                	jne    8004212195 <_dwarf_frame_regtable_copy+0x55>
  8004212160:	48 b9 9a 96 21 04 80 	movabs $0x800421969a,%rcx
  8004212167:	00 00 00 
  800421216a:	48 ba a7 96 21 04 80 	movabs $0x80042196a7,%rdx
  8004212171:	00 00 00 
  8004212174:	be 63 00 00 00       	mov    $0x63,%esi
  8004212179:	48 bf bc 96 21 04 80 	movabs $0x80042196bc,%rdi
  8004212180:	00 00 00 
  8004212183:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212188:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800421218f:	00 00 00 
  8004212192:	41 ff d0             	callq  *%r8
        assert(src != NULL);
  8004212195:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800421219a:	75 35                	jne    80042121d1 <_dwarf_frame_regtable_copy+0x91>
  800421219c:	48 b9 d2 96 21 04 80 	movabs $0x80042196d2,%rcx
  80042121a3:	00 00 00 
  80042121a6:	48 ba a7 96 21 04 80 	movabs $0x80042196a7,%rdx
  80042121ad:	00 00 00 
  80042121b0:	be 64 00 00 00       	mov    $0x64,%esi
  80042121b5:	48 bf bc 96 21 04 80 	movabs $0x80042196bc,%rdi
  80042121bc:	00 00 00 
  80042121bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042121c4:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042121cb:	00 00 00 
  80042121ce:	41 ff d0             	callq  *%r8

        if (*dest == NULL) {
  80042121d1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042121d5:	48 8b 00             	mov    (%rax),%rax
  80042121d8:	48 85 c0             	test   %rax,%rax
  80042121db:	75 39                	jne    8004212216 <_dwarf_frame_regtable_copy+0xd6>
		*dest = &global_rt_table_shadow;
  80042121dd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042121e1:	48 bb 60 17 36 04 80 	movabs $0x8004361760,%rbx
  80042121e8:	00 00 00 
  80042121eb:	48 89 18             	mov    %rbx,(%rax)
                /*if ((*dest = malloc(sizeof(Dwarf_Regtable3))) == NULL) {
                        DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
                        return (DW_DLE_MEMORY);
                }*/
                (*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  80042121ee:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042121f2:	48 8b 00             	mov    (%rax),%rax
  80042121f5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042121f9:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  80042121fd:	66 89 50 18          	mov    %dx,0x18(%rax)
		(*dest)->rt3_rules = global_rules_shadow;
  8004212201:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212205:	48 8b 00             	mov    (%rax),%rax
  8004212208:	48 bb 20 18 36 04 80 	movabs $0x8004361820,%rbx
  800421220f:	00 00 00 
  8004212212:	48 89 58 20          	mov    %rbx,0x20(%rax)
                        DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
                        return (DW_DLE_MEMORY);
                }*/
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  8004212216:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800421221a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421221e:	48 8b 00             	mov    (%rax),%rax
  8004212221:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212226:	48 89 ce             	mov    %rcx,%rsi
  8004212229:	48 89 c7             	mov    %rax,%rdi
  800421222c:	48 b8 55 fd 20 04 80 	movabs $0x800420fd55,%rax
  8004212233:	00 00 00 
  8004212236:	ff d0                	callq  *%rax
            sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004212238:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  800421223f:	eb 5a                	jmp    800421229b <_dwarf_frame_regtable_copy+0x15b>
             i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  8004212241:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212245:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212249:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421224c:	48 63 d0             	movslq %eax,%rdx
  800421224f:	48 89 d0             	mov    %rdx,%rax
  8004212252:	48 01 c0             	add    %rax,%rax
  8004212255:	48 01 d0             	add    %rdx,%rax
  8004212258:	48 c1 e0 03          	shl    $0x3,%rax
  800421225c:	48 01 c1             	add    %rax,%rcx
  800421225f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212263:	48 8b 00             	mov    (%rax),%rax
  8004212266:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421226a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421226d:	48 63 d0             	movslq %eax,%rdx
  8004212270:	48 89 d0             	mov    %rdx,%rax
  8004212273:	48 01 c0             	add    %rax,%rax
  8004212276:	48 01 d0             	add    %rdx,%rax
  8004212279:	48 c1 e0 03          	shl    $0x3,%rax
  800421227d:	48 01 f0             	add    %rsi,%rax
  8004212280:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212285:	48 89 ce             	mov    %rcx,%rsi
  8004212288:	48 89 c7             	mov    %rax,%rdi
  800421228b:	48 b8 55 fd 20 04 80 	movabs $0x800420fd55,%rax
  8004212292:	00 00 00 
  8004212295:	ff d0                	callq  *%rax

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
            sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
             i < src->rt3_reg_table_size; i++)
  8004212297:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
            sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  800421229b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421229f:	48 8b 00             	mov    (%rax),%rax
  80042122a2:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042122a6:	0f b7 c0             	movzwl %ax,%eax
  80042122a9:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  80042122ac:	7e 10                	jle    80042122be <_dwarf_frame_regtable_copy+0x17e>
             i < src->rt3_reg_table_size; i++)
  80042122ae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042122b2:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042122b6:	0f b7 c0             	movzwl %ax,%eax
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
            sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  80042122b9:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  80042122bc:	7f 83                	jg     8004212241 <_dwarf_frame_regtable_copy+0x101>
             i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
                    sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
  80042122be:	eb 32                	jmp    80042122f2 <_dwarf_frame_regtable_copy+0x1b2>
                (*dest)->rt3_rules[i].dw_regnum =
  80042122c0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042122c4:	48 8b 00             	mov    (%rax),%rax
  80042122c7:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042122cb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042122ce:	48 63 d0             	movslq %eax,%rdx
  80042122d1:	48 89 d0             	mov    %rdx,%rax
  80042122d4:	48 01 c0             	add    %rax,%rax
  80042122d7:	48 01 d0             	add    %rdx,%rax
  80042122da:	48 c1 e0 03          	shl    $0x3,%rax
  80042122de:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
                    dbg->dbg_frame_undefined_value;
  80042122e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042122e6:	0f b7 40 48          	movzwl 0x48(%rax),%eax
             i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
                    sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
                (*dest)->rt3_rules[i].dw_regnum =
  80042122ea:	66 89 42 02          	mov    %ax,0x2(%rdx)
        for (i = 0; i < (*dest)->rt3_reg_table_size &&
             i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
                    sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
  80042122ee:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042122f2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042122f6:	48 8b 00             	mov    (%rax),%rax
  80042122f9:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042122fd:	0f b7 c0             	movzwl %ax,%eax
  8004212300:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004212303:	7f bb                	jg     80042122c0 <_dwarf_frame_regtable_copy+0x180>
                (*dest)->rt3_rules[i].dw_regnum =
                    dbg->dbg_frame_undefined_value;

        return (DW_DLE_NONE);
  8004212305:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421230a:	48 83 c4 38          	add    $0x38,%rsp
  800421230e:	5b                   	pop    %rbx
  800421230f:	5d                   	pop    %rbp
  8004212310:	c3                   	retq   

0000008004212311 <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
    Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
    Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  8004212311:	55                   	push   %rbp
  8004212312:	48 89 e5             	mov    %rsp,%rbp
  8004212315:	53                   	push   %rbx
  8004212316:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  800421231d:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  8004212321:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  8004212325:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  8004212329:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  800421232d:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  8004212334:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)

#ifdef FRAME_DEBUG
        printf("frame_run_inst: (caf=%ju, daf=%jd)\n", caf, daf);
#endif

        ret = DW_DLE_NONE;
  800421233b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
        init_rt = saved_rt = NULL;
  8004212342:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004212349:	00 
  800421234a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421234e:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        *row_pc = pc;
  8004212352:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212356:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421235a:	48 89 10             	mov    %rdx,(%rax)

        /* Save a copy of the table as initial state. */
        _dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  800421235d:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004212361:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004212365:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  8004212369:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421236d:	48 89 c7             	mov    %rax,%rdi
  8004212370:	48 b8 40 21 21 04 80 	movabs $0x8004212140,%rax
  8004212377:	00 00 00 
  800421237a:	ff d0                	callq  *%rax
        p = insts;
  800421237c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004212380:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        pe = p + len;
  8004212384:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004212388:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421238c:	48 01 d0             	add    %rdx,%rax
  800421238f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

        while (p < pe) {
  8004212393:	e9 79 0d 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>

#ifdef FRAME_DEBUG
                printf("p=%p pe=%p pc=%#jx pc_req=%#jx\n", p, pe, pc, pc_req);
#endif

                if (*p == DW_CFA_nop) {
  8004212398:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421239c:	0f b6 00             	movzbl (%rax),%eax
  800421239f:	84 c0                	test   %al,%al
  80042123a1:	75 11                	jne    80042123b4 <_dwarf_frame_run_inst+0xa3>
#ifdef FRAME_DEBUG
                        printf("DW_CFA_nop\n");
#endif
                        p++;
  80042123a3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042123a7:	48 83 c0 01          	add    $0x1,%rax
  80042123ab:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        continue;
  80042123af:	e9 5d 0d 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                }

                high2 = *p & 0xc0;
  80042123b4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042123b8:	0f b6 00             	movzbl (%rax),%eax
  80042123bb:	83 e0 c0             	and    $0xffffffc0,%eax
  80042123be:	88 45 df             	mov    %al,-0x21(%rbp)
                low6 = *p & 0x3f;
  80042123c1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042123c5:	0f b6 00             	movzbl (%rax),%eax
  80042123c8:	83 e0 3f             	and    $0x3f,%eax
  80042123cb:	88 45 de             	mov    %al,-0x22(%rbp)
                p++;
  80042123ce:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042123d2:	48 83 c0 01          	add    $0x1,%rax
  80042123d6:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

                if (high2 > 0) {
  80042123da:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  80042123de:	0f 84 a1 01 00 00    	je     8004212585 <_dwarf_frame_run_inst+0x274>
                        switch (high2) {
  80042123e4:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80042123e8:	3d 80 00 00 00       	cmp    $0x80,%eax
  80042123ed:	74 38                	je     8004212427 <_dwarf_frame_run_inst+0x116>
  80042123ef:	3d c0 00 00 00       	cmp    $0xc0,%eax
  80042123f4:	0f 84 01 01 00 00    	je     80042124fb <_dwarf_frame_run_inst+0x1ea>
  80042123fa:	83 f8 40             	cmp    $0x40,%eax
  80042123fd:	0f 85 71 01 00 00    	jne    8004212574 <_dwarf_frame_run_inst+0x263>
                        case DW_CFA_advance_loc:
                                pc += low6 * caf;
  8004212403:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004212407:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800421240e:	ff 
  800421240f:	48 01 45 10          	add    %rax,0x10(%rbp)
#ifdef FRAME_DEBUG
                                printf("DW_CFA_advance_loc(%#jx(%u))\n", pc,
                                    low6);
#endif
                                if (pc_req < pc)
  8004212413:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212417:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421241b:	73 05                	jae    8004212422 <_dwarf_frame_run_inst+0x111>
                                        goto program_done;
  800421241d:	e9 fd 0c 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
                                break;
  8004212422:	e9 59 01 00 00       	jmpq   8004212580 <_dwarf_frame_run_inst+0x26f>
                        case DW_CFA_offset:
                                *row_pc = pc;
  8004212427:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421242b:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421242f:	48 89 10             	mov    %rdx,(%rax)
                                CHECK_TABLE_SIZE(low6);
  8004212432:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212436:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421243a:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421243e:	66 39 c2             	cmp    %ax,%dx
  8004212441:	72 0c                	jb     800421244f <_dwarf_frame_run_inst+0x13e>
  8004212443:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421244a:	e9 d0 0c 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
                                RL[low6].dw_offset_relevant = 1;
  800421244f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212453:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212457:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421245b:	48 89 d0             	mov    %rdx,%rax
  800421245e:	48 01 c0             	add    %rax,%rax
  8004212461:	48 01 d0             	add    %rdx,%rax
  8004212464:	48 c1 e0 03          	shl    $0x3,%rax
  8004212468:	48 01 c8             	add    %rcx,%rax
  800421246b:	c6 00 01             	movb   $0x1,(%rax)
                                RL[low6].dw_value_type = DW_EXPR_OFFSET;
  800421246e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212472:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212476:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421247a:	48 89 d0             	mov    %rdx,%rax
  800421247d:	48 01 c0             	add    %rax,%rax
  8004212480:	48 01 d0             	add    %rdx,%rax
  8004212483:	48 c1 e0 03          	shl    $0x3,%rax
  8004212487:	48 01 c8             	add    %rcx,%rax
  800421248a:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                                RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  800421248e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212492:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212496:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421249a:	48 89 d0             	mov    %rdx,%rax
  800421249d:	48 01 c0             	add    %rax,%rax
  80042124a0:	48 01 d0             	add    %rdx,%rax
  80042124a3:	48 c1 e0 03          	shl    $0x3,%rax
  80042124a7:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042124ab:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042124af:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  80042124b3:	66 89 42 02          	mov    %ax,0x2(%rdx)
                                RL[low6].dw_offset_or_block_len =
  80042124b7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042124bb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042124bf:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042124c3:	48 89 d0             	mov    %rdx,%rax
  80042124c6:	48 01 c0             	add    %rax,%rax
  80042124c9:	48 01 d0             	add    %rdx,%rax
  80042124cc:	48 c1 e0 03          	shl    $0x3,%rax
  80042124d0:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
                                    _dwarf_decode_uleb128(&p) * daf;
  80042124d4:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042124d8:	48 89 c7             	mov    %rax,%rdi
  80042124db:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  80042124e2:	00 00 00 
  80042124e5:	ff d0                	callq  *%rax
  80042124e7:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  80042124ee:	48 0f af c2          	imul   %rdx,%rax
                                *row_pc = pc;
                                CHECK_TABLE_SIZE(low6);
                                RL[low6].dw_offset_relevant = 1;
                                RL[low6].dw_value_type = DW_EXPR_OFFSET;
                                RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
                                RL[low6].dw_offset_or_block_len =
  80042124f2:	48 89 43 08          	mov    %rax,0x8(%rbx)
                                    _dwarf_decode_uleb128(&p) * daf;
#ifdef FRAME_DEBUG
                                printf("DW_CFA_offset(%jd)\n",
                                    RL[low6].dw_offset_or_block_len);
#endif
                                break;
  80042124f6:	e9 85 00 00 00       	jmpq   8004212580 <_dwarf_frame_run_inst+0x26f>
                        case DW_CFA_restore:
                                *row_pc = pc;
  80042124fb:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042124ff:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212503:	48 89 10             	mov    %rdx,(%rax)
                                CHECK_TABLE_SIZE(low6);
  8004212506:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421250a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421250e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212512:	66 39 c2             	cmp    %ax,%dx
  8004212515:	72 0c                	jb     8004212523 <_dwarf_frame_run_inst+0x212>
  8004212517:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421251e:	e9 fc 0b 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
                                memcpy(&RL[low6], &INITRL[low6],
  8004212523:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212527:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421252b:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421252f:	48 89 d0             	mov    %rdx,%rax
  8004212532:	48 01 c0             	add    %rax,%rax
  8004212535:	48 01 d0             	add    %rdx,%rax
  8004212538:	48 c1 e0 03          	shl    $0x3,%rax
  800421253c:	48 01 c1             	add    %rax,%rcx
  800421253f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212543:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212547:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421254b:	48 89 d0             	mov    %rdx,%rax
  800421254e:	48 01 c0             	add    %rax,%rax
  8004212551:	48 01 d0             	add    %rdx,%rax
  8004212554:	48 c1 e0 03          	shl    $0x3,%rax
  8004212558:	48 01 f0             	add    %rsi,%rax
  800421255b:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212560:	48 89 ce             	mov    %rcx,%rsi
  8004212563:	48 89 c7             	mov    %rax,%rdi
  8004212566:	48 b8 55 fd 20 04 80 	movabs $0x800420fd55,%rax
  800421256d:	00 00 00 
  8004212570:	ff d0                	callq  *%rax
                                    sizeof(Dwarf_Regtable_Entry3));
#ifdef FRAME_DEBUG
                                printf("DW_CFA_restore(%u)\n", low6);
#endif
                                break;
  8004212572:	eb 0c                	jmp    8004212580 <_dwarf_frame_run_inst+0x26f>
                        default:
                                DWARF_SET_ERROR(dbg, error,
                                    DW_DLE_FRAME_INSTR_EXEC_ERROR);
                                ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  8004212574:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
                                goto program_done;
  800421257b:	e9 9f 0b 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
                        }

                        continue;
  8004212580:	e9 8c 0b 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                }

                switch (low6) {
  8004212585:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004212589:	83 f8 16             	cmp    $0x16,%eax
  800421258c:	0f 87 76 0b 00 00    	ja     8004213108 <_dwarf_frame_run_inst+0xdf7>
  8004212592:	89 c0                	mov    %eax,%eax
  8004212594:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421259b:	00 
  800421259c:	48 b8 08 97 21 04 80 	movabs $0x8004219708,%rax
  80042125a3:	00 00 00 
  80042125a6:	48 01 d0             	add    %rdx,%rax
  80042125a9:	48 8b 00             	mov    (%rax),%rax
  80042125ac:	ff e0                	jmpq   *%rax
                case DW_CFA_set_loc:
			printf("dbg pointersize :%x\n",dbg->dbg_pointer_size);
  80042125ae:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042125b2:	8b 40 28             	mov    0x28(%rax),%eax
  80042125b5:	89 c6                	mov    %eax,%esi
  80042125b7:	48 bf de 96 21 04 80 	movabs $0x80042196de,%rdi
  80042125be:	00 00 00 
  80042125c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042125c6:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  80042125cd:	00 00 00 
  80042125d0:	ff d2                	callq  *%rdx
                        pc = dbg->decode(&p, dbg->dbg_pointer_size);
  80042125d2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042125d6:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042125da:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042125de:	8b 4a 28             	mov    0x28(%rdx),%ecx
  80042125e1:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  80042125e5:	89 ce                	mov    %ecx,%esi
  80042125e7:	48 89 d7             	mov    %rdx,%rdi
  80042125ea:	ff d0                	callq  *%rax
  80042125ec:	48 89 45 10          	mov    %rax,0x10(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
  80042125f0:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042125f4:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042125f8:	73 20                	jae    800421261a <_dwarf_frame_run_inst+0x309>
				printf("Program done\n");
  80042125fa:	48 bf f3 96 21 04 80 	movabs $0x80042196f3,%rdi
  8004212601:	00 00 00 
  8004212604:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212609:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004212610:	00 00 00 
  8004212613:	ff d2                	callq  *%rdx
                                goto program_done;
  8004212615:	e9 05 0b 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
  800421261a:	e9 00 0b 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
                        break;
                case DW_CFA_advance_loc1:
                        pc += dbg->decode(&p, 1) * caf;
  800421261f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212623:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004212627:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800421262b:	be 01 00 00 00       	mov    $0x1,%esi
  8004212630:	48 89 d7             	mov    %rdx,%rdi
  8004212633:	ff d0                	callq  *%rax
  8004212635:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800421263c:	ff 
  800421263d:	48 01 45 10          	add    %rax,0x10(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc1(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
  8004212641:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212645:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004212649:	73 05                	jae    8004212650 <_dwarf_frame_run_inst+0x33f>
                                goto program_done;
  800421264b:	e9 cf 0a 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
                        break;
  8004212650:	e9 bc 0a 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_advance_loc2:
                        pc += dbg->decode(&p, 2) * caf;
  8004212655:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212659:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421265d:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004212661:	be 02 00 00 00       	mov    $0x2,%esi
  8004212666:	48 89 d7             	mov    %rdx,%rdi
  8004212669:	ff d0                	callq  *%rax
  800421266b:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004212672:	ff 
  8004212673:	48 01 45 10          	add    %rax,0x10(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc2(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
  8004212677:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421267b:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421267f:	73 05                	jae    8004212686 <_dwarf_frame_run_inst+0x375>
                                goto program_done;
  8004212681:	e9 99 0a 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
                        break;
  8004212686:	e9 86 0a 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_advance_loc4:
                        pc += dbg->decode(&p, 4) * caf;
  800421268b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421268f:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004212693:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004212697:	be 04 00 00 00       	mov    $0x4,%esi
  800421269c:	48 89 d7             	mov    %rdx,%rdi
  800421269f:	ff d0                	callq  *%rax
  80042126a1:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042126a8:	ff 
  80042126a9:	48 01 45 10          	add    %rax,0x10(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc4(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
  80042126ad:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042126b1:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042126b5:	73 05                	jae    80042126bc <_dwarf_frame_run_inst+0x3ab>
                                goto program_done;
  80042126b7:	e9 63 0a 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
                        break;
  80042126bc:	e9 50 0a 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_offset_extended:
                        *row_pc = pc;
  80042126c1:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042126c5:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042126c9:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042126cc:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042126d0:	48 89 c7             	mov    %rax,%rdi
  80042126d3:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  80042126da:	00 00 00 
  80042126dd:	ff d0                	callq  *%rax
  80042126df:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  80042126e3:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042126e7:	48 89 c7             	mov    %rax,%rdi
  80042126ea:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  80042126f1:	00 00 00 
  80042126f4:	ff d0                	callq  *%rax
  80042126f6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042126fa:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042126fe:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212702:	0f b7 c0             	movzwl %ax,%eax
  8004212705:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212709:	77 0c                	ja     8004212717 <_dwarf_frame_run_inst+0x406>
  800421270b:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212712:	e9 08 0a 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
                        RL[reg].dw_offset_relevant = 1;
  8004212717:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421271b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421271f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212723:	48 89 d0             	mov    %rdx,%rax
  8004212726:	48 01 c0             	add    %rax,%rax
  8004212729:	48 01 d0             	add    %rdx,%rax
  800421272c:	48 c1 e0 03          	shl    $0x3,%rax
  8004212730:	48 01 c8             	add    %rcx,%rax
  8004212733:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004212736:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421273a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421273e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212742:	48 89 d0             	mov    %rdx,%rax
  8004212745:	48 01 c0             	add    %rax,%rax
  8004212748:	48 01 d0             	add    %rdx,%rax
  800421274b:	48 c1 e0 03          	shl    $0x3,%rax
  800421274f:	48 01 c8             	add    %rcx,%rax
  8004212752:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212756:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421275a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421275e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212762:	48 89 d0             	mov    %rdx,%rax
  8004212765:	48 01 c0             	add    %rax,%rax
  8004212768:	48 01 d0             	add    %rdx,%rax
  800421276b:	48 c1 e0 03          	shl    $0x3,%rax
  800421276f:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212773:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212777:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  800421277b:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = uoff * daf;
  800421277f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212783:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212787:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421278b:	48 89 d0             	mov    %rdx,%rax
  800421278e:	48 01 c0             	add    %rax,%rax
  8004212791:	48 01 d0             	add    %rdx,%rax
  8004212794:	48 c1 e0 03          	shl    $0x3,%rax
  8004212798:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421279c:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042127a3:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  80042127a8:	48 89 42 08          	mov    %rax,0x8(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_offset_extended(reg=%ju,uoff=%ju)\n",
                            reg, uoff);
#endif
                        break;
  80042127ac:	e9 60 09 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_restore_extended:
                        *row_pc = pc;
  80042127b1:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042127b5:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042127b9:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042127bc:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042127c0:	48 89 c7             	mov    %rax,%rdi
  80042127c3:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  80042127ca:	00 00 00 
  80042127cd:	ff d0                	callq  *%rax
  80042127cf:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042127d3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042127d7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042127db:	0f b7 c0             	movzwl %ax,%eax
  80042127de:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042127e2:	77 0c                	ja     80042127f0 <_dwarf_frame_run_inst+0x4df>
  80042127e4:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042127eb:	e9 2f 09 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
                        memcpy(&RL[reg], &INITRL[reg],
  80042127f0:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042127f4:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042127f8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042127fc:	48 89 d0             	mov    %rdx,%rax
  80042127ff:	48 01 c0             	add    %rax,%rax
  8004212802:	48 01 d0             	add    %rdx,%rax
  8004212805:	48 c1 e0 03          	shl    $0x3,%rax
  8004212809:	48 01 c1             	add    %rax,%rcx
  800421280c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212810:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212814:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212818:	48 89 d0             	mov    %rdx,%rax
  800421281b:	48 01 c0             	add    %rax,%rax
  800421281e:	48 01 d0             	add    %rdx,%rax
  8004212821:	48 c1 e0 03          	shl    $0x3,%rax
  8004212825:	48 01 f0             	add    %rsi,%rax
  8004212828:	ba 18 00 00 00       	mov    $0x18,%edx
  800421282d:	48 89 ce             	mov    %rcx,%rsi
  8004212830:	48 89 c7             	mov    %rax,%rdi
  8004212833:	48 b8 55 fd 20 04 80 	movabs $0x800420fd55,%rax
  800421283a:	00 00 00 
  800421283d:	ff d0                	callq  *%rax
                            sizeof(Dwarf_Regtable_Entry3));
#ifdef FRAME_DEBUG
                        printf("DW_CFA_restore_extended(%ju)\n", reg);
#endif
                        break;
  800421283f:	e9 cd 08 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_undefined:
                        *row_pc = pc;
  8004212844:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212848:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421284c:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  800421284f:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212853:	48 89 c7             	mov    %rax,%rdi
  8004212856:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  800421285d:	00 00 00 
  8004212860:	ff d0                	callq  *%rax
  8004212862:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212866:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421286a:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421286e:	0f b7 c0             	movzwl %ax,%eax
  8004212871:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212875:	77 0c                	ja     8004212883 <_dwarf_frame_run_inst+0x572>
  8004212877:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421287e:	e9 9c 08 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
                        RL[reg].dw_offset_relevant = 0;
  8004212883:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212887:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421288b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421288f:	48 89 d0             	mov    %rdx,%rax
  8004212892:	48 01 c0             	add    %rax,%rax
  8004212895:	48 01 d0             	add    %rdx,%rax
  8004212898:	48 c1 e0 03          	shl    $0x3,%rax
  800421289c:	48 01 c8             	add    %rcx,%rax
  800421289f:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  80042128a2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042128a6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042128aa:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042128ae:	48 89 d0             	mov    %rdx,%rax
  80042128b1:	48 01 c0             	add    %rax,%rax
  80042128b4:	48 01 d0             	add    %rdx,%rax
  80042128b7:	48 c1 e0 03          	shl    $0x3,%rax
  80042128bb:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042128bf:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042128c3:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  80042128c7:	66 89 42 02          	mov    %ax,0x2(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_undefined(%ju)\n", reg);
#endif
                        break;
  80042128cb:	e9 41 08 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_same_value:
                        reg = _dwarf_decode_uleb128(&p);
  80042128d0:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042128d4:	48 89 c7             	mov    %rax,%rdi
  80042128d7:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  80042128de:	00 00 00 
  80042128e1:	ff d0                	callq  *%rax
  80042128e3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042128e7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042128eb:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042128ef:	0f b7 c0             	movzwl %ax,%eax
  80042128f2:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042128f6:	77 0c                	ja     8004212904 <_dwarf_frame_run_inst+0x5f3>
  80042128f8:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042128ff:	e9 1b 08 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
                        RL[reg].dw_offset_relevant = 0;
  8004212904:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212908:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421290c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212910:	48 89 d0             	mov    %rdx,%rax
  8004212913:	48 01 c0             	add    %rax,%rax
  8004212916:	48 01 d0             	add    %rdx,%rax
  8004212919:	48 c1 e0 03          	shl    $0x3,%rax
  800421291d:	48 01 c8             	add    %rcx,%rax
  8004212920:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  8004212923:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212927:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421292b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421292f:	48 89 d0             	mov    %rdx,%rax
  8004212932:	48 01 c0             	add    %rax,%rax
  8004212935:	48 01 d0             	add    %rdx,%rax
  8004212938:	48 c1 e0 03          	shl    $0x3,%rax
  800421293c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212940:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212944:	0f b7 40 46          	movzwl 0x46(%rax),%eax
  8004212948:	66 89 42 02          	mov    %ax,0x2(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_same_value(%ju)\n", reg);
#endif
                        break;
  800421294c:	e9 c0 07 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_register:
                        *row_pc = pc;
  8004212951:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212955:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212959:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  800421295c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212960:	48 89 c7             	mov    %rax,%rdi
  8004212963:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  800421296a:	00 00 00 
  800421296d:	ff d0                	callq  *%rax
  800421296f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        reg2 = _dwarf_decode_uleb128(&p);
  8004212973:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212977:	48 89 c7             	mov    %rax,%rdi
  800421297a:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004212981:	00 00 00 
  8004212984:	ff d0                	callq  *%rax
  8004212986:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
                        CHECK_TABLE_SIZE(reg);
  800421298a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421298e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212992:	0f b7 c0             	movzwl %ax,%eax
  8004212995:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212999:	77 0c                	ja     80042129a7 <_dwarf_frame_run_inst+0x696>
  800421299b:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042129a2:	e9 78 07 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
                        RL[reg].dw_offset_relevant = 0;
  80042129a7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042129ab:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042129af:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042129b3:	48 89 d0             	mov    %rdx,%rax
  80042129b6:	48 01 c0             	add    %rax,%rax
  80042129b9:	48 01 d0             	add    %rdx,%rax
  80042129bc:	48 c1 e0 03          	shl    $0x3,%rax
  80042129c0:	48 01 c8             	add    %rcx,%rax
  80042129c3:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = reg2;
  80042129c6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042129ca:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042129ce:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042129d2:	48 89 d0             	mov    %rdx,%rax
  80042129d5:	48 01 c0             	add    %rax,%rax
  80042129d8:	48 01 d0             	add    %rdx,%rax
  80042129db:	48 c1 e0 03          	shl    $0x3,%rax
  80042129df:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042129e3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042129e7:	66 89 42 02          	mov    %ax,0x2(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_register(reg=%ju,reg2=%ju)\n", reg,
                            reg2);
#endif
                        break;
  80042129eb:	e9 21 07 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_remember_state:
                        _dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  80042129f0:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042129f4:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  80042129f8:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  80042129fc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212a00:	48 89 c7             	mov    %rax,%rdi
  8004212a03:	48 b8 40 21 21 04 80 	movabs $0x8004212140,%rax
  8004212a0a:	00 00 00 
  8004212a0d:	ff d0                	callq  *%rax
#ifdef FRAME_DEBUG
                        printf("DW_CFA_remember_state\n");
#endif
                        break;
  8004212a0f:	e9 fd 06 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_restore_state:
                        *row_pc = pc;
  8004212a14:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212a18:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212a1c:	48 89 10             	mov    %rdx,(%rax)
                        _dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  8004212a1f:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004212a23:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004212a27:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  8004212a2b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212a2f:	48 89 c7             	mov    %rax,%rdi
  8004212a32:	48 b8 40 21 21 04 80 	movabs $0x8004212140,%rax
  8004212a39:	00 00 00 
  8004212a3c:	ff d0                	callq  *%rax
#ifdef FRAME_DEBUG
                        printf("DW_CFA_restore_state\n");
#endif
                        break;
  8004212a3e:	e9 ce 06 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_def_cfa:
                        *row_pc = pc;
  8004212a43:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212a47:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212a4b:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212a4e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212a52:	48 89 c7             	mov    %rax,%rdi
  8004212a55:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004212a5c:	00 00 00 
  8004212a5f:	ff d0                	callq  *%rax
  8004212a61:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  8004212a65:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212a69:	48 89 c7             	mov    %rax,%rdi
  8004212a6c:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004212a73:	00 00 00 
  8004212a76:	ff d0                	callq  *%rax
  8004212a78:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004212a7c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212a80:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004212a83:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212a87:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_regnum = reg;
  8004212a8b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212a8f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212a93:	66 89 50 02          	mov    %dx,0x2(%rax)
                        CFA.dw_offset_or_block_len = uoff;
  8004212a97:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212a9b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212a9f:	48 89 50 08          	mov    %rdx,0x8(%rax)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_def_cfa(reg=%ju,uoff=%ju)\n", reg, uoff);
#endif
                        break;
  8004212aa3:	e9 69 06 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_def_cfa_register:
                        *row_pc = pc;
  8004212aa8:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212aac:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212ab0:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212ab3:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212ab7:	48 89 c7             	mov    %rax,%rdi
  8004212aba:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004212ac1:	00 00 00 
  8004212ac4:	ff d0                	callq  *%rax
  8004212ac6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CFA.dw_regnum = reg;
  8004212aca:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ace:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212ad2:	66 89 50 02          	mov    %dx,0x2(%rax)
                         * here.
                         */
#ifdef FRAME_DEBUG
                        printf("DW_CFA_def_cfa_register(%ju)\n", reg);
#endif
                        break;
  8004212ad6:	e9 36 06 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_def_cfa_offset:
                        *row_pc = pc;
  8004212adb:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212adf:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212ae3:	48 89 10             	mov    %rdx,(%rax)
                        uoff = _dwarf_decode_uleb128(&p);
  8004212ae6:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212aea:	48 89 c7             	mov    %rax,%rdi
  8004212aed:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004212af4:	00 00 00 
  8004212af7:	ff d0                	callq  *%rax
  8004212af9:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004212afd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b01:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004212b04:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b08:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_offset_or_block_len = uoff;
  8004212b0c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b10:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212b14:	48 89 50 08          	mov    %rdx,0x8(%rax)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_def_cfa_offset(%ju)\n", uoff);
#endif
                        break;
  8004212b18:	e9 f4 05 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_def_cfa_expression:
                        *row_pc = pc;
  8004212b1d:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212b21:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212b25:	48 89 10             	mov    %rdx,(%rax)
                        CFA.dw_offset_relevant = 0;
  8004212b28:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b2c:	c6 00 00             	movb   $0x0,(%rax)
                        CFA.dw_value_type = DW_EXPR_EXPRESSION;
  8004212b2f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b33:	c6 40 01 02          	movb   $0x2,0x1(%rax)
                        CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  8004212b37:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  8004212b3b:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212b3f:	48 89 c7             	mov    %rax,%rdi
  8004212b42:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004212b49:	00 00 00 
  8004212b4c:	ff d0                	callq  *%rax
  8004212b4e:	48 89 43 08          	mov    %rax,0x8(%rbx)
                        CFA.dw_block_ptr = p;
  8004212b52:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b56:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004212b5a:	48 89 50 10          	mov    %rdx,0x10(%rax)
                        p += CFA.dw_offset_or_block_len;
  8004212b5e:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004212b62:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b66:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212b6a:	48 01 d0             	add    %rdx,%rax
  8004212b6d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_def_cfa_expression\n");
#endif
                        break;
  8004212b71:	e9 9b 05 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_expression:
                        *row_pc = pc;
  8004212b76:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212b7a:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212b7e:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212b81:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212b85:	48 89 c7             	mov    %rax,%rdi
  8004212b88:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004212b8f:	00 00 00 
  8004212b92:	ff d0                	callq  *%rax
  8004212b94:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212b98:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b9c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212ba0:	0f b7 c0             	movzwl %ax,%eax
  8004212ba3:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212ba7:	77 0c                	ja     8004212bb5 <_dwarf_frame_run_inst+0x8a4>
  8004212ba9:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212bb0:	e9 6a 05 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
                        RL[reg].dw_offset_relevant = 0;
  8004212bb5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212bb9:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212bbd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212bc1:	48 89 d0             	mov    %rdx,%rax
  8004212bc4:	48 01 c0             	add    %rax,%rax
  8004212bc7:	48 01 d0             	add    %rdx,%rax
  8004212bca:	48 c1 e0 03          	shl    $0x3,%rax
  8004212bce:	48 01 c8             	add    %rcx,%rax
  8004212bd1:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  8004212bd4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212bd8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212bdc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212be0:	48 89 d0             	mov    %rdx,%rax
  8004212be3:	48 01 c0             	add    %rax,%rax
  8004212be6:	48 01 d0             	add    %rdx,%rax
  8004212be9:	48 c1 e0 03          	shl    $0x3,%rax
  8004212bed:	48 01 c8             	add    %rcx,%rax
  8004212bf0:	c6 40 01 02          	movb   $0x2,0x1(%rax)
                        RL[reg].dw_offset_or_block_len =
  8004212bf4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212bf8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212bfc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212c00:	48 89 d0             	mov    %rdx,%rax
  8004212c03:	48 01 c0             	add    %rax,%rax
  8004212c06:	48 01 d0             	add    %rdx,%rax
  8004212c09:	48 c1 e0 03          	shl    $0x3,%rax
  8004212c0d:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
                            _dwarf_decode_uleb128(&p);
  8004212c11:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212c15:	48 89 c7             	mov    %rax,%rdi
  8004212c18:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004212c1f:	00 00 00 
  8004212c22:	ff d0                	callq  *%rax
                        *row_pc = pc;
                        reg = _dwarf_decode_uleb128(&p);
                        CHECK_TABLE_SIZE(reg);
                        RL[reg].dw_offset_relevant = 0;
                        RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
                        RL[reg].dw_offset_or_block_len =
  8004212c24:	48 89 43 08          	mov    %rax,0x8(%rbx)
                            _dwarf_decode_uleb128(&p);
                        RL[reg].dw_block_ptr = p;
  8004212c28:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c2c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212c30:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212c34:	48 89 d0             	mov    %rdx,%rax
  8004212c37:	48 01 c0             	add    %rax,%rax
  8004212c3a:	48 01 d0             	add    %rdx,%rax
  8004212c3d:	48 c1 e0 03          	shl    $0x3,%rax
  8004212c41:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212c45:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212c49:	48 89 42 10          	mov    %rax,0x10(%rdx)
                        p += RL[reg].dw_offset_or_block_len;
  8004212c4d:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004212c51:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c55:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212c59:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212c5d:	48 89 d0             	mov    %rdx,%rax
  8004212c60:	48 01 c0             	add    %rax,%rax
  8004212c63:	48 01 d0             	add    %rdx,%rax
  8004212c66:	48 c1 e0 03          	shl    $0x3,%rax
  8004212c6a:	48 01 f0             	add    %rsi,%rax
  8004212c6d:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212c71:	48 01 c8             	add    %rcx,%rax
  8004212c74:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_expression\n");
#endif
                        break;
  8004212c78:	e9 94 04 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_offset_extended_sf:
                        *row_pc = pc;
  8004212c7d:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212c81:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212c85:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212c88:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212c8c:	48 89 c7             	mov    %rax,%rdi
  8004212c8f:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004212c96:	00 00 00 
  8004212c99:	ff d0                	callq  *%rax
  8004212c9b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004212c9f:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212ca3:	48 89 c7             	mov    %rax,%rdi
  8004212ca6:	48 b8 44 07 21 04 80 	movabs $0x8004210744,%rax
  8004212cad:	00 00 00 
  8004212cb0:	ff d0                	callq  *%rax
  8004212cb2:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212cb6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212cba:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212cbe:	0f b7 c0             	movzwl %ax,%eax
  8004212cc1:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212cc5:	77 0c                	ja     8004212cd3 <_dwarf_frame_run_inst+0x9c2>
  8004212cc7:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212cce:	e9 4c 04 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
                        RL[reg].dw_offset_relevant = 1;
  8004212cd3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212cd7:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212cdb:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212cdf:	48 89 d0             	mov    %rdx,%rax
  8004212ce2:	48 01 c0             	add    %rax,%rax
  8004212ce5:	48 01 d0             	add    %rdx,%rax
  8004212ce8:	48 c1 e0 03          	shl    $0x3,%rax
  8004212cec:	48 01 c8             	add    %rcx,%rax
  8004212cef:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004212cf2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212cf6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212cfa:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212cfe:	48 89 d0             	mov    %rdx,%rax
  8004212d01:	48 01 c0             	add    %rax,%rax
  8004212d04:	48 01 d0             	add    %rdx,%rax
  8004212d07:	48 c1 e0 03          	shl    $0x3,%rax
  8004212d0b:	48 01 c8             	add    %rcx,%rax
  8004212d0e:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212d12:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212d16:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212d1a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212d1e:	48 89 d0             	mov    %rdx,%rax
  8004212d21:	48 01 c0             	add    %rax,%rax
  8004212d24:	48 01 d0             	add    %rdx,%rax
  8004212d27:	48 c1 e0 03          	shl    $0x3,%rax
  8004212d2b:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212d2f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212d33:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  8004212d37:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = soff * daf;
  8004212d3b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212d3f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212d43:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212d47:	48 89 d0             	mov    %rdx,%rax
  8004212d4a:	48 01 c0             	add    %rax,%rax
  8004212d4d:	48 01 d0             	add    %rdx,%rax
  8004212d50:	48 c1 e0 03          	shl    $0x3,%rax
  8004212d54:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212d58:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212d5f:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004212d64:	48 89 42 08          	mov    %rax,0x8(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_offset_extended_sf(reg=%ju,soff=%jd)\n",
                            reg, soff);
#endif
                        break;
  8004212d68:	e9 a4 03 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_def_cfa_sf:
                        *row_pc = pc;
  8004212d6d:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212d71:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212d75:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212d78:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212d7c:	48 89 c7             	mov    %rax,%rdi
  8004212d7f:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004212d86:	00 00 00 
  8004212d89:	ff d0                	callq  *%rax
  8004212d8b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004212d8f:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212d93:	48 89 c7             	mov    %rax,%rdi
  8004212d96:	48 b8 44 07 21 04 80 	movabs $0x8004210744,%rax
  8004212d9d:	00 00 00 
  8004212da0:	ff d0                	callq  *%rax
  8004212da2:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004212da6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212daa:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004212dad:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212db1:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_regnum = reg;
  8004212db5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212db9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212dbd:	66 89 50 02          	mov    %dx,0x2(%rax)
                        CFA.dw_offset_or_block_len = soff * daf;
  8004212dc1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212dc5:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004212dcc:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004212dd1:	48 89 50 08          	mov    %rdx,0x8(%rax)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_def_cfa_sf(reg=%ju,soff=%jd)\n", reg,
                            soff);
#endif
                        break;
  8004212dd5:	e9 37 03 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_def_cfa_offset_sf:
                        *row_pc = pc;
  8004212dda:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212dde:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212de2:	48 89 10             	mov    %rdx,(%rax)
                        soff = _dwarf_decode_sleb128(&p);
  8004212de5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212de9:	48 89 c7             	mov    %rax,%rdi
  8004212dec:	48 b8 44 07 21 04 80 	movabs $0x8004210744,%rax
  8004212df3:	00 00 00 
  8004212df6:	ff d0                	callq  *%rax
  8004212df8:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004212dfc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212e00:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004212e03:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212e07:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_offset_or_block_len = soff * daf;
  8004212e0b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212e0f:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004212e16:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004212e1b:	48 89 50 08          	mov    %rdx,0x8(%rax)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_def_cfa_offset_sf(soff=%jd)\n", soff);
#endif
                        break;
  8004212e1f:	e9 ed 02 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_val_offset:
                        *row_pc = pc;
  8004212e24:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212e28:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212e2c:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212e2f:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212e33:	48 89 c7             	mov    %rax,%rdi
  8004212e36:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004212e3d:	00 00 00 
  8004212e40:	ff d0                	callq  *%rax
  8004212e42:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  8004212e46:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212e4a:	48 89 c7             	mov    %rax,%rdi
  8004212e4d:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004212e54:	00 00 00 
  8004212e57:	ff d0                	callq  *%rax
  8004212e59:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212e5d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212e61:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212e65:	0f b7 c0             	movzwl %ax,%eax
  8004212e68:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212e6c:	77 0c                	ja     8004212e7a <_dwarf_frame_run_inst+0xb69>
  8004212e6e:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212e75:	e9 a5 02 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
                        RL[reg].dw_offset_relevant = 1;
  8004212e7a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212e7e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212e82:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212e86:	48 89 d0             	mov    %rdx,%rax
  8004212e89:	48 01 c0             	add    %rax,%rax
  8004212e8c:	48 01 d0             	add    %rdx,%rax
  8004212e8f:	48 c1 e0 03          	shl    $0x3,%rax
  8004212e93:	48 01 c8             	add    %rcx,%rax
  8004212e96:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004212e99:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212e9d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212ea1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212ea5:	48 89 d0             	mov    %rdx,%rax
  8004212ea8:	48 01 c0             	add    %rax,%rax
  8004212eab:	48 01 d0             	add    %rdx,%rax
  8004212eae:	48 c1 e0 03          	shl    $0x3,%rax
  8004212eb2:	48 01 c8             	add    %rcx,%rax
  8004212eb5:	c6 40 01 01          	movb   $0x1,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212eb9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ebd:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212ec1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212ec5:	48 89 d0             	mov    %rdx,%rax
  8004212ec8:	48 01 c0             	add    %rax,%rax
  8004212ecb:	48 01 d0             	add    %rdx,%rax
  8004212ece:	48 c1 e0 03          	shl    $0x3,%rax
  8004212ed2:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212ed6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212eda:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  8004212ede:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = uoff * daf;
  8004212ee2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ee6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212eea:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212eee:	48 89 d0             	mov    %rdx,%rax
  8004212ef1:	48 01 c0             	add    %rax,%rax
  8004212ef4:	48 01 d0             	add    %rdx,%rax
  8004212ef7:	48 c1 e0 03          	shl    $0x3,%rax
  8004212efb:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212eff:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212f06:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004212f0b:	48 89 42 08          	mov    %rax,0x8(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_val_offset(reg=%ju,uoff=%ju)\n", reg,
                            uoff);
#endif
                        break;
  8004212f0f:	e9 fd 01 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_val_offset_sf:
                        *row_pc = pc;
  8004212f14:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212f18:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212f1c:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212f1f:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212f23:	48 89 c7             	mov    %rax,%rdi
  8004212f26:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004212f2d:	00 00 00 
  8004212f30:	ff d0                	callq  *%rax
  8004212f32:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004212f36:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212f3a:	48 89 c7             	mov    %rax,%rdi
  8004212f3d:	48 b8 44 07 21 04 80 	movabs $0x8004210744,%rax
  8004212f44:	00 00 00 
  8004212f47:	ff d0                	callq  *%rax
  8004212f49:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212f4d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212f51:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212f55:	0f b7 c0             	movzwl %ax,%eax
  8004212f58:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212f5c:	77 0c                	ja     8004212f6a <_dwarf_frame_run_inst+0xc59>
  8004212f5e:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212f65:	e9 b5 01 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
                        RL[reg].dw_offset_relevant = 1;
  8004212f6a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212f6e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212f72:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212f76:	48 89 d0             	mov    %rdx,%rax
  8004212f79:	48 01 c0             	add    %rax,%rax
  8004212f7c:	48 01 d0             	add    %rdx,%rax
  8004212f7f:	48 c1 e0 03          	shl    $0x3,%rax
  8004212f83:	48 01 c8             	add    %rcx,%rax
  8004212f86:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004212f89:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212f8d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212f91:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212f95:	48 89 d0             	mov    %rdx,%rax
  8004212f98:	48 01 c0             	add    %rax,%rax
  8004212f9b:	48 01 d0             	add    %rdx,%rax
  8004212f9e:	48 c1 e0 03          	shl    $0x3,%rax
  8004212fa2:	48 01 c8             	add    %rcx,%rax
  8004212fa5:	c6 40 01 01          	movb   $0x1,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212fa9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212fad:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212fb1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212fb5:	48 89 d0             	mov    %rdx,%rax
  8004212fb8:	48 01 c0             	add    %rax,%rax
  8004212fbb:	48 01 d0             	add    %rdx,%rax
  8004212fbe:	48 c1 e0 03          	shl    $0x3,%rax
  8004212fc2:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212fc6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212fca:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  8004212fce:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = soff * daf;
  8004212fd2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212fd6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212fda:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212fde:	48 89 d0             	mov    %rdx,%rax
  8004212fe1:	48 01 c0             	add    %rax,%rax
  8004212fe4:	48 01 d0             	add    %rdx,%rax
  8004212fe7:	48 c1 e0 03          	shl    $0x3,%rax
  8004212feb:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212fef:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212ff6:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004212ffb:	48 89 42 08          	mov    %rax,0x8(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_val_offset_sf(reg=%ju,soff=%jd)\n", reg,
                            soff);
#endif
                        break;
  8004212fff:	e9 0d 01 00 00       	jmpq   8004213111 <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_val_expression:
                        *row_pc = pc;
  8004213004:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213008:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421300c:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  800421300f:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213013:	48 89 c7             	mov    %rax,%rdi
  8004213016:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  800421301d:	00 00 00 
  8004213020:	ff d0                	callq  *%rax
  8004213022:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004213026:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421302a:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421302e:	0f b7 c0             	movzwl %ax,%eax
  8004213031:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213035:	77 0c                	ja     8004213043 <_dwarf_frame_run_inst+0xd32>
  8004213037:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421303e:	e9 dc 00 00 00       	jmpq   800421311f <_dwarf_frame_run_inst+0xe0e>
                        RL[reg].dw_offset_relevant = 0;
  8004213043:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213047:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421304b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421304f:	48 89 d0             	mov    %rdx,%rax
  8004213052:	48 01 c0             	add    %rax,%rax
  8004213055:	48 01 d0             	add    %rdx,%rax
  8004213058:	48 c1 e0 03          	shl    $0x3,%rax
  800421305c:	48 01 c8             	add    %rcx,%rax
  800421305f:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  8004213062:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213066:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421306a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421306e:	48 89 d0             	mov    %rdx,%rax
  8004213071:	48 01 c0             	add    %rax,%rax
  8004213074:	48 01 d0             	add    %rdx,%rax
  8004213077:	48 c1 e0 03          	shl    $0x3,%rax
  800421307b:	48 01 c8             	add    %rcx,%rax
  800421307e:	c6 40 01 03          	movb   $0x3,0x1(%rax)
                        RL[reg].dw_offset_or_block_len =
  8004213082:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213086:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421308a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421308e:	48 89 d0             	mov    %rdx,%rax
  8004213091:	48 01 c0             	add    %rax,%rax
  8004213094:	48 01 d0             	add    %rdx,%rax
  8004213097:	48 c1 e0 03          	shl    $0x3,%rax
  800421309b:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
                            _dwarf_decode_uleb128(&p);
  800421309f:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042130a3:	48 89 c7             	mov    %rax,%rdi
  80042130a6:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  80042130ad:	00 00 00 
  80042130b0:	ff d0                	callq  *%rax
                        *row_pc = pc;
                        reg = _dwarf_decode_uleb128(&p);
                        CHECK_TABLE_SIZE(reg);
                        RL[reg].dw_offset_relevant = 0;
                        RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
                        RL[reg].dw_offset_or_block_len =
  80042130b2:	48 89 43 08          	mov    %rax,0x8(%rbx)
                            _dwarf_decode_uleb128(&p);
                        RL[reg].dw_block_ptr = p;
  80042130b6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042130ba:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042130be:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042130c2:	48 89 d0             	mov    %rdx,%rax
  80042130c5:	48 01 c0             	add    %rax,%rax
  80042130c8:	48 01 d0             	add    %rdx,%rax
  80042130cb:	48 c1 e0 03          	shl    $0x3,%rax
  80042130cf:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042130d3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042130d7:	48 89 42 10          	mov    %rax,0x10(%rdx)
                        p += RL[reg].dw_offset_or_block_len;
  80042130db:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042130df:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042130e3:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042130e7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042130eb:	48 89 d0             	mov    %rdx,%rax
  80042130ee:	48 01 c0             	add    %rax,%rax
  80042130f1:	48 01 d0             	add    %rdx,%rax
  80042130f4:	48 c1 e0 03          	shl    $0x3,%rax
  80042130f8:	48 01 f0             	add    %rsi,%rax
  80042130fb:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042130ff:	48 01 c8             	add    %rcx,%rax
  8004213102:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_val_expression\n");
#endif
                        break;
  8004213106:	eb 09                	jmp    8004213111 <_dwarf_frame_run_inst+0xe00>
                default:
                        DWARF_SET_ERROR(dbg, error,
                            DW_DLE_FRAME_INSTR_EXEC_ERROR);
                        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  8004213108:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
                        goto program_done;
  800421310f:	eb 0e                	jmp    800421311f <_dwarf_frame_run_inst+0xe0e>
        /* Save a copy of the table as initial state. */
        _dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
        p = insts;
        pe = p + len;

        while (p < pe) {
  8004213111:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213115:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004213119:	0f 82 79 f2 ff ff    	jb     8004212398 <_dwarf_frame_run_inst+0x87>
        free(init_rt);
        if (saved_rt) {
                free(saved_rt->rt3_rules);
                free(saved_rt);
        }*/
        return (ret);
  800421311f:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  8004213122:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  8004213129:	5b                   	pop    %rbx
  800421312a:	5d                   	pop    %rbp
  800421312b:	c3                   	retq   

000000800421312c <_dwarf_frame_get_internal_table>:


int
_dwarf_frame_get_internal_table(Dwarf_Fde fde, Dwarf_Addr pc_req,
    Dwarf_Regtable3 **ret_rt, Dwarf_Addr *ret_row_pc, Dwarf_Error *error)
{
  800421312c:	55                   	push   %rbp
  800421312d:	48 89 e5             	mov    %rsp,%rbp
  8004213130:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004213134:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004213138:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421313c:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004213140:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004213144:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
        Dwarf_Cie cie;
        Dwarf_Regtable3 *rt;
        Dwarf_Addr row_pc;
        int i, ret;

        assert(ret_rt != NULL);
  8004213148:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  800421314d:	75 35                	jne    8004213184 <_dwarf_frame_get_internal_table+0x58>
  800421314f:	48 b9 c0 97 21 04 80 	movabs $0x80042197c0,%rcx
  8004213156:	00 00 00 
  8004213159:	48 ba a7 96 21 04 80 	movabs $0x80042196a7,%rdx
  8004213160:	00 00 00 
  8004213163:	be 01 02 00 00       	mov    $0x201,%esi
  8004213168:	48 bf bc 96 21 04 80 	movabs $0x80042196bc,%rdi
  800421316f:	00 00 00 
  8004213172:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213177:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800421317e:	00 00 00 
  8004213181:	41 ff d0             	callq  *%r8

        //dbg = fde->fde_dbg;
        assert(dbg != NULL);
  8004213184:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  800421318b:	00 00 00 
  800421318e:	48 8b 00             	mov    (%rax),%rax
  8004213191:	48 85 c0             	test   %rax,%rax
  8004213194:	75 35                	jne    80042131cb <_dwarf_frame_get_internal_table+0x9f>
  8004213196:	48 b9 cf 97 21 04 80 	movabs $0x80042197cf,%rcx
  800421319d:	00 00 00 
  80042131a0:	48 ba a7 96 21 04 80 	movabs $0x80042196a7,%rdx
  80042131a7:	00 00 00 
  80042131aa:	be 04 02 00 00       	mov    $0x204,%esi
  80042131af:	48 bf bc 96 21 04 80 	movabs $0x80042196bc,%rdi
  80042131b6:	00 00 00 
  80042131b9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042131be:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042131c5:	00 00 00 
  80042131c8:	41 ff d0             	callq  *%r8

        rt = dbg->dbg_internal_reg_table;
  80042131cb:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  80042131d2:	00 00 00 
  80042131d5:	48 8b 00             	mov    (%rax),%rax
  80042131d8:	48 8b 40 50          	mov    0x50(%rax),%rax
  80042131dc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

        /* Clear the content of regtable from previous run. */
        memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  80042131e0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042131e4:	ba 18 00 00 00       	mov    $0x18,%edx
  80042131e9:	be 00 00 00 00       	mov    $0x0,%esi
  80042131ee:	48 89 c7             	mov    %rax,%rdi
  80042131f1:	48 b8 b3 fb 20 04 80 	movabs $0x800420fbb3,%rax
  80042131f8:	00 00 00 
  80042131fb:	ff d0                	callq  *%rax
        memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  80042131fd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213201:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213205:	0f b7 d0             	movzwl %ax,%edx
  8004213208:	48 89 d0             	mov    %rdx,%rax
  800421320b:	48 01 c0             	add    %rax,%rax
  800421320e:	48 01 d0             	add    %rdx,%rax
  8004213211:	48 c1 e0 03          	shl    $0x3,%rax
  8004213215:	48 89 c2             	mov    %rax,%rdx
  8004213218:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421321c:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213220:	be 00 00 00 00       	mov    $0x0,%esi
  8004213225:	48 89 c7             	mov    %rax,%rdi
  8004213228:	48 b8 b3 fb 20 04 80 	movabs $0x800420fbb3,%rax
  800421322f:	00 00 00 
  8004213232:	ff d0                	callq  *%rax
            sizeof(Dwarf_Regtable_Entry3));

        /* Set rules to initial values. */
        for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004213234:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421323b:	eb 38                	jmp    8004213275 <_dwarf_frame_get_internal_table+0x149>
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  800421323d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213241:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213245:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213248:	48 63 d0             	movslq %eax,%rdx
  800421324b:	48 89 d0             	mov    %rdx,%rax
  800421324e:	48 01 c0             	add    %rax,%rax
  8004213251:	48 01 d0             	add    %rdx,%rax
  8004213254:	48 c1 e0 03          	shl    $0x3,%rax
  8004213258:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421325c:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004213263:	00 00 00 
  8004213266:	48 8b 00             	mov    (%rax),%rax
  8004213269:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  800421326d:	66 89 42 02          	mov    %ax,0x2(%rdx)
        memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
        memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
            sizeof(Dwarf_Regtable_Entry3));

        /* Set rules to initial values. */
        for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004213271:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004213275:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213279:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421327d:	0f b7 c0             	movzwl %ax,%eax
  8004213280:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004213283:	7f b8                	jg     800421323d <_dwarf_frame_get_internal_table+0x111>
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

        /* Run initial instructions in CIE. */
        cie = fde->fde_cie;
  8004213285:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213289:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421328d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        assert(cie != NULL);
  8004213291:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004213296:	75 35                	jne    80042132cd <_dwarf_frame_get_internal_table+0x1a1>
  8004213298:	48 b9 db 97 21 04 80 	movabs $0x80042197db,%rcx
  800421329f:	00 00 00 
  80042132a2:	48 ba a7 96 21 04 80 	movabs $0x80042196a7,%rdx
  80042132a9:	00 00 00 
  80042132ac:	be 13 02 00 00       	mov    $0x213,%esi
  80042132b1:	48 bf bc 96 21 04 80 	movabs $0x80042196bc,%rdi
  80042132b8:	00 00 00 
  80042132bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042132c0:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042132c7:	00 00 00 
  80042132ca:	41 ff d0             	callq  *%r8
        ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  80042132cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042132d1:	4c 8b 48 40          	mov    0x40(%rax),%r9
  80042132d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042132d9:	4c 8b 40 38          	mov    0x38(%rax),%r8
  80042132dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042132e1:	48 8b 48 70          	mov    0x70(%rax),%rcx
  80042132e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042132e9:	48 8b 50 68          	mov    0x68(%rax),%rdx
  80042132ed:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  80042132f4:	00 00 00 
  80042132f7:	48 8b 00             	mov    (%rax),%rax
  80042132fa:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042132fe:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  8004213302:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004213307:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  800421330b:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004213310:	48 c7 44 24 08 ff ff 	movq   $0xffffffffffffffff,0x8(%rsp)
  8004213317:	ff ff 
  8004213319:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8004213320:	00 
  8004213321:	48 89 c7             	mov    %rax,%rdi
  8004213324:	48 b8 11 23 21 04 80 	movabs $0x8004212311,%rax
  800421332b:	00 00 00 
  800421332e:	ff d0                	callq  *%rax
  8004213330:	89 45 e4             	mov    %eax,-0x1c(%rbp)
            cie->cie_instlen, cie->cie_caf, cie->cie_daf, 0, ~0ULL,
            &row_pc, error);
        if (ret != DW_DLE_NONE)
  8004213333:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004213337:	74 08                	je     8004213341 <_dwarf_frame_get_internal_table+0x215>
                return (ret);
  8004213339:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421333c:	e9 a1 00 00 00       	jmpq   80042133e2 <_dwarf_frame_get_internal_table+0x2b6>
        /* Run instructions in FDE. */
        if (pc_req >= fde->fde_initloc) {
  8004213341:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213345:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004213349:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  800421334d:	77 78                	ja     80042133c7 <_dwarf_frame_get_internal_table+0x29b>
                ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  800421334f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213353:	48 8b 78 30          	mov    0x30(%rax),%rdi
  8004213357:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421335b:	4c 8b 48 40          	mov    0x40(%rax),%r9
  800421335f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213363:	4c 8b 50 38          	mov    0x38(%rax),%r10
  8004213367:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421336b:	48 8b 48 58          	mov    0x58(%rax),%rcx
  800421336f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213373:	48 8b 50 50          	mov    0x50(%rax),%rdx
  8004213377:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  800421337e:	00 00 00 
  8004213381:	48 8b 00             	mov    (%rax),%rax
  8004213384:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004213388:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
  800421338c:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004213391:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  8004213395:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  800421339a:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  800421339e:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  80042133a3:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042133a7:	4d 89 d0             	mov    %r10,%r8
  80042133aa:	48 89 c7             	mov    %rax,%rdi
  80042133ad:	48 b8 11 23 21 04 80 	movabs $0x8004212311,%rax
  80042133b4:	00 00 00 
  80042133b7:	ff d0                	callq  *%rax
  80042133b9:	89 45 e4             	mov    %eax,-0x1c(%rbp)
                    fde->fde_instlen, cie->cie_caf, cie->cie_daf,
                    fde->fde_initloc, pc_req, &row_pc, error);
                if (ret != DW_DLE_NONE)
  80042133bc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042133c0:	74 05                	je     80042133c7 <_dwarf_frame_get_internal_table+0x29b>
                        return (ret);
  80042133c2:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042133c5:	eb 1b                	jmp    80042133e2 <_dwarf_frame_get_internal_table+0x2b6>
        }

        *ret_rt = rt;
  80042133c7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042133cb:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042133cf:	48 89 10             	mov    %rdx,(%rax)
        *ret_row_pc = row_pc;
  80042133d2:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042133d6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042133da:	48 89 10             	mov    %rdx,(%rax)

        return (DW_DLE_NONE);
  80042133dd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042133e2:	c9                   	leaveq 
  80042133e3:	c3                   	retq   

00000080042133e4 <dwarf_get_fde_info_for_all_regs>:


int
dwarf_get_fde_info_for_all_regs(Dwarf_Fde fde, Dwarf_Addr pc_requested,
    Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  80042133e4:	55                   	push   %rbp
  80042133e5:	48 89 e5             	mov    %rsp,%rbp
  80042133e8:	48 83 ec 50          	sub    $0x50,%rsp
  80042133ec:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042133f0:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042133f4:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80042133f8:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  80042133fc:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
        Dwarf_Regtable3 *rt;
        Dwarf_Addr pc;
        Dwarf_Half cfa;
        int i, ret;

        if (fde == NULL || reg_table == NULL || row_pc == NULL) {
  8004213400:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004213405:	74 0e                	je     8004213415 <dwarf_get_fde_info_for_all_regs+0x31>
  8004213407:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800421340c:	74 07                	je     8004213415 <dwarf_get_fde_info_for_all_regs+0x31>
  800421340e:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004213413:	75 15                	jne    800421342a <dwarf_get_fde_info_for_all_regs+0x46>
                DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
				*(int*) 0 =0;
  8004213415:	b8 00 00 00 00       	mov    $0x0,%eax
  800421341a:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
                return (DW_DLV_ERROR);
  8004213420:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213425:	e9 33 02 00 00       	jmpq   800421365d <dwarf_get_fde_info_for_all_regs+0x279>
        }

        assert(dbg != NULL);
  800421342a:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004213431:	00 00 00 
  8004213434:	48 8b 00             	mov    (%rax),%rax
  8004213437:	48 85 c0             	test   %rax,%rax
  800421343a:	75 35                	jne    8004213471 <dwarf_get_fde_info_for_all_regs+0x8d>
  800421343c:	48 b9 cf 97 21 04 80 	movabs $0x80042197cf,%rcx
  8004213443:	00 00 00 
  8004213446:	48 ba a7 96 21 04 80 	movabs $0x80042196a7,%rdx
  800421344d:	00 00 00 
  8004213450:	be 39 02 00 00       	mov    $0x239,%esi
  8004213455:	48 bf bc 96 21 04 80 	movabs $0x80042196bc,%rdi
  800421345c:	00 00 00 
  800421345f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213464:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  800421346b:	00 00 00 
  800421346e:	41 ff d0             	callq  *%r8

        if (pc_requested < fde->fde_initloc ||
  8004213471:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213475:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004213479:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421347d:	77 19                	ja     8004213498 <dwarf_get_fde_info_for_all_regs+0xb4>
            pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  800421347f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213483:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004213487:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421348b:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421348f:	48 01 d0             	add    %rdx,%rax
                return (DW_DLV_ERROR);
        }

        assert(dbg != NULL);

        if (pc_requested < fde->fde_initloc ||
  8004213492:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213496:	77 15                	ja     80042134ad <dwarf_get_fde_info_for_all_regs+0xc9>
            pc_requested >= fde->fde_initloc + fde->fde_adrange) {
                DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
				*(int*) 0 =0;
  8004213498:	b8 00 00 00 00       	mov    $0x0,%eax
  800421349d:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
                return (DW_DLV_ERROR);
  80042134a3:	b8 01 00 00 00       	mov    $0x1,%eax
  80042134a8:	e9 b0 01 00 00       	jmpq   800421365d <dwarf_get_fde_info_for_all_regs+0x279>
        }

        ret = _dwarf_frame_get_internal_table(fde, pc_requested, &rt, &pc,
  80042134ad:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042134b1:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  80042134b5:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  80042134b9:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042134bd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042134c1:	49 89 f8             	mov    %rdi,%r8
  80042134c4:	48 89 c7             	mov    %rax,%rdi
  80042134c7:	48 b8 2c 31 21 04 80 	movabs $0x800421312c,%rax
  80042134ce:	00 00 00 
  80042134d1:	ff d0                	callq  *%rax
  80042134d3:	89 45 f8             	mov    %eax,-0x8(%rbp)
            error);
        if (ret != DW_DLE_NONE)
  80042134d6:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042134da:	74 15                	je     80042134f1 <dwarf_get_fde_info_for_all_regs+0x10d>
		{

				*(int*)0 = 0;
  80042134dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042134e1:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
                return (DW_DLV_ERROR);
  80042134e7:	b8 01 00 00 00       	mov    $0x1,%eax
  80042134ec:	e9 6c 01 00 00       	jmpq   800421365d <dwarf_get_fde_info_for_all_regs+0x279>
        /*
         * Copy the CFA rule to the column intended for holding the CFA,
         * if it's within the range of regtable.
         */
#define CFA rt->rt3_cfa_rule
        cfa = dbg->dbg_frame_cfa_value;
  80042134f1:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  80042134f8:	00 00 00 
  80042134fb:	48 8b 00             	mov    (%rax),%rax
  80042134fe:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  8004213502:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
        if (cfa < DW_REG_TABLE_SIZE) {
  8004213506:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  800421350b:	77 5a                	ja     8004213567 <dwarf_get_fde_info_for_all_regs+0x183>
                reg_table->rules[cfa].dw_offset_relevant =
  800421350d:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
                   CFA.dw_offset_relevant;
  8004213511:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213515:	0f b6 00             	movzbl (%rax),%eax
         * if it's within the range of regtable.
         */
#define CFA rt->rt3_cfa_rule
        cfa = dbg->dbg_frame_cfa_value;
        if (cfa < DW_REG_TABLE_SIZE) {
                reg_table->rules[cfa].dw_offset_relevant =
  8004213518:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421351c:	48 63 c9             	movslq %ecx,%rcx
  800421351f:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213523:	48 01 ca             	add    %rcx,%rdx
  8004213526:	88 02                	mov    %al,(%rdx)
                   CFA.dw_offset_relevant;
                reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  8004213528:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800421352c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213530:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004213534:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213538:	48 63 c9             	movslq %ecx,%rcx
  800421353b:	48 c1 e1 04          	shl    $0x4,%rcx
  800421353f:	48 01 ca             	add    %rcx,%rdx
  8004213542:	66 89 42 02          	mov    %ax,0x2(%rdx)
                reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  8004213546:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800421354a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421354e:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213552:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213556:	48 63 c9             	movslq %ecx,%rcx
  8004213559:	48 c1 e1 04          	shl    $0x4,%rcx
  800421355d:	48 01 ca             	add    %rcx,%rdx
  8004213560:	48 83 c2 08          	add    $0x8,%rdx
  8004213564:	48 89 02             	mov    %rax,(%rdx)
        }

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  8004213567:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421356e:	e9 b7 00 00 00       	jmpq   800421362a <dwarf_get_fde_info_for_all_regs+0x246>
             i++) {

                /* Do not overwrite CFA column */
                if (i == cfa)
  8004213573:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8004213577:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800421357a:	75 05                	jne    8004213581 <dwarf_get_fde_info_for_all_regs+0x19d>
                        continue;
  800421357c:	e9 a5 00 00 00       	jmpq   8004213626 <dwarf_get_fde_info_for_all_regs+0x242>

                reg_table->rules[i].dw_offset_relevant =
                    rt->rt3_rules[i].dw_offset_relevant;
  8004213581:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213585:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213589:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421358c:	48 63 d0             	movslq %eax,%rdx
  800421358f:	48 89 d0             	mov    %rdx,%rax
  8004213592:	48 01 c0             	add    %rax,%rax
  8004213595:	48 01 d0             	add    %rdx,%rax
  8004213598:	48 c1 e0 03          	shl    $0x3,%rax
  800421359c:	48 01 c8             	add    %rcx,%rax
  800421359f:	0f b6 00             	movzbl (%rax),%eax

                /* Do not overwrite CFA column */
                if (i == cfa)
                        continue;

                reg_table->rules[i].dw_offset_relevant =
  80042135a2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042135a6:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042135a9:	48 63 c9             	movslq %ecx,%rcx
  80042135ac:	48 c1 e1 04          	shl    $0x4,%rcx
  80042135b0:	48 01 ca             	add    %rcx,%rdx
  80042135b3:	88 02                	mov    %al,(%rdx)
                    rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  80042135b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042135b9:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042135bd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042135c0:	48 63 d0             	movslq %eax,%rdx
  80042135c3:	48 89 d0             	mov    %rdx,%rax
  80042135c6:	48 01 c0             	add    %rax,%rax
  80042135c9:	48 01 d0             	add    %rdx,%rax
  80042135cc:	48 c1 e0 03          	shl    $0x3,%rax
  80042135d0:	48 01 c8             	add    %rcx,%rax
  80042135d3:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80042135d7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042135db:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042135de:	48 63 c9             	movslq %ecx,%rcx
  80042135e1:	48 c1 e1 04          	shl    $0x4,%rcx
  80042135e5:	48 01 ca             	add    %rcx,%rdx
  80042135e8:	66 89 42 02          	mov    %ax,0x2(%rdx)
                reg_table->rules[i].dw_offset =
                    rt->rt3_rules[i].dw_offset_or_block_len;
  80042135ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042135f0:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042135f4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042135f7:	48 63 d0             	movslq %eax,%rdx
  80042135fa:	48 89 d0             	mov    %rdx,%rax
  80042135fd:	48 01 c0             	add    %rax,%rax
  8004213600:	48 01 d0             	add    %rdx,%rax
  8004213603:	48 c1 e0 03          	shl    $0x3,%rax
  8004213607:	48 01 c8             	add    %rcx,%rax
  800421360a:	48 8b 40 08          	mov    0x8(%rax),%rax
                        continue;

                reg_table->rules[i].dw_offset_relevant =
                    rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
                reg_table->rules[i].dw_offset =
  800421360e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213612:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004213615:	48 63 c9             	movslq %ecx,%rcx
  8004213618:	48 c1 e1 04          	shl    $0x4,%rcx
  800421361c:	48 01 ca             	add    %rcx,%rdx
  800421361f:	48 83 c2 08          	add    $0x8,%rdx
  8004213623:	48 89 02             	mov    %rax,(%rdx)

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
             i++) {
  8004213626:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
        }

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  800421362a:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  800421362e:	7f 1d                	jg     800421364d <dwarf_get_fde_info_for_all_regs+0x269>
  8004213630:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004213637:	00 00 00 
  800421363a:	48 8b 00             	mov    (%rax),%rax
  800421363d:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  8004213641:	0f b7 c0             	movzwl %ax,%eax
  8004213644:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004213647:	0f 8f 26 ff ff ff    	jg     8004213573 <dwarf_get_fde_info_for_all_regs+0x18f>
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
                reg_table->rules[i].dw_offset =
                    rt->rt3_rules[i].dw_offset_or_block_len;
        }

        *row_pc = pc;
  800421364d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213651:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213655:	48 89 10             	mov    %rdx,(%rax)

        return (DW_DLV_OK);
  8004213658:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421365d:	c9                   	leaveq 
  800421365e:	c3                   	retq   

000000800421365f <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
    uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  800421365f:	55                   	push   %rbp
  8004213660:	48 89 e5             	mov    %rsp,%rbp
  8004213663:	48 83 ec 40          	sub    $0x40,%rsp
  8004213667:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421366b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421366f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004213673:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004213677:	44 89 c0             	mov    %r8d,%eax
  800421367a:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  800421367e:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  8004213681:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  8004213685:	75 0a                	jne    8004213691 <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  8004213687:	b8 00 00 00 00       	mov    $0x0,%eax
  800421368c:	e9 e6 01 00 00       	jmpq   8004213877 <_dwarf_frame_read_lsb_encoded+0x218>

	application = encode & 0xf0;
  8004213691:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004213695:	83 e0 f0             	and    $0xfffffff0,%eax
  8004213698:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  800421369b:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  800421369f:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  80042136a3:	83 f8 0c             	cmp    $0xc,%eax
  80042136a6:	0f 87 72 01 00 00    	ja     800421381e <_dwarf_frame_read_lsb_encoded+0x1bf>
  80042136ac:	89 c0                	mov    %eax,%eax
  80042136ae:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042136b5:	00 
  80042136b6:	48 b8 e8 97 21 04 80 	movabs $0x80042197e8,%rax
  80042136bd:	00 00 00 
  80042136c0:	48 01 d0             	add    %rdx,%rax
  80042136c3:	48 8b 00             	mov    (%rax),%rax
  80042136c6:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  80042136c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042136cc:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042136d0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042136d4:	8b 52 28             	mov    0x28(%rdx),%edx
  80042136d7:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042136db:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042136df:	48 89 cf             	mov    %rcx,%rdi
  80042136e2:	ff d0                	callq  *%rax
  80042136e4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042136e8:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042136eb:	e9 35 01 00 00       	jmpq   8004213825 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  80042136f0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042136f4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042136f8:	48 89 d6             	mov    %rdx,%rsi
  80042136fb:	48 89 c7             	mov    %rax,%rdi
  80042136fe:	48 b8 c5 06 21 04 80 	movabs $0x80042106c5,%rax
  8004213705:	00 00 00 
  8004213708:	ff d0                	callq  *%rax
  800421370a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421370e:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213711:	e9 0f 01 00 00       	jmpq   8004213825 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  8004213716:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421371a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421371e:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213722:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213726:	ba 02 00 00 00       	mov    $0x2,%edx
  800421372b:	48 89 cf             	mov    %rcx,%rdi
  800421372e:	ff d0                	callq  *%rax
  8004213730:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213734:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213737:	e9 e9 00 00 00       	jmpq   8004213825 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  800421373c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213740:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213744:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213748:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421374c:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213751:	48 89 cf             	mov    %rcx,%rdi
  8004213754:	ff d0                	callq  *%rax
  8004213756:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421375a:	48 89 02             	mov    %rax,(%rdx)
		break;
  800421375d:	e9 c3 00 00 00       	jmpq   8004213825 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  8004213762:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213766:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421376a:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421376e:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213772:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213777:	48 89 cf             	mov    %rcx,%rdi
  800421377a:	ff d0                	callq  *%rax
  800421377c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213780:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213783:	e9 9d 00 00 00       	jmpq   8004213825 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  8004213788:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421378c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213790:	48 89 d6             	mov    %rdx,%rsi
  8004213793:	48 89 c7             	mov    %rax,%rdi
  8004213796:	48 b8 21 06 21 04 80 	movabs $0x8004210621,%rax
  800421379d:	00 00 00 
  80042137a0:	ff d0                	callq  *%rax
  80042137a2:	48 89 c2             	mov    %rax,%rdx
  80042137a5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042137a9:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042137ac:	eb 77                	jmp    8004213825 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  80042137ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042137b2:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042137b6:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042137ba:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042137be:	ba 02 00 00 00       	mov    $0x2,%edx
  80042137c3:	48 89 cf             	mov    %rcx,%rdi
  80042137c6:	ff d0                	callq  *%rax
  80042137c8:	48 0f bf d0          	movswq %ax,%rdx
  80042137cc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042137d0:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042137d3:	eb 50                	jmp    8004213825 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  80042137d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042137d9:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042137dd:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042137e1:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042137e5:	ba 04 00 00 00       	mov    $0x4,%edx
  80042137ea:	48 89 cf             	mov    %rcx,%rdi
  80042137ed:	ff d0                	callq  *%rax
  80042137ef:	48 63 d0             	movslq %eax,%rdx
  80042137f2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042137f6:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042137f9:	eb 2a                	jmp    8004213825 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  80042137fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042137ff:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213803:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213807:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421380b:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213810:	48 89 cf             	mov    %rcx,%rdi
  8004213813:	ff d0                	callq  *%rax
  8004213815:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213819:	48 89 02             	mov    %rax,(%rdx)
		break;
  800421381c:	eb 07                	jmp    8004213825 <_dwarf_frame_read_lsb_encoded+0x1c6>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  800421381e:	b8 14 00 00 00       	mov    $0x14,%eax
  8004213823:	eb 52                	jmp    8004213877 <_dwarf_frame_read_lsb_encoded+0x218>
	}

	if (application == DW_EH_PE_pcrel) {
  8004213825:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  8004213829:	75 47                	jne    8004213872 <_dwarf_frame_read_lsb_encoded+0x213>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  800421382b:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800421382f:	83 f8 01             	cmp    $0x1,%eax
  8004213832:	7c 3d                	jl     8004213871 <_dwarf_frame_read_lsb_encoded+0x212>
  8004213834:	83 f8 04             	cmp    $0x4,%eax
  8004213837:	7e 0a                	jle    8004213843 <_dwarf_frame_read_lsb_encoded+0x1e4>
  8004213839:	83 e8 09             	sub    $0x9,%eax
  800421383c:	83 f8 03             	cmp    $0x3,%eax
  800421383f:	77 30                	ja     8004213871 <_dwarf_frame_read_lsb_encoded+0x212>
  8004213841:	eb 17                	jmp    800421385a <_dwarf_frame_read_lsb_encoded+0x1fb>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  8004213843:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213847:	48 8b 10             	mov    (%rax),%rdx
  800421384a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421384e:	48 01 c2             	add    %rax,%rdx
  8004213851:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213855:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004213858:	eb 18                	jmp    8004213872 <_dwarf_frame_read_lsb_encoded+0x213>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  800421385a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421385e:	48 8b 10             	mov    (%rax),%rdx
  8004213861:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213865:	48 01 c2             	add    %rax,%rdx
  8004213868:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421386c:	48 89 10             	mov    %rdx,(%rax)
			break;
  800421386f:	eb 01                	jmp    8004213872 <_dwarf_frame_read_lsb_encoded+0x213>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  8004213871:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  8004213872:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213877:	c9                   	leaveq 
  8004213878:	c3                   	retq   

0000008004213879 <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
    Dwarf_Error *error)
{
  8004213879:	55                   	push   %rbp
  800421387a:	48 89 e5             	mov    %rsp,%rbp
  800421387d:	48 83 ec 50          	sub    $0x50,%rsp
  8004213881:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004213885:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004213889:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  800421388d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213891:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213895:	48 85 c0             	test   %rax,%rax
  8004213898:	74 0f                	je     80042138a9 <_dwarf_frame_parse_lsb_cie_augment+0x30>
  800421389a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421389e:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042138a2:	0f b6 00             	movzbl (%rax),%eax
  80042138a5:	3c 7a                	cmp    $0x7a,%al
  80042138a7:	74 35                	je     80042138de <_dwarf_frame_parse_lsb_cie_augment+0x65>
  80042138a9:	48 b9 50 98 21 04 80 	movabs $0x8004219850,%rcx
  80042138b0:	00 00 00 
  80042138b3:	48 ba a7 96 21 04 80 	movabs $0x80042196a7,%rdx
  80042138ba:	00 00 00 
  80042138bd:	be c0 02 00 00       	mov    $0x2c0,%esi
  80042138c2:	48 bf bc 96 21 04 80 	movabs $0x80042196bc,%rdi
  80042138c9:	00 00 00 
  80042138cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042138d1:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042138d8:	00 00 00 
  80042138db:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  80042138de:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042138e2:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042138e6:	48 83 c0 01          	add    $0x1,%rax
  80042138ea:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  80042138ee:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042138f2:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042138f6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  80042138fa:	e9 af 00 00 00       	jmpq   80042139ae <_dwarf_frame_parse_lsb_cie_augment+0x135>
		switch (*aug_p) {
  80042138ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213903:	0f b6 00             	movzbl (%rax),%eax
  8004213906:	0f b6 c0             	movzbl %al,%eax
  8004213909:	83 f8 50             	cmp    $0x50,%eax
  800421390c:	74 18                	je     8004213926 <_dwarf_frame_parse_lsb_cie_augment+0xad>
  800421390e:	83 f8 52             	cmp    $0x52,%eax
  8004213911:	74 77                	je     800421398a <_dwarf_frame_parse_lsb_cie_augment+0x111>
  8004213913:	83 f8 4c             	cmp    $0x4c,%eax
  8004213916:	0f 85 86 00 00 00    	jne    80042139a2 <_dwarf_frame_parse_lsb_cie_augment+0x129>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  800421391c:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  8004213921:	e9 83 00 00 00       	jmpq   80042139a9 <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  8004213926:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421392a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421392e:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004213932:	0f b6 00             	movzbl (%rax),%eax
  8004213935:	88 45 ef             	mov    %al,-0x11(%rbp)
			offset = 0;
  8004213938:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  800421393f:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004213940:	44 0f b6 45 ef       	movzbl -0x11(%rbp),%r8d
  8004213945:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004213949:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421394d:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8004213951:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213955:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004213959:	48 89 3c 24          	mov    %rdi,(%rsp)
  800421395d:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004213963:	48 89 c7             	mov    %rax,%rdi
  8004213966:	48 b8 5f 36 21 04 80 	movabs $0x800421365f,%rax
  800421396d:	00 00 00 
  8004213970:	ff d0                	callq  *%rax
  8004213972:	89 45 e8             	mov    %eax,-0x18(%rbp)
			    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  8004213975:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  8004213979:	74 05                	je     8004213980 <_dwarf_frame_parse_lsb_cie_augment+0x107>
				return (ret);
  800421397b:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421397e:	eb 42                	jmp    80042139c2 <_dwarf_frame_parse_lsb_cie_augment+0x149>
			augdata_p += offset;
  8004213980:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213984:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  8004213988:	eb 1f                	jmp    80042139a9 <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  800421398a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421398e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213992:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004213996:	0f b6 10             	movzbl (%rax),%edx
  8004213999:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421399d:	88 50 60             	mov    %dl,0x60(%rax)
			break;
  80042139a0:	eb 07                	jmp    80042139a9 <_dwarf_frame_parse_lsb_cie_augment+0x130>
		default:
			DWARF_SET_ERROR(dbg, error,
			    DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  80042139a2:	b8 14 00 00 00       	mov    $0x14,%eax
  80042139a7:	eb 19                	jmp    80042139c2 <_dwarf_frame_parse_lsb_cie_augment+0x149>
		}
		aug_p++;
  80042139a9:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
	augdata_p = cie->cie_augdata;
	while (*aug_p != '\0') {
  80042139ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042139b2:	0f b6 00             	movzbl (%rax),%eax
  80042139b5:	84 c0                	test   %al,%al
  80042139b7:	0f 85 42 ff ff ff    	jne    80042138ff <_dwarf_frame_parse_lsb_cie_augment+0x86>
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		}
		aug_p++;
	}

	return (DW_DLE_NONE);
  80042139bd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042139c2:	c9                   	leaveq 
  80042139c3:	c3                   	retq   

00000080042139c4 <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Section *ds,
    Dwarf_Unsigned *off, Dwarf_Cie ret_cie, Dwarf_Error *error)
{
  80042139c4:	55                   	push   %rbp
  80042139c5:	48 89 e5             	mov    %rsp,%rbp
  80042139c8:	48 83 ec 60          	sub    $0x60,%rsp
  80042139cc:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042139d0:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042139d4:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042139d8:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80042139dc:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  80042139e0:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  80042139e5:	75 35                	jne    8004213a1c <_dwarf_frame_set_cie+0x58>
  80042139e7:	48 b9 85 98 21 04 80 	movabs $0x8004219885,%rcx
  80042139ee:	00 00 00 
  80042139f1:	48 ba a7 96 21 04 80 	movabs $0x80042196a7,%rdx
  80042139f8:	00 00 00 
  80042139fb:	be f1 02 00 00       	mov    $0x2f1,%esi
  8004213a00:	48 bf bc 96 21 04 80 	movabs $0x80042196bc,%rdi
  8004213a07:	00 00 00 
  8004213a0a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213a0f:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004213a16:	00 00 00 
  8004213a19:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  8004213a1c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213a20:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  8004213a24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a28:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213a2c:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  8004213a2f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213a33:	48 8b 10             	mov    (%rax),%rdx
  8004213a36:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a3a:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read(ds->ds_data, off, 4);
  8004213a3e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a42:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213a46:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213a4a:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213a4e:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213a52:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213a57:	48 89 cf             	mov    %rcx,%rdi
  8004213a5a:	ff d0                	callq  *%rax
  8004213a5c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004213a60:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213a65:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004213a69:	75 2b                	jne    8004213a96 <_dwarf_frame_set_cie+0xd2>
		dwarf_size = 8;
  8004213a6b:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read(ds->ds_data, off, 8);
  8004213a72:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a76:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213a7a:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213a7e:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213a82:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213a86:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213a8b:	48 89 cf             	mov    %rcx,%rdi
  8004213a8e:	ff d0                	callq  *%rax
  8004213a90:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004213a94:	eb 07                	jmp    8004213a9d <_dwarf_frame_set_cie+0xd9>
	} else
		dwarf_size = 4;
  8004213a96:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > ds->ds_size - *off) {
  8004213a9d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213aa1:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213aa5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213aa9:	48 8b 00             	mov    (%rax),%rax
  8004213aac:	48 29 c2             	sub    %rax,%rdx
  8004213aaf:	48 89 d0             	mov    %rdx,%rax
  8004213ab2:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004213ab6:	73 0a                	jae    8004213ac2 <_dwarf_frame_set_cie+0xfe>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004213ab8:	b8 12 00 00 00       	mov    $0x12,%eax
  8004213abd:	e9 4b 03 00 00       	jmpq   8004213e0d <_dwarf_frame_set_cie+0x449>
	}

	(void) dbg->read(ds->ds_data, off, dwarf_size); /* Skip CIE id. */
  8004213ac2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213ac6:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213aca:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213ace:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213ad2:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004213ad5:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213ad9:	48 89 cf             	mov    %rcx,%rdi
  8004213adc:	ff d0                	callq  *%rax
	cie->cie_length = length;
  8004213ade:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ae2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213ae6:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read(ds->ds_data, off, 1);
  8004213aea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213aee:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213af2:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213af6:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213afa:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213afe:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213b03:	48 89 cf             	mov    %rcx,%rdi
  8004213b06:	ff d0                	callq  *%rax
  8004213b08:	89 c2                	mov    %eax,%edx
  8004213b0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213b0e:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004213b12:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213b16:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004213b1a:	66 83 f8 01          	cmp    $0x1,%ax
  8004213b1e:	74 26                	je     8004213b46 <_dwarf_frame_set_cie+0x182>
  8004213b20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213b24:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004213b28:	66 83 f8 03          	cmp    $0x3,%ax
  8004213b2c:	74 18                	je     8004213b46 <_dwarf_frame_set_cie+0x182>
	    cie->cie_version != 4) {
  8004213b2e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213b32:	0f b7 40 20          	movzwl 0x20(%rax),%eax

	(void) dbg->read(ds->ds_data, off, dwarf_size); /* Skip CIE id. */
	cie->cie_length = length;

	cie->cie_version = dbg->read(ds->ds_data, off, 1);
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004213b36:	66 83 f8 04          	cmp    $0x4,%ax
  8004213b3a:	74 0a                	je     8004213b46 <_dwarf_frame_set_cie+0x182>
	    cie->cie_version != 4) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  8004213b3c:	b8 16 00 00 00       	mov    $0x16,%eax
  8004213b41:	e9 c7 02 00 00       	jmpq   8004213e0d <_dwarf_frame_set_cie+0x449>
	}

	cie->cie_augment = ds->ds_data + *off;
  8004213b46:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213b4a:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004213b4e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213b52:	48 8b 00             	mov    (%rax),%rax
  8004213b55:	48 01 c2             	add    %rax,%rdx
  8004213b58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213b5c:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *) ds->ds_data;
  8004213b60:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213b64:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213b68:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  8004213b6c:	90                   	nop
  8004213b6d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213b71:	48 8b 00             	mov    (%rax),%rax
  8004213b74:	48 8d 48 01          	lea    0x1(%rax),%rcx
  8004213b78:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213b7c:	48 89 0a             	mov    %rcx,(%rdx)
  8004213b7f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213b83:	48 01 d0             	add    %rdx,%rax
  8004213b86:	0f b6 00             	movzbl (%rax),%eax
  8004213b89:	84 c0                	test   %al,%al
  8004213b8b:	75 e0                	jne    8004213b6d <_dwarf_frame_set_cie+0x1a9>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  8004213b8d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213b91:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213b95:	0f b6 00             	movzbl (%rax),%eax
  8004213b98:	84 c0                	test   %al,%al
  8004213b9a:	74 48                	je     8004213be4 <_dwarf_frame_set_cie+0x220>
  8004213b9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ba0:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213ba4:	0f b6 00             	movzbl (%rax),%eax
  8004213ba7:	3c 7a                	cmp    $0x7a,%al
  8004213ba9:	74 39                	je     8004213be4 <_dwarf_frame_set_cie+0x220>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004213bab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213baf:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213bb3:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213bb7:	75 07                	jne    8004213bc0 <_dwarf_frame_set_cie+0x1fc>
  8004213bb9:	b8 04 00 00 00       	mov    $0x4,%eax
  8004213bbe:	eb 05                	jmp    8004213bc5 <_dwarf_frame_set_cie+0x201>
  8004213bc0:	b8 0c 00 00 00       	mov    $0xc,%eax
  8004213bc5:	48 01 c2             	add    %rax,%rdx
		    cie->cie_length;
  8004213bc8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213bcc:	48 8b 40 18          	mov    0x18(%rax),%rax
	while (p[(*off)++] != '\0')
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004213bd0:	48 01 c2             	add    %rax,%rdx
  8004213bd3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213bd7:	48 89 10             	mov    %rdx,(%rax)
		    cie->cie_length;
		return (DW_DLE_NONE);
  8004213bda:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213bdf:	e9 29 02 00 00       	jmpq   8004213e0d <_dwarf_frame_set_cie+0x449>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  8004213be4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213be8:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213bec:	48 be 8d 98 21 04 80 	movabs $0x800421988d,%rsi
  8004213bf3:	00 00 00 
  8004213bf6:	48 89 c7             	mov    %rax,%rdi
  8004213bf9:	48 b8 d8 ff 20 04 80 	movabs $0x800420ffd8,%rax
  8004213c00:	00 00 00 
  8004213c03:	ff d0                	callq  *%rax
  8004213c05:	48 85 c0             	test   %rax,%rax
  8004213c08:	74 28                	je     8004213c32 <_dwarf_frame_set_cie+0x26e>
		cie->cie_ehdata = dbg->read(ds->ds_data, off,
  8004213c0a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213c0e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213c12:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213c16:	8b 52 28             	mov    0x28(%rdx),%edx
  8004213c19:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004213c1d:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  8004213c21:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213c25:	48 89 cf             	mov    %rcx,%rdi
  8004213c28:	ff d0                	callq  *%rax
  8004213c2a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213c2e:	48 89 42 30          	mov    %rax,0x30(%rdx)
	    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128(ds->ds_data, off);
  8004213c32:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213c36:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213c3a:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213c3e:	48 89 d6             	mov    %rdx,%rsi
  8004213c41:	48 89 c7             	mov    %rax,%rdi
  8004213c44:	48 b8 c5 06 21 04 80 	movabs $0x80042106c5,%rax
  8004213c4b:	00 00 00 
  8004213c4e:	ff d0                	callq  *%rax
  8004213c50:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213c54:	48 89 42 38          	mov    %rax,0x38(%rdx)
	cie->cie_daf = _dwarf_read_sleb128(ds->ds_data, off);
  8004213c58:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213c5c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213c60:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213c64:	48 89 d6             	mov    %rdx,%rsi
  8004213c67:	48 89 c7             	mov    %rax,%rdi
  8004213c6a:	48 b8 21 06 21 04 80 	movabs $0x8004210621,%rax
  8004213c71:	00 00 00 
  8004213c74:	ff d0                	callq  *%rax
  8004213c76:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213c7a:	48 89 42 40          	mov    %rax,0x40(%rdx)

	/* Return address register. */
	if (cie->cie_version == 1)
  8004213c7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c82:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004213c86:	66 83 f8 01          	cmp    $0x1,%ax
  8004213c8a:	75 28                	jne    8004213cb4 <_dwarf_frame_set_cie+0x2f0>
		cie->cie_ra = dbg->read(ds->ds_data, off, 1);
  8004213c8c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213c90:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213c94:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213c98:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213c9c:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213ca0:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213ca5:	48 89 cf             	mov    %rcx,%rdi
  8004213ca8:	ff d0                	callq  *%rax
  8004213caa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213cae:	48 89 42 48          	mov    %rax,0x48(%rdx)
  8004213cb2:	eb 26                	jmp    8004213cda <_dwarf_frame_set_cie+0x316>
	else
		cie->cie_ra = _dwarf_read_uleb128(ds->ds_data, off);
  8004213cb4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213cb8:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213cbc:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213cc0:	48 89 d6             	mov    %rdx,%rsi
  8004213cc3:	48 89 c7             	mov    %rax,%rdi
  8004213cc6:	48 b8 c5 06 21 04 80 	movabs $0x80042106c5,%rax
  8004213ccd:	00 00 00 
  8004213cd0:	ff d0                	callq  *%rax
  8004213cd2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213cd6:	48 89 42 48          	mov    %rax,0x48(%rdx)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  8004213cda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213cde:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213ce2:	0f b6 00             	movzbl (%rax),%eax
  8004213ce5:	3c 7a                	cmp    $0x7a,%al
  8004213ce7:	0f 85 90 00 00 00    	jne    8004213d7d <_dwarf_frame_set_cie+0x3b9>
		cie->cie_auglen = _dwarf_read_uleb128(ds->ds_data, off);
  8004213ced:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213cf1:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213cf5:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213cf9:	48 89 d6             	mov    %rdx,%rsi
  8004213cfc:	48 89 c7             	mov    %rax,%rdi
  8004213cff:	48 b8 c5 06 21 04 80 	movabs $0x80042106c5,%rax
  8004213d06:	00 00 00 
  8004213d09:	ff d0                	callq  *%rax
  8004213d0b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213d0f:	48 89 42 50          	mov    %rax,0x50(%rdx)
		cie->cie_augdata = ds->ds_data + *off;
  8004213d13:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213d17:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004213d1b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213d1f:	48 8b 00             	mov    (%rax),%rax
  8004213d22:	48 01 c2             	add    %rax,%rdx
  8004213d25:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d29:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  8004213d2d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213d31:	48 8b 10             	mov    (%rax),%rdx
  8004213d34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d38:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004213d3c:	48 01 c2             	add    %rax,%rdx
  8004213d3f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213d43:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  8004213d46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d4a:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  8004213d4e:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004213d52:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004213d56:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213d5a:	48 89 ce             	mov    %rcx,%rsi
  8004213d5d:	48 89 c7             	mov    %rax,%rdi
  8004213d60:	48 b8 79 38 21 04 80 	movabs $0x8004213879,%rax
  8004213d67:	00 00 00 
  8004213d6a:	ff d0                	callq  *%rax
  8004213d6c:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  8004213d6f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213d73:	74 08                	je     8004213d7d <_dwarf_frame_set_cie+0x3b9>
			return (ret);
  8004213d75:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213d78:	e9 90 00 00 00       	jmpq   8004213e0d <_dwarf_frame_set_cie+0x449>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = ds->ds_data + *off;
  8004213d7d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213d81:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004213d85:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213d89:	48 8b 00             	mov    (%rax),%rax
  8004213d8c:	48 01 c2             	add    %rax,%rdx
  8004213d8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d93:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  8004213d97:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213d9b:	75 2a                	jne    8004213dc7 <_dwarf_frame_set_cie+0x403>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  8004213d9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213da1:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213da5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213da9:	48 01 c2             	add    %rax,%rdx
  8004213dac:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213db0:	48 8b 00             	mov    (%rax),%rax
  8004213db3:	48 29 c2             	sub    %rax,%rdx
  8004213db6:	48 89 d0             	mov    %rdx,%rax
  8004213db9:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004213dbd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213dc1:	48 89 50 70          	mov    %rdx,0x70(%rax)
  8004213dc5:	eb 28                	jmp    8004213def <_dwarf_frame_set_cie+0x42b>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  8004213dc7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213dcb:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213dcf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213dd3:	48 01 c2             	add    %rax,%rdx
  8004213dd6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213dda:	48 8b 00             	mov    (%rax),%rax
  8004213ddd:	48 29 c2             	sub    %rax,%rdx
  8004213de0:	48 89 d0             	mov    %rdx,%rax
  8004213de3:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004213de7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213deb:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  8004213def:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213df3:	48 8b 10             	mov    (%rax),%rdx
  8004213df6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213dfa:	48 8b 40 70          	mov    0x70(%rax),%rax
  8004213dfe:	48 01 c2             	add    %rax,%rdx
  8004213e01:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213e05:	48 89 10             	mov    %rdx,(%rax)
	    cie->cie_daf, *off);

	printf("%x %lx\n", (unsigned int)cie->cie_ra, (unsigned long)cie->cie_initinst);
#endif

	return (DW_DLE_NONE);
  8004213e08:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213e0d:	c9                   	leaveq 
  8004213e0e:	c3                   	retq   

0000008004213e0f <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde retfde, Dwarf_Section *ds,
    Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  8004213e0f:	55                   	push   %rbp
  8004213e10:	48 89 e5             	mov    %rsp,%rbp
  8004213e13:	48 83 ec 70          	sub    $0x70,%rsp
  8004213e17:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004213e1b:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004213e1f:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004213e23:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004213e27:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
  8004213e2b:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = retfde;
  8004213e2f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213e33:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	fde->fde_dbg = dbg;
  8004213e37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e3b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213e3f:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = ds->ds_data + *off;
  8004213e42:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213e46:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004213e4a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213e4e:	48 8b 00             	mov    (%rax),%rax
  8004213e51:	48 01 c2             	add    %rax,%rdx
  8004213e54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e58:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  8004213e5c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213e60:	48 8b 10             	mov    (%rax),%rdx
  8004213e63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e67:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read(ds->ds_data, off, 4);
  8004213e6b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213e6f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213e73:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213e77:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213e7b:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213e7f:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213e84:	48 89 cf             	mov    %rcx,%rdi
  8004213e87:	ff d0                	callq  *%rax
  8004213e89:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004213e8d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213e92:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004213e96:	75 2b                	jne    8004213ec3 <_dwarf_frame_set_fde+0xb4>
		dwarf_size = 8;
  8004213e98:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read(ds->ds_data, off, 8);
  8004213e9f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213ea3:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213ea7:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213eab:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213eaf:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213eb3:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213eb8:	48 89 cf             	mov    %rcx,%rdi
  8004213ebb:	ff d0                	callq  *%rax
  8004213ebd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004213ec1:	eb 07                	jmp    8004213eca <_dwarf_frame_set_fde+0xbb>
	} else
		dwarf_size = 4;
  8004213ec3:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > ds->ds_size - *off) {
  8004213eca:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213ece:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213ed2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213ed6:	48 8b 00             	mov    (%rax),%rax
  8004213ed9:	48 29 c2             	sub    %rax,%rdx
  8004213edc:	48 89 d0             	mov    %rdx,%rax
  8004213edf:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004213ee3:	73 0a                	jae    8004213eef <_dwarf_frame_set_fde+0xe0>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004213ee5:	b8 12 00 00 00       	mov    $0x12,%eax
  8004213eea:	e9 b8 02 00 00       	jmpq   80042141a7 <_dwarf_frame_set_fde+0x398>
	}

	fde->fde_length = length;
  8004213eef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ef3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213ef7:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  8004213efb:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004213eff:	74 5b                	je     8004213f5c <_dwarf_frame_set_fde+0x14d>
		fde->fde_cieoff = dbg->read(ds->ds_data, off, 4);
  8004213f01:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213f05:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213f09:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213f0d:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213f11:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213f15:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213f1a:	48 89 cf             	mov    %rcx,%rdi
  8004213f1d:	ff d0                	callq  *%rax
  8004213f1f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213f23:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = *off - (4 + fde->fde_cieoff);
  8004213f27:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213f2b:	48 8b 10             	mov    (%rax),%rdx
  8004213f2e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213f32:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213f36:	48 29 c2             	sub    %rax,%rdx
  8004213f39:	48 89 d0             	mov    %rdx,%rax
  8004213f3c:	48 83 e8 04          	sub    $0x4,%rax
  8004213f40:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  8004213f44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213f48:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213f4c:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004213f50:	75 3a                	jne    8004213f8c <_dwarf_frame_set_fde+0x17d>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  8004213f52:	b8 13 00 00 00       	mov    $0x13,%eax
  8004213f57:	e9 4b 02 00 00       	jmpq   80042141a7 <_dwarf_frame_set_fde+0x398>
		}
	} else {
		fde->fde_cieoff = dbg->read(ds->ds_data, off, dwarf_size);
  8004213f5c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213f60:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213f64:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213f68:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213f6c:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004213f6f:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213f73:	48 89 cf             	mov    %rcx,%rdi
  8004213f76:	ff d0                	callq  *%rax
  8004213f78:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213f7c:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = fde->fde_cieoff;
  8004213f80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213f84:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213f88:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  8004213f8c:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004213f90:	0f 84 c3 00 00 00    	je     8004214059 <_dwarf_frame_set_fde+0x24a>
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
		    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004213f96:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213f9a:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213f9e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213fa2:	48 8b 00             	mov    (%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
  8004213fa5:	4c 8d 0c 02          	lea    (%rdx,%rax,1),%r9
		    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004213fa9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213fad:	0f b6 40 60          	movzbl 0x60(%rax),%eax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
  8004213fb1:	44 0f b6 c0          	movzbl %al,%r8d
  8004213fb5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213fb9:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004213fbd:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004213fc1:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004213fc5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213fc9:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004213fcd:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004213fd1:	48 89 c7             	mov    %rax,%rdi
  8004213fd4:	48 b8 5f 36 21 04 80 	movabs $0x800421365f,%rax
  8004213fdb:	00 00 00 
  8004213fde:	ff d0                	callq  *%rax
  8004213fe0:	89 45 dc             	mov    %eax,-0x24(%rbp)
		    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
		if (ret != DW_DLE_NONE)
  8004213fe3:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213fe7:	74 08                	je     8004213ff1 <_dwarf_frame_set_fde+0x1e2>
			return (ret);
  8004213fe9:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213fec:	e9 b6 01 00 00       	jmpq   80042141a7 <_dwarf_frame_set_fde+0x398>
		fde->fde_initloc = val;
  8004213ff1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213ff5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ff9:	48 89 50 30          	mov    %rdx,0x30(%rax)
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
		    off, cie->cie_fde_encode, 0, error);
  8004213ffd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214001:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
  8004214005:	44 0f b6 c0          	movzbl %al,%r8d
  8004214009:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421400d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214011:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004214015:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004214019:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421401d:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004214021:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004214025:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800421402b:	48 89 c7             	mov    %rax,%rdi
  800421402e:	48 b8 5f 36 21 04 80 	movabs $0x800421365f,%rax
  8004214035:	00 00 00 
  8004214038:	ff d0                	callq  *%rax
  800421403a:	89 45 dc             	mov    %eax,-0x24(%rbp)
		    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
  800421403d:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004214041:	74 08                	je     800421404b <_dwarf_frame_set_fde+0x23c>
			return (ret);
  8004214043:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004214046:	e9 5c 01 00 00       	jmpq   80042141a7 <_dwarf_frame_set_fde+0x398>
		fde->fde_adrange = val;
  800421404b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421404f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214053:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004214057:	eb 50                	jmp    80042140a9 <_dwarf_frame_set_fde+0x29a>
	} else {
		fde->fde_initloc = dbg->read(ds->ds_data, off,
  8004214059:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421405d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214061:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214065:	8b 52 28             	mov    0x28(%rdx),%edx
  8004214068:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  800421406c:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  8004214070:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004214074:	48 89 cf             	mov    %rcx,%rdi
  8004214077:	ff d0                	callq  *%rax
  8004214079:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421407d:	48 89 42 30          	mov    %rax,0x30(%rdx)
		    dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read(ds->ds_data, off,
  8004214081:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214085:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214089:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421408d:	8b 52 28             	mov    0x28(%rdx),%edx
  8004214090:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004214094:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  8004214098:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800421409c:	48 89 cf             	mov    %rcx,%rdi
  800421409f:	ff d0                	callq  *%rax
  80042140a1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042140a5:	48 89 42 38          	mov    %rax,0x38(%rdx)
		    dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  80042140a9:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  80042140ad:	74 68                	je     8004214117 <_dwarf_frame_set_fde+0x308>
  80042140af:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042140b3:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042140b7:	0f b6 00             	movzbl (%rax),%eax
  80042140ba:	3c 7a                	cmp    $0x7a,%al
  80042140bc:	75 59                	jne    8004214117 <_dwarf_frame_set_fde+0x308>
		fde->fde_auglen = _dwarf_read_uleb128(ds->ds_data, off);
  80042140be:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042140c2:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042140c6:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042140ca:	48 89 d6             	mov    %rdx,%rsi
  80042140cd:	48 89 c7             	mov    %rax,%rdi
  80042140d0:	48 b8 c5 06 21 04 80 	movabs $0x80042106c5,%rax
  80042140d7:	00 00 00 
  80042140da:	ff d0                	callq  *%rax
  80042140dc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042140e0:	48 89 42 40          	mov    %rax,0x40(%rdx)
		fde->fde_augdata = ds->ds_data + *off;
  80042140e4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042140e8:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042140ec:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042140f0:	48 8b 00             	mov    (%rax),%rax
  80042140f3:	48 01 c2             	add    %rax,%rdx
  80042140f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042140fa:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  80042140fe:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214102:	48 8b 10             	mov    (%rax),%rdx
  8004214105:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214109:	48 8b 40 40          	mov    0x40(%rax),%rax
  800421410d:	48 01 c2             	add    %rax,%rdx
  8004214110:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214114:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = ds->ds_data + *off;
  8004214117:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421411b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421411f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214123:	48 8b 00             	mov    (%rax),%rax
  8004214126:	48 01 c2             	add    %rax,%rdx
  8004214129:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421412d:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  8004214131:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004214135:	75 2a                	jne    8004214161 <_dwarf_frame_set_fde+0x352>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  8004214137:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421413b:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421413f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214143:	48 01 c2             	add    %rax,%rdx
  8004214146:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421414a:	48 8b 00             	mov    (%rax),%rax
  800421414d:	48 29 c2             	sub    %rax,%rdx
  8004214150:	48 89 d0             	mov    %rdx,%rax
  8004214153:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004214157:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421415b:	48 89 50 58          	mov    %rdx,0x58(%rax)
  800421415f:	eb 28                	jmp    8004214189 <_dwarf_frame_set_fde+0x37a>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  8004214161:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214165:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214169:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421416d:	48 01 c2             	add    %rax,%rdx
  8004214170:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214174:	48 8b 00             	mov    (%rax),%rax
  8004214177:	48 29 c2             	sub    %rax,%rdx
  800421417a:	48 89 d0             	mov    %rdx,%rax
  800421417d:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004214181:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214185:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  8004214189:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421418d:	48 8b 10             	mov    (%rax),%rdx
  8004214190:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214194:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004214198:	48 01 c2             	add    %rax,%rdx
  800421419b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421419f:	48 89 10             	mov    %rdx,(%rax)
	printf("\tfde_offset=%ju fde_length=%ju fde_cieoff=%ju"
	    " fde_instlen=%ju off=%ju\n", fde->fde_offset, fde->fde_length,
	    fde->fde_cieoff, fde->fde_instlen, *off);
#endif

	return (DW_DLE_NONE);
  80042141a2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042141a7:	c9                   	leaveq 
  80042141a8:	c3                   	retq   

00000080042141a9 <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  80042141a9:	55                   	push   %rbp
  80042141aa:	48 89 e5             	mov    %rsp,%rbp
  80042141ad:	48 83 ec 20          	sub    $0x20,%rsp
  80042141b1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042141b5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
        Dwarf_Regtable3 *rt = &global_rt_table;
  80042141b9:	48 b8 20 17 36 04 80 	movabs $0x8004361720,%rax
  80042141c0:	00 00 00 
  80042141c3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

        if (dbg->dbg_internal_reg_table != NULL)
  80042141c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042141cb:	48 8b 40 50          	mov    0x50(%rax),%rax
  80042141cf:	48 85 c0             	test   %rax,%rax
  80042141d2:	74 07                	je     80042141db <_dwarf_frame_interal_table_init+0x32>
                return (DW_DLE_NONE);
  80042141d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042141d9:	eb 33                	jmp    800421420e <_dwarf_frame_interal_table_init+0x65>
        /*if ((rt = calloc(1, sizeof(Dwarf_Regtable3))) == NULL) {
                DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
                return (DW_DLE_MEMORY);
        }*/

        rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  80042141db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042141df:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  80042141e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042141e7:	66 89 50 18          	mov    %dx,0x18(%rax)

	//assert(!strcmp(section_info[0].ds_name,".debug_info"));
	//cprintf("Table size:%x\n", rt->rt3_reg_table_size);

	rt->rt3_rules = global_rules;
  80042141eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042141ef:	48 b9 60 1e 36 04 80 	movabs $0x8004361e60,%rcx
  80042141f6:	00 00 00 
  80042141f9:	48 89 48 20          	mov    %rcx,0x20(%rax)
                free(rt);
                DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
                return (DW_DLE_MEMORY);
        }*/

        dbg->dbg_internal_reg_table = rt;
  80042141fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214201:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214205:	48 89 50 50          	mov    %rdx,0x50(%rax)

        return (DW_DLE_NONE);
  8004214209:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421420e:	c9                   	leaveq 
  800421420f:	c3                   	retq   

0000008004214210 <_dwarf_get_next_fde>:


static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
                    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  8004214210:	55                   	push   %rbp
  8004214211:	48 89 e5             	mov    %rsp,%rbp
  8004214214:	48 83 ec 60          	sub    $0x60,%rsp
  8004214218:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421421c:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800421421f:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004214223:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Section *ds = &debug_frame_sec; 
  8004214227:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  800421422e:	00 00 00 
  8004214231:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  8004214235:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->dbg_eh_offset;
  800421423c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214240:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004214244:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	if (offset < ds->ds_size) {
  8004214248:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421424c:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214250:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214254:	48 39 c2             	cmp    %rax,%rdx
  8004214257:	0f 86 f5 01 00 00    	jbe    8004214452 <_dwarf_get_next_fde+0x242>
		entry_off = offset;
  800421425d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214261:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		length = dbg->read(ds->ds_data, &offset, 4);
  8004214265:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214269:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421426d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214271:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214275:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004214279:	ba 04 00 00 00       	mov    $0x4,%edx
  800421427e:	48 89 cf             	mov    %rcx,%rdi
  8004214281:	ff d0                	callq  *%rax
  8004214283:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  8004214287:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421428c:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004214290:	75 2b                	jne    80042142bd <_dwarf_get_next_fde+0xad>
			dwarf_size = 8;
  8004214292:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read(ds->ds_data, &offset, 8);
  8004214299:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421429d:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042142a1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042142a5:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042142a9:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  80042142ad:	ba 08 00 00 00       	mov    $0x8,%edx
  80042142b2:	48 89 cf             	mov    %rcx,%rdi
  80042142b5:	ff d0                	callq  *%rax
  80042142b7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042142bb:	eb 07                	jmp    80042142c4 <_dwarf_get_next_fde+0xb4>
		} else
			dwarf_size = 4;
  80042142bd:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > ds->ds_size - offset ||
  80042142c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042142c8:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042142cc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042142d0:	48 29 c2             	sub    %rax,%rdx
  80042142d3:	48 89 d0             	mov    %rdx,%rax
  80042142d6:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042142da:	72 0d                	jb     80042142e9 <_dwarf_get_next_fde+0xd9>
  80042142dc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042142e1:	75 10                	jne    80042142f3 <_dwarf_get_next_fde+0xe3>
		    (length == 0 && !eh_frame)) {
  80042142e3:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80042142e7:	75 0a                	jne    80042142f3 <_dwarf_get_next_fde+0xe3>
			DWARF_SET_ERROR(dbg, error,
			    DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  80042142e9:	b8 12 00 00 00       	mov    $0x12,%eax
  80042142ee:	e9 64 01 00 00       	jmpq   8004214457 <_dwarf_get_next_fde+0x247>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  80042142f3:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80042142f7:	74 11                	je     800421430a <_dwarf_get_next_fde+0xfa>
  80042142f9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042142fe:	75 0a                	jne    800421430a <_dwarf_get_next_fde+0xfa>
			return(-1);
  8004214300:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214305:	e9 4d 01 00 00       	jmpq   8004214457 <_dwarf_get_next_fde+0x247>

		cie_id = dbg->read(ds->ds_data, &offset, dwarf_size);
  800421430a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421430e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214312:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214316:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800421431a:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421431d:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004214321:	48 89 cf             	mov    %rcx,%rdi
  8004214324:	ff d0                	callq  *%rax
  8004214326:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		if (eh_frame) {
  800421432a:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800421432e:	74 79                	je     80042143a9 <_dwarf_get_next_fde+0x199>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  8004214330:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004214335:	75 32                	jne    8004214369 <_dwarf_get_next_fde+0x159>
				ret = _dwarf_frame_set_cie(dbg, ds,
  8004214337:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421433b:	48 8b 48 08          	mov    0x8(%rax),%rcx
  800421433f:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004214343:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004214347:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800421434b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421434f:	49 89 f8             	mov    %rdi,%r8
  8004214352:	48 89 c7             	mov    %rax,%rdi
  8004214355:	48 b8 c4 39 21 04 80 	movabs $0x80042139c4,%rax
  800421435c:	00 00 00 
  800421435f:	ff d0                	callq  *%rax
  8004214361:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004214364:	e9 c8 00 00 00       	jmpq   8004214431 <_dwarf_get_next_fde+0x221>
				    &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  8004214369:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421436d:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004214371:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  8004214375:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214379:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800421437d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214381:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004214385:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004214389:	4d 89 c1             	mov    %r8,%r9
  800421438c:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8004214392:	48 89 c7             	mov    %rax,%rdi
  8004214395:	48 b8 0f 3e 21 04 80 	movabs $0x8004213e0f,%rax
  800421439c:	00 00 00 
  800421439f:	ff d0                	callq  *%rax
  80042143a1:	89 45 f0             	mov    %eax,-0x10(%rbp)
  80042143a4:	e9 88 00 00 00       	jmpq   8004214431 <_dwarf_get_next_fde+0x221>
				    &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  80042143a9:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042143ad:	75 0b                	jne    80042143ba <_dwarf_get_next_fde+0x1aa>
  80042143af:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042143b4:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  80042143b8:	74 0d                	je     80042143c7 <_dwarf_get_next_fde+0x1b7>
  80042143ba:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  80042143be:	75 36                	jne    80042143f6 <_dwarf_get_next_fde+0x1e6>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  80042143c0:	48 83 7d e0 ff       	cmpq   $0xffffffffffffffff,-0x20(%rbp)
  80042143c5:	75 2f                	jne    80042143f6 <_dwarf_get_next_fde+0x1e6>
				ret = _dwarf_frame_set_cie(dbg, ds,
  80042143c7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042143cb:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042143cf:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042143d3:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80042143d7:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  80042143db:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042143df:	49 89 f8             	mov    %rdi,%r8
  80042143e2:	48 89 c7             	mov    %rax,%rdi
  80042143e5:	48 b8 c4 39 21 04 80 	movabs $0x80042139c4,%rax
  80042143ec:	00 00 00 
  80042143ef:	ff d0                	callq  *%rax
  80042143f1:	89 45 f0             	mov    %eax,-0x10(%rbp)
  80042143f4:	eb 3b                	jmp    8004214431 <_dwarf_get_next_fde+0x221>
				    &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  80042143f6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042143fa:	4c 8b 40 08          	mov    0x8(%rax),%r8
  80042143fe:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  8004214402:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214406:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800421440a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421440e:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004214412:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004214416:	4d 89 c1             	mov    %r8,%r9
  8004214419:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800421441f:	48 89 c7             	mov    %rax,%rdi
  8004214422:	48 b8 0f 3e 21 04 80 	movabs $0x8004213e0f,%rax
  8004214429:	00 00 00 
  800421442c:	ff d0                	callq  *%rax
  800421442e:	89 45 f0             	mov    %eax,-0x10(%rbp)
				    &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  8004214431:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8004214435:	74 07                	je     800421443e <_dwarf_get_next_fde+0x22e>
			return(-1);
  8004214437:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421443c:	eb 19                	jmp    8004214457 <_dwarf_get_next_fde+0x247>

		offset = entry_off;
  800421443e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214442:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		dbg->dbg_eh_offset = offset;
  8004214446:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421444a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421444e:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  8004214452:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214457:	c9                   	leaveq 
  8004214458:	c3                   	retq   

0000008004214459 <dwarf_set_frame_cfa_value>:


Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  8004214459:	55                   	push   %rbp
  800421445a:	48 89 e5             	mov    %rsp,%rbp
  800421445d:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004214461:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214465:	89 f0                	mov    %esi,%eax
  8004214467:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
        Dwarf_Half old_value;

        old_value = dbg->dbg_frame_cfa_value;
  800421446b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421446f:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  8004214473:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
        dbg->dbg_frame_cfa_value = value;
  8004214477:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421447b:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  800421447f:	66 89 50 44          	mov    %dx,0x44(%rax)

        return (old_value);
  8004214483:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  8004214487:	c9                   	leaveq 
  8004214488:	c3                   	retq   

0000008004214489 <_dwarf_frame_section_load_eh>:

int
_dwarf_frame_section_load_eh(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004214489:	55                   	push   %rbp
  800421448a:	48 89 e5             	mov    %rsp,%rbp
  800421448d:	48 83 ec 20          	sub    $0x20,%rsp
  8004214491:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214495:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int status;
	Dwarf_Section *ds = &debug_frame_sec;
  8004214499:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  80042144a0:	00 00 00 
  80042144a3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        status  = _dwarf_find_section_enhanced(&debug_frame_sec);
  80042144a7:	48 bf e0 a6 22 04 80 	movabs $0x800422a6e0,%rdi
  80042144ae:	00 00 00 
  80042144b1:	48 b8 63 1f 21 04 80 	movabs $0x8004211f63,%rax
  80042144b8:	00 00 00 
  80042144bb:	ff d0                	callq  *%rax
  80042144bd:	89 45 f4             	mov    %eax,-0xc(%rbp)
        return (DW_DLE_NONE);
  80042144c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042144c5:	c9                   	leaveq 
  80042144c6:	c3                   	retq   

00000080042144c7 <dwarf_init_eh_section>:


int
dwarf_init_eh_section(Dwarf_Debug dbg,
                      Dwarf_Error *error)
{
  80042144c7:	55                   	push   %rbp
  80042144c8:	48 89 e5             	mov    %rsp,%rbp
  80042144cb:	48 83 ec 10          	sub    $0x10,%rsp
  80042144cf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80042144d3:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)

        if (dbg == NULL) {
  80042144d7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042144dc:	75 07                	jne    80042144e5 <dwarf_init_eh_section+0x1e>
                DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
                return (DW_DLV_ERROR);
  80042144de:	b8 01 00 00 00       	mov    $0x1,%eax
  80042144e3:	eb 7e                	jmp    8004214563 <dwarf_init_eh_section+0x9c>
        }

        if (dbg->dbg_internal_reg_table == NULL) {
  80042144e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042144e9:	48 8b 40 50          	mov    0x50(%rax),%rax
  80042144ed:	48 85 c0             	test   %rax,%rax
  80042144f0:	75 25                	jne    8004214517 <dwarf_init_eh_section+0x50>
                if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  80042144f2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042144f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042144fa:	48 89 d6             	mov    %rdx,%rsi
  80042144fd:	48 89 c7             	mov    %rax,%rdi
  8004214500:	48 b8 a9 41 21 04 80 	movabs $0x80042141a9,%rax
  8004214507:	00 00 00 
  800421450a:	ff d0                	callq  *%rax
  800421450c:	85 c0                	test   %eax,%eax
  800421450e:	74 07                	je     8004214517 <dwarf_init_eh_section+0x50>
                        return (DW_DLV_ERROR);
  8004214510:	b8 01 00 00 00       	mov    $0x1,%eax
  8004214515:	eb 4c                	jmp    8004214563 <dwarf_init_eh_section+0x9c>
	}

	if (_dwarf_frame_section_load_eh(dbg, error) != DW_DLE_NONE)
  8004214517:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421451b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421451f:	48 89 d6             	mov    %rdx,%rsi
  8004214522:	48 89 c7             	mov    %rax,%rdi
  8004214525:	48 b8 89 44 21 04 80 	movabs $0x8004214489,%rax
  800421452c:	00 00 00 
  800421452f:	ff d0                	callq  *%rax
  8004214531:	85 c0                	test   %eax,%eax
  8004214533:	74 07                	je     800421453c <dwarf_init_eh_section+0x75>
		return (DW_DLV_ERROR);
  8004214535:	b8 01 00 00 00       	mov    $0x1,%eax
  800421453a:	eb 27                	jmp    8004214563 <dwarf_init_eh_section+0x9c>

	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  800421453c:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004214543:	00 00 00 
  8004214546:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421454a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421454e:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_offset = 0;
  8004214552:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214556:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  800421455d:	00 

    return (DW_DLV_OK);
  800421455e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214563:	c9                   	leaveq 
  8004214564:	c3                   	retq   

0000008004214565 <_dwarf_lineno_run_program>:


static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
    uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004214565:	55                   	push   %rbp
  8004214566:	48 89 e5             	mov    %rsp,%rbp
  8004214569:	53                   	push   %rbx
  800421456a:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  8004214571:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  8004214575:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  8004214579:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  8004214580:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  8004214587:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)
  800421458e:	4c 89 8d 60 ff ff ff 	mov    %r9,-0xa0(%rbp)
    uint64_t address, file, line, column, isa, opsize;
    int is_stmt, basic_block, end_sequence;
    int prologue_end, epilogue_begin;
    int ret;

	ln = &li->li_line;
  8004214595:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214599:	48 83 c0 48          	add    $0x48,%rax
  800421459d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

    /*
     *   ln->ln_li     = li;             \
     * Set registers to their default values.
     */
    RESET_REGISTERS;
  80042145a1:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042145a8:	00 
  80042145a9:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  80042145b0:	00 
  80042145b1:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  80042145b8:	00 
  80042145b9:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  80042145c0:	00 
  80042145c1:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042145c5:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  80042145c9:	0f b6 c0             	movzbl %al,%eax
  80042145cc:	89 45 cc             	mov    %eax,-0x34(%rbp)
  80042145cf:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  80042145d6:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  80042145dd:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  80042145e4:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

    /*
     * Start line number program.
     */
    while (p < pe) {
  80042145eb:	e9 0a 05 00 00       	jmpq   8004214afa <_dwarf_lineno_run_program+0x595>
        if (*p == 0) {
  80042145f0:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042145f7:	0f b6 00             	movzbl (%rax),%eax
  80042145fa:	84 c0                	test   %al,%al
  80042145fc:	0f 85 78 01 00 00    	jne    800421477a <_dwarf_lineno_run_program+0x215>

            /*
             * Extended Opcodes.
             */

            p++;
  8004214602:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214609:	48 83 c0 01          	add    $0x1,%rax
  800421460d:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
            opsize = _dwarf_decode_uleb128(&p);
  8004214614:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421461b:	48 89 c7             	mov    %rax,%rdi
  800421461e:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004214625:	00 00 00 
  8004214628:	ff d0                	callq  *%rax
  800421462a:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
            switch (*p) {
  800421462e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214635:	0f b6 00             	movzbl (%rax),%eax
  8004214638:	0f b6 c0             	movzbl %al,%eax
  800421463b:	83 f8 02             	cmp    $0x2,%eax
  800421463e:	74 7a                	je     80042146ba <_dwarf_lineno_run_program+0x155>
  8004214640:	83 f8 03             	cmp    $0x3,%eax
  8004214643:	0f 84 b3 00 00 00    	je     80042146fc <_dwarf_lineno_run_program+0x197>
  8004214649:	83 f8 01             	cmp    $0x1,%eax
  800421464c:	0f 85 09 01 00 00    	jne    800421475b <_dwarf_lineno_run_program+0x1f6>
            case DW_LNE_end_sequence:
                p++;
  8004214652:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214659:	48 83 c0 01          	add    $0x1,%rax
  800421465d:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
                end_sequence = 1;
  8004214664:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
                RESET_REGISTERS;
  800421466b:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004214672:	00 
  8004214673:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  800421467a:	00 
  800421467b:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  8004214682:	00 
  8004214683:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  800421468a:	00 
  800421468b:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421468f:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004214693:	0f b6 c0             	movzbl %al,%eax
  8004214696:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004214699:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  80042146a0:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  80042146a7:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  80042146ae:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
                break;
  80042146b5:	e9 bb 00 00 00       	jmpq   8004214775 <_dwarf_lineno_run_program+0x210>
            case DW_LNE_set_address:
                p++;
  80042146ba:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042146c1:	48 83 c0 01          	add    $0x1,%rax
  80042146c5:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
                address = dbg->decode(&p, cu->addr_size);
  80042146cc:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  80042146d3:	00 00 00 
  80042146d6:	48 8b 00             	mov    (%rax),%rax
  80042146d9:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042146dd:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  80042146e1:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  80042146e5:	0f b6 ca             	movzbl %dl,%ecx
  80042146e8:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  80042146ef:	89 ce                	mov    %ecx,%esi
  80042146f1:	48 89 d7             	mov    %rdx,%rdi
  80042146f4:	ff d0                	callq  *%rax
  80042146f6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                break;
  80042146fa:	eb 79                	jmp    8004214775 <_dwarf_lineno_run_program+0x210>
            case DW_LNE_define_file:
                p++;
  80042146fc:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214703:	48 83 c0 01          	add    $0x1,%rax
  8004214707:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
                ret = _dwarf_lineno_add_file(li, &p, NULL,
  800421470e:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004214715:	00 00 00 
  8004214718:	48 8b 08             	mov    (%rax),%rcx
  800421471b:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004214722:	48 8d b5 78 ff ff ff 	lea    -0x88(%rbp),%rsi
  8004214729:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421472d:	49 89 c8             	mov    %rcx,%r8
  8004214730:	48 89 d1             	mov    %rdx,%rcx
  8004214733:	ba 00 00 00 00       	mov    $0x0,%edx
  8004214738:	48 89 c7             	mov    %rax,%rdi
  800421473b:	48 b8 1d 4b 21 04 80 	movabs $0x8004214b1d,%rax
  8004214742:	00 00 00 
  8004214745:	ff d0                	callq  *%rax
  8004214747:	89 45 a4             	mov    %eax,-0x5c(%rbp)
                    error, dbg);
                if (ret != DW_DLE_NONE)
  800421474a:	83 7d a4 00          	cmpl   $0x0,-0x5c(%rbp)
  800421474e:	74 09                	je     8004214759 <_dwarf_lineno_run_program+0x1f4>
                    goto prog_fail;
  8004214750:	90                   	nop

    return (DW_DLE_NONE);

prog_fail:

    return (ret);
  8004214751:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004214754:	e9 ba 03 00 00       	jmpq   8004214b13 <_dwarf_lineno_run_program+0x5ae>
                p++;
                ret = _dwarf_lineno_add_file(li, &p, NULL,
                    error, dbg);
                if (ret != DW_DLE_NONE)
                    goto prog_fail;
                break;
  8004214759:	eb 1a                	jmp    8004214775 <_dwarf_lineno_run_program+0x210>
            default:
                /* Unrecognized extened opcodes. */
                p += opsize;
  800421475b:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004214762:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004214766:	48 01 d0             	add    %rdx,%rax
  8004214769:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004214770:	e9 85 03 00 00       	jmpq   8004214afa <_dwarf_lineno_run_program+0x595>
  8004214775:	e9 80 03 00 00       	jmpq   8004214afa <_dwarf_lineno_run_program+0x595>
            }

        } else if (*p > 0 && *p < li->li_opbase) {
  800421477a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214781:	0f b6 00             	movzbl (%rax),%eax
  8004214784:	84 c0                	test   %al,%al
  8004214786:	0f 84 3c 02 00 00    	je     80042149c8 <_dwarf_lineno_run_program+0x463>
  800421478c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214793:	0f b6 10             	movzbl (%rax),%edx
  8004214796:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421479a:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  800421479e:	38 c2                	cmp    %al,%dl
  80042147a0:	0f 83 22 02 00 00    	jae    80042149c8 <_dwarf_lineno_run_program+0x463>

            /*
             * Standard Opcodes.
             */

            switch (*p++) {
  80042147a6:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042147ad:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042147b1:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  80042147b8:	0f b6 00             	movzbl (%rax),%eax
  80042147bb:	0f b6 c0             	movzbl %al,%eax
  80042147be:	83 f8 0c             	cmp    $0xc,%eax
  80042147c1:	0f 87 fb 01 00 00    	ja     80042149c2 <_dwarf_lineno_run_program+0x45d>
  80042147c7:	89 c0                	mov    %eax,%eax
  80042147c9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042147d0:	00 
  80042147d1:	48 b8 90 98 21 04 80 	movabs $0x8004219890,%rax
  80042147d8:	00 00 00 
  80042147db:	48 01 d0             	add    %rdx,%rax
  80042147de:	48 8b 00             	mov    (%rax),%rax
  80042147e1:	ff e0                	jmpq   *%rax
            case DW_LNS_copy:
                APPEND_ROW;
  80042147e3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042147ea:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042147ee:	73 0a                	jae    80042147fa <_dwarf_lineno_run_program+0x295>
  80042147f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042147f5:	e9 19 03 00 00       	jmpq   8004214b13 <_dwarf_lineno_run_program+0x5ae>
  80042147fa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042147fe:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214802:	48 89 10             	mov    %rdx,(%rax)
  8004214805:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214809:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004214810:	00 
  8004214811:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214815:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214819:	48 89 50 10          	mov    %rdx,0x10(%rax)
  800421481d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214821:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214825:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004214829:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421482d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214831:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004214835:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214839:	8b 55 c8             	mov    -0x38(%rbp),%edx
  800421483c:	89 50 28             	mov    %edx,0x28(%rax)
  800421483f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214843:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004214846:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004214849:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421484d:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004214850:	89 50 30             	mov    %edx,0x30(%rax)
  8004214853:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214857:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  800421485e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214862:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214866:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
                basic_block = 0;
  800421486d:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
                prologue_end = 0;
  8004214874:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
                epilogue_begin = 0;
  800421487b:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
                break;
  8004214882:	e9 3c 01 00 00       	jmpq   80042149c3 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_advance_pc:
                address += _dwarf_decode_uleb128(&p) *
  8004214887:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421488e:	48 89 c7             	mov    %rax,%rdi
  8004214891:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004214898:	00 00 00 
  800421489b:	ff d0                	callq  *%rax
                    li->li_minlen;
  800421489d:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  80042148a1:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
                basic_block = 0;
                prologue_end = 0;
                epilogue_begin = 0;
                break;
            case DW_LNS_advance_pc:
                address += _dwarf_decode_uleb128(&p) *
  80042148a5:	0f b6 d2             	movzbl %dl,%edx
  80042148a8:	48 0f af c2          	imul   %rdx,%rax
  80042148ac:	48 01 45 e8          	add    %rax,-0x18(%rbp)
                    li->li_minlen;
                break;
  80042148b0:	e9 0e 01 00 00       	jmpq   80042149c3 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_advance_line:
                line += _dwarf_decode_sleb128(&p);
  80042148b5:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042148bc:	48 89 c7             	mov    %rax,%rdi
  80042148bf:	48 b8 44 07 21 04 80 	movabs $0x8004210744,%rax
  80042148c6:	00 00 00 
  80042148c9:	ff d0                	callq  *%rax
  80042148cb:	48 01 45 d8          	add    %rax,-0x28(%rbp)
                break;
  80042148cf:	e9 ef 00 00 00       	jmpq   80042149c3 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_set_file:
                file = _dwarf_decode_uleb128(&p);
  80042148d4:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042148db:	48 89 c7             	mov    %rax,%rdi
  80042148de:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  80042148e5:	00 00 00 
  80042148e8:	ff d0                	callq  *%rax
  80042148ea:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
                break;
  80042148ee:	e9 d0 00 00 00       	jmpq   80042149c3 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_set_column:
                column = _dwarf_decode_uleb128(&p);
  80042148f3:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042148fa:	48 89 c7             	mov    %rax,%rdi
  80042148fd:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004214904:	00 00 00 
  8004214907:	ff d0                	callq  *%rax
  8004214909:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                break;
  800421490d:	e9 b1 00 00 00       	jmpq   80042149c3 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_negate_stmt:
                is_stmt = !is_stmt;
  8004214912:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004214916:	0f 94 c0             	sete   %al
  8004214919:	0f b6 c0             	movzbl %al,%eax
  800421491c:	89 45 cc             	mov    %eax,-0x34(%rbp)
                break;
  800421491f:	e9 9f 00 00 00       	jmpq   80042149c3 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_set_basic_block:
                basic_block = 1;
  8004214924:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%rbp)
                break;
  800421492b:	e9 93 00 00 00       	jmpq   80042149c3 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_const_add_pc:
                address += ADDRESS(255);
  8004214930:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214934:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214938:	0f b6 c0             	movzbl %al,%eax
  800421493b:	ba ff 00 00 00       	mov    $0xff,%edx
  8004214940:	89 d1                	mov    %edx,%ecx
  8004214942:	29 c1                	sub    %eax,%ecx
  8004214944:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214948:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  800421494c:	0f b6 d8             	movzbl %al,%ebx
  800421494f:	89 c8                	mov    %ecx,%eax
  8004214951:	99                   	cltd   
  8004214952:	f7 fb                	idiv   %ebx
  8004214954:	89 c2                	mov    %eax,%edx
  8004214956:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421495a:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  800421495e:	0f b6 c0             	movzbl %al,%eax
  8004214961:	0f af c2             	imul   %edx,%eax
  8004214964:	48 98                	cltq   
  8004214966:	48 01 45 e8          	add    %rax,-0x18(%rbp)
                break;
  800421496a:	eb 57                	jmp    80042149c3 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_fixed_advance_pc:
                address += dbg->decode(&p, 2);
  800421496c:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004214973:	00 00 00 
  8004214976:	48 8b 00             	mov    (%rax),%rax
  8004214979:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421497d:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  8004214984:	be 02 00 00 00       	mov    $0x2,%esi
  8004214989:	48 89 d7             	mov    %rdx,%rdi
  800421498c:	ff d0                	callq  *%rax
  800421498e:	48 01 45 e8          	add    %rax,-0x18(%rbp)
                break;
  8004214992:	eb 2f                	jmp    80042149c3 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_set_prologue_end:
                prologue_end = 1;
  8004214994:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%rbp)
                break;
  800421499b:	eb 26                	jmp    80042149c3 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_set_epilogue_begin:
                epilogue_begin = 1;
  800421499d:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
                break;
  80042149a4:	eb 1d                	jmp    80042149c3 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_set_isa:
                isa = _dwarf_decode_uleb128(&p);
  80042149a6:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042149ad:	48 89 c7             	mov    %rax,%rdi
  80042149b0:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  80042149b7:	00 00 00 
  80042149ba:	ff d0                	callq  *%rax
  80042149bc:	48 89 45 98          	mov    %rax,-0x68(%rbp)
                break;
  80042149c0:	eb 01                	jmp    80042149c3 <_dwarf_lineno_run_program+0x45e>
            default:
                /* Unrecognized extened opcodes. What to do? */
                break;
  80042149c2:	90                   	nop
            }

        } else {
  80042149c3:	e9 32 01 00 00       	jmpq   8004214afa <_dwarf_lineno_run_program+0x595>

            /*
             * Special Opcodes.
             */

            line += LINE(*p);
  80042149c8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042149cc:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  80042149d0:	0f be c8             	movsbl %al,%ecx
  80042149d3:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042149da:	0f b6 00             	movzbl (%rax),%eax
  80042149dd:	0f b6 d0             	movzbl %al,%edx
  80042149e0:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042149e4:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042149e8:	0f b6 c0             	movzbl %al,%eax
  80042149eb:	29 c2                	sub    %eax,%edx
  80042149ed:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042149f1:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042149f5:	0f b6 f0             	movzbl %al,%esi
  80042149f8:	89 d0                	mov    %edx,%eax
  80042149fa:	99                   	cltd   
  80042149fb:	f7 fe                	idiv   %esi
  80042149fd:	89 d0                	mov    %edx,%eax
  80042149ff:	01 c8                	add    %ecx,%eax
  8004214a01:	48 98                	cltq   
  8004214a03:	48 01 45 d8          	add    %rax,-0x28(%rbp)
            address += ADDRESS(*p);
  8004214a07:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214a0e:	0f b6 00             	movzbl (%rax),%eax
  8004214a11:	0f b6 d0             	movzbl %al,%edx
  8004214a14:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214a18:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214a1c:	0f b6 c0             	movzbl %al,%eax
  8004214a1f:	89 d1                	mov    %edx,%ecx
  8004214a21:	29 c1                	sub    %eax,%ecx
  8004214a23:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214a27:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004214a2b:	0f b6 d8             	movzbl %al,%ebx
  8004214a2e:	89 c8                	mov    %ecx,%eax
  8004214a30:	99                   	cltd   
  8004214a31:	f7 fb                	idiv   %ebx
  8004214a33:	89 c2                	mov    %eax,%edx
  8004214a35:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214a39:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004214a3d:	0f b6 c0             	movzbl %al,%eax
  8004214a40:	0f af c2             	imul   %edx,%eax
  8004214a43:	48 98                	cltq   
  8004214a45:	48 01 45 e8          	add    %rax,-0x18(%rbp)
            APPEND_ROW;
  8004214a49:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214a50:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004214a54:	73 0a                	jae    8004214a60 <_dwarf_lineno_run_program+0x4fb>
  8004214a56:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214a5b:	e9 b3 00 00 00       	jmpq   8004214b13 <_dwarf_lineno_run_program+0x5ae>
  8004214a60:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214a64:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214a68:	48 89 10             	mov    %rdx,(%rax)
  8004214a6b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214a6f:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004214a76:	00 
  8004214a77:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214a7b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214a7f:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004214a83:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214a87:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214a8b:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004214a8f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214a93:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214a97:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004214a9b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214a9f:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004214aa2:	89 50 28             	mov    %edx,0x28(%rax)
  8004214aa5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214aa9:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004214aac:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004214aaf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214ab3:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004214ab6:	89 50 30             	mov    %edx,0x30(%rax)
  8004214ab9:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214abd:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004214ac4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214ac8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214acc:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
            basic_block = 0;
  8004214ad3:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
            prologue_end = 0;
  8004214ada:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
            epilogue_begin = 0;
  8004214ae1:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
            p++;
  8004214ae8:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214aef:	48 83 c0 01          	add    $0x1,%rax
  8004214af3:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    RESET_REGISTERS;

    /*
     * Start line number program.
     */
    while (p < pe) {
  8004214afa:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214b01:	48 3b 85 70 ff ff ff 	cmp    -0x90(%rbp),%rax
  8004214b08:	0f 82 e2 fa ff ff    	jb     80042145f0 <_dwarf_lineno_run_program+0x8b>
            epilogue_begin = 0;
            p++;
        }
    }

    return (DW_DLE_NONE);
  8004214b0e:	b8 00 00 00 00       	mov    $0x0,%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  8004214b13:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  8004214b1a:	5b                   	pop    %rbx
  8004214b1b:	5d                   	pop    %rbp
  8004214b1c:	c3                   	retq   

0000008004214b1d <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
    Dwarf_Error *error, Dwarf_Debug dbg)
{
  8004214b1d:	55                   	push   %rbp
  8004214b1e:	48 89 e5             	mov    %rsp,%rbp
  8004214b21:	53                   	push   %rbx
  8004214b22:	48 83 ec 48          	sub    $0x48,%rsp
  8004214b26:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004214b2a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004214b2e:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004214b32:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004214b36:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
    char *fname;
    //const char *dirname;
    uint8_t *src;
    int slen;

    src = *p;
  8004214b3a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214b3e:	48 8b 00             	mov    (%rax),%rax
  8004214b41:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
        return (DW_DLE_MEMORY);
    }
*/  
    //lf->lf_fullpath = NULL;
    fname = (char *) src;
  8004214b45:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214b49:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    src += strlen(fname) + 1;
  8004214b4d:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  8004214b51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214b55:	48 89 c7             	mov    %rax,%rdi
  8004214b58:	48 b8 ae f8 20 04 80 	movabs $0x800420f8ae,%rax
  8004214b5f:	00 00 00 
  8004214b62:	ff d0                	callq  *%rax
  8004214b64:	48 98                	cltq   
  8004214b66:	48 83 c0 01          	add    $0x1,%rax
  8004214b6a:	48 01 d8             	add    %rbx,%rax
  8004214b6d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    _dwarf_decode_uleb128(&src);
  8004214b71:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004214b75:	48 89 c7             	mov    %rax,%rdi
  8004214b78:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004214b7f:	00 00 00 
  8004214b82:	ff d0                	callq  *%rax
            snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
                lf->lf_fname);
        }
    }
*/
    _dwarf_decode_uleb128(&src);
  8004214b84:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004214b88:	48 89 c7             	mov    %rax,%rdi
  8004214b8b:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004214b92:	00 00 00 
  8004214b95:	ff d0                	callq  *%rax
    _dwarf_decode_uleb128(&src);
  8004214b97:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004214b9b:	48 89 c7             	mov    %rax,%rdi
  8004214b9e:	48 b8 d6 07 21 04 80 	movabs $0x80042107d6,%rax
  8004214ba5:	00 00 00 
  8004214ba8:	ff d0                	callq  *%rax
    //STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
    //li->li_lflen++;

    *p = src;
  8004214baa:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214bae:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214bb2:	48 89 10             	mov    %rdx,(%rax)

    return (DW_DLE_NONE);
  8004214bb5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214bba:	48 83 c4 48          	add    $0x48,%rsp
  8004214bbe:	5b                   	pop    %rbx
  8004214bbf:	5d                   	pop    %rbp
  8004214bc0:	c3                   	retq   

0000008004214bc1 <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  8004214bc1:	55                   	push   %rbp
  8004214bc2:	48 89 e5             	mov    %rsp,%rbp
  8004214bc5:	53                   	push   %rbx
  8004214bc6:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  8004214bcd:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  8004214bd4:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  8004214bdb:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  8004214be2:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  8004214be9:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
    Dwarf_Section myds = {.ds_name = ".debug_line"};
  8004214bf0:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8004214bf7:	00 
  8004214bf8:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  8004214bff:	00 
  8004214c00:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  8004214c07:	00 
  8004214c08:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004214c0f:	00 
  8004214c10:	48 b8 f8 98 21 04 80 	movabs $0x80042198f8,%rax
  8004214c17:	00 00 00 
  8004214c1a:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  8004214c1e:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8004214c22:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    //Dwarf_LineFile lf, tlf;
    uint64_t length, hdroff, endoff;
    uint8_t *p;
    int dwarf_size, i, ret;
            
    cu = die->cu_header;
  8004214c26:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004214c2d:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  8004214c34:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    assert(cu != NULL); 
  8004214c38:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004214c3d:	75 35                	jne    8004214c74 <_dwarf_lineno_init+0xb3>
  8004214c3f:	48 b9 04 99 21 04 80 	movabs $0x8004219904,%rcx
  8004214c46:	00 00 00 
  8004214c49:	48 ba 0f 99 21 04 80 	movabs $0x800421990f,%rdx
  8004214c50:	00 00 00 
  8004214c53:	be 17 01 00 00       	mov    $0x117,%esi
  8004214c58:	48 bf 24 99 21 04 80 	movabs $0x8004219924,%rdi
  8004214c5f:	00 00 00 
  8004214c62:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214c67:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004214c6e:	00 00 00 
  8004214c71:	41 ff d0             	callq  *%r8
    assert(dbg != NULL);
  8004214c74:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004214c7b:	00 00 00 
  8004214c7e:	48 8b 00             	mov    (%rax),%rax
  8004214c81:	48 85 c0             	test   %rax,%rax
  8004214c84:	75 35                	jne    8004214cbb <_dwarf_lineno_init+0xfa>
  8004214c86:	48 b9 3b 99 21 04 80 	movabs $0x800421993b,%rcx
  8004214c8d:	00 00 00 
  8004214c90:	48 ba 0f 99 21 04 80 	movabs $0x800421990f,%rdx
  8004214c97:	00 00 00 
  8004214c9a:	be 18 01 00 00       	mov    $0x118,%esi
  8004214c9f:	48 bf 24 99 21 04 80 	movabs $0x8004219924,%rdi
  8004214ca6:	00 00 00 
  8004214ca9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214cae:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004214cb5:	00 00 00 
  8004214cb8:	41 ff d0             	callq  *%r8

    if ((_dwarf_find_section_enhanced(ds)) != 0)
  8004214cbb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214cbf:	48 89 c7             	mov    %rax,%rdi
  8004214cc2:	48 b8 63 1f 21 04 80 	movabs $0x8004211f63,%rax
  8004214cc9:	00 00 00 
  8004214ccc:	ff d0                	callq  *%rax
  8004214cce:	85 c0                	test   %eax,%eax
  8004214cd0:	74 0a                	je     8004214cdc <_dwarf_lineno_init+0x11b>
        return (DW_DLE_NONE);
  8004214cd2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214cd7:	e9 4f 04 00 00       	jmpq   800421512b <_dwarf_lineno_init+0x56a>

	li = linfo;
  8004214cdc:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004214ce3:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
            break;
        }
    }
     */

    length = dbg->read(ds->ds_data, &offset, 4);
  8004214ce7:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004214cee:	00 00 00 
  8004214cf1:	48 8b 00             	mov    (%rax),%rax
  8004214cf4:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214cf8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214cfc:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214d00:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214d07:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214d0c:	48 89 cf             	mov    %rcx,%rdi
  8004214d0f:	ff d0                	callq  *%rax
  8004214d11:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (length == 0xffffffff) {
  8004214d15:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214d1a:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004214d1e:	75 37                	jne    8004214d57 <_dwarf_lineno_init+0x196>
        dwarf_size = 8;
  8004214d20:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
        length = dbg->read(ds->ds_data, &offset, 8);
  8004214d27:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004214d2e:	00 00 00 
  8004214d31:	48 8b 00             	mov    (%rax),%rax
  8004214d34:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214d38:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214d3c:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214d40:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214d47:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214d4c:	48 89 cf             	mov    %rcx,%rdi
  8004214d4f:	ff d0                	callq  *%rax
  8004214d51:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004214d55:	eb 07                	jmp    8004214d5e <_dwarf_lineno_init+0x19d>
    } else
        dwarf_size = 4;
  8004214d57:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

    if (length > ds->ds_size - offset) {
  8004214d5e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214d62:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214d66:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004214d6d:	48 29 c2             	sub    %rax,%rdx
  8004214d70:	48 89 d0             	mov    %rdx,%rax
  8004214d73:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004214d77:	73 0a                	jae    8004214d83 <_dwarf_lineno_init+0x1c2>
        DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
        return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004214d79:	b8 0f 00 00 00       	mov    $0xf,%eax
  8004214d7e:	e9 a8 03 00 00       	jmpq   800421512b <_dwarf_lineno_init+0x56a>
    }
    /*
     * Read in line number program header.
     */
    li->li_length = length;
  8004214d83:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214d87:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214d8b:	48 89 10             	mov    %rdx,(%rax)
    endoff = offset + length;
  8004214d8e:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  8004214d95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214d99:	48 01 d0             	add    %rdx,%rax
  8004214d9c:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  8004214da0:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004214da7:	00 00 00 
  8004214daa:	48 8b 00             	mov    (%rax),%rax
  8004214dad:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214db1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214db5:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214db9:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214dc0:	ba 02 00 00 00       	mov    $0x2,%edx
  8004214dc5:	48 89 cf             	mov    %rcx,%rdi
  8004214dc8:	ff d0                	callq  *%rax
  8004214dca:	89 c2                	mov    %eax,%edx
  8004214dcc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214dd0:	66 89 50 08          	mov    %dx,0x8(%rax)
    li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  8004214dd4:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004214ddb:	00 00 00 
  8004214dde:	48 8b 00             	mov    (%rax),%rax
  8004214de1:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214de5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214de9:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214ded:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004214df0:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214df7:	48 89 cf             	mov    %rcx,%rdi
  8004214dfa:	ff d0                	callq  *%rax
  8004214dfc:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214e00:	48 89 42 10          	mov    %rax,0x10(%rdx)
    hdroff = offset;
  8004214e04:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004214e0b:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  8004214e0f:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004214e16:	00 00 00 
  8004214e19:	48 8b 00             	mov    (%rax),%rax
  8004214e1c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214e20:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214e24:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214e28:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214e2f:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214e34:	48 89 cf             	mov    %rcx,%rdi
  8004214e37:	ff d0                	callq  *%rax
  8004214e39:	89 c2                	mov    %eax,%edx
  8004214e3b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214e3f:	88 50 18             	mov    %dl,0x18(%rax)
    li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  8004214e42:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004214e49:	00 00 00 
  8004214e4c:	48 8b 00             	mov    (%rax),%rax
  8004214e4f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214e53:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214e57:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214e5b:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214e62:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214e67:	48 89 cf             	mov    %rcx,%rdi
  8004214e6a:	ff d0                	callq  *%rax
  8004214e6c:	89 c2                	mov    %eax,%edx
  8004214e6e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214e72:	88 50 19             	mov    %dl,0x19(%rax)
    li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  8004214e75:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004214e7c:	00 00 00 
  8004214e7f:	48 8b 00             	mov    (%rax),%rax
  8004214e82:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214e86:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214e8a:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214e8e:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214e95:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214e9a:	48 89 cf             	mov    %rcx,%rdi
  8004214e9d:	ff d0                	callq  *%rax
  8004214e9f:	89 c2                	mov    %eax,%edx
  8004214ea1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214ea5:	88 50 1a             	mov    %dl,0x1a(%rax)
    li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  8004214ea8:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004214eaf:	00 00 00 
  8004214eb2:	48 8b 00             	mov    (%rax),%rax
  8004214eb5:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214eb9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214ebd:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214ec1:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214ec8:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214ecd:	48 89 cf             	mov    %rcx,%rdi
  8004214ed0:	ff d0                	callq  *%rax
  8004214ed2:	89 c2                	mov    %eax,%edx
  8004214ed4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214ed8:	88 50 1b             	mov    %dl,0x1b(%rax)
    li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  8004214edb:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004214ee2:	00 00 00 
  8004214ee5:	48 8b 00             	mov    (%rax),%rax
  8004214ee8:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214eec:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214ef0:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214ef4:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214efb:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214f00:	48 89 cf             	mov    %rcx,%rdi
  8004214f03:	ff d0                	callq  *%rax
  8004214f05:	89 c2                	mov    %eax,%edx
  8004214f07:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214f0b:	88 50 1c             	mov    %dl,0x1c(%rax)
    //STAILQ_INIT(&li->li_lflist);
    //STAILQ_INIT(&li->li_lnlist);

    if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  8004214f0e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214f12:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214f16:	8d 50 fb             	lea    -0x5(%rax),%edx
  8004214f19:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214f1d:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214f21:	0f b6 c0             	movzbl %al,%eax
  8004214f24:	83 e8 01             	sub    $0x1,%eax
  8004214f27:	39 c2                	cmp    %eax,%edx
  8004214f29:	7d 0c                	jge    8004214f37 <_dwarf_lineno_init+0x376>
        ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004214f2b:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
        DWARF_SET_ERROR(dbg, error, ret);
        goto fail_cleanup;
  8004214f32:	e9 f1 01 00 00       	jmpq   8004215128 <_dwarf_lineno_init+0x567>
    }

    li->li_oplen = global_std_op;
  8004214f37:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214f3b:	48 bb a0 24 36 04 80 	movabs $0x80043624a0,%rbx
  8004214f42:	00 00 00 
  8004214f45:	48 89 58 20          	mov    %rbx,0x20(%rax)

    /*
     * Read in std opcode arg length list. Note that the first
     * element is not used.
     */
    for (i = 1; i < li->li_opbase; i++)
  8004214f49:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  8004214f50:	eb 41                	jmp    8004214f93 <_dwarf_lineno_init+0x3d2>
        li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  8004214f52:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214f56:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214f5a:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004214f5d:	48 98                	cltq   
  8004214f5f:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004214f63:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  8004214f6a:	00 00 00 
  8004214f6d:	48 8b 00             	mov    (%rax),%rax
  8004214f70:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214f74:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214f78:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214f7c:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214f83:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214f88:	48 89 cf             	mov    %rcx,%rdi
  8004214f8b:	ff d0                	callq  *%rax
  8004214f8d:	88 03                	mov    %al,(%rbx)

    /*
     * Read in std opcode arg length list. Note that the first
     * element is not used.
     */
    for (i = 1; i < li->li_opbase; i++)
  8004214f8f:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  8004214f93:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214f97:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214f9b:	0f b6 c0             	movzbl %al,%eax
  8004214f9e:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  8004214fa1:	7f af                	jg     8004214f52 <_dwarf_lineno_init+0x391>
        li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);

    /*
     * Check how many strings in the include dir string array.
     */
    length = 0;
  8004214fa3:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004214faa:	00 
    p = ds->ds_data + offset;
  8004214fab:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214faf:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214fb3:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004214fba:	48 01 d0             	add    %rdx,%rax
  8004214fbd:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
    while (*p != '\0') {
  8004214fc4:	eb 1f                	jmp    8004214fe5 <_dwarf_lineno_init+0x424>
        while (*p++ != '\0')
  8004214fc6:	90                   	nop
  8004214fc7:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214fce:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214fd2:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
  8004214fd9:	0f b6 00             	movzbl (%rax),%eax
  8004214fdc:	84 c0                	test   %al,%al
  8004214fde:	75 e7                	jne    8004214fc7 <_dwarf_lineno_init+0x406>
            ;
        length++;
  8004214fe0:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
    /*
     * Check how many strings in the include dir string array.
     */
    length = 0;
    p = ds->ds_data + offset;
    while (*p != '\0') {
  8004214fe5:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214fec:	0f b6 00             	movzbl (%rax),%eax
  8004214fef:	84 c0                	test   %al,%al
  8004214ff1:	75 d3                	jne    8004214fc6 <_dwarf_lineno_init+0x405>
        while (*p++ != '\0')
            ;
        length++;
    }
    li->li_inclen = length;
  8004214ff3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214ff7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214ffb:	48 89 50 30          	mov    %rdx,0x30(%rax)

    /* Sanity check. */
    if (p - ds->ds_data > (int) ds->ds_size) {
  8004214fff:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004215006:	48 89 c2             	mov    %rax,%rdx
  8004215009:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421500d:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004215011:	48 29 c2             	sub    %rax,%rdx
  8004215014:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215018:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421501c:	48 98                	cltq   
  800421501e:	48 39 c2             	cmp    %rax,%rdx
  8004215021:	7e 0c                	jle    800421502f <_dwarf_lineno_init+0x46e>
        ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004215023:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
        DWARF_SET_ERROR(dbg, error, ret);
        goto fail_cleanup;
  800421502a:	e9 f9 00 00 00       	jmpq   8004215128 <_dwarf_lineno_init+0x567>
        li->li_incdirs[i++] = (char *) p;
        while (*p++ != '\0')
            ;
    }
*/
    p++;
  800421502f:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004215036:	48 83 c0 01          	add    $0x1,%rax
  800421503a:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

    /*
     * Process file list.
     */
    while (*p != '\0') {
  8004215041:	eb 3c                	jmp    800421507f <_dwarf_lineno_init+0x4be>
        ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  8004215043:	48 b8 d8 a6 22 04 80 	movabs $0x800422a6d8,%rax
  800421504a:	00 00 00 
  800421504d:	48 8b 08             	mov    (%rax),%rcx
  8004215050:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004215057:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  800421505e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215062:	49 89 c8             	mov    %rcx,%r8
  8004215065:	48 89 d1             	mov    %rdx,%rcx
  8004215068:	ba 00 00 00 00       	mov    $0x0,%edx
  800421506d:	48 89 c7             	mov    %rax,%rdi
  8004215070:	48 b8 1d 4b 21 04 80 	movabs $0x8004214b1d,%rax
  8004215077:	00 00 00 
  800421507a:	ff d0                	callq  *%rax
  800421507c:	89 45 dc             	mov    %eax,-0x24(%rbp)
    p++;

    /*
     * Process file list.
     */
    while (*p != '\0') {
  800421507f:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004215086:	0f b6 00             	movzbl (%rax),%eax
  8004215089:	84 c0                	test   %al,%al
  800421508b:	75 b6                	jne    8004215043 <_dwarf_lineno_init+0x482>
        ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
		//p++;
    }

    p++;
  800421508d:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004215094:	48 83 c0 01          	add    $0x1,%rax
  8004215098:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
    /* Sanity check. */
    if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  800421509f:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042150a6:	48 89 c2             	mov    %rax,%rdx
  80042150a9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042150ad:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042150b1:	48 29 c2             	sub    %rax,%rdx
  80042150b4:	48 89 d0             	mov    %rdx,%rax
  80042150b7:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
  80042150bb:	48 89 c2             	mov    %rax,%rdx
  80042150be:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042150c2:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042150c6:	48 39 c2             	cmp    %rax,%rdx
  80042150c9:	74 09                	je     80042150d4 <_dwarf_lineno_init+0x513>
        ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  80042150cb:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
        DWARF_SET_ERROR(dbg, error, ret);
        goto fail_cleanup;
  80042150d2:	eb 54                	jmp    8004215128 <_dwarf_lineno_init+0x567>
    }

    /*
     * Process line number program.
     */
    ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  80042150d4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042150d8:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042150dc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042150e0:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  80042150e4:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  80042150eb:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  80042150f2:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  80042150f9:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042150fd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215101:	4d 89 c1             	mov    %r8,%r9
  8004215104:	49 89 f8             	mov    %rdi,%r8
  8004215107:	48 89 c7             	mov    %rax,%rdi
  800421510a:	48 b8 65 45 21 04 80 	movabs $0x8004214565,%rax
  8004215111:	00 00 00 
  8004215114:	ff d0                	callq  *%rax
  8004215116:	89 45 dc             	mov    %eax,-0x24(%rbp)
        error);
    if (ret != DW_DLE_NONE)
  8004215119:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800421511d:	74 02                	je     8004215121 <_dwarf_lineno_init+0x560>
        goto fail_cleanup;
  800421511f:	eb 07                	jmp    8004215128 <_dwarf_lineno_init+0x567>

    //cu->cu_lineinfo = li;

    return (DW_DLE_NONE);
  8004215121:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215126:	eb 03                	jmp    800421512b <_dwarf_lineno_init+0x56a>
fail_cleanup:

    /*if (li->li_oplen)
        free(li->li_oplen);*/

    return (ret);
  8004215128:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  800421512b:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  8004215132:	5b                   	pop    %rbx
  8004215133:	5d                   	pop    %rbp
  8004215134:	c3                   	retq   

0000008004215135 <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004215135:	55                   	push   %rbp
  8004215136:	48 89 e5             	mov    %rsp,%rbp
  8004215139:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004215140:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004215147:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  800421514e:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004215155:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
    _Dwarf_LineInfo li;
    Dwarf_Attribute *at;

	assert(die);
  800421515c:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  8004215163:	00 
  8004215164:	75 35                	jne    800421519b <dwarf_srclines+0x66>
  8004215166:	48 b9 47 99 21 04 80 	movabs $0x8004219947,%rcx
  800421516d:	00 00 00 
  8004215170:	48 ba 0f 99 21 04 80 	movabs $0x800421990f,%rdx
  8004215177:	00 00 00 
  800421517a:	be ae 01 00 00       	mov    $0x1ae,%esi
  800421517f:	48 bf 24 99 21 04 80 	movabs $0x8004219924,%rdi
  8004215186:	00 00 00 
  8004215189:	b8 00 00 00 00       	mov    $0x0,%eax
  800421518e:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004215195:	00 00 00 
  8004215198:	41 ff d0             	callq  *%r8
	assert(linebuf);
  800421519b:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  80042151a2:	00 
  80042151a3:	75 35                	jne    80042151da <dwarf_srclines+0xa5>
  80042151a5:	48 b9 4b 99 21 04 80 	movabs $0x800421994b,%rcx
  80042151ac:	00 00 00 
  80042151af:	48 ba 0f 99 21 04 80 	movabs $0x800421990f,%rdx
  80042151b6:	00 00 00 
  80042151b9:	be af 01 00 00       	mov    $0x1af,%esi
  80042151be:	48 bf 24 99 21 04 80 	movabs $0x8004219924,%rdi
  80042151c5:	00 00 00 
  80042151c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042151cd:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042151d4:	00 00 00 
  80042151d7:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  80042151da:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  80042151e1:	ba 88 00 00 00       	mov    $0x88,%edx
  80042151e6:	be 00 00 00 00       	mov    $0x0,%esi
  80042151eb:	48 89 c7             	mov    %rax,%rdi
  80042151ee:	48 b8 b3 fb 20 04 80 	movabs $0x800420fbb3,%rax
  80042151f5:	00 00 00 
  80042151f8:	ff d0                	callq  *%rax

    if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  80042151fa:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004215201:	be 10 00 00 00       	mov    $0x10,%esi
  8004215206:	48 89 c7             	mov    %rax,%rdi
  8004215209:	48 b8 e8 1a 21 04 80 	movabs $0x8004211ae8,%rax
  8004215210:	00 00 00 
  8004215213:	ff d0                	callq  *%rax
  8004215215:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004215219:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421521e:	75 0a                	jne    800421522a <dwarf_srclines+0xf5>
        DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
        return (DW_DLV_NO_ENTRY);
  8004215220:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004215225:	e9 84 00 00 00       	jmpq   80042152ae <dwarf_srclines+0x179>
    }

    if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  800421522a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421522e:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004215232:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  8004215239:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  8004215240:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  8004215247:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421524e:	49 89 f8             	mov    %rdi,%r8
  8004215251:	48 89 c7             	mov    %rax,%rdi
  8004215254:	48 b8 c1 4b 21 04 80 	movabs $0x8004214bc1,%rax
  800421525b:	00 00 00 
  800421525e:	ff d0                	callq  *%rax
  8004215260:	85 c0                	test   %eax,%eax
  8004215262:	74 07                	je     800421526b <dwarf_srclines+0x136>
        DW_DLE_NONE)
	{
          return (DW_DLV_ERROR);
  8004215264:	b8 01 00 00 00       	mov    $0x1,%eax
  8004215269:	eb 43                	jmp    80042152ae <dwarf_srclines+0x179>
	}
    *linebuf = li.li_line;
  800421526b:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004215272:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004215276:	48 89 10             	mov    %rdx,(%rax)
  8004215279:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421527d:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004215281:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004215285:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004215289:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421528d:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004215291:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215295:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004215299:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421529d:	48 89 50 28          	mov    %rdx,0x28(%rax)
  80042152a1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042152a5:	48 89 50 30          	mov    %rdx,0x30(%rax)

    return (DW_DLV_OK);
  80042152a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042152ae:	c9                   	leaveq 
  80042152af:	c3                   	retq   

00000080042152b0 <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  80042152b0:	55                   	push   %rbp
  80042152b1:	48 89 e5             	mov    %rsp,%rbp
  80042152b4:	48 83 ec 20          	sub    $0x20,%rsp
  80042152b8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    Dwarf_Section *ret=NULL;
  80042152bc:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042152c3:	00 
    int i;

    for(i=0; i < NDEBUG_SECT; i++) {
  80042152c4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042152cb:	eb 57                	jmp    8004215324 <_dwarf_find_section+0x74>
        if(!strcmp(section_info[i].ds_name, name)) {
  80042152cd:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  80042152d4:	00 00 00 
  80042152d7:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042152da:	48 63 d2             	movslq %edx,%rdx
  80042152dd:	48 c1 e2 05          	shl    $0x5,%rdx
  80042152e1:	48 01 d0             	add    %rdx,%rax
  80042152e4:	48 8b 00             	mov    (%rax),%rax
  80042152e7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042152eb:	48 89 d6             	mov    %rdx,%rsi
  80042152ee:	48 89 c7             	mov    %rax,%rdi
  80042152f1:	48 b8 7c fa 20 04 80 	movabs $0x800420fa7c,%rax
  80042152f8:	00 00 00 
  80042152fb:	ff d0                	callq  *%rax
  80042152fd:	85 c0                	test   %eax,%eax
  80042152ff:	75 1f                	jne    8004215320 <_dwarf_find_section+0x70>
            ret = (section_info + i);
  8004215301:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215304:	48 98                	cltq   
  8004215306:	48 c1 e0 05          	shl    $0x5,%rax
  800421530a:	48 89 c2             	mov    %rax,%rdx
  800421530d:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215314:	00 00 00 
  8004215317:	48 01 d0             	add    %rdx,%rax
  800421531a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
            break;
  800421531e:	eb 0a                	jmp    800421532a <_dwarf_find_section+0x7a>
_dwarf_find_section(const char *name)
{
    Dwarf_Section *ret=NULL;
    int i;

    for(i=0; i < NDEBUG_SECT; i++) {
  8004215320:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004215324:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004215328:	7e a3                	jle    80042152cd <_dwarf_find_section+0x1d>
            ret = (section_info + i);
            break;
        }
    }

    return ret;
  800421532a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421532e:	c9                   	leaveq 
  800421532f:	c3                   	retq   

0000008004215330 <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  8004215330:	55                   	push   %rbp
  8004215331:	48 89 e5             	mov    %rsp,%rbp
  8004215334:	48 83 ec 40          	sub    $0x40,%rsp
  8004215338:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    Elf *ehdr = (Elf *)elf;
  800421533c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215340:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    uintptr_t debug_address = USTABDATA;
  8004215344:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  800421534b:	00 
    Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  800421534c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215350:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004215354:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215358:	48 01 d0             	add    %rdx,%rax
  800421535b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  800421535f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215363:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004215367:	0f b7 c0             	movzwl %ax,%eax
  800421536a:	48 c1 e0 06          	shl    $0x6,%rax
  800421536e:	48 89 c2             	mov    %rax,%rdx
  8004215371:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215375:	48 01 d0             	add    %rdx,%rax
  8004215378:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    Secthdr* esh = sh + ehdr->e_shnum;
  800421537c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215380:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004215384:	0f b7 c0             	movzwl %ax,%eax
  8004215387:	48 c1 e0 06          	shl    $0x6,%rax
  800421538b:	48 89 c2             	mov    %rax,%rdx
  800421538e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215392:	48 01 d0             	add    %rdx,%rax
  8004215395:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    for(;sh < esh; sh++) {
  8004215399:	e9 4b 02 00 00       	jmpq   80042155e9 <find_debug_sections+0x2b9>
        char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  800421539e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042153a2:	8b 00                	mov    (%rax),%eax
  80042153a4:	89 c2                	mov    %eax,%edx
  80042153a6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042153aa:	48 8b 48 18          	mov    0x18(%rax),%rcx
  80042153ae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042153b2:	48 01 c8             	add    %rcx,%rax
  80042153b5:	48 01 d0             	add    %rdx,%rax
  80042153b8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!strcmp(name, ".debug_info")) {
  80042153bc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042153c0:	48 be 53 99 21 04 80 	movabs $0x8004219953,%rsi
  80042153c7:	00 00 00 
  80042153ca:	48 89 c7             	mov    %rax,%rdi
  80042153cd:	48 b8 7c fa 20 04 80 	movabs $0x800420fa7c,%rax
  80042153d4:	00 00 00 
  80042153d7:	ff d0                	callq  *%rax
  80042153d9:	85 c0                	test   %eax,%eax
  80042153db:	75 4b                	jne    8004215428 <find_debug_sections+0xf8>
            section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  80042153dd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042153e1:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  80042153e8:	00 00 00 
  80042153eb:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  80042153ef:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  80042153f6:	00 00 00 
  80042153f9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042153fd:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  8004215401:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215405:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215409:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215410:	00 00 00 
  8004215413:	48 89 50 18          	mov    %rdx,0x18(%rax)
            debug_address += sh->sh_size;
  8004215417:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421541b:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421541f:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004215423:	e9 bc 01 00 00       	jmpq   80042155e4 <find_debug_sections+0x2b4>
        } else if(!strcmp(name, ".debug_abbrev")) {
  8004215428:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421542c:	48 be 5f 99 21 04 80 	movabs $0x800421995f,%rsi
  8004215433:	00 00 00 
  8004215436:	48 89 c7             	mov    %rax,%rdi
  8004215439:	48 b8 7c fa 20 04 80 	movabs $0x800420fa7c,%rax
  8004215440:	00 00 00 
  8004215443:	ff d0                	callq  *%rax
  8004215445:	85 c0                	test   %eax,%eax
  8004215447:	75 4b                	jne    8004215494 <find_debug_sections+0x164>
            section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  8004215449:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421544d:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215454:	00 00 00 
  8004215457:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  800421545b:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215462:	00 00 00 
  8004215465:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215469:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  800421546d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215471:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215475:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  800421547c:	00 00 00 
  800421547f:	48 89 50 38          	mov    %rdx,0x38(%rax)
            debug_address += sh->sh_size;
  8004215483:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215487:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421548b:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  800421548f:	e9 50 01 00 00       	jmpq   80042155e4 <find_debug_sections+0x2b4>
        } else if(!strcmp(name, ".debug_line")){
  8004215494:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215498:	48 be 77 99 21 04 80 	movabs $0x8004219977,%rsi
  800421549f:	00 00 00 
  80042154a2:	48 89 c7             	mov    %rax,%rdi
  80042154a5:	48 b8 7c fa 20 04 80 	movabs $0x800420fa7c,%rax
  80042154ac:	00 00 00 
  80042154af:	ff d0                	callq  *%rax
  80042154b1:	85 c0                	test   %eax,%eax
  80042154b3:	75 4b                	jne    8004215500 <find_debug_sections+0x1d0>
            section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  80042154b5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042154b9:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  80042154c0:	00 00 00 
  80042154c3:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  80042154c7:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  80042154ce:	00 00 00 
  80042154d1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042154d5:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  80042154d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042154dd:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042154e1:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  80042154e8:	00 00 00 
  80042154eb:	48 89 50 78          	mov    %rdx,0x78(%rax)
            debug_address += sh->sh_size;
  80042154ef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042154f3:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042154f7:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042154fb:	e9 e4 00 00 00       	jmpq   80042155e4 <find_debug_sections+0x2b4>
        } else if(!strcmp(name, ".eh_frame")){
  8004215500:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215504:	48 be 6d 99 21 04 80 	movabs $0x800421996d,%rsi
  800421550b:	00 00 00 
  800421550e:	48 89 c7             	mov    %rax,%rdi
  8004215511:	48 b8 7c fa 20 04 80 	movabs $0x800420fa7c,%rax
  8004215518:	00 00 00 
  800421551b:	ff d0                	callq  *%rax
  800421551d:	85 c0                	test   %eax,%eax
  800421551f:	75 53                	jne    8004215574 <find_debug_sections+0x244>
            section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  8004215521:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215525:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004215529:	48 89 c2             	mov    %rax,%rdx
  800421552c:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215533:	00 00 00 
  8004215536:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  800421553a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421553e:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004215542:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215549:	00 00 00 
  800421554c:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  8004215550:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215554:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215558:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  800421555f:	00 00 00 
  8004215562:	48 89 50 58          	mov    %rdx,0x58(%rax)
            debug_address += sh->sh_size;
  8004215566:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421556a:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421556e:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004215572:	eb 70                	jmp    80042155e4 <find_debug_sections+0x2b4>
        } else if(!strcmp(name, ".debug_str")) {
  8004215574:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215578:	48 be 83 99 21 04 80 	movabs $0x8004219983,%rsi
  800421557f:	00 00 00 
  8004215582:	48 89 c7             	mov    %rax,%rdi
  8004215585:	48 b8 7c fa 20 04 80 	movabs $0x800420fa7c,%rax
  800421558c:	00 00 00 
  800421558f:	ff d0                	callq  *%rax
  8004215591:	85 c0                	test   %eax,%eax
  8004215593:	75 4f                	jne    80042155e4 <find_debug_sections+0x2b4>
            section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  8004215595:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215599:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  80042155a0:	00 00 00 
  80042155a3:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  80042155aa:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  80042155b1:	00 00 00 
  80042155b4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042155b8:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  80042155bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042155c3:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042155c7:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  80042155ce:	00 00 00 
  80042155d1:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
            debug_address += sh->sh_size;
  80042155d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042155dc:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042155e0:	48 01 45 f8          	add    %rax,-0x8(%rbp)
    Elf *ehdr = (Elf *)elf;
    uintptr_t debug_address = USTABDATA;
    Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
    Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
    Secthdr* esh = sh + ehdr->e_shnum;
    for(;sh < esh; sh++) {
  80042155e4:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  80042155e9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042155ed:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80042155f1:	0f 82 a7 fd ff ff    	jb     800421539e <find_debug_sections+0x6e>
			section_info[DEBUG_STR].ds_size = sh->sh_size;
            debug_address += sh->sh_size;
        }
    }

}
  80042155f7:	c9                   	leaveq 
  80042155f8:	c3                   	retq   

00000080042155f9 <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  80042155f9:	55                   	push   %rbp
  80042155fa:	48 89 e5             	mov    %rsp,%rbp
  80042155fd:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  8004215604:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  800421560b:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
    Secthdr* secthdr_ptr[20] = {0};
  8004215612:	48 8d b5 c0 fe ff ff 	lea    -0x140(%rbp),%rsi
  8004215619:	b8 00 00 00 00       	mov    $0x0,%eax
  800421561e:	ba 14 00 00 00       	mov    $0x14,%edx
  8004215623:	48 89 f7             	mov    %rsi,%rdi
  8004215626:	48 89 d1             	mov    %rdx,%rcx
  8004215629:	f3 48 ab             	rep stos %rax,%es:(%rdi)
    char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  800421562c:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  8004215633:	00 
  8004215634:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215638:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  800421563f:	48 01 d0             	add    %rdx,%rax
  8004215642:	48 83 e8 01          	sub    $0x1,%rax
  8004215646:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800421564a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421564e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004215653:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004215657:	48 89 d0             	mov    %rdx,%rax
  800421565a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421565e:	48 29 c2             	sub    %rax,%rdx
  8004215661:	48 89 d0             	mov    %rdx,%rax
  8004215664:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    uint64_t kvoffset = 0;
  8004215668:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  800421566f:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  8004215673:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215677:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    char * secthdr = NULL;
  800421567b:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8004215682:	00 
    uint64_t offset;
    if(elfhdr == KELFHDR)
  8004215683:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800421568a:	00 00 00 
  800421568d:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  8004215694:	75 11                	jne    80042156a7 <read_section_headers+0xae>
        offset = ((Elf*)elfhdr)->e_shoff;
  8004215696:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421569d:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042156a1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042156a5:	eb 26                	jmp    80042156cd <read_section_headers+0xd4>
    else
        offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  80042156a7:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042156ae:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042156b2:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042156b9:	48 01 c2             	add    %rax,%rdx
  80042156bc:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  80042156c3:	ff ff ff 
  80042156c6:	48 01 d0             	add    %rdx,%rax
  80042156c9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  80042156cd:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042156d4:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  80042156d8:	0f b7 c0             	movzwl %ax,%eax
  80042156db:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  80042156de:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042156e5:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  80042156e9:	0f b7 c0             	movzwl %ax,%eax
  80042156ec:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  80042156ef:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042156f6:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  80042156fa:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042156fd:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  8004215701:	48 63 f0             	movslq %eax,%rsi
  8004215704:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215708:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421570f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215713:	48 89 c7             	mov    %rax,%rdi
  8004215716:	48 b8 38 5d 21 04 80 	movabs $0x8004215d38,%rax
  800421571d:	00 00 00 
  8004215720:	ff d0                	callq  *%rax
             offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  8004215722:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215726:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  800421572a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421572e:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004215734:	48 89 c2             	mov    %rax,%rdx
  8004215737:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421573b:	48 29 d0             	sub    %rdx,%rax
  800421573e:	48 89 c2             	mov    %rax,%rdx
  8004215741:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215745:	48 01 d0             	add    %rdx,%rax
  8004215748:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  800421574c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004215753:	eb 24                	jmp    8004215779 <read_section_headers+0x180>
	{
		 secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  8004215755:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215758:	48 98                	cltq   
  800421575a:	48 c1 e0 06          	shl    $0x6,%rax
  800421575e:	48 89 c2             	mov    %rax,%rdx
  8004215761:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215765:	48 01 c2             	add    %rax,%rdx
  8004215768:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421576b:	48 98                	cltq   
  800421576d:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  8004215774:	ff 
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
             offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
	for (i = 0; i < numSectionHeaders; i++)
  8004215775:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004215779:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421577c:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  800421577f:	7c d4                	jl     8004215755 <read_section_headers+0x15c>
	{
		 secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  8004215781:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215785:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004215789:	0f b7 c0             	movzwl %ax,%eax
  800421578c:	48 98                	cltq   
  800421578e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215795:	ff 
  8004215796:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  800421579a:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042157a1:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  80042157a5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042157a9:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042157ad:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042157b1:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042157b5:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  80042157bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042157c0:	48 01 c8             	add    %rcx,%rax
  80042157c3:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042157ca:	48 89 c7             	mov    %rax,%rdi
  80042157cd:	48 b8 38 5d 21 04 80 	movabs $0x8004215d38,%rax
  80042157d4:	00 00 00 
  80042157d7:	ff d0                	callq  *%rax
            sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  80042157d9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042157dd:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042157e1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042157e5:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042157e9:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  80042157ed:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042157f1:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042157f7:	48 29 c2             	sub    %rax,%rdx
  80042157fa:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042157fe:	48 01 c2             	add    %rax,%rdx
  8004215801:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215805:	48 01 d0             	add    %rdx,%rax
  8004215808:	48 89 45 90          	mov    %rax,-0x70(%rbp)

    
	for (i = 0; i < numSectionHeaders; i++)
  800421580c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004215813:	e9 04 05 00 00       	jmpq   8004215d1c <read_section_headers+0x723>
    {
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  8004215818:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421581b:	48 98                	cltq   
  800421581d:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215824:	ff 
  8004215825:	8b 00                	mov    (%rax),%eax
  8004215827:	89 c2                	mov    %eax,%edx
  8004215829:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421582d:	48 01 d0             	add    %rdx,%rax
  8004215830:	48 89 45 88          	mov    %rax,-0x78(%rbp)
        assert(kvoffset % SECTSIZE == 0);
  8004215834:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  800421583b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215840:	48 85 c0             	test   %rax,%rax
  8004215843:	74 35                	je     800421587a <read_section_headers+0x281>
  8004215845:	48 b9 8e 99 21 04 80 	movabs $0x800421998e,%rcx
  800421584c:	00 00 00 
  800421584f:	48 ba a7 99 21 04 80 	movabs $0x80042199a7,%rdx
  8004215856:	00 00 00 
  8004215859:	be 87 00 00 00       	mov    $0x87,%esi
  800421585e:	48 bf bc 99 21 04 80 	movabs $0x80042199bc,%rdi
  8004215865:	00 00 00 
  8004215868:	b8 00 00 00 00       	mov    $0x0,%eax
  800421586d:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004215874:	00 00 00 
  8004215877:	41 ff d0             	callq  *%r8
        temp = kvoffset;
  800421587a:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004215881:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
        cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
  8004215885:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215889:	48 be 53 99 21 04 80 	movabs $0x8004219953,%rsi
  8004215890:	00 00 00 
  8004215893:	48 89 c7             	mov    %rax,%rdi
  8004215896:	48 b8 7c fa 20 04 80 	movabs $0x800420fa7c,%rax
  800421589d:	00 00 00 
  80042158a0:	ff d0                	callq  *%rax
  80042158a2:	85 c0                	test   %eax,%eax
  80042158a4:	0f 85 d8 00 00 00    	jne    8004215982 <read_section_headers+0x389>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042158aa:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042158ad:	48 98                	cltq   
  80042158af:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042158b6:	ff 
#ifdef DWARF_DEBUG
        cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042158b7:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042158bb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042158be:	48 98                	cltq   
  80042158c0:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042158c7:	ff 
  80042158c8:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042158cc:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  80042158d3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042158d7:	48 01 c8             	add    %rcx,%rax
  80042158da:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042158e1:	48 89 c7             	mov    %rax,%rdi
  80042158e4:	48 b8 38 5d 21 04 80 	movabs $0x8004215d38,%rax
  80042158eb:	00 00 00 
  80042158ee:	ff d0                	callq  *%rax
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042158f0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042158f3:	48 98                	cltq   
  80042158f5:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042158fc:	ff 
  80042158fd:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215901:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215904:	48 98                	cltq   
  8004215906:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421590d:	ff 
  800421590e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215912:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  8004215916:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421591a:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004215920:	48 29 c2             	sub    %rax,%rdx
  8004215923:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215927:	48 01 c2             	add    %rax,%rdx
  800421592a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421592e:	48 01 c2             	add    %rax,%rdx
  8004215931:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215938:	00 00 00 
  800421593b:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  800421593f:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215946:	00 00 00 
  8004215949:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421594d:	48 89 c2             	mov    %rax,%rdx
  8004215950:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215957:	00 00 00 
  800421595a:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  800421595e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215961:	48 98                	cltq   
  8004215963:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421596a:	ff 
  800421596b:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421596f:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215976:	00 00 00 
  8004215979:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421597d:	e9 96 03 00 00       	jmpq   8004215d18 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_abbrev"))
  8004215982:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215986:	48 be 5f 99 21 04 80 	movabs $0x800421995f,%rsi
  800421598d:	00 00 00 
  8004215990:	48 89 c7             	mov    %rax,%rdi
  8004215993:	48 b8 7c fa 20 04 80 	movabs $0x800420fa7c,%rax
  800421599a:	00 00 00 
  800421599d:	ff d0                	callq  *%rax
  800421599f:	85 c0                	test   %eax,%eax
  80042159a1:	0f 85 de 00 00 00    	jne    8004215a85 <read_section_headers+0x48c>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042159a7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042159aa:	48 98                	cltq   
  80042159ac:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042159b3:	ff 
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_abbrev"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042159b4:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042159b8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042159bb:	48 98                	cltq   
  80042159bd:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042159c4:	ff 
  80042159c5:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042159c9:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  80042159d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042159d4:	48 01 c8             	add    %rcx,%rax
  80042159d7:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042159de:	48 89 c7             	mov    %rax,%rdi
  80042159e1:	48 b8 38 5d 21 04 80 	movabs $0x8004215d38,%rax
  80042159e8:	00 00 00 
  80042159eb:	ff d0                	callq  *%rax
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042159ed:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042159f0:	48 98                	cltq   
  80042159f2:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042159f9:	ff 
  80042159fa:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042159fe:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215a01:	48 98                	cltq   
  8004215a03:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215a0a:	ff 
  8004215a0b:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215a0f:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004215a16:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004215a1d:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004215a23:	48 29 c2             	sub    %rax,%rdx
  8004215a26:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215a2a:	48 01 c2             	add    %rax,%rdx
  8004215a2d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215a31:	48 01 c2             	add    %rax,%rdx
  8004215a34:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215a3b:	00 00 00 
  8004215a3e:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  8004215a42:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215a49:	00 00 00 
  8004215a4c:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004215a50:	48 89 c2             	mov    %rax,%rdx
  8004215a53:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215a5a:	00 00 00 
  8004215a5d:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  8004215a61:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215a64:	48 98                	cltq   
  8004215a66:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215a6d:	ff 
  8004215a6e:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215a72:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215a79:	00 00 00 
  8004215a7c:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004215a80:	e9 93 02 00 00       	jmpq   8004215d18 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_line"))
  8004215a85:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215a89:	48 be 77 99 21 04 80 	movabs $0x8004219977,%rsi
  8004215a90:	00 00 00 
  8004215a93:	48 89 c7             	mov    %rax,%rdi
  8004215a96:	48 b8 7c fa 20 04 80 	movabs $0x800420fa7c,%rax
  8004215a9d:	00 00 00 
  8004215aa0:	ff d0                	callq  *%rax
  8004215aa2:	85 c0                	test   %eax,%eax
  8004215aa4:	0f 85 de 00 00 00    	jne    8004215b88 <read_section_headers+0x58f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004215aaa:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215aad:	48 98                	cltq   
  8004215aaf:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215ab6:	ff 
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_line"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004215ab7:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215abb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215abe:	48 98                	cltq   
  8004215ac0:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215ac7:	ff 
  8004215ac8:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004215acc:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004215ad3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215ad7:	48 01 c8             	add    %rcx,%rax
  8004215ada:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004215ae1:	48 89 c7             	mov    %rax,%rdi
  8004215ae4:	48 b8 38 5d 21 04 80 	movabs $0x8004215d38,%rax
  8004215aeb:	00 00 00 
  8004215aee:	ff d0                	callq  *%rax
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004215af0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215af3:	48 98                	cltq   
  8004215af5:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215afc:	ff 
  8004215afd:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215b01:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215b04:	48 98                	cltq   
  8004215b06:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215b0d:	ff 
  8004215b0e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215b12:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004215b19:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004215b20:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004215b26:	48 29 c2             	sub    %rax,%rdx
  8004215b29:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215b2d:	48 01 c2             	add    %rax,%rdx
  8004215b30:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215b34:	48 01 c2             	add    %rax,%rdx
  8004215b37:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215b3e:	00 00 00 
  8004215b41:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  8004215b45:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215b4c:	00 00 00 
  8004215b4f:	48 8b 40 68          	mov    0x68(%rax),%rax
  8004215b53:	48 89 c2             	mov    %rax,%rdx
  8004215b56:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215b5d:	00 00 00 
  8004215b60:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  8004215b64:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215b67:	48 98                	cltq   
  8004215b69:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215b70:	ff 
  8004215b71:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215b75:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215b7c:	00 00 00 
  8004215b7f:	48 89 50 78          	mov    %rdx,0x78(%rax)
  8004215b83:	e9 90 01 00 00       	jmpq   8004215d18 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".eh_frame"))
  8004215b88:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215b8c:	48 be 6d 99 21 04 80 	movabs $0x800421996d,%rsi
  8004215b93:	00 00 00 
  8004215b96:	48 89 c7             	mov    %rax,%rdi
  8004215b99:	48 b8 7c fa 20 04 80 	movabs $0x800420fa7c,%rax
  8004215ba0:	00 00 00 
  8004215ba3:	ff d0                	callq  *%rax
  8004215ba5:	85 c0                	test   %eax,%eax
  8004215ba7:	75 65                	jne    8004215c0e <read_section_headers+0x615>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  8004215ba9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215bac:	48 98                	cltq   
  8004215bae:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215bb5:	ff 
  8004215bb6:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004215bba:	48 89 c2             	mov    %rax,%rdx
  8004215bbd:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215bc4:	00 00 00 
  8004215bc7:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  8004215bcb:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215bd2:	00 00 00 
  8004215bd5:	48 8b 40 48          	mov    0x48(%rax),%rax
  8004215bd9:	48 89 c2             	mov    %rax,%rdx
  8004215bdc:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215be3:	00 00 00 
  8004215be6:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  8004215bea:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215bed:	48 98                	cltq   
  8004215bef:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215bf6:	ff 
  8004215bf7:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215bfb:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215c02:	00 00 00 
  8004215c05:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004215c09:	e9 0a 01 00 00       	jmpq   8004215d18 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_str"))
  8004215c0e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215c12:	48 be 83 99 21 04 80 	movabs $0x8004219983,%rsi
  8004215c19:	00 00 00 
  8004215c1c:	48 89 c7             	mov    %rax,%rdi
  8004215c1f:	48 b8 7c fa 20 04 80 	movabs $0x800420fa7c,%rax
  8004215c26:	00 00 00 
  8004215c29:	ff d0                	callq  *%rax
  8004215c2b:	85 c0                	test   %eax,%eax
  8004215c2d:	0f 85 e5 00 00 00    	jne    8004215d18 <read_section_headers+0x71f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004215c33:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215c36:	48 98                	cltq   
  8004215c38:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215c3f:	ff 
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_str"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004215c40:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215c44:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215c47:	48 98                	cltq   
  8004215c49:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215c50:	ff 
  8004215c51:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004215c55:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004215c5c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215c60:	48 01 c8             	add    %rcx,%rax
  8004215c63:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004215c6a:	48 89 c7             	mov    %rax,%rdi
  8004215c6d:	48 b8 38 5d 21 04 80 	movabs $0x8004215d38,%rax
  8004215c74:	00 00 00 
  8004215c77:	ff d0                	callq  *%rax
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004215c79:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215c7c:	48 98                	cltq   
  8004215c7e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215c85:	ff 
  8004215c86:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215c8a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215c8d:	48 98                	cltq   
  8004215c8f:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215c96:	ff 
  8004215c97:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215c9b:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  8004215ca2:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004215ca9:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004215caf:	48 29 c2             	sub    %rax,%rdx
  8004215cb2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215cb6:	48 01 c2             	add    %rax,%rdx
  8004215cb9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215cbd:	48 01 c2             	add    %rax,%rdx
  8004215cc0:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215cc7:	00 00 00 
  8004215cca:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  8004215cd1:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215cd8:	00 00 00 
  8004215cdb:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004215ce2:	48 89 c2             	mov    %rax,%rdx
  8004215ce5:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215cec:	00 00 00 
  8004215cef:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  8004215cf6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215cf9:	48 98                	cltq   
  8004215cfb:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215d02:	ff 
  8004215d03:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215d07:	48 b8 20 a7 22 04 80 	movabs $0x800422a720,%rax
  8004215d0e:	00 00 00 
  8004215d11:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
            sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	

    
	for (i = 0; i < numSectionHeaders; i++)
  8004215d18:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004215d1c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215d1f:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004215d22:	0f 8c f0 fa ff ff    	jl     8004215818 <read_section_headers+0x21f>
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
		}
    }
	
    return ((uintptr_t)kvbase + kvoffset);
  8004215d28:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215d2c:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004215d33:	48 01 d0             	add    %rdx,%rax
}
  8004215d36:	c9                   	leaveq 
  8004215d37:	c3                   	retq   

0000008004215d38 <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  8004215d38:	55                   	push   %rbp
  8004215d39:	48 89 e5             	mov    %rsp,%rbp
  8004215d3c:	48 83 ec 30          	sub    $0x30,%rsp
  8004215d40:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004215d44:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004215d48:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004215d4c:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  8004215d50:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215d54:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  8004215d58:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215d5c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215d60:	48 01 d0             	add    %rdx,%rax
  8004215d63:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  8004215d67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215d6b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215d70:	48 85 c0             	test   %rax,%rax
  8004215d73:	74 35                	je     8004215daa <readseg+0x72>
  8004215d75:	48 b9 ca 99 21 04 80 	movabs $0x80042199ca,%rcx
  8004215d7c:	00 00 00 
  8004215d7f:	48 ba a7 99 21 04 80 	movabs $0x80042199a7,%rdx
  8004215d86:	00 00 00 
  8004215d89:	be c1 00 00 00       	mov    $0xc1,%esi
  8004215d8e:	48 bf bc 99 21 04 80 	movabs $0x80042199bc,%rdi
  8004215d95:	00 00 00 
  8004215d98:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215d9d:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004215da4:	00 00 00 
  8004215da7:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  8004215daa:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  8004215db1:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  8004215db2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215db6:	48 c1 e8 09          	shr    $0x9,%rax
  8004215dba:	48 83 c0 01          	add    $0x1,%rax
  8004215dbe:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004215dc2:	eb 3c                	jmp    8004215e00 <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  8004215dc4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215dc8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215dcc:	48 89 d6             	mov    %rdx,%rsi
  8004215dcf:	48 89 c7             	mov    %rax,%rdi
  8004215dd2:	48 b8 c8 5e 21 04 80 	movabs $0x8004215ec8,%rax
  8004215dd9:	00 00 00 
  8004215ddc:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  8004215dde:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  8004215de5:	00 
		*kvoffset += SECTSIZE;
  8004215de6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215dea:	48 8b 00             	mov    (%rax),%rax
  8004215ded:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004215df4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215df8:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  8004215dfb:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004215e00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215e04:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004215e08:	72 ba                	jb     8004215dc4 <readseg+0x8c>
		pa += SECTSIZE;
		*kvoffset += SECTSIZE;
		offset++;
	}

	if(((orgoff % SECTSIZE) + count) > SECTSIZE)
  8004215e0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215e0e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215e13:	48 89 c2             	mov    %rax,%rdx
  8004215e16:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215e1a:	48 01 d0             	add    %rdx,%rax
  8004215e1d:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  8004215e23:	76 2f                	jbe    8004215e54 <readseg+0x11c>
	{
		readsect((uint8_t*) pa, offset);
  8004215e25:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215e29:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215e2d:	48 89 d6             	mov    %rdx,%rsi
  8004215e30:	48 89 c7             	mov    %rax,%rdi
  8004215e33:	48 b8 c8 5e 21 04 80 	movabs $0x8004215ec8,%rax
  8004215e3a:	00 00 00 
  8004215e3d:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  8004215e3f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215e43:	48 8b 00             	mov    (%rax),%rax
  8004215e46:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004215e4d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215e51:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  8004215e54:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215e58:	48 8b 00             	mov    (%rax),%rax
  8004215e5b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215e60:	48 85 c0             	test   %rax,%rax
  8004215e63:	74 35                	je     8004215e9a <readseg+0x162>
  8004215e65:	48 b9 dd 99 21 04 80 	movabs $0x80042199dd,%rcx
  8004215e6c:	00 00 00 
  8004215e6f:	48 ba a7 99 21 04 80 	movabs $0x80042199a7,%rdx
  8004215e76:	00 00 00 
  8004215e79:	be d7 00 00 00       	mov    $0xd7,%esi
  8004215e7e:	48 bf bc 99 21 04 80 	movabs $0x80042199bc,%rdi
  8004215e85:	00 00 00 
  8004215e88:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215e8d:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004215e94:	00 00 00 
  8004215e97:	41 ff d0             	callq  *%r8
}
  8004215e9a:	c9                   	leaveq 
  8004215e9b:	c3                   	retq   

0000008004215e9c <waitdisk>:

void
waitdisk(void)
{
  8004215e9c:	55                   	push   %rbp
  8004215e9d:	48 89 e5             	mov    %rsp,%rbp
  8004215ea0:	48 83 ec 10          	sub    $0x10,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  8004215ea4:	90                   	nop
  8004215ea5:	c7 45 fc f7 01 00 00 	movl   $0x1f7,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004215eac:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215eaf:	89 c2                	mov    %eax,%edx
  8004215eb1:	ec                   	in     (%dx),%al
  8004215eb2:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  8004215eb5:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004215eb9:	0f b6 c0             	movzbl %al,%eax
  8004215ebc:	25 c0 00 00 00       	and    $0xc0,%eax
  8004215ec1:	83 f8 40             	cmp    $0x40,%eax
  8004215ec4:	75 df                	jne    8004215ea5 <waitdisk+0x9>
		/* do nothing */;
}
  8004215ec6:	c9                   	leaveq 
  8004215ec7:	c3                   	retq   

0000008004215ec8 <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  8004215ec8:	55                   	push   %rbp
  8004215ec9:	48 89 e5             	mov    %rsp,%rbp
  8004215ecc:	48 83 ec 60          	sub    $0x60,%rsp
  8004215ed0:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004215ed4:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	// wait for disk to be ready
	waitdisk();
  8004215ed8:	48 b8 9c 5e 21 04 80 	movabs $0x8004215e9c,%rax
  8004215edf:	00 00 00 
  8004215ee2:	ff d0                	callq  *%rax
  8004215ee4:	c7 45 fc f2 01 00 00 	movl   $0x1f2,-0x4(%rbp)
  8004215eeb:	c6 45 fb 01          	movb   $0x1,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004215eef:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004215ef3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215ef6:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  8004215ef7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215efb:	0f b6 c0             	movzbl %al,%eax
  8004215efe:	c7 45 f4 f3 01 00 00 	movl   $0x1f3,-0xc(%rbp)
  8004215f05:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004215f08:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004215f0c:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004215f0f:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  8004215f10:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215f14:	48 c1 e8 08          	shr    $0x8,%rax
  8004215f18:	0f b6 c0             	movzbl %al,%eax
  8004215f1b:	c7 45 ec f4 01 00 00 	movl   $0x1f4,-0x14(%rbp)
  8004215f22:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004215f25:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004215f29:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004215f2c:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  8004215f2d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215f31:	48 c1 e8 10          	shr    $0x10,%rax
  8004215f35:	0f b6 c0             	movzbl %al,%eax
  8004215f38:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%rbp)
  8004215f3f:	88 45 e3             	mov    %al,-0x1d(%rbp)
  8004215f42:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004215f46:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004215f49:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  8004215f4a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215f4e:	48 c1 e8 18          	shr    $0x18,%rax
  8004215f52:	83 c8 e0             	or     $0xffffffe0,%eax
  8004215f55:	0f b6 c0             	movzbl %al,%eax
  8004215f58:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%rbp)
  8004215f5f:	88 45 db             	mov    %al,-0x25(%rbp)
  8004215f62:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004215f66:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215f69:	ee                   	out    %al,(%dx)
  8004215f6a:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%rbp)
  8004215f71:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
  8004215f75:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004215f79:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004215f7c:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  8004215f7d:	48 b8 9c 5e 21 04 80 	movabs $0x8004215e9c,%rax
  8004215f84:	00 00 00 
  8004215f87:	ff d0                	callq  *%rax
  8004215f89:	c7 45 cc f0 01 00 00 	movl   $0x1f0,-0x34(%rbp)
  8004215f90:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215f94:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004215f98:	c7 45 bc 80 00 00 00 	movl   $0x80,-0x44(%rbp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
  8004215f9f:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004215fa2:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004215fa6:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004215fa9:	48 89 ce             	mov    %rcx,%rsi
  8004215fac:	48 89 f7             	mov    %rsi,%rdi
  8004215faf:	89 c1                	mov    %eax,%ecx
  8004215fb1:	fc                   	cld    
  8004215fb2:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  8004215fb4:	89 c8                	mov    %ecx,%eax
  8004215fb6:	48 89 fe             	mov    %rdi,%rsi
  8004215fb9:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004215fbd:	89 45 bc             	mov    %eax,-0x44(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  8004215fc0:	c9                   	leaveq 
  8004215fc1:	c3                   	retq   
  8004215fc2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000008004215fc8 <mpentry_start>:
.set pml4, pml4phys

.code16           
.globl mpentry_start
mpentry_start:
	cli
  8004215fc8:	fa                   	cli    
	xorw    %ax, %ax
  8004215fc9:	31 c0                	xor    %eax,%eax
	movw    %ax, %ds
  8004215fcb:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004215fcd:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004215fcf:	8e d0                	mov    %eax,%ss
	
	
	lgdt    MPBOOTPHYS(gdt32desc)   // load 32 bit global descritor table
  8004215fd1:	0f 01 16             	lgdt   (%rsi)
  8004215fd4:	e0 70                	loopne 8004216046 <start64+0x10>
	movl    %cr0, %eax
  8004215fd6:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004215fd9:	66 83 c8 01          	or     $0x1,%ax
	movl    %eax, %cr0
  8004215fdd:	0f 22 c0             	mov    %rax,%cr0
	ljmp	$(PROT_MODE_CSEG),$(MPBOOTPHYS(start32))
  8004215fe0:	ea                   	(bad)  
  8004215fe1:	1d 70 08 00 66       	sbb    $0x66000870,%eax

0000008004215fe5 <start32>:

.code32
start32:
	
	movw    $(PROT_MODE_DSEG), %ax
  8004215fe5:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004215fe9:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004215feb:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004215fed:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004215fef:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004215ff3:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004215ff5:	8e e8                	mov    %eax,%gs

	movl $CR4_PAE,%eax
  8004215ff7:	b8 20 00 00 00       	mov    $0x20,%eax
	movl %eax,%cr4
  8004215ffc:	0f 22 e0             	mov    %rax,%cr4
	
	lgdt    MPBOOTPHYS(gdtdesc)
  8004215fff:	0f 01 15 c0 70 00 00 	lgdt   0x70c0(%rip)        # 421d0c6 <_start+0x401d0ba>
	movl    %cr0, %eax
  8004216006:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004216009:	83 c8 01             	or     $0x1,%eax
	movl    %eax, %cr0
  800421600c:	0f 22 c0             	mov    %rax,%cr0
	
	# Set up initial page table. We cannot use kern_pgdir yet because
	# we are still running at a low EIP.
	movl    $pml4, %eax
  800421600f:	b8 00 20 10 00       	mov    $0x102000,%eax
	movl    %eax, %cr3
  8004216014:	0f 22 d8             	mov    %rax,%cr3
	
	# enable the long mode in MSR
	movl $EFER_MSR,%ecx
  8004216017:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  800421601c:	0f 32                	rdmsr  
	btsl $EFER_LME,%eax
  800421601e:	0f ba e8 08          	bts    $0x8,%eax
	wrmsr
  8004216022:	0f 30                	wrmsr  
	
	# Turn on paging.
	movl    %cr0, %eax
  8004216024:	0f 20 c0             	mov    %cr0,%rax
	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  8004216027:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl    %eax, %cr0
  800421602c:	0f 22 c0             	mov    %rax,%cr0
	

	ljmpl   $(LONG_MODE_CSEG), $(MPBOOTPHYS(start64))
  800421602f:	ea                   	(bad)  
  8004216030:	6e                   	outsb  %ds:(%rsi),(%dx)
  8004216031:	70 00                	jo     8004216033 <start32+0x4e>
  8004216033:	00 08                	add    %cl,(%rax)
	...

0000008004216036 <start64>:

.code64
start64:
	movw    $(LONG_MODE_DSEG), %ax
  8004216036:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  800421603a:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  800421603c:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  800421603e:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004216040:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004216044:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004216046:	8e e8                	mov    %eax,%gs

	# Switch to the per-cpu stack allocated in boot_aps()
	movabs    mpentry_kstack, %rax
  8004216048:	48 a1 98 17 36 04 80 	movabs 0x8004361798,%rax
  800421604f:	00 00 00 
	movq    %rax,%rsp
  8004216052:	48 89 c4             	mov    %rax,%rsp
	movq    $0x0, %rbp       # nuke frame pointer
  8004216055:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movabs    $mp_main, %rax
  800421605c:	48 b8 45 04 20 04 80 	movabs $0x8004200445,%rax
  8004216063:	00 00 00 
	call    *%rax
  8004216066:	ff d0                	callq  *%rax

0000008004216068 <spin>:

	# If mp_main returns (it shouldn't), loop.
spin:
	jmp     spin
  8004216068:	eb fe                	jmp    8004216068 <spin>
  800421606a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000008004216070 <gdt>:
	...
  8004216078:	ff                   	(bad)  
  8004216079:	ff 00                	incl   (%rax)
  800421607b:	00 00                	add    %al,(%rax)
  800421607d:	9a                   	(bad)  
  800421607e:	af                   	scas   %es:(%rdi),%eax
  800421607f:	00 ff                	add    %bh,%bh
  8004216081:	ff 00                	incl   (%rax)
  8004216083:	00 00                	add    %al,(%rax)
  8004216085:	92                   	xchg   %eax,%edx
  8004216086:	af                   	scas   %es:(%rdi),%eax
	...

0000008004216088 <gdtdesc>:
  8004216088:	17                   	(bad)  
  8004216089:	00 a8 70 00 00 66    	add    %ch,0x66000070(%rax)
  800421608f:	90                   	nop

0000008004216090 <gdt32>:
	...
  8004216098:	ff                   	(bad)  
  8004216099:	ff 00                	incl   (%rax)
  800421609b:	00 00                	add    %al,(%rax)
  800421609d:	9a                   	(bad)  
  800421609e:	cf                   	iret   
  800421609f:	00 ff                	add    %bh,%bh
  80042160a1:	ff 00                	incl   (%rax)
  80042160a3:	00 00                	add    %al,(%rax)
  80042160a5:	92                   	xchg   %eax,%edx
  80042160a6:	cf                   	iret   
	...

00000080042160a8 <gdt32desc>:
  80042160a8:	17                   	(bad)  
  80042160a9:	00 c8                	add    %cl,%al
  80042160ab:	70 00                	jo     80042160ad <gdt32desc+0x5>
	...

00000080042160ae <mpentry_end>:
	.long   MPBOOTPHYS(gdt32)			# address gdt


.globl mpentry_end
mpentry_end:
	nop
  80042160ae:	90                   	nop

00000080042160af <sum>:
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source

static uint8_t
sum(void *addr, int len)
{
  80042160af:	55                   	push   %rbp
  80042160b0:	48 89 e5             	mov    %rsp,%rbp
  80042160b3:	48 83 ec 1c          	sub    $0x1c,%rsp
  80042160b7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042160bb:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int i, sum;

	sum = 0;
  80042160be:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < len; i++)
  80042160c5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042160cc:	eb 1a                	jmp    80042160e8 <sum+0x39>
		sum += ((uint8_t *)addr)[i];
  80042160ce:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042160d1:	48 63 d0             	movslq %eax,%rdx
  80042160d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042160d8:	48 01 d0             	add    %rdx,%rax
  80042160db:	0f b6 00             	movzbl (%rax),%eax
  80042160de:	0f b6 c0             	movzbl %al,%eax
  80042160e1:	01 45 f8             	add    %eax,-0x8(%rbp)
sum(void *addr, int len)
{
	int i, sum;

	sum = 0;
	for (i = 0; i < len; i++)
  80042160e4:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042160e8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042160eb:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  80042160ee:	7c de                	jl     80042160ce <sum+0x1f>
		sum += ((uint8_t *)addr)[i];
	return sum;
  80042160f0:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  80042160f3:	c9                   	leaveq 
  80042160f4:	c3                   	retq   

00000080042160f5 <mpsearch1>:

// Look for an MP structure in the len bytes at physical address addr.
static struct mp *
mpsearch1(physaddr_t a, int len)
{
  80042160f5:	55                   	push   %rbp
  80042160f6:	48 89 e5             	mov    %rsp,%rbp
  80042160f9:	48 83 ec 40          	sub    $0x40,%rsp
  80042160fd:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004216101:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	struct mp *mp = KADDR(a), *end = KADDR(a + len);
  8004216104:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004216108:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800421610c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216110:	48 c1 e8 0c          	shr    $0xc,%rax
  8004216114:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004216117:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421611a:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004216121:	00 00 00 
  8004216124:	48 8b 00             	mov    (%rax),%rax
  8004216127:	48 39 c2             	cmp    %rax,%rdx
  800421612a:	72 32                	jb     800421615e <mpsearch1+0x69>
  800421612c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216130:	48 89 c1             	mov    %rax,%rcx
  8004216133:	48 ba f8 99 21 04 80 	movabs $0x80042199f8,%rdx
  800421613a:	00 00 00 
  800421613d:	be 57 00 00 00       	mov    $0x57,%esi
  8004216142:	48 bf 1b 9a 21 04 80 	movabs $0x8004219a1b,%rdi
  8004216149:	00 00 00 
  800421614c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216151:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004216158:	00 00 00 
  800421615b:	41 ff d0             	callq  *%r8
  800421615e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004216165:	00 00 00 
  8004216168:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421616c:	48 01 d0             	add    %rdx,%rax
  800421616f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004216173:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004216176:	48 63 d0             	movslq %eax,%rdx
  8004216179:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421617d:	48 01 d0             	add    %rdx,%rax
  8004216180:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004216184:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216188:	48 c1 e8 0c          	shr    $0xc,%rax
  800421618c:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800421618f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004216192:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004216199:	00 00 00 
  800421619c:	48 8b 00             	mov    (%rax),%rax
  800421619f:	48 39 c2             	cmp    %rax,%rdx
  80042161a2:	72 32                	jb     80042161d6 <mpsearch1+0xe1>
  80042161a4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042161a8:	48 89 c1             	mov    %rax,%rcx
  80042161ab:	48 ba f8 99 21 04 80 	movabs $0x80042199f8,%rdx
  80042161b2:	00 00 00 
  80042161b5:	be 57 00 00 00       	mov    $0x57,%esi
  80042161ba:	48 bf 1b 9a 21 04 80 	movabs $0x8004219a1b,%rdi
  80042161c1:	00 00 00 
  80042161c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042161c9:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042161d0:	00 00 00 
  80042161d3:	41 ff d0             	callq  *%r8
  80042161d6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042161dd:	00 00 00 
  80042161e0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042161e4:	48 01 d0             	add    %rdx,%rax
  80042161e7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	for (; mp < end; mp++)
  80042161eb:	eb 4d                	jmp    800421623a <mpsearch1+0x145>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  80042161ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042161f1:	ba 04 00 00 00       	mov    $0x4,%edx
  80042161f6:	48 be 2b 9a 21 04 80 	movabs $0x8004219a2b,%rsi
  80042161fd:	00 00 00 
  8004216200:	48 89 c7             	mov    %rax,%rdi
  8004216203:	48 b8 89 fd 20 04 80 	movabs $0x800420fd89,%rax
  800421620a:	00 00 00 
  800421620d:	ff d0                	callq  *%rax
  800421620f:	85 c0                	test   %eax,%eax
  8004216211:	75 22                	jne    8004216235 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
  8004216213:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216217:	be 10 00 00 00       	mov    $0x10,%esi
  800421621c:	48 89 c7             	mov    %rax,%rdi
  800421621f:	48 b8 af 60 21 04 80 	movabs $0x80042160af,%rax
  8004216226:	00 00 00 
  8004216229:	ff d0                	callq  *%rax
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  800421622b:	84 c0                	test   %al,%al
  800421622d:	75 06                	jne    8004216235 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
  800421622f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216233:	eb 14                	jmp    8004216249 <mpsearch1+0x154>
static struct mp *
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
  8004216235:	48 83 45 f8 10       	addq   $0x10,-0x8(%rbp)
  800421623a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421623e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004216242:	72 a9                	jb     80042161ed <mpsearch1+0xf8>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
	return NULL;
  8004216244:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004216249:	c9                   	leaveq 
  800421624a:	c3                   	retq   

000000800421624b <mpsearch>:
// 1) in the first KB of the EBDA;
// 2) if there is no EBDA, in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp *
mpsearch(void)
{
  800421624b:	55                   	push   %rbp
  800421624c:	48 89 e5             	mov    %rsp,%rbp
  800421624f:	48 83 ec 30          	sub    $0x30,%rsp
	struct mp *mp;

	//static_assert(sizeof(*mp) == 32);

	// The BIOS data area lives in 16-bit segment 0x40.
	bda = (uint8_t *) KADDR(0x40 << 4);
  8004216253:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  800421625a:	00 
  800421625b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421625f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004216263:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004216266:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004216269:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004216270:	00 00 00 
  8004216273:	48 8b 00             	mov    (%rax),%rax
  8004216276:	48 39 c2             	cmp    %rax,%rdx
  8004216279:	72 32                	jb     80042162ad <mpsearch+0x62>
  800421627b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421627f:	48 89 c1             	mov    %rax,%rcx
  8004216282:	48 ba f8 99 21 04 80 	movabs $0x80042199f8,%rdx
  8004216289:	00 00 00 
  800421628c:	be 6f 00 00 00       	mov    $0x6f,%esi
  8004216291:	48 bf 1b 9a 21 04 80 	movabs $0x8004219a1b,%rdi
  8004216298:	00 00 00 
  800421629b:	b8 00 00 00 00       	mov    $0x0,%eax
  80042162a0:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  80042162a7:	00 00 00 
  80042162aa:	41 ff d0             	callq  *%r8
  80042162ad:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042162b4:	00 00 00 
  80042162b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042162bb:	48 01 d0             	add    %rdx,%rax
  80042162be:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// [MP 4] The 16-bit segment of the EBDA is in the two bytes
	// starting at byte 0x0E of the BDA.  0 if not present.
	if ((p = *(uint16_t *) (bda + 0x0E))) {
  80042162c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042162c6:	48 83 c0 0e          	add    $0xe,%rax
  80042162ca:	0f b7 00             	movzwl (%rax),%eax
  80042162cd:	0f b7 c0             	movzwl %ax,%eax
  80042162d0:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  80042162d3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042162d7:	74 2c                	je     8004216305 <mpsearch+0xba>
		p <<= 4;	// Translate from segment to PA
  80042162d9:	c1 65 e4 04          	shll   $0x4,-0x1c(%rbp)
		if ((mp = mpsearch1(p, 1024)))
  80042162dd:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042162e0:	be 00 04 00 00       	mov    $0x400,%esi
  80042162e5:	48 89 c7             	mov    %rax,%rdi
  80042162e8:	48 b8 f5 60 21 04 80 	movabs $0x80042160f5,%rax
  80042162ef:	00 00 00 
  80042162f2:	ff d0                	callq  *%rax
  80042162f4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042162f8:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042162fd:	74 49                	je     8004216348 <mpsearch+0xfd>
			return mp;
  80042162ff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216303:	eb 59                	jmp    800421635e <mpsearch+0x113>
	} else {
		// The size of base memory, in KB is in the two bytes
		// starting at 0x13 of the BDA.
		p = *(uint16_t *) (bda + 0x13) * 1024;
  8004216305:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216309:	48 83 c0 13          	add    $0x13,%rax
  800421630d:	0f b7 00             	movzwl (%rax),%eax
  8004216310:	0f b7 c0             	movzwl %ax,%eax
  8004216313:	c1 e0 0a             	shl    $0xa,%eax
  8004216316:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if ((mp = mpsearch1(p - 1024, 1024)))
  8004216319:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421631c:	2d 00 04 00 00       	sub    $0x400,%eax
  8004216321:	89 c0                	mov    %eax,%eax
  8004216323:	be 00 04 00 00       	mov    $0x400,%esi
  8004216328:	48 89 c7             	mov    %rax,%rdi
  800421632b:	48 b8 f5 60 21 04 80 	movabs $0x80042160f5,%rax
  8004216332:	00 00 00 
  8004216335:	ff d0                	callq  *%rax
  8004216337:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800421633b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004216340:	74 06                	je     8004216348 <mpsearch+0xfd>
			return mp;
  8004216342:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216346:	eb 16                	jmp    800421635e <mpsearch+0x113>
	}
	return mpsearch1(0xF0000, 0x10000);
  8004216348:	be 00 00 01 00       	mov    $0x10000,%esi
  800421634d:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  8004216352:	48 b8 f5 60 21 04 80 	movabs $0x80042160f5,%rax
  8004216359:	00 00 00 
  800421635c:	ff d0                	callq  *%rax
}
  800421635e:	c9                   	leaveq 
  800421635f:	c3                   	retq   

0000008004216360 <mpconfig>:
// Search for an MP configuration table.  For now, don't accept the
// default configurations (physaddr == 0).
// Check for the correct signature, checksum, and version.
static struct mpconf *
mpconfig(struct mp **pmp)
{
  8004216360:	55                   	push   %rbp
  8004216361:	48 89 e5             	mov    %rsp,%rbp
  8004216364:	48 83 ec 30          	sub    $0x30,%rsp
  8004216368:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	struct mpconf *conf;
	struct mp *mp;

	if ((mp = mpsearch()) == 0)
  800421636c:	48 b8 4b 62 21 04 80 	movabs $0x800421624b,%rax
  8004216373:	00 00 00 
  8004216376:	ff d0                	callq  *%rax
  8004216378:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421637c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004216381:	75 0a                	jne    800421638d <mpconfig+0x2d>
		return NULL;
  8004216383:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216388:	e9 f6 01 00 00       	jmpq   8004216583 <mpconfig+0x223>
	if (mp->physaddr == 0 || mp->type != 0) {
  800421638d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216391:	8b 40 04             	mov    0x4(%rax),%eax
  8004216394:	85 c0                	test   %eax,%eax
  8004216396:	74 0c                	je     80042163a4 <mpconfig+0x44>
  8004216398:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421639c:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  80042163a0:	84 c0                	test   %al,%al
  80042163a2:	74 25                	je     80042163c9 <mpconfig+0x69>
		cprintf("SMP: Default configurations not implemented\n");
  80042163a4:	48 bf 30 9a 21 04 80 	movabs $0x8004219a30,%rdi
  80042163ab:	00 00 00 
  80042163ae:	b8 00 00 00 00       	mov    $0x0,%eax
  80042163b3:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  80042163ba:	00 00 00 
  80042163bd:	ff d2                	callq  *%rdx
		return NULL;
  80042163bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042163c4:	e9 ba 01 00 00       	jmpq   8004216583 <mpconfig+0x223>
	}
	conf = (struct mpconf *) KADDR(mp->physaddr);
  80042163c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042163cd:	8b 40 04             	mov    0x4(%rax),%eax
  80042163d0:	89 c0                	mov    %eax,%eax
  80042163d2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042163d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042163da:	48 c1 e8 0c          	shr    $0xc,%rax
  80042163de:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042163e1:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042163e4:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  80042163eb:	00 00 00 
  80042163ee:	48 8b 00             	mov    (%rax),%rax
  80042163f1:	48 39 c2             	cmp    %rax,%rdx
  80042163f4:	72 32                	jb     8004216428 <mpconfig+0xc8>
  80042163f6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042163fa:	48 89 c1             	mov    %rax,%rcx
  80042163fd:	48 ba f8 99 21 04 80 	movabs $0x80042199f8,%rdx
  8004216404:	00 00 00 
  8004216407:	be 90 00 00 00       	mov    $0x90,%esi
  800421640c:	48 bf 1b 9a 21 04 80 	movabs $0x8004219a1b,%rdi
  8004216413:	00 00 00 
  8004216416:	b8 00 00 00 00       	mov    $0x0,%eax
  800421641b:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004216422:	00 00 00 
  8004216425:	41 ff d0             	callq  *%r8
  8004216428:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421642f:	00 00 00 
  8004216432:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216436:	48 01 d0             	add    %rdx,%rax
  8004216439:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (memcmp(conf, "PCMP", 4) != 0) {
  800421643d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216441:	ba 04 00 00 00       	mov    $0x4,%edx
  8004216446:	48 be 5d 9a 21 04 80 	movabs $0x8004219a5d,%rsi
  800421644d:	00 00 00 
  8004216450:	48 89 c7             	mov    %rax,%rdi
  8004216453:	48 b8 89 fd 20 04 80 	movabs $0x800420fd89,%rax
  800421645a:	00 00 00 
  800421645d:	ff d0                	callq  *%rax
  800421645f:	85 c0                	test   %eax,%eax
  8004216461:	74 25                	je     8004216488 <mpconfig+0x128>
		cprintf("SMP: Incorrect MP configuration table signature\n");
  8004216463:	48 bf 68 9a 21 04 80 	movabs $0x8004219a68,%rdi
  800421646a:	00 00 00 
  800421646d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216472:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004216479:	00 00 00 
  800421647c:	ff d2                	callq  *%rdx
		return NULL;
  800421647e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216483:	e9 fb 00 00 00       	jmpq   8004216583 <mpconfig+0x223>
	}
	if (sum(conf, conf->length) != 0) {
  8004216488:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421648c:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8004216490:	0f b7 d0             	movzwl %ax,%edx
  8004216493:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216497:	89 d6                	mov    %edx,%esi
  8004216499:	48 89 c7             	mov    %rax,%rdi
  800421649c:	48 b8 af 60 21 04 80 	movabs $0x80042160af,%rax
  80042164a3:	00 00 00 
  80042164a6:	ff d0                	callq  *%rax
  80042164a8:	84 c0                	test   %al,%al
  80042164aa:	74 25                	je     80042164d1 <mpconfig+0x171>
		cprintf("SMP: Bad MP configuration checksum\n");
  80042164ac:	48 bf a0 9a 21 04 80 	movabs $0x8004219aa0,%rdi
  80042164b3:	00 00 00 
  80042164b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042164bb:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  80042164c2:	00 00 00 
  80042164c5:	ff d2                	callq  *%rdx
		return NULL;
  80042164c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042164cc:	e9 b2 00 00 00       	jmpq   8004216583 <mpconfig+0x223>
	}
	if (conf->version != 1 && conf->version != 4) {
  80042164d1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042164d5:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042164d9:	3c 01                	cmp    $0x1,%al
  80042164db:	74 3b                	je     8004216518 <mpconfig+0x1b8>
  80042164dd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042164e1:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042164e5:	3c 04                	cmp    $0x4,%al
  80042164e7:	74 2f                	je     8004216518 <mpconfig+0x1b8>
		cprintf("SMP: Unsupported MP version %d\n", conf->version);
  80042164e9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042164ed:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042164f1:	0f b6 c0             	movzbl %al,%eax
  80042164f4:	89 c6                	mov    %eax,%esi
  80042164f6:	48 bf c8 9a 21 04 80 	movabs $0x8004219ac8,%rdi
  80042164fd:	00 00 00 
  8004216500:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216505:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800421650c:	00 00 00 
  800421650f:	ff d2                	callq  *%rdx
		return NULL;
  8004216511:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216516:	eb 6b                	jmp    8004216583 <mpconfig+0x223>
	}
	if (sum((uint8_t *)conf + conf->length, conf->xlength) != conf->xchecksum) {
  8004216518:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421651c:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  8004216520:	0f b7 c0             	movzwl %ax,%eax
  8004216523:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004216527:	0f b7 52 04          	movzwl 0x4(%rdx),%edx
  800421652b:	0f b7 ca             	movzwl %dx,%ecx
  800421652e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004216532:	48 01 ca             	add    %rcx,%rdx
  8004216535:	89 c6                	mov    %eax,%esi
  8004216537:	48 89 d7             	mov    %rdx,%rdi
  800421653a:	48 b8 af 60 21 04 80 	movabs $0x80042160af,%rax
  8004216541:	00 00 00 
  8004216544:	ff d0                	callq  *%rax
  8004216546:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421654a:	0f b6 52 2a          	movzbl 0x2a(%rdx),%edx
  800421654e:	38 d0                	cmp    %dl,%al
  8004216550:	74 22                	je     8004216574 <mpconfig+0x214>
		cprintf("SMP: Bad MP configuration extended checksum\n");
  8004216552:	48 bf e8 9a 21 04 80 	movabs $0x8004219ae8,%rdi
  8004216559:	00 00 00 
  800421655c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216561:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004216568:	00 00 00 
  800421656b:	ff d2                	callq  *%rdx
		return NULL;
  800421656d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216572:	eb 0f                	jmp    8004216583 <mpconfig+0x223>
	}
	*pmp = mp;
  8004216574:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216578:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421657c:	48 89 10             	mov    %rdx,(%rax)
	return conf;
  800421657f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  8004216583:	c9                   	leaveq 
  8004216584:	c3                   	retq   

0000008004216585 <mp_init>:

void
mp_init(void)
{
  8004216585:	55                   	push   %rbp
  8004216586:	48 89 e5             	mov    %rsp,%rbp
  8004216589:	53                   	push   %rbx
  800421658a:	48 83 ec 48          	sub    $0x48,%rsp
	struct mpconf *conf;
	struct mpproc *proc;
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
  800421658e:	48 b8 e0 33 36 04 80 	movabs $0x80043633e0,%rax
  8004216595:	00 00 00 
  8004216598:	48 bb 20 30 36 04 80 	movabs $0x8004363020,%rbx
  800421659f:	00 00 00 
  80042165a2:	48 89 18             	mov    %rbx,(%rax)
	if ((conf = mpconfig(&mp)) == 0)
  80042165a5:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  80042165a9:	48 89 c7             	mov    %rax,%rdi
  80042165ac:	48 b8 60 63 21 04 80 	movabs $0x8004216360,%rax
  80042165b3:	00 00 00 
  80042165b6:	ff d0                	callq  *%rax
  80042165b8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042165bc:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042165c1:	75 05                	jne    80042165c8 <mp_init+0x43>
		return;
  80042165c3:	e9 b5 02 00 00       	jmpq   800421687d <mp_init+0x2f8>
	ismp = 1;
  80042165c8:	48 b8 00 30 36 04 80 	movabs $0x8004363000,%rax
  80042165cf:	00 00 00 
  80042165d2:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	lapicaddr = conf->lapicaddr;
  80042165d8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042165dc:	8b 40 24             	mov    0x24(%rax),%eax
  80042165df:	89 c2                	mov    %eax,%edx
  80042165e1:	48 b8 00 40 3e 04 80 	movabs $0x80043e4000,%rax
  80042165e8:	00 00 00 
  80042165eb:	48 89 10             	mov    %rdx,(%rax)

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  80042165ee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042165f2:	48 83 c0 2c          	add    $0x2c,%rax
  80042165f6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042165fa:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  8004216601:	e9 5c 01 00 00       	jmpq   8004216762 <mp_init+0x1dd>
		switch (*p) {
  8004216606:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421660a:	0f b6 00             	movzbl (%rax),%eax
  800421660d:	0f b6 c0             	movzbl %al,%eax
  8004216610:	85 c0                	test   %eax,%eax
  8004216612:	74 16                	je     800421662a <mp_init+0xa5>
  8004216614:	85 c0                	test   %eax,%eax
  8004216616:	0f 88 fd 00 00 00    	js     8004216719 <mp_init+0x194>
  800421661c:	83 f8 04             	cmp    $0x4,%eax
  800421661f:	0f 8f f4 00 00 00    	jg     8004216719 <mp_init+0x194>
  8004216625:	e9 e8 00 00 00       	jmpq   8004216712 <mp_init+0x18d>
		case MPPROC:
			proc = (struct mpproc *)p;
  800421662a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421662e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			if (proc->flags & MPPROC_BOOT)
  8004216632:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216636:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  800421663a:	0f b6 c0             	movzbl %al,%eax
  800421663d:	83 e0 02             	and    $0x2,%eax
  8004216640:	85 c0                	test   %eax,%eax
  8004216642:	74 36                	je     800421667a <mp_init+0xf5>
				bootcpu = &cpus[ncpu];
  8004216644:	48 b8 e8 33 36 04 80 	movabs $0x80043633e8,%rax
  800421664b:	00 00 00 
  800421664e:	8b 00                	mov    (%rax),%eax
  8004216650:	48 98                	cltq   
  8004216652:	48 c1 e0 03          	shl    $0x3,%rax
  8004216656:	48 89 c2             	mov    %rax,%rdx
  8004216659:	48 c1 e2 04          	shl    $0x4,%rdx
  800421665d:	48 29 c2             	sub    %rax,%rdx
  8004216660:	48 b8 20 30 36 04 80 	movabs $0x8004363020,%rax
  8004216667:	00 00 00 
  800421666a:	48 01 c2             	add    %rax,%rdx
  800421666d:	48 b8 e0 33 36 04 80 	movabs $0x80043633e0,%rax
  8004216674:	00 00 00 
  8004216677:	48 89 10             	mov    %rdx,(%rax)
			if (ncpu < NCPU) {
  800421667a:	48 b8 e8 33 36 04 80 	movabs $0x80043633e8,%rax
  8004216681:	00 00 00 
  8004216684:	8b 00                	mov    (%rax),%eax
  8004216686:	83 f8 07             	cmp    $0x7,%eax
  8004216689:	7f 58                	jg     80042166e3 <mp_init+0x15e>
				cpus[ncpu].cpu_id = ncpu;
  800421668b:	48 b8 e8 33 36 04 80 	movabs $0x80043633e8,%rax
  8004216692:	00 00 00 
  8004216695:	8b 10                	mov    (%rax),%edx
  8004216697:	48 b8 e8 33 36 04 80 	movabs $0x80043633e8,%rax
  800421669e:	00 00 00 
  80042166a1:	8b 00                	mov    (%rax),%eax
  80042166a3:	89 c1                	mov    %eax,%ecx
  80042166a5:	48 be 20 30 36 04 80 	movabs $0x8004363020,%rsi
  80042166ac:	00 00 00 
  80042166af:	48 63 c2             	movslq %edx,%rax
  80042166b2:	48 c1 e0 03          	shl    $0x3,%rax
  80042166b6:	48 89 c2             	mov    %rax,%rdx
  80042166b9:	48 c1 e2 04          	shl    $0x4,%rdx
  80042166bd:	48 29 c2             	sub    %rax,%rdx
  80042166c0:	48 8d 04 16          	lea    (%rsi,%rdx,1),%rax
  80042166c4:	88 08                	mov    %cl,(%rax)
				ncpu++;
  80042166c6:	48 b8 e8 33 36 04 80 	movabs $0x80043633e8,%rax
  80042166cd:	00 00 00 
  80042166d0:	8b 00                	mov    (%rax),%eax
  80042166d2:	8d 50 01             	lea    0x1(%rax),%edx
  80042166d5:	48 b8 e8 33 36 04 80 	movabs $0x80043633e8,%rax
  80042166dc:	00 00 00 
  80042166df:	89 10                	mov    %edx,(%rax)
  80042166e1:	eb 28                	jmp    800421670b <mp_init+0x186>
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
					proc->apicid);
  80042166e3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042166e7:	0f b6 40 01          	movzbl 0x1(%rax),%eax
				bootcpu = &cpus[ncpu];
			if (ncpu < NCPU) {
				cpus[ncpu].cpu_id = ncpu;
				ncpu++;
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
  80042166eb:	0f b6 c0             	movzbl %al,%eax
  80042166ee:	89 c6                	mov    %eax,%esi
  80042166f0:	48 bf 18 9b 21 04 80 	movabs $0x8004219b18,%rdi
  80042166f7:	00 00 00 
  80042166fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042166ff:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004216706:	00 00 00 
  8004216709:	ff d2                	callq  *%rdx
					proc->apicid);
			}
			p += sizeof(struct mpproc);
  800421670b:	48 83 45 e8 14       	addq   $0x14,-0x18(%rbp)
			continue;
  8004216710:	eb 4c                	jmp    800421675e <mp_init+0x1d9>
		case MPBUS:
		case MPIOAPIC:
		case MPIOINTR:
		case MPLINTR:
			p += 8;
  8004216712:	48 83 45 e8 08       	addq   $0x8,-0x18(%rbp)
			continue;
  8004216717:	eb 45                	jmp    800421675e <mp_init+0x1d9>
		default:
			cprintf("mpinit: unknown config type %x\n", *p);
  8004216719:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421671d:	0f b6 00             	movzbl (%rax),%eax
  8004216720:	0f b6 c0             	movzbl %al,%eax
  8004216723:	89 c6                	mov    %eax,%esi
  8004216725:	48 bf 40 9b 21 04 80 	movabs $0x8004219b40,%rdi
  800421672c:	00 00 00 
  800421672f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216734:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  800421673b:	00 00 00 
  800421673e:	ff d2                	callq  *%rdx
			ismp = 0;
  8004216740:	48 b8 00 30 36 04 80 	movabs $0x8004363000,%rax
  8004216747:	00 00 00 
  800421674a:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			i = conf->entry;
  8004216750:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216754:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004216758:	0f b7 c0             	movzwl %ax,%eax
  800421675b:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if ((conf = mpconfig(&mp)) == 0)
		return;
	ismp = 1;
	lapicaddr = conf->lapicaddr;

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  800421675e:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  8004216762:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216766:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  800421676a:	0f b7 c0             	movzwl %ax,%eax
  800421676d:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8004216770:	0f 87 90 fe ff ff    	ja     8004216606 <mp_init+0x81>
			ismp = 0;
			i = conf->entry;
		}
	}

	bootcpu->cpu_status = CPU_STARTED;
  8004216776:	48 b8 e0 33 36 04 80 	movabs $0x80043633e0,%rax
  800421677d:	00 00 00 
  8004216780:	48 8b 00             	mov    (%rax),%rax
  8004216783:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
	if (!ismp) {
  800421678a:	48 b8 00 30 36 04 80 	movabs $0x8004363000,%rax
  8004216791:	00 00 00 
  8004216794:	8b 00                	mov    (%rax),%eax
  8004216796:	85 c0                	test   %eax,%eax
  8004216798:	75 41                	jne    80042167db <mp_init+0x256>
		// Didn't like what we found; fall back to no MP.
		ncpu = 1;
  800421679a:	48 b8 e8 33 36 04 80 	movabs $0x80043633e8,%rax
  80042167a1:	00 00 00 
  80042167a4:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
		lapicaddr = 0;
  80042167aa:	48 b8 00 40 3e 04 80 	movabs $0x80043e4000,%rax
  80042167b1:	00 00 00 
  80042167b4:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		cprintf("SMP: configuration not found, SMP disabled\n");
  80042167bb:	48 bf 60 9b 21 04 80 	movabs $0x8004219b60,%rdi
  80042167c2:	00 00 00 
  80042167c5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042167ca:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  80042167d1:	00 00 00 
  80042167d4:	ff d2                	callq  *%rdx
		return;
  80042167d6:	e9 a2 00 00 00       	jmpq   800421687d <mp_init+0x2f8>
	}
	cprintf("SMP: CPU %d found %d CPU(s)\n", bootcpu->cpu_id,  ncpu);
  80042167db:	48 b8 e8 33 36 04 80 	movabs $0x80043633e8,%rax
  80042167e2:	00 00 00 
  80042167e5:	8b 10                	mov    (%rax),%edx
  80042167e7:	48 b8 e0 33 36 04 80 	movabs $0x80043633e0,%rax
  80042167ee:	00 00 00 
  80042167f1:	48 8b 00             	mov    (%rax),%rax
  80042167f4:	0f b6 00             	movzbl (%rax),%eax
  80042167f7:	0f b6 c0             	movzbl %al,%eax
  80042167fa:	89 c6                	mov    %eax,%esi
  80042167fc:	48 bf 8c 9b 21 04 80 	movabs $0x8004219b8c,%rdi
  8004216803:	00 00 00 
  8004216806:	b8 00 00 00 00       	mov    $0x0,%eax
  800421680b:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  8004216812:	00 00 00 
  8004216815:	ff d1                	callq  *%rcx

	if (mp->imcrp) {
  8004216817:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421681b:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  800421681f:	84 c0                	test   %al,%al
  8004216821:	74 5a                	je     800421687d <mp_init+0x2f8>
		// [MP 3.2.6.1] If the hardware implements PIC mode,
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
  8004216823:	48 bf b0 9b 21 04 80 	movabs $0x8004219bb0,%rdi
  800421682a:	00 00 00 
  800421682d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216832:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  8004216839:	00 00 00 
  800421683c:	ff d2                	callq  *%rdx
  800421683e:	c7 45 cc 22 00 00 00 	movl   $0x22,-0x34(%rbp)
  8004216845:	c6 45 cb 70          	movb   $0x70,-0x35(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004216849:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  800421684d:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004216850:	ee                   	out    %al,(%dx)
  8004216851:	c7 45 c4 23 00 00 00 	movl   $0x23,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004216858:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421685b:	89 c2                	mov    %eax,%edx
  800421685d:	ec                   	in     (%dx),%al
  800421685e:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  8004216861:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  8004216865:	83 c8 01             	or     $0x1,%eax
  8004216868:	0f b6 c0             	movzbl %al,%eax
  800421686b:	c7 45 bc 23 00 00 00 	movl   $0x23,-0x44(%rbp)
  8004216872:	88 45 bb             	mov    %al,-0x45(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004216875:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004216879:	8b 55 bc             	mov    -0x44(%rbp),%edx
  800421687c:	ee                   	out    %al,(%dx)
	}
}
  800421687d:	48 83 c4 48          	add    $0x48,%rsp
  8004216881:	5b                   	pop    %rbx
  8004216882:	5d                   	pop    %rbp
  8004216883:	c3                   	retq   

0000008004216884 <lapicw>:
physaddr_t lapicaddr;        // Initialized in mpconfig.c
volatile uint32_t *lapic;

static void
lapicw(int index, int value)
{
  8004216884:	55                   	push   %rbp
  8004216885:	48 89 e5             	mov    %rsp,%rbp
  8004216888:	48 83 ec 08          	sub    $0x8,%rsp
  800421688c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800421688f:	89 75 f8             	mov    %esi,-0x8(%rbp)
	lapic[index] = value;
  8004216892:	48 b8 08 40 3e 04 80 	movabs $0x80043e4008,%rax
  8004216899:	00 00 00 
  800421689c:	48 8b 00             	mov    (%rax),%rax
  800421689f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042168a2:	48 63 d2             	movslq %edx,%rdx
  80042168a5:	48 c1 e2 02          	shl    $0x2,%rdx
  80042168a9:	48 01 c2             	add    %rax,%rdx
  80042168ac:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042168af:	89 02                	mov    %eax,(%rdx)
	lapic[ID];  // wait for write to finish, by reading
  80042168b1:	48 b8 08 40 3e 04 80 	movabs $0x80043e4008,%rax
  80042168b8:	00 00 00 
  80042168bb:	48 8b 00             	mov    (%rax),%rax
  80042168be:	48 83 c0 20          	add    $0x20,%rax
  80042168c2:	8b 00                	mov    (%rax),%eax
}
  80042168c4:	c9                   	leaveq 
  80042168c5:	c3                   	retq   

00000080042168c6 <lapic_init>:

void
lapic_init(void)
{
  80042168c6:	55                   	push   %rbp
  80042168c7:	48 89 e5             	mov    %rsp,%rbp
	if (!lapicaddr)
  80042168ca:	48 b8 00 40 3e 04 80 	movabs $0x80043e4000,%rax
  80042168d1:	00 00 00 
  80042168d4:	48 8b 00             	mov    (%rax),%rax
  80042168d7:	48 85 c0             	test   %rax,%rax
  80042168da:	75 05                	jne    80042168e1 <lapic_init+0x1b>
		return;
  80042168dc:	e9 da 01 00 00       	jmpq   8004216abb <lapic_init+0x1f5>

	// lapicaddr is the physical address of the LAPIC's 4K MMIO
	// region.  Map it in to virtual memory so we can access it.
	lapic = mmio_map_region(lapicaddr, 4096);
  80042168e1:	48 b8 00 40 3e 04 80 	movabs $0x80043e4000,%rax
  80042168e8:	00 00 00 
  80042168eb:	48 8b 00             	mov    (%rax),%rax
  80042168ee:	be 00 10 00 00       	mov    $0x1000,%esi
  80042168f3:	48 89 c7             	mov    %rax,%rdi
  80042168f6:	48 b8 24 40 20 04 80 	movabs $0x8004204024,%rax
  80042168fd:	00 00 00 
  8004216900:	ff d0                	callq  *%rax
  8004216902:	48 ba 08 40 3e 04 80 	movabs $0x80043e4008,%rdx
  8004216909:	00 00 00 
  800421690c:	48 89 02             	mov    %rax,(%rdx)

	// Enable local APIC; set spurious interrupt vector.
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));
  800421690f:	be 27 01 00 00       	mov    $0x127,%esi
  8004216914:	bf 3c 00 00 00       	mov    $0x3c,%edi
  8004216919:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  8004216920:	00 00 00 
  8004216923:	ff d0                	callq  *%rax

	// The timer repeatedly counts down at bus frequency
	// from lapic[TICR] and then issues an interrupt.  
	// If we cared more about precise timekeeping,
	// TICR would be calibrated using an external time source.
	lapicw(TDCR, X1);
  8004216925:	be 0b 00 00 00       	mov    $0xb,%esi
  800421692a:	bf f8 00 00 00       	mov    $0xf8,%edi
  800421692f:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  8004216936:	00 00 00 
  8004216939:	ff d0                	callq  *%rax
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
  800421693b:	be 20 00 02 00       	mov    $0x20020,%esi
  8004216940:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004216945:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  800421694c:	00 00 00 
  800421694f:	ff d0                	callq  *%rax
	lapicw(TICR, 10000000); 
  8004216951:	be 80 96 98 00       	mov    $0x989680,%esi
  8004216956:	bf e0 00 00 00       	mov    $0xe0,%edi
  800421695b:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  8004216962:	00 00 00 
  8004216965:	ff d0                	callq  *%rax
	//
	// According to Intel MP Specification, the BIOS should initialize
	// BSP's local APIC in Virtual Wire Mode, in which 8259A's
	// INTR is virtually connected to BSP's LINTIN0. In this mode,
	// we do not need to program the IOAPIC.
	if (thiscpu != bootcpu)
  8004216967:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  800421696e:	00 00 00 
  8004216971:	ff d0                	callq  *%rax
  8004216973:	48 98                	cltq   
  8004216975:	48 c1 e0 03          	shl    $0x3,%rax
  8004216979:	48 89 c2             	mov    %rax,%rdx
  800421697c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216980:	48 29 c2             	sub    %rax,%rdx
  8004216983:	48 b8 20 30 36 04 80 	movabs $0x8004363020,%rax
  800421698a:	00 00 00 
  800421698d:	48 01 c2             	add    %rax,%rdx
  8004216990:	48 b8 e0 33 36 04 80 	movabs $0x80043633e0,%rax
  8004216997:	00 00 00 
  800421699a:	48 8b 00             	mov    (%rax),%rax
  800421699d:	48 39 c2             	cmp    %rax,%rdx
  80042169a0:	74 16                	je     80042169b8 <lapic_init+0xf2>
		lapicw(LINT0, MASKED);
  80042169a2:	be 00 00 01 00       	mov    $0x10000,%esi
  80042169a7:	bf d4 00 00 00       	mov    $0xd4,%edi
  80042169ac:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  80042169b3:	00 00 00 
  80042169b6:	ff d0                	callq  *%rax

	// Disable NMI (LINT1) on all CPUs
	lapicw(LINT1, MASKED);
  80042169b8:	be 00 00 01 00       	mov    $0x10000,%esi
  80042169bd:	bf d8 00 00 00       	mov    $0xd8,%edi
  80042169c2:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  80042169c9:	00 00 00 
  80042169cc:	ff d0                	callq  *%rax

	// Disable performance counter overflow interrupts
	// on machines that provide that interrupt entry.
	if (((lapic[VER]>>16) & 0xFF) >= 4)
  80042169ce:	48 b8 08 40 3e 04 80 	movabs $0x80043e4008,%rax
  80042169d5:	00 00 00 
  80042169d8:	48 8b 00             	mov    (%rax),%rax
  80042169db:	48 83 c0 30          	add    $0x30,%rax
  80042169df:	8b 00                	mov    (%rax),%eax
  80042169e1:	c1 e8 10             	shr    $0x10,%eax
  80042169e4:	0f b6 c0             	movzbl %al,%eax
  80042169e7:	83 f8 03             	cmp    $0x3,%eax
  80042169ea:	76 16                	jbe    8004216a02 <lapic_init+0x13c>
		lapicw(PCINT, MASKED);
  80042169ec:	be 00 00 01 00       	mov    $0x10000,%esi
  80042169f1:	bf d0 00 00 00       	mov    $0xd0,%edi
  80042169f6:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  80042169fd:	00 00 00 
  8004216a00:	ff d0                	callq  *%rax

	// Map error interrupt to IRQ_ERROR.
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);
  8004216a02:	be 33 00 00 00       	mov    $0x33,%esi
  8004216a07:	bf dc 00 00 00       	mov    $0xdc,%edi
  8004216a0c:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  8004216a13:	00 00 00 
  8004216a16:	ff d0                	callq  *%rax

	// Clear error status register (requires back-to-back writes).
	lapicw(ESR, 0);
  8004216a18:	be 00 00 00 00       	mov    $0x0,%esi
  8004216a1d:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004216a22:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  8004216a29:	00 00 00 
  8004216a2c:	ff d0                	callq  *%rax
	lapicw(ESR, 0);
  8004216a2e:	be 00 00 00 00       	mov    $0x0,%esi
  8004216a33:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004216a38:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  8004216a3f:	00 00 00 
  8004216a42:	ff d0                	callq  *%rax

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);
  8004216a44:	be 00 00 00 00       	mov    $0x0,%esi
  8004216a49:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004216a4e:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  8004216a55:	00 00 00 
  8004216a58:	ff d0                	callq  *%rax

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
  8004216a5a:	be 00 00 00 00       	mov    $0x0,%esi
  8004216a5f:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004216a64:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  8004216a6b:	00 00 00 
  8004216a6e:	ff d0                	callq  *%rax
	lapicw(ICRLO, BCAST | INIT | LEVEL);
  8004216a70:	be 00 85 08 00       	mov    $0x88500,%esi
  8004216a75:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216a7a:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  8004216a81:	00 00 00 
  8004216a84:	ff d0                	callq  *%rax
	while(lapic[ICRLO] & DELIVS)
  8004216a86:	90                   	nop
  8004216a87:	48 b8 08 40 3e 04 80 	movabs $0x80043e4008,%rax
  8004216a8e:	00 00 00 
  8004216a91:	48 8b 00             	mov    (%rax),%rax
  8004216a94:	48 05 00 03 00 00    	add    $0x300,%rax
  8004216a9a:	8b 00                	mov    (%rax),%eax
  8004216a9c:	25 00 10 00 00       	and    $0x1000,%eax
  8004216aa1:	85 c0                	test   %eax,%eax
  8004216aa3:	75 e2                	jne    8004216a87 <lapic_init+0x1c1>
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
  8004216aa5:	be 00 00 00 00       	mov    $0x0,%esi
  8004216aaa:	bf 20 00 00 00       	mov    $0x20,%edi
  8004216aaf:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  8004216ab6:	00 00 00 
  8004216ab9:	ff d0                	callq  *%rax
}
  8004216abb:	5d                   	pop    %rbp
  8004216abc:	c3                   	retq   

0000008004216abd <cpunum>:

int
cpunum(void)
{
  8004216abd:	55                   	push   %rbp
  8004216abe:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004216ac1:	48 b8 08 40 3e 04 80 	movabs $0x80043e4008,%rax
  8004216ac8:	00 00 00 
  8004216acb:	48 8b 00             	mov    (%rax),%rax
  8004216ace:	48 85 c0             	test   %rax,%rax
  8004216ad1:	74 18                	je     8004216aeb <cpunum+0x2e>
		return lapic[ID] >> 24;
  8004216ad3:	48 b8 08 40 3e 04 80 	movabs $0x80043e4008,%rax
  8004216ada:	00 00 00 
  8004216add:	48 8b 00             	mov    (%rax),%rax
  8004216ae0:	48 83 c0 20          	add    $0x20,%rax
  8004216ae4:	8b 00                	mov    (%rax),%eax
  8004216ae6:	c1 e8 18             	shr    $0x18,%eax
  8004216ae9:	eb 05                	jmp    8004216af0 <cpunum+0x33>
	return 0;
  8004216aeb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004216af0:	5d                   	pop    %rbp
  8004216af1:	c3                   	retq   

0000008004216af2 <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  8004216af2:	55                   	push   %rbp
  8004216af3:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004216af6:	48 b8 08 40 3e 04 80 	movabs $0x80043e4008,%rax
  8004216afd:	00 00 00 
  8004216b00:	48 8b 00             	mov    (%rax),%rax
  8004216b03:	48 85 c0             	test   %rax,%rax
  8004216b06:	74 16                	je     8004216b1e <lapic_eoi+0x2c>
		lapicw(EOI, 0);
  8004216b08:	be 00 00 00 00       	mov    $0x0,%esi
  8004216b0d:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004216b12:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  8004216b19:	00 00 00 
  8004216b1c:	ff d0                	callq  *%rax
}
  8004216b1e:	5d                   	pop    %rbp
  8004216b1f:	c3                   	retq   

0000008004216b20 <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  8004216b20:	55                   	push   %rbp
  8004216b21:	48 89 e5             	mov    %rsp,%rbp
  8004216b24:	48 83 ec 04          	sub    $0x4,%rsp
  8004216b28:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
  8004216b2b:	c9                   	leaveq 
  8004216b2c:	c3                   	retq   

0000008004216b2d <lapic_startap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uint8_t apicid, uint32_t addr)
{
  8004216b2d:	55                   	push   %rbp
  8004216b2e:	48 89 e5             	mov    %rsp,%rbp
  8004216b31:	48 83 ec 40          	sub    $0x40,%rsp
  8004216b35:	89 f8                	mov    %edi,%eax
  8004216b37:	89 75 c8             	mov    %esi,-0x38(%rbp)
  8004216b3a:	88 45 cc             	mov    %al,-0x34(%rbp)
  8004216b3d:	c7 45 dc 70 00 00 00 	movl   $0x70,-0x24(%rbp)
  8004216b44:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
  8004216b48:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004216b4c:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004216b4f:	ee                   	out    %al,(%dx)
  8004216b50:	c7 45 d4 71 00 00 00 	movl   $0x71,-0x2c(%rbp)
  8004216b57:	c6 45 d3 0a          	movb   $0xa,-0x2d(%rbp)
  8004216b5b:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004216b5f:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004216b62:	ee                   	out    %al,(%dx)
	// "The BSP must initialize CMOS shutdown code to 0AH
	// and the warm reset vector (DWORD based at 40:67) to point at
	// the AP startup code prior to the [universal startup algorithm]."
	outb(IO_RTC, 0xF);  // offset 0xF is shutdown code
	outb(IO_RTC+1, 0x0A);
	wrv = (uint16_t *)KADDR((0x40 << 4 | 0x67));  // Warm reset vector
  8004216b63:	48 c7 45 f0 67 04 00 	movq   $0x467,-0x10(%rbp)
  8004216b6a:	00 
  8004216b6b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216b6f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004216b73:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004216b76:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004216b79:	48 b8 b0 17 36 04 80 	movabs $0x80043617b0,%rax
  8004216b80:	00 00 00 
  8004216b83:	48 8b 00             	mov    (%rax),%rax
  8004216b86:	48 39 c2             	cmp    %rax,%rdx
  8004216b89:	72 32                	jb     8004216bbd <lapic_startap+0x90>
  8004216b8b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216b8f:	48 89 c1             	mov    %rax,%rcx
  8004216b92:	48 ba f8 9b 21 04 80 	movabs $0x8004219bf8,%rdx
  8004216b99:	00 00 00 
  8004216b9c:	be 98 00 00 00       	mov    $0x98,%esi
  8004216ba1:	48 bf 1b 9c 21 04 80 	movabs $0x8004219c1b,%rdi
  8004216ba8:	00 00 00 
  8004216bab:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216bb0:	49 b8 0b 05 20 04 80 	movabs $0x800420050b,%r8
  8004216bb7:	00 00 00 
  8004216bba:	41 ff d0             	callq  *%r8
  8004216bbd:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004216bc4:	00 00 00 
  8004216bc7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216bcb:	48 01 d0             	add    %rdx,%rax
  8004216bce:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	wrv[0] = 0;
  8004216bd2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216bd6:	66 c7 00 00 00       	movw   $0x0,(%rax)
	wrv[1] = addr >> 4;
  8004216bdb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216bdf:	48 8d 50 02          	lea    0x2(%rax),%rdx
  8004216be3:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004216be6:	c1 e8 04             	shr    $0x4,%eax
  8004216be9:	66 89 02             	mov    %ax,(%rdx)

	// "Universal startup algorithm."
	// Send INIT (level-triggered) interrupt to reset other CPU.
	lapicw(ICRHI, apicid << 24);
  8004216bec:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004216bf0:	c1 e0 18             	shl    $0x18,%eax
  8004216bf3:	89 c6                	mov    %eax,%esi
  8004216bf5:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004216bfa:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  8004216c01:	00 00 00 
  8004216c04:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL | ASSERT);
  8004216c06:	be 00 c5 00 00       	mov    $0xc500,%esi
  8004216c0b:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216c10:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  8004216c17:	00 00 00 
  8004216c1a:	ff d0                	callq  *%rax
	microdelay(200);
  8004216c1c:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004216c21:	48 b8 20 6b 21 04 80 	movabs $0x8004216b20,%rax
  8004216c28:	00 00 00 
  8004216c2b:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL);
  8004216c2d:	be 00 85 00 00       	mov    $0x8500,%esi
  8004216c32:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216c37:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  8004216c3e:	00 00 00 
  8004216c41:	ff d0                	callq  *%rax
	microdelay(100);    // should be 10ms, but too slow in Bochs!
  8004216c43:	bf 64 00 00 00       	mov    $0x64,%edi
  8004216c48:	48 b8 20 6b 21 04 80 	movabs $0x8004216b20,%rax
  8004216c4f:	00 00 00 
  8004216c52:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004216c54:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004216c5b:	eb 4b                	jmp    8004216ca8 <lapic_startap+0x17b>
		lapicw(ICRHI, apicid << 24);
  8004216c5d:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004216c61:	c1 e0 18             	shl    $0x18,%eax
  8004216c64:	89 c6                	mov    %eax,%esi
  8004216c66:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004216c6b:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  8004216c72:	00 00 00 
  8004216c75:	ff d0                	callq  *%rax
		lapicw(ICRLO, STARTUP | (addr >> 12));
  8004216c77:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004216c7a:	c1 e8 0c             	shr    $0xc,%eax
  8004216c7d:	80 cc 06             	or     $0x6,%ah
  8004216c80:	89 c6                	mov    %eax,%esi
  8004216c82:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216c87:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  8004216c8e:	00 00 00 
  8004216c91:	ff d0                	callq  *%rax
		microdelay(200);
  8004216c93:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004216c98:	48 b8 20 6b 21 04 80 	movabs $0x8004216b20,%rax
  8004216c9f:	00 00 00 
  8004216ca2:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004216ca4:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004216ca8:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  8004216cac:	7e af                	jle    8004216c5d <lapic_startap+0x130>
		lapicw(ICRHI, apicid << 24);
		lapicw(ICRLO, STARTUP | (addr >> 12));
		microdelay(200);
	}
}
  8004216cae:	c9                   	leaveq 
  8004216caf:	c3                   	retq   

0000008004216cb0 <lapic_ipi>:

void
lapic_ipi(int vector)
{
  8004216cb0:	55                   	push   %rbp
  8004216cb1:	48 89 e5             	mov    %rsp,%rbp
  8004216cb4:	48 83 ec 08          	sub    $0x8,%rsp
  8004216cb8:	89 7d fc             	mov    %edi,-0x4(%rbp)
	lapicw(ICRLO, OTHERS | FIXED | vector);
  8004216cbb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004216cbe:	0d 00 00 0c 00       	or     $0xc0000,%eax
  8004216cc3:	89 c6                	mov    %eax,%esi
  8004216cc5:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216cca:	48 b8 84 68 21 04 80 	movabs $0x8004216884,%rax
  8004216cd1:	00 00 00 
  8004216cd4:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  8004216cd6:	90                   	nop
  8004216cd7:	48 b8 08 40 3e 04 80 	movabs $0x80043e4008,%rax
  8004216cde:	00 00 00 
  8004216ce1:	48 8b 00             	mov    (%rax),%rax
  8004216ce4:	48 05 00 03 00 00    	add    $0x300,%rax
  8004216cea:	8b 00                	mov    (%rax),%eax
  8004216cec:	25 00 10 00 00       	and    $0x1000,%eax
  8004216cf1:	85 c0                	test   %eax,%eax
  8004216cf3:	75 e2                	jne    8004216cd7 <lapic_ipi+0x27>
		;
}
  8004216cf5:	c9                   	leaveq 
  8004216cf6:	c3                   	retq   

0000008004216cf7 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004216cf7:	55                   	push   %rbp
  8004216cf8:	48 89 e5             	mov    %rsp,%rbp
  8004216cfb:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004216cff:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004216d03:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004216d06:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004216d0a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216d0d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004216d11:	f0 87 02             	lock xchg %eax,(%rdx)
  8004216d14:	89 45 fc             	mov    %eax,-0x4(%rbp)
	"+m" (*addr), "=a" (result):
	"1"(newval):
	"cc");
	return result;
  8004216d17:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004216d1a:	c9                   	leaveq 
  8004216d1b:	c3                   	retq   

0000008004216d1c <get_caller_pcs>:

#ifdef DEBUG_SPINLOCK
// Record the current call stack in pcs[] by following the %ebp chain.
static void
get_caller_pcs(uint64_t pcs[])
{
  8004216d1c:	55                   	push   %rbp
  8004216d1d:	48 89 e5             	mov    %rsp,%rbp
  8004216d20:	48 83 ec 28          	sub    $0x28,%rsp
  8004216d24:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

static __inline uint64_t
read_rbp(void)
{
        uint64_t rbp;
        __asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  8004216d28:	48 89 e8             	mov    %rbp,%rax
  8004216d2b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        return rbp;
  8004216d2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
  8004216d33:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (i = 0; i < 10; i++){
  8004216d37:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004216d3e:	eb 45                	jmp    8004216d85 <get_caller_pcs+0x69>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
  8004216d40:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004216d45:	74 44                	je     8004216d8b <get_caller_pcs+0x6f>
  8004216d47:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004216d4e:	00 00 00 
  8004216d51:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004216d55:	76 34                	jbe    8004216d8b <get_caller_pcs+0x6f>
			break;
		pcs[i] = rbp[1];          // saved %rip
  8004216d57:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216d5a:	48 98                	cltq   
  8004216d5c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004216d63:	00 
  8004216d64:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216d68:	48 01 c2             	add    %rax,%rdx
  8004216d6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216d6f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004216d73:	48 89 02             	mov    %rax,(%rdx)
		rbp = (uint64_t *)rbp[0]; // saved %rbp
  8004216d76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216d7a:	48 8b 00             	mov    (%rax),%rax
  8004216d7d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
{
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
	for (i = 0; i < 10; i++){
  8004216d81:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216d85:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004216d89:	7e b5                	jle    8004216d40 <get_caller_pcs+0x24>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004216d8b:	eb 1f                	jmp    8004216dac <get_caller_pcs+0x90>
		pcs[i] = 0;
  8004216d8d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216d90:	48 98                	cltq   
  8004216d92:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004216d99:	00 
  8004216d9a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216d9e:	48 01 d0             	add    %rdx,%rax
  8004216da1:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004216da8:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216dac:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004216db0:	7e db                	jle    8004216d8d <get_caller_pcs+0x71>
		pcs[i] = 0;
}
  8004216db2:	c9                   	leaveq 
  8004216db3:	c3                   	retq   

0000008004216db4 <holding>:

// Check whether this CPU is holding the lock.
static int
holding(struct spinlock *lock)
{
  8004216db4:	55                   	push   %rbp
  8004216db5:	48 89 e5             	mov    %rsp,%rbp
  8004216db8:	53                   	push   %rbx
  8004216db9:	48 83 ec 18          	sub    $0x18,%rsp
  8004216dbd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return lock->locked && lock->cpu == thiscpu;
  8004216dc1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216dc5:	8b 00                	mov    (%rax),%eax
  8004216dc7:	85 c0                	test   %eax,%eax
  8004216dc9:	74 3d                	je     8004216e08 <holding+0x54>
  8004216dcb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216dcf:	48 8b 58 10          	mov    0x10(%rax),%rbx
  8004216dd3:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004216dda:	00 00 00 
  8004216ddd:	ff d0                	callq  *%rax
  8004216ddf:	48 98                	cltq   
  8004216de1:	48 c1 e0 03          	shl    $0x3,%rax
  8004216de5:	48 89 c2             	mov    %rax,%rdx
  8004216de8:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216dec:	48 29 c2             	sub    %rax,%rdx
  8004216def:	48 b8 20 30 36 04 80 	movabs $0x8004363020,%rax
  8004216df6:	00 00 00 
  8004216df9:	48 01 d0             	add    %rdx,%rax
  8004216dfc:	48 39 c3             	cmp    %rax,%rbx
  8004216dff:	75 07                	jne    8004216e08 <holding+0x54>
  8004216e01:	b8 01 00 00 00       	mov    $0x1,%eax
  8004216e06:	eb 05                	jmp    8004216e0d <holding+0x59>
  8004216e08:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004216e0d:	48 83 c4 18          	add    $0x18,%rsp
  8004216e11:	5b                   	pop    %rbx
  8004216e12:	5d                   	pop    %rbp
  8004216e13:	c3                   	retq   

0000008004216e14 <__spin_initlock>:
#endif

void
__spin_initlock(struct spinlock *lk, char *name)
{
  8004216e14:	55                   	push   %rbp
  8004216e15:	48 89 e5             	mov    %rsp,%rbp
  8004216e18:	48 83 ec 10          	sub    $0x10,%rsp
  8004216e1c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004216e20:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	lk->locked = 0;
  8004216e24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216e28:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
#ifdef DEBUG_SPINLOCK
	lk->name = name;
  8004216e2e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216e32:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004216e36:	48 89 50 08          	mov    %rdx,0x8(%rax)
	lk->cpu = 0;
  8004216e3a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216e3e:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004216e45:	00 
#endif
}
  8004216e46:	c9                   	leaveq 
  8004216e47:	c3                   	retq   

0000008004216e48 <spin_lock>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
spin_lock(struct spinlock *lk)
{
  8004216e48:	55                   	push   %rbp
  8004216e49:	48 89 e5             	mov    %rsp,%rbp
  8004216e4c:	53                   	push   %rbx
  8004216e4d:	48 83 ec 18          	sub    $0x18,%rsp
  8004216e51:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
  8004216e55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216e59:	48 89 c7             	mov    %rax,%rdi
  8004216e5c:	48 b8 b4 6d 21 04 80 	movabs $0x8004216db4,%rax
  8004216e63:	00 00 00 
  8004216e66:	ff d0                	callq  *%rax
  8004216e68:	85 c0                	test   %eax,%eax
  8004216e6a:	74 44                	je     8004216eb0 <spin_lock+0x68>
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
  8004216e6c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216e70:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216e74:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004216e7b:	00 00 00 
  8004216e7e:	ff d0                	callq  *%rax
  8004216e80:	49 89 d8             	mov    %rbx,%r8
  8004216e83:	89 c1                	mov    %eax,%ecx
  8004216e85:	48 ba 38 9c 21 04 80 	movabs $0x8004219c38,%rdx
  8004216e8c:	00 00 00 
  8004216e8f:	be 41 00 00 00       	mov    $0x41,%esi
  8004216e94:	48 bf 62 9c 21 04 80 	movabs $0x8004219c62,%rdi
  8004216e9b:	00 00 00 
  8004216e9e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216ea3:	49 b9 0b 05 20 04 80 	movabs $0x800420050b,%r9
  8004216eaa:	00 00 00 
  8004216ead:	41 ff d1             	callq  *%r9
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004216eb0:	eb 02                	jmp    8004216eb4 <spin_lock+0x6c>
		asm volatile ("pause");
  8004216eb2:	f3 90                	pause  
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004216eb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216eb8:	be 01 00 00 00       	mov    $0x1,%esi
  8004216ebd:	48 89 c7             	mov    %rax,%rdi
  8004216ec0:	48 b8 f7 6c 21 04 80 	movabs $0x8004216cf7,%rax
  8004216ec7:	00 00 00 
  8004216eca:	ff d0                	callq  *%rax
  8004216ecc:	85 c0                	test   %eax,%eax
  8004216ece:	75 e2                	jne    8004216eb2 <spin_lock+0x6a>
		asm volatile ("pause");

	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
  8004216ed0:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004216ed7:	00 00 00 
  8004216eda:	ff d0                	callq  *%rax
  8004216edc:	48 98                	cltq   
  8004216ede:	48 c1 e0 03          	shl    $0x3,%rax
  8004216ee2:	48 89 c2             	mov    %rax,%rdx
  8004216ee5:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216ee9:	48 29 c2             	sub    %rax,%rdx
  8004216eec:	48 b8 20 30 36 04 80 	movabs $0x8004363020,%rax
  8004216ef3:	00 00 00 
  8004216ef6:	48 01 c2             	add    %rax,%rdx
  8004216ef9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216efd:	48 89 50 10          	mov    %rdx,0x10(%rax)
	get_caller_pcs(lk->pcs);
  8004216f01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216f05:	48 83 c0 18          	add    $0x18,%rax
  8004216f09:	48 89 c7             	mov    %rax,%rdi
  8004216f0c:	48 b8 1c 6d 21 04 80 	movabs $0x8004216d1c,%rax
  8004216f13:	00 00 00 
  8004216f16:	ff d0                	callq  *%rax
#endif
}
  8004216f18:	48 83 c4 18          	add    $0x18,%rsp
  8004216f1c:	5b                   	pop    %rbx
  8004216f1d:	5d                   	pop    %rbp
  8004216f1e:	c3                   	retq   

0000008004216f1f <spin_unlock>:

// Release the lock.
void
spin_unlock(struct spinlock *lk)
{
  8004216f1f:	55                   	push   %rbp
  8004216f20:	48 89 e5             	mov    %rsp,%rbp
  8004216f23:	41 54                	push   %r12
  8004216f25:	53                   	push   %rbx
  8004216f26:	48 81 ec c0 04 00 00 	sub    $0x4c0,%rsp
  8004216f2d:	48 89 bd 38 fb ff ff 	mov    %rdi,-0x4c8(%rbp)
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
  8004216f34:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  8004216f3b:	48 89 c7             	mov    %rax,%rdi
  8004216f3e:	48 b8 b4 6d 21 04 80 	movabs $0x8004216db4,%rax
  8004216f45:	00 00 00 
  8004216f48:	ff d0                	callq  *%rax
  8004216f4a:	85 c0                	test   %eax,%eax
  8004216f4c:	0f 85 d2 01 00 00    	jne    8004217124 <spin_unlock+0x205>
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
  8004216f52:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  8004216f59:	48 8d 48 18          	lea    0x18(%rax),%rcx
  8004216f5d:	48 8d 85 40 fb ff ff 	lea    -0x4c0(%rbp),%rax
  8004216f64:	ba 28 00 00 00       	mov    $0x28,%edx
  8004216f69:	48 89 ce             	mov    %rcx,%rsi
  8004216f6c:	48 89 c7             	mov    %rax,%rdi
  8004216f6f:	48 b8 3e fc 20 04 80 	movabs $0x800420fc3e,%rax
  8004216f76:	00 00 00 
  8004216f79:	ff d0                	callq  *%rax
		if (!lk->cpu) 
  8004216f7b:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  8004216f82:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216f86:	48 85 c0             	test   %rax,%rax
  8004216f89:	75 39                	jne    8004216fc4 <spin_unlock+0xa5>
			cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
  8004216f8b:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  8004216f92:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216f96:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004216f9d:	00 00 00 
  8004216fa0:	ff d0                	callq  *%rax
  8004216fa2:	48 89 da             	mov    %rbx,%rdx
  8004216fa5:	89 c6                	mov    %eax,%esi
  8004216fa7:	48 bf 78 9c 21 04 80 	movabs $0x8004219c78,%rdi
  8004216fae:	00 00 00 
  8004216fb1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216fb6:	48 b9 11 96 20 04 80 	movabs $0x8004209611,%rcx
  8004216fbd:	00 00 00 
  8004216fc0:	ff d1                	callq  *%rcx
  8004216fc2:	eb 4d                	jmp    8004217011 <spin_unlock+0xf2>
				cpunum(), lk->name);
		else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
  8004216fc4:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  8004216fcb:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216fcf:	0f b6 00             	movzbl (%rax),%eax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
			cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
				cpunum(), lk->name);
		else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  8004216fd2:	44 0f b6 e0          	movzbl %al,%r12d
  8004216fd6:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  8004216fdd:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216fe1:	48 b8 bd 6a 21 04 80 	movabs $0x8004216abd,%rax
  8004216fe8:	00 00 00 
  8004216feb:	ff d0                	callq  *%rax
  8004216fed:	44 89 e1             	mov    %r12d,%ecx
  8004216ff0:	48 89 da             	mov    %rbx,%rdx
  8004216ff3:	89 c6                	mov    %eax,%esi
  8004216ff5:	48 bf b8 9c 21 04 80 	movabs $0x8004219cb8,%rdi
  8004216ffc:	00 00 00 
  8004216fff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217004:	49 b8 11 96 20 04 80 	movabs $0x8004209611,%r8
  800421700b:	00 00 00 
  800421700e:	41 ff d0             	callq  *%r8
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004217011:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004217018:	e9 c3 00 00 00       	jmpq   80042170e0 <spin_unlock+0x1c1>
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
  800421701d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004217020:	48 98                	cltq   
  8004217022:	8b 84 85 40 fb ff ff 	mov    -0x4c0(%rbp,%rax,4),%eax
  8004217029:	89 c0                	mov    %eax,%eax
  800421702b:	48 8d 95 70 fb ff ff 	lea    -0x490(%rbp),%rdx
  8004217032:	48 89 d6             	mov    %rdx,%rsi
  8004217035:	48 89 c7             	mov    %rax,%rdi
  8004217038:	48 b8 eb e8 20 04 80 	movabs $0x800420e8eb,%rax
  800421703f:	00 00 00 
  8004217042:	ff d0                	callq  *%rax
  8004217044:	85 c0                	test   %eax,%eax
  8004217046:	78 6b                	js     80042170b3 <spin_unlock+0x194>
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004217048:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421704b:	48 98                	cltq   
  800421704d:	8b 84 85 40 fb ff ff 	mov    -0x4c0(%rbp,%rax,4),%eax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004217054:	89 c2                	mov    %eax,%edx
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004217056:	48 8b 85 90 fb ff ff 	mov    -0x470(%rbp),%rax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  800421705d:	48 29 c2             	sub    %rax,%rdx
  8004217060:	49 89 d0             	mov    %rdx,%r8
  8004217063:	48 8b bd 80 fb ff ff 	mov    -0x480(%rbp),%rdi
  800421706a:	8b b5 88 fb ff ff    	mov    -0x478(%rbp),%esi
  8004217070:	8b 8d 78 fb ff ff    	mov    -0x488(%rbp),%ecx
  8004217076:	48 8b 95 70 fb ff ff 	mov    -0x490(%rbp),%rdx
  800421707d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004217080:	48 98                	cltq   
  8004217082:	8b 84 85 40 fb ff ff 	mov    -0x4c0(%rbp,%rax,4),%eax
  8004217089:	4c 89 04 24          	mov    %r8,(%rsp)
  800421708d:	49 89 f9             	mov    %rdi,%r9
  8004217090:	41 89 f0             	mov    %esi,%r8d
  8004217093:	89 c6                	mov    %eax,%esi
  8004217095:	48 bf ee 9c 21 04 80 	movabs $0x8004219cee,%rdi
  800421709c:	00 00 00 
  800421709f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042170a4:	49 ba 11 96 20 04 80 	movabs $0x8004209611,%r10
  80042170ab:	00 00 00 
  80042170ae:	41 ff d2             	callq  *%r10
  80042170b1:	eb 29                	jmp    80042170dc <spin_unlock+0x1bd>
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
  80042170b3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042170b6:	48 98                	cltq   
  80042170b8:	8b 84 85 40 fb ff ff 	mov    -0x4c0(%rbp,%rax,4),%eax
  80042170bf:	89 c6                	mov    %eax,%esi
  80042170c1:	48 bf 05 9d 21 04 80 	movabs $0x8004219d05,%rdi
  80042170c8:	00 00 00 
  80042170cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042170d0:	48 ba 11 96 20 04 80 	movabs $0x8004209611,%rdx
  80042170d7:	00 00 00 
  80042170da:	ff d2                	callq  *%rdx
			cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
				cpunum(), lk->name);
		else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  80042170dc:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042170e0:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  80042170e4:	7f 14                	jg     80042170fa <spin_unlock+0x1db>
  80042170e6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042170e9:	48 98                	cltq   
  80042170eb:	8b 84 85 40 fb ff ff 	mov    -0x4c0(%rbp,%rax,4),%eax
  80042170f2:	85 c0                	test   %eax,%eax
  80042170f4:	0f 85 23 ff ff ff    	jne    800421701d <spin_unlock+0xfe>
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
		}
		panic("spin_unlock");
  80042170fa:	48 ba 0d 9d 21 04 80 	movabs $0x8004219d0d,%rdx
  8004217101:	00 00 00 
  8004217104:	be 6b 00 00 00       	mov    $0x6b,%esi
  8004217109:	48 bf 62 9c 21 04 80 	movabs $0x8004219c62,%rdi
  8004217110:	00 00 00 
  8004217113:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217118:	48 b9 0b 05 20 04 80 	movabs $0x800420050b,%rcx
  800421711f:	00 00 00 
  8004217122:	ff d1                	callq  *%rcx
	}

	lk->pcs[0] = 0;
  8004217124:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  800421712b:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  8004217132:	00 
	lk->cpu = 0;
  8004217133:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  800421713a:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004217141:	00 
	// But the 2007 Intel 64 Architecture Memory Ordering White
	// Paper says that Intel 64 and IA-32 will not move a load
	// after a store. So lock->locked = 0 would work here.
	// The xchg being asm volatile ensures gcc emits it after
	// the above assignments (and after the critical section).
	xchg(&lk->locked, 0);
  8004217142:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  8004217149:	be 00 00 00 00       	mov    $0x0,%esi
  800421714e:	48 89 c7             	mov    %rax,%rdi
  8004217151:	48 b8 f7 6c 21 04 80 	movabs $0x8004216cf7,%rax
  8004217158:	00 00 00 
  800421715b:	ff d0                	callq  *%rax
}
  800421715d:	48 81 c4 c0 04 00 00 	add    $0x4c0,%rsp
  8004217164:	5b                   	pop    %rbx
  8004217165:	41 5c                	pop    %r12
  8004217167:	5d                   	pop    %rbp
  8004217168:	c3                   	retq   
