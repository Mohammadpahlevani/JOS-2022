
obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000000100000 <_head64>:
.globl _head64
_head64:

# Save multiboot_info addr passed by bootloader
	
    movl $multiboot_info, %eax
  100000:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  100005:	89 18                	mov    %ebx,(%rax)

    movw $0x1234,0x472			# warm boot	
  100007:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472(%rip)        # 100482 <verify_cpu_no_longmode+0x36f>
  10000e:	34 12 
	
# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  100010:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100015:	e8 cc 00 00 00       	callq  1000e6 <verify_cpu>
    movl $CR4_PAE,%eax	
  10001a:	b8 20 00 00 00       	mov    $0x20,%eax
    movl %eax,%cr4
  10001f:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100022:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100027:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100029:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002e:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  100030:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100035:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  10003a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  100040:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100042:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100047:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10004a:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004d:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  100050:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100055:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  10005a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100060:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100062:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100067:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006c:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006f:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100072:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100074:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100079:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007e:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100083:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100089:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008e:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  100090:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100092:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100095:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100098:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009d:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  1000a0:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a3:	75 e9                	jne    10008e <_head64+0x8e>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a5:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000aa:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ad:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b2:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b4:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b8:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000ba:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bd:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000c0:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c5:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000ca:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000cf:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d2:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d5:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000da:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dd:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000df:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e4:	50                   	push   %rax

00000000001000e5 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e5:	cb                   	lret   

00000000001000e6 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e6:	9c                   	pushfq 
    popl %eax
  1000e7:	58                   	pop    %rax
    movl %eax,%ecx
  1000e8:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000ea:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ef:	50                   	push   %rax
    popfl
  1000f0:	9d                   	popfq  
    pushfl
  1000f1:	9c                   	pushfq 
    popl %eax
  1000f2:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f3:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f5:	74 1c                	je     100113 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f7:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fc:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fe:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100101:	72 10                	jb     100113 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100103:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100108:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  10010a:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  100110:	74 01                	je     100113 <verify_cpu_no_longmode>

    ret
  100112:	c3                   	retq   

0000000000100113 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100113:	eb fe                	jmp    100113 <verify_cpu_no_longmode>
  100115:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10011c:	00 00 00 
  10011f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100126:	00 00 00 
  100129:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100130:	00 00 00 
  100133:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10013a:	00 00 00 
  10013d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100144:	00 00 00 
  100147:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10014e:	00 00 00 
  100151:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100158:	00 00 00 
  10015b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100162:	00 00 00 
  100165:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10016c:	00 00 00 
  10016f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100176:	00 00 00 
  100179:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100180:	00 00 00 
  100183:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10018a:	00 00 00 
  10018d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100194:	00 00 00 
  100197:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10019e:	00 00 00 
  1001a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001a8:	00 00 00 
  1001ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001b2:	00 00 00 
  1001b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001bc:	00 00 00 
  1001bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001c6:	00 00 00 
  1001c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001d0:	00 00 00 
  1001d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001da:	00 00 00 
  1001dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001e4:	00 00 00 
  1001e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001ee:	00 00 00 
  1001f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001f8:	00 00 00 
  1001fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100202:	00 00 00 
  100205:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10020c:	00 00 00 
  10020f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100216:	00 00 00 
  100219:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100220:	00 00 00 
  100223:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10022a:	00 00 00 
  10022d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100234:	00 00 00 
  100237:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10023e:	00 00 00 
  100241:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100248:	00 00 00 
  10024b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100252:	00 00 00 
  100255:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10025c:	00 00 00 
  10025f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100266:	00 00 00 
  100269:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100270:	00 00 00 
  100273:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10027a:	00 00 00 
  10027d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100284:	00 00 00 
  100287:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10028e:	00 00 00 
  100291:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100298:	00 00 00 
  10029b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002a2:	00 00 00 
  1002a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ac:	00 00 00 
  1002af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002b6:	00 00 00 
  1002b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002c0:	00 00 00 
  1002c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ca:	00 00 00 
  1002cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002d4:	00 00 00 
  1002d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002de:	00 00 00 
  1002e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002e8:	00 00 00 
  1002eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002f2:	00 00 00 
  1002f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002fc:	00 00 00 
  1002ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100306:	00 00 00 
  100309:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100310:	00 00 00 
  100313:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10031a:	00 00 00 
  10031d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100324:	00 00 00 
  100327:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10032e:	00 00 00 
  100331:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100338:	00 00 00 
  10033b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100342:	00 00 00 
  100345:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10034c:	00 00 00 
  10034f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100356:	00 00 00 
  100359:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100360:	00 00 00 
  100363:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10036a:	00 00 00 
  10036d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100374:	00 00 00 
  100377:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10037e:	00 00 00 
  100381:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100388:	00 00 00 
  10038b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100392:	00 00 00 
  100395:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10039c:	00 00 00 
  10039f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003a6:	00 00 00 
  1003a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003b0:	00 00 00 
  1003b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ba:	00 00 00 
  1003bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003c4:	00 00 00 
  1003c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ce:	00 00 00 
  1003d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003d8:	00 00 00 
  1003db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003e2:	00 00 00 
  1003e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ec:	00 00 00 
  1003ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003f6:	00 00 00 
  1003f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100400:	00 00 00 
  100403:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10040a:	00 00 00 
  10040d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100414:	00 00 00 
  100417:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10041e:	00 00 00 
  100421:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100428:	00 00 00 
  10042b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100432:	00 00 00 
  100435:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10043c:	00 00 00 
  10043f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100446:	00 00 00 
  100449:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100450:	00 00 00 
  100453:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10045a:	00 00 00 
  10045d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100464:	00 00 00 
  100467:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10046e:	00 00 00 
  100471:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100478:	00 00 00 
  10047b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100482:	00 00 00 
  100485:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10048c:	00 00 00 
  10048f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100496:	00 00 00 
  100499:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004a0:	00 00 00 
  1004a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004aa:	00 00 00 
  1004ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004b4:	00 00 00 
  1004b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004be:	00 00 00 
  1004c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004c8:	00 00 00 
  1004cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004d2:	00 00 00 
  1004d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004dc:	00 00 00 
  1004df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004e6:	00 00 00 
  1004e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004f0:	00 00 00 
  1004f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004fa:	00 00 00 
  1004fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100504:	00 00 00 
  100507:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10050e:	00 00 00 
  100511:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100518:	00 00 00 
  10051b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100522:	00 00 00 
  100525:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10052c:	00 00 00 
  10052f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100536:	00 00 00 
  100539:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100540:	00 00 00 
  100543:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10054a:	00 00 00 
  10054d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100554:	00 00 00 
  100557:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10055e:	00 00 00 
  100561:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100568:	00 00 00 
  10056b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100572:	00 00 00 
  100575:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10057c:	00 00 00 
  10057f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100586:	00 00 00 
  100589:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100590:	00 00 00 
  100593:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10059a:	00 00 00 
  10059d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005a4:	00 00 00 
  1005a7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ae:	00 00 00 
  1005b1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005b8:	00 00 00 
  1005bb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005c2:	00 00 00 
  1005c5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005cc:	00 00 00 
  1005cf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005d6:	00 00 00 
  1005d9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005e0:	00 00 00 
  1005e3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ea:	00 00 00 
  1005ed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005f4:	00 00 00 
  1005f7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005fe:	00 00 00 
  100601:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100608:	00 00 00 
  10060b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100612:	00 00 00 
  100615:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10061c:	00 00 00 
  10061f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100626:	00 00 00 
  100629:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100630:	00 00 00 
  100633:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10063a:	00 00 00 
  10063d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100644:	00 00 00 
  100647:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10064e:	00 00 00 
  100651:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100658:	00 00 00 
  10065b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100662:	00 00 00 
  100665:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10066c:	00 00 00 
  10066f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100676:	00 00 00 
  100679:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100680:	00 00 00 
  100683:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10068a:	00 00 00 
  10068d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100694:	00 00 00 
  100697:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10069e:	00 00 00 
  1006a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006a8:	00 00 00 
  1006ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006b2:	00 00 00 
  1006b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006bc:	00 00 00 
  1006bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006c6:	00 00 00 
  1006c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006d0:	00 00 00 
  1006d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006da:	00 00 00 
  1006dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006e4:	00 00 00 
  1006e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006ee:	00 00 00 
  1006f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006f8:	00 00 00 
  1006fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100702:	00 00 00 
  100705:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10070c:	00 00 00 
  10070f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100716:	00 00 00 
  100719:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100720:	00 00 00 
  100723:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10072a:	00 00 00 
  10072d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100734:	00 00 00 
  100737:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10073e:	00 00 00 
  100741:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100748:	00 00 00 
  10074b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100752:	00 00 00 
  100755:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10075c:	00 00 00 
  10075f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100766:	00 00 00 
  100769:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100770:	00 00 00 
  100773:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10077a:	00 00 00 
  10077d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100784:	00 00 00 
  100787:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10078e:	00 00 00 
  100791:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100798:	00 00 00 
  10079b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007a2:	00 00 00 
  1007a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ac:	00 00 00 
  1007af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007b6:	00 00 00 
  1007b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007c0:	00 00 00 
  1007c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ca:	00 00 00 
  1007cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007d4:	00 00 00 
  1007d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007de:	00 00 00 
  1007e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007e8:	00 00 00 
  1007eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007f2:	00 00 00 
  1007f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007fc:	00 00 00 
  1007ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100806:	00 00 00 
  100809:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100810:	00 00 00 
  100813:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10081a:	00 00 00 
  10081d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100824:	00 00 00 
  100827:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10082e:	00 00 00 
  100831:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100838:	00 00 00 
  10083b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100842:	00 00 00 
  100845:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10084c:	00 00 00 
  10084f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100856:	00 00 00 
  100859:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100860:	00 00 00 
  100863:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10086a:	00 00 00 
  10086d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100874:	00 00 00 
  100877:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10087e:	00 00 00 
  100881:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100888:	00 00 00 
  10088b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100892:	00 00 00 
  100895:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10089c:	00 00 00 
  10089f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008a6:	00 00 00 
  1008a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008b0:	00 00 00 
  1008b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ba:	00 00 00 
  1008bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008c4:	00 00 00 
  1008c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ce:	00 00 00 
  1008d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008d8:	00 00 00 
  1008db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008e2:	00 00 00 
  1008e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ec:	00 00 00 
  1008ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008f6:	00 00 00 
  1008f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100900:	00 00 00 
  100903:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10090a:	00 00 00 
  10090d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100914:	00 00 00 
  100917:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10091e:	00 00 00 
  100921:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100928:	00 00 00 
  10092b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100932:	00 00 00 
  100935:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10093c:	00 00 00 
  10093f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100946:	00 00 00 
  100949:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100950:	00 00 00 
  100953:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10095a:	00 00 00 
  10095d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100964:	00 00 00 
  100967:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10096e:	00 00 00 
  100971:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100978:	00 00 00 
  10097b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100982:	00 00 00 
  100985:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10098c:	00 00 00 
  10098f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100996:	00 00 00 
  100999:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009a0:	00 00 00 
  1009a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009aa:	00 00 00 
  1009ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009b4:	00 00 00 
  1009b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009be:	00 00 00 
  1009c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009c8:	00 00 00 
  1009cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009d2:	00 00 00 
  1009d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009dc:	00 00 00 
  1009df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009e6:	00 00 00 
  1009e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009f0:	00 00 00 
  1009f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009fa:	00 00 00 
  1009fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a04:	00 00 00 
  100a07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a0e:	00 00 00 
  100a11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a18:	00 00 00 
  100a1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a22:	00 00 00 
  100a25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a2c:	00 00 00 
  100a2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a36:	00 00 00 
  100a39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a40:	00 00 00 
  100a43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a4a:	00 00 00 
  100a4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a54:	00 00 00 
  100a57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a5e:	00 00 00 
  100a61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a68:	00 00 00 
  100a6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a72:	00 00 00 
  100a75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a7c:	00 00 00 
  100a7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a86:	00 00 00 
  100a89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a90:	00 00 00 
  100a93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a9a:	00 00 00 
  100a9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aa4:	00 00 00 
  100aa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aae:	00 00 00 
  100ab1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ab8:	00 00 00 
  100abb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ac2:	00 00 00 
  100ac5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100acc:	00 00 00 
  100acf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ad6:	00 00 00 
  100ad9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ae0:	00 00 00 
  100ae3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aea:	00 00 00 
  100aed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100af4:	00 00 00 
  100af7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100afe:	00 00 00 
  100b01:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b08:	00 00 00 
  100b0b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b12:	00 00 00 
  100b15:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b1c:	00 00 00 
  100b1f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b26:	00 00 00 
  100b29:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b30:	00 00 00 
  100b33:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b3a:	00 00 00 
  100b3d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b44:	00 00 00 
  100b47:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b4e:	00 00 00 
  100b51:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b58:	00 00 00 
  100b5b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b62:	00 00 00 
  100b65:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b6c:	00 00 00 
  100b6f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b76:	00 00 00 
  100b79:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b80:	00 00 00 
  100b83:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b8a:	00 00 00 
  100b8d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b94:	00 00 00 
  100b97:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b9e:	00 00 00 
  100ba1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ba8:	00 00 00 
  100bab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bb2:	00 00 00 
  100bb5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bbc:	00 00 00 
  100bbf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bc6:	00 00 00 
  100bc9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bd0:	00 00 00 
  100bd3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bda:	00 00 00 
  100bdd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100be4:	00 00 00 
  100be7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bee:	00 00 00 
  100bf1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bf8:	00 00 00 
  100bfb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c02:	00 00 00 
  100c05:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c0c:	00 00 00 
  100c0f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c16:	00 00 00 
  100c19:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c20:	00 00 00 
  100c23:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c2a:	00 00 00 
  100c2d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c34:	00 00 00 
  100c37:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c3e:	00 00 00 
  100c41:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c48:	00 00 00 
  100c4b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c52:	00 00 00 
  100c55:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c5c:	00 00 00 
  100c5f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c66:	00 00 00 
  100c69:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c70:	00 00 00 
  100c73:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c7a:	00 00 00 
  100c7d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c84:	00 00 00 
  100c87:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c8e:	00 00 00 
  100c91:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c98:	00 00 00 
  100c9b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ca2:	00 00 00 
  100ca5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cac:	00 00 00 
  100caf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cb6:	00 00 00 
  100cb9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cc0:	00 00 00 
  100cc3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cca:	00 00 00 
  100ccd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cd4:	00 00 00 
  100cd7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cde:	00 00 00 
  100ce1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ce8:	00 00 00 
  100ceb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cf2:	00 00 00 
  100cf5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cfc:	00 00 00 
  100cff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d06:	00 00 00 
  100d09:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d10:	00 00 00 
  100d13:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d1a:	00 00 00 
  100d1d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d24:	00 00 00 
  100d27:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d2e:	00 00 00 
  100d31:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d38:	00 00 00 
  100d3b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d42:	00 00 00 
  100d45:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d4c:	00 00 00 
  100d4f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d56:	00 00 00 
  100d59:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d60:	00 00 00 
  100d63:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d6a:	00 00 00 
  100d6d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d74:	00 00 00 
  100d77:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d7e:	00 00 00 
  100d81:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d88:	00 00 00 
  100d8b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d92:	00 00 00 
  100d95:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d9c:	00 00 00 
  100d9f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100da6:	00 00 00 
  100da9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100db0:	00 00 00 
  100db3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dba:	00 00 00 
  100dbd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dc4:	00 00 00 
  100dc7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dce:	00 00 00 
  100dd1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dd8:	00 00 00 
  100ddb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100de2:	00 00 00 
  100de5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dec:	00 00 00 
  100def:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100df6:	00 00 00 
  100df9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e00:	00 00 00 
  100e03:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e0a:	00 00 00 
  100e0d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e14:	00 00 00 
  100e17:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e1e:	00 00 00 
  100e21:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e28:	00 00 00 
  100e2b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e32:	00 00 00 
  100e35:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e3c:	00 00 00 
  100e3f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e46:	00 00 00 
  100e49:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e50:	00 00 00 
  100e53:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e5a:	00 00 00 
  100e5d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e64:	00 00 00 
  100e67:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e6e:	00 00 00 
  100e71:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e78:	00 00 00 
  100e7b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e82:	00 00 00 
  100e85:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e8c:	00 00 00 
  100e8f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e96:	00 00 00 
  100e99:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ea0:	00 00 00 
  100ea3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eaa:	00 00 00 
  100ead:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eb4:	00 00 00 
  100eb7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ebe:	00 00 00 
  100ec1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ec8:	00 00 00 
  100ecb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ed2:	00 00 00 
  100ed5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100edc:	00 00 00 
  100edf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ee6:	00 00 00 
  100ee9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ef0:	00 00 00 
  100ef3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100efa:	00 00 00 
  100efd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f04:	00 00 00 
  100f07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f0e:	00 00 00 
  100f11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f18:	00 00 00 
  100f1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f22:	00 00 00 
  100f25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f2c:	00 00 00 
  100f2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f36:	00 00 00 
  100f39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f40:	00 00 00 
  100f43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f4a:	00 00 00 
  100f4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f54:	00 00 00 
  100f57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f5e:	00 00 00 
  100f61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f68:	00 00 00 
  100f6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f72:	00 00 00 
  100f75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f7c:	00 00 00 
  100f7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f86:	00 00 00 
  100f89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f90:	00 00 00 
  100f93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f9a:	00 00 00 
  100f9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fa4:	00 00 00 
  100fa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fae:	00 00 00 
  100fb1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fb8:	00 00 00 
  100fbb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fc2:	00 00 00 
  100fc5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fcc:	00 00 00 
  100fcf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fd6:	00 00 00 
  100fd9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fe0:	00 00 00 
  100fe3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fea:	00 00 00 
  100fed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ff4:	00 00 00 
  100ff7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  100ffe:	00 00 

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4phys>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Disassembly of section .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4 48                	in     $0x48,%al

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 a0 22 04 80 	movabs $0x800422a038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 a0 22 04 80 	movabs $0x800422a000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 99 00 20 04 80 	movabs $0x8004200099,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
  800420005c:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004200060:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004200064:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004200067:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420006b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420006e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004200072:	f0 87 02             	lock xchg %eax,(%rdx)
  8004200075:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004200078:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420007b:	c9                   	leaveq 
  800420007c:	c3                   	retq   

000000800420007d <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800420007d:	55                   	push   %rbp
  800420007e:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004200081:	48 bf 20 a9 22 04 80 	movabs $0x800422a920,%rdi
  8004200088:	00 00 00 
  800420008b:	48 b8 1c 4e 21 04 80 	movabs $0x8004214e1c,%rax
  8004200092:	00 00 00 
  8004200095:	ff d0                	callq  *%rax
}
  8004200097:	5d                   	pop    %rbp
  8004200098:	c3                   	retq   

0000008004200099 <i386_init>:



void
i386_init(void)
{
  8004200099:	55                   	push   %rbp
  800420009a:	48 89 e5             	mov    %rsp,%rbp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  800420009d:	48 ba 10 10 52 04 80 	movabs $0x8004521010,%rdx
  80042000a4:	00 00 00 
  80042000a7:	48 b8 2e cc 49 04 80 	movabs $0x800449cc2e,%rax
  80042000ae:	00 00 00 
  80042000b1:	48 29 c2             	sub    %rax,%rdx
  80042000b4:	48 89 d0             	mov    %rdx,%rax
  80042000b7:	48 89 c2             	mov    %rax,%rdx
  80042000ba:	be 00 00 00 00       	mov    $0x0,%esi
  80042000bf:	48 bf 2e cc 49 04 80 	movabs $0x800449cc2e,%rdi
  80042000c6:	00 00 00 
  80042000c9:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  80042000d0:	00 00 00 
  80042000d3:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  80042000d5:	48 b8 7f 11 20 04 80 	movabs $0x800420117f,%rax
  80042000dc:	00 00 00 
  80042000df:	ff d0                	callq  *%rax

	cprintf("6828 decimal is %o octal!\n", 6828);
  80042000e1:	be ac 1a 00 00       	mov    $0x1aac,%esi
  80042000e6:	48 bf 40 51 21 04 80 	movabs $0x8004215140,%rdi
  80042000ed:	00 00 00 
  80042000f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042000f5:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042000fc:	00 00 00 
  80042000ff:	ff d2                	callq  *%rdx

	extern char end[];
	end_debug = read_section_headers((0x10000+KERNBASE), (uintptr_t)end);
  8004200101:	48 b8 10 10 52 04 80 	movabs $0x8004521010,%rax
  8004200108:	00 00 00 
  800420010b:	48 89 c6             	mov    %rax,%rsi
  800420010e:	48 bf 00 00 01 04 80 	movabs $0x8004010000,%rdi
  8004200115:	00 00 00 
  8004200118:	48 b8 16 35 21 04 80 	movabs $0x8004213516,%rax
  800420011f:	00 00 00 
  8004200122:	ff d0                	callq  *%rax
  8004200124:	48 ba 08 e7 49 04 80 	movabs $0x800449e708,%rdx
  800420012b:	00 00 00 
  800420012e:	48 89 02             	mov    %rax,(%rdx)

	// Lab 2 memory management initialization functions
	x64_vm_init();
  8004200131:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200136:	48 ba fe 2d 20 04 80 	movabs $0x8004202dfe,%rdx
  800420013d:	00 00 00 
  8004200140:	ff d2                	callq  *%rdx

	// Lab 3 user environment initialization functions
	env_init();
  8004200142:	48 b8 c9 7e 20 04 80 	movabs $0x8004207ec9,%rax
  8004200149:	00 00 00 
  800420014c:	ff d0                	callq  *%rax
	trap_init();
  800420014e:	48 b8 86 93 20 04 80 	movabs $0x8004209386,%rax
  8004200155:	00 00 00 
  8004200158:	ff d0                	callq  *%rax

	// Lab 4 multiprocessor initialization functions
	mp_init();
  800420015a:	48 b8 9d 44 21 04 80 	movabs $0x800421449d,%rax
  8004200161:	00 00 00 
  8004200164:	ff d0                	callq  *%rax
	lapic_init();
  8004200166:	48 b8 9a 48 21 04 80 	movabs $0x800421489a,%rax
  800420016d:	00 00 00 
  8004200170:	ff d0                	callq  *%rax

	// Lab 4 multitasking initialization functions
	pic_init();
  8004200172:	48 b8 3e 8f 20 04 80 	movabs $0x8004208f3e,%rax
  8004200179:	00 00 00 
  800420017c:	ff d0                	callq  *%rax

	// Acquire the big kernel lock before waking up APs
	// Your code here:

	// Starting non-boot CPUs
	lock_kernel();
  800420017e:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  8004200185:	00 00 00 
  8004200188:	ff d0                	callq  *%rax
	boot_aps();
  800420018a:	48 b8 e4 01 20 04 80 	movabs $0x80042001e4,%rax
  8004200191:	00 00 00 
  8004200194:	ff d0                	callq  *%rax




	// Start fs.
	ENV_CREATE(fs_fs, ENV_TYPE_FS);
  8004200196:	be 01 00 00 00       	mov    $0x1,%esi
  800420019b:	48 bf 83 60 3d 04 80 	movabs $0x80043d6083,%rdi
  80042001a2:	00 00 00 
  80042001a5:	48 b8 7f 85 20 04 80 	movabs $0x800420857f,%rax
  80042001ac:	00 00 00 
  80042001af:	ff d0                	callq  *%rax

#if defined(TEST)
	// Don't touch -- used by grading script!
	ENV_CREATE(TEST, ENV_TYPE_USER);
  80042001b1:	be 00 00 00 00       	mov    $0x0,%esi
  80042001b6:	48 bf 3c 05 46 04 80 	movabs $0x800446053c,%rdi
  80042001bd:	00 00 00 
  80042001c0:	48 b8 7f 85 20 04 80 	movabs $0x800420857f,%rax
  80042001c7:	00 00 00 
  80042001ca:	ff d0                	callq  *%rax

	ENV_CREATE(user_icode, ENV_TYPE_USER);
#endif // TEST*

	// Should not be necessary - drains keyboard because interrupt has given up.
	kbd_intr();
  80042001cc:	48 b8 b1 0f 20 04 80 	movabs $0x8004200fb1,%rax
  80042001d3:	00 00 00 
  80042001d6:	ff d0                	callq  *%rax

	// Schedule and run the first user environment!
	sched_yield();
  80042001d8:	48 b8 c1 b0 20 04 80 	movabs $0x800420b0c1,%rax
  80042001df:	00 00 00 
  80042001e2:	ff d0                	callq  *%rax

00000080042001e4 <boot_aps>:
void *mpentry_kstack;

// Start the non-boot (AP) processors.
static void
boot_aps(void)
{
  80042001e4:	55                   	push   %rbp
  80042001e5:	48 89 e5             	mov    %rsp,%rbp
  80042001e8:	48 83 ec 30          	sub    $0x30,%rsp
	extern unsigned char mpentry_start[], mpentry_end[];
	void *code;
	struct CpuInfo *c;

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
  80042001ec:	48 c7 45 f0 00 70 00 	movq   $0x7000,-0x10(%rbp)
  80042001f3:	00 
  80042001f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042001f8:	48 c1 e8 0c          	shr    $0xc,%rax
  80042001fc:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042001ff:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200202:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004200209:	00 00 00 
  800420020c:	48 8b 00             	mov    (%rax),%rax
  800420020f:	48 39 c2             	cmp    %rax,%rdx
  8004200212:	72 32                	jb     8004200246 <boot_aps+0x62>
  8004200214:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200218:	48 89 c1             	mov    %rax,%rcx
  800420021b:	48 ba 60 51 21 04 80 	movabs $0x8004215160,%rdx
  8004200222:	00 00 00 
  8004200225:	be 6b 00 00 00       	mov    $0x6b,%esi
  800420022a:	48 bf 83 51 21 04 80 	movabs $0x8004215183,%rdi
  8004200231:	00 00 00 
  8004200234:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200239:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004200240:	00 00 00 
  8004200243:	41 ff d0             	callq  *%r8
  8004200246:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420024d:	00 00 00 
  8004200250:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200254:	48 01 d0             	add    %rdx,%rax
  8004200257:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
  800420025b:	48 ba c6 3f 21 04 80 	movabs $0x8004213fc6,%rdx
  8004200262:	00 00 00 
  8004200265:	48 b8 e0 3e 21 04 80 	movabs $0x8004213ee0,%rax
  800420026c:	00 00 00 
  800420026f:	48 29 c2             	sub    %rax,%rdx
  8004200272:	48 89 d0             	mov    %rdx,%rax
  8004200275:	48 89 c2             	mov    %rax,%rdx
  8004200278:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420027c:	48 be e0 3e 21 04 80 	movabs $0x8004213ee0,%rsi
  8004200283:	00 00 00 
  8004200286:	48 89 c7             	mov    %rax,%rdi
  8004200289:	48 b8 81 db 20 04 80 	movabs $0x800420db81,%rax
  8004200290:	00 00 00 
  8004200293:	ff d0                	callq  *%rax
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  8004200295:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  800420029c:	00 00 00 
  800420029f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042002a3:	e9 0b 01 00 00       	jmpq   80042003b3 <boot_aps+0x1cf>
		if (c == cpus + cpunum())  // We've started already.
  80042002a8:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  80042002af:	00 00 00 
  80042002b2:	ff d0                	callq  *%rax
  80042002b4:	48 98                	cltq   
  80042002b6:	48 c1 e0 03          	shl    $0x3,%rax
  80042002ba:	48 89 c2             	mov    %rax,%rdx
  80042002bd:	48 c1 e2 04          	shl    $0x4,%rdx
  80042002c1:	48 29 c2             	sub    %rax,%rdx
  80042002c4:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  80042002cb:	00 00 00 
  80042002ce:	48 01 d0             	add    %rdx,%rax
  80042002d1:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042002d5:	75 05                	jne    80042002dc <boot_aps+0xf8>
			continue;
  80042002d7:	e9 d2 00 00 00       	jmpq   80042003ae <boot_aps+0x1ca>

		// Tell mpentry.S what stack to use 
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
  80042002dc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042002e0:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  80042002e7:	00 00 00 
  80042002ea:	48 29 c2             	sub    %rax,%rdx
  80042002ed:	48 89 d0             	mov    %rdx,%rax
  80042002f0:	48 c1 f8 03          	sar    $0x3,%rax
  80042002f4:	48 89 c2             	mov    %rax,%rdx
  80042002f7:	48 b8 ef ee ee ee ee 	movabs $0xeeeeeeeeeeeeeeef,%rax
  80042002fe:	ee ee ee 
  8004200301:	48 0f af c2          	imul   %rdx,%rax
  8004200305:	48 83 c0 01          	add    $0x1,%rax
  8004200309:	48 c1 e0 10          	shl    $0x10,%rax
  800420030d:	48 89 c2             	mov    %rax,%rdx
  8004200310:	48 b8 00 10 4a 04 80 	movabs $0x80044a1000,%rax
  8004200317:	00 00 00 
  800420031a:	48 01 c2             	add    %rax,%rdx
  800420031d:	48 b8 18 e7 49 04 80 	movabs $0x800449e718,%rax
  8004200324:	00 00 00 
  8004200327:	48 89 10             	mov    %rdx,(%rax)
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
  800420032a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420032e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004200332:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004200339:	00 00 00 
  800420033c:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004200340:	77 32                	ja     8004200374 <boot_aps+0x190>
  8004200342:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200346:	48 89 c1             	mov    %rax,%rcx
  8004200349:	48 ba 90 51 21 04 80 	movabs $0x8004215190,%rdx
  8004200350:	00 00 00 
  8004200353:	be 75 00 00 00       	mov    $0x75,%esi
  8004200358:	48 bf 83 51 21 04 80 	movabs $0x8004215183,%rdi
  800420035f:	00 00 00 
  8004200362:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200367:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420036e:	00 00 00 
  8004200371:	41 ff d0             	callq  *%r8
  8004200374:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420037b:	ff ff ff 
  800420037e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200382:	48 01 d0             	add    %rdx,%rax
  8004200385:	89 c2                	mov    %eax,%edx
  8004200387:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420038b:	0f b6 00             	movzbl (%rax),%eax
  800420038e:	0f b6 c0             	movzbl %al,%eax
  8004200391:	89 d6                	mov    %edx,%esi
  8004200393:	89 c7                	mov    %eax,%edi
  8004200395:	48 b8 01 4b 21 04 80 	movabs $0x8004214b01,%rax
  800420039c:	00 00 00 
  800420039f:	ff d0                	callq  *%rax
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
  80042003a1:	90                   	nop
  80042003a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042003a6:	8b 40 04             	mov    0x4(%rax),%eax
  80042003a9:	83 f8 01             	cmp    $0x1,%eax
  80042003ac:	75 f4                	jne    80042003a2 <boot_aps+0x1be>

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  80042003ae:	48 83 45 f8 78       	addq   $0x78,-0x8(%rbp)
  80042003b3:	48 b8 e8 03 4a 04 80 	movabs $0x80044a03e8,%rax
  80042003ba:	00 00 00 
  80042003bd:	8b 00                	mov    (%rax),%eax
  80042003bf:	48 98                	cltq   
  80042003c1:	48 c1 e0 03          	shl    $0x3,%rax
  80042003c5:	48 89 c2             	mov    %rax,%rdx
  80042003c8:	48 c1 e2 04          	shl    $0x4,%rdx
  80042003cc:	48 29 c2             	sub    %rax,%rdx
  80042003cf:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  80042003d6:	00 00 00 
  80042003d9:	48 01 d0             	add    %rdx,%rax
  80042003dc:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042003e0:	0f 87 c2 fe ff ff    	ja     80042002a8 <boot_aps+0xc4>
		lapic_startap(c->cpu_id, PADDR(code));
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
			;
	}
}
  80042003e6:	c9                   	leaveq 
  80042003e7:	c3                   	retq   

00000080042003e8 <mp_main>:

// Setup code for APs
void
mp_main(void)
{
  80042003e8:	55                   	push   %rbp
  80042003e9:	48 89 e5             	mov    %rsp,%rbp
  80042003ec:	48 83 ec 10          	sub    $0x10,%rsp
	// We are in high EIP now, safe to switch to kern_pgdir 
	lcr3(boot_cr3);
  80042003f0:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  80042003f7:	00 00 00 
  80042003fa:	48 8b 00             	mov    (%rax),%rax
  80042003fd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004200401:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200405:	0f 22 d8             	mov    %rax,%cr3
	cprintf("SMP: CPU %d starting\n", cpunum());
  8004200408:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420040f:	00 00 00 
  8004200412:	ff d0                	callq  *%rax
  8004200414:	89 c6                	mov    %eax,%esi
  8004200416:	48 bf b4 51 21 04 80 	movabs $0x80042151b4,%rdi
  800420041d:	00 00 00 
  8004200420:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200425:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420042c:	00 00 00 
  800420042f:	ff d2                	callq  *%rdx

	lapic_init();
  8004200431:	48 b8 9a 48 21 04 80 	movabs $0x800421489a,%rax
  8004200438:	00 00 00 
  800420043b:	ff d0                	callq  *%rax
	env_init_percpu();
  800420043d:	48 b8 5b 7f 20 04 80 	movabs $0x8004207f5b,%rax
  8004200444:	00 00 00 
  8004200447:	ff d0                	callq  *%rax
	trap_init_percpu();
  8004200449:	48 b8 2f 9d 20 04 80 	movabs $0x8004209d2f,%rax
  8004200450:	00 00 00 
  8004200453:	ff d0                	callq  *%rax
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
  8004200455:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420045c:	00 00 00 
  800420045f:	ff d0                	callq  *%rax
  8004200461:	48 98                	cltq   
  8004200463:	48 c1 e0 03          	shl    $0x3,%rax
  8004200467:	48 89 c2             	mov    %rax,%rdx
  800420046a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420046e:	48 29 c2             	sub    %rax,%rdx
  8004200471:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  8004200478:	00 00 00 
  800420047b:	48 01 d0             	add    %rdx,%rax
  800420047e:	48 83 c0 04          	add    $0x4,%rax
  8004200482:	be 01 00 00 00       	mov    $0x1,%esi
  8004200487:	48 89 c7             	mov    %rax,%rdi
  800420048a:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  8004200491:	00 00 00 
  8004200494:	ff d0                	callq  *%rax
	//
	// Your code here:

	// Remove this after you finish Exercise 4
	//for (;;);
	lock_kernel();
  8004200496:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  800420049d:	00 00 00 
  80042004a0:	ff d0                	callq  *%rax
	sched_yield();
  80042004a2:	48 b8 c1 b0 20 04 80 	movabs $0x800420b0c1,%rax
  80042004a9:	00 00 00 
  80042004ac:	ff d0                	callq  *%rax

00000080042004ae <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  80042004ae:	55                   	push   %rbp
  80042004af:	48 89 e5             	mov    %rsp,%rbp
  80042004b2:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  80042004b9:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  80042004c0:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  80042004c6:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  80042004cd:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  80042004d4:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  80042004db:	84 c0                	test   %al,%al
  80042004dd:	74 20                	je     80042004ff <_panic+0x51>
  80042004df:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80042004e3:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80042004e7:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  80042004eb:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80042004ef:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80042004f3:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80042004f7:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  80042004fb:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  80042004ff:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	if (panicstr)
  8004200506:	48 b8 10 e7 49 04 80 	movabs $0x800449e710,%rax
  800420050d:	00 00 00 
  8004200510:	48 8b 00             	mov    (%rax),%rax
  8004200513:	48 85 c0             	test   %rax,%rax
  8004200516:	74 05                	je     800420051d <_panic+0x6f>
		goto dead;
  8004200518:	e9 b5 00 00 00       	jmpq   80042005d2 <_panic+0x124>
	panicstr = fmt;
  800420051d:	48 b8 10 e7 49 04 80 	movabs $0x800449e710,%rax
  8004200524:	00 00 00 
  8004200527:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420052e:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  8004200531:	fa                   	cli    
  8004200532:	fc                   	cld    

	va_start(ap, fmt);
  8004200533:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420053a:	00 00 00 
  800420053d:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  8004200544:	00 00 00 
  8004200547:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420054b:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004200552:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004200559:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
  8004200560:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004200567:	00 00 00 
  800420056a:	ff d0                	callq  *%rax
  800420056c:	8b 8d 24 ff ff ff    	mov    -0xdc(%rbp),%ecx
  8004200572:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  8004200579:	89 c6                	mov    %eax,%esi
  800420057b:	48 bf d0 51 21 04 80 	movabs $0x80042151d0,%rdi
  8004200582:	00 00 00 
  8004200585:	b8 00 00 00 00       	mov    $0x0,%eax
  800420058a:	49 b8 0e 92 20 04 80 	movabs $0x800420920e,%r8
  8004200591:	00 00 00 
  8004200594:	41 ff d0             	callq  *%r8
	vcprintf(fmt, ap);
  8004200597:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  800420059e:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042005a5:	48 89 d6             	mov    %rdx,%rsi
  80042005a8:	48 89 c7             	mov    %rax,%rdi
  80042005ab:	48 b8 af 91 20 04 80 	movabs $0x80042091af,%rax
  80042005b2:	00 00 00 
  80042005b5:	ff d0                	callq  *%rax
	cprintf("\n");
  80042005b7:	48 bf f2 51 21 04 80 	movabs $0x80042151f2,%rdi
  80042005be:	00 00 00 
  80042005c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042005c6:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042005cd:	00 00 00 
  80042005d0:	ff d2                	callq  *%rdx
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  80042005d2:	bf 00 00 00 00       	mov    $0x0,%edi
  80042005d7:	48 b8 bc 21 20 04 80 	movabs $0x80042021bc,%rax
  80042005de:	00 00 00 
  80042005e1:	ff d0                	callq  *%rax
  80042005e3:	eb ed                	jmp    80042005d2 <_panic+0x124>

00000080042005e5 <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  80042005e5:	55                   	push   %rbp
  80042005e6:	48 89 e5             	mov    %rsp,%rbp
  80042005e9:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  80042005f0:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  80042005f7:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  80042005fd:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004200604:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420060b:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004200612:	84 c0                	test   %al,%al
  8004200614:	74 20                	je     8004200636 <_warn+0x51>
  8004200616:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420061a:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420061e:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004200622:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004200626:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420062a:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420062e:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004200632:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004200636:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420063d:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  8004200644:	00 00 00 
  8004200647:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420064e:	00 00 00 
  8004200651:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004200655:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420065c:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004200663:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  800420066a:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004200670:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004200677:	48 89 c6             	mov    %rax,%rsi
  800420067a:	48 bf f4 51 21 04 80 	movabs $0x80042151f4,%rdi
  8004200681:	00 00 00 
  8004200684:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200689:	48 b9 0e 92 20 04 80 	movabs $0x800420920e,%rcx
  8004200690:	00 00 00 
  8004200693:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  8004200695:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  800420069c:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042006a3:	48 89 d6             	mov    %rdx,%rsi
  80042006a6:	48 89 c7             	mov    %rax,%rdi
  80042006a9:	48 b8 af 91 20 04 80 	movabs $0x80042091af,%rax
  80042006b0:	00 00 00 
  80042006b3:	ff d0                	callq  *%rax
	cprintf("\n");
  80042006b5:	48 bf f2 51 21 04 80 	movabs $0x80042151f2,%rdi
  80042006bc:	00 00 00 
  80042006bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042006c4:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042006cb:	00 00 00 
  80042006ce:	ff d2                	callq  *%rdx
	va_end(ap);
}
  80042006d0:	c9                   	leaveq 
  80042006d1:	c3                   	retq   

00000080042006d2 <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  80042006d2:	55                   	push   %rbp
  80042006d3:	48 89 e5             	mov    %rsp,%rbp
  80042006d6:	48 83 ec 20          	sub    $0x20,%rsp
  80042006da:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042006e1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042006e4:	89 c2                	mov    %eax,%edx
  80042006e6:	ec                   	in     (%dx),%al
  80042006e7:	88 45 fb             	mov    %al,-0x5(%rbp)
  80042006ea:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)
  80042006f1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042006f4:	89 c2                	mov    %eax,%edx
  80042006f6:	ec                   	in     (%dx),%al
  80042006f7:	88 45 f3             	mov    %al,-0xd(%rbp)
  80042006fa:	c7 45 ec 84 00 00 00 	movl   $0x84,-0x14(%rbp)
  8004200701:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200704:	89 c2                	mov    %eax,%edx
  8004200706:	ec                   	in     (%dx),%al
  8004200707:	88 45 eb             	mov    %al,-0x15(%rbp)
  800420070a:	c7 45 e4 84 00 00 00 	movl   $0x84,-0x1c(%rbp)
  8004200711:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200714:	89 c2                	mov    %eax,%edx
  8004200716:	ec                   	in     (%dx),%al
  8004200717:	88 45 e3             	mov    %al,-0x1d(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  800420071a:	c9                   	leaveq 
  800420071b:	c3                   	retq   

000000800420071c <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  800420071c:	55                   	push   %rbp
  800420071d:	48 89 e5             	mov    %rsp,%rbp
  8004200720:	48 83 ec 10          	sub    $0x10,%rsp
  8004200724:	c7 45 fc fd 03 00 00 	movl   $0x3fd,-0x4(%rbp)
  800420072b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420072e:	89 c2                	mov    %eax,%edx
  8004200730:	ec                   	in     (%dx),%al
  8004200731:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  8004200734:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  8004200738:	0f b6 c0             	movzbl %al,%eax
  800420073b:	83 e0 01             	and    $0x1,%eax
  800420073e:	85 c0                	test   %eax,%eax
  8004200740:	75 07                	jne    8004200749 <serial_proc_data+0x2d>
		return -1;
  8004200742:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200747:	eb 17                	jmp    8004200760 <serial_proc_data+0x44>
  8004200749:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200750:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200753:	89 c2                	mov    %eax,%edx
  8004200755:	ec                   	in     (%dx),%al
  8004200756:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004200759:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(COM1+COM_RX);
  800420075d:	0f b6 c0             	movzbl %al,%eax
}
  8004200760:	c9                   	leaveq 
  8004200761:	c3                   	retq   

0000008004200762 <serial_intr>:

void
serial_intr(void)
{
  8004200762:	55                   	push   %rbp
  8004200763:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  8004200766:	48 b8 00 d0 49 04 80 	movabs $0x800449d000,%rax
  800420076d:	00 00 00 
  8004200770:	0f b6 00             	movzbl (%rax),%eax
  8004200773:	84 c0                	test   %al,%al
  8004200775:	74 16                	je     800420078d <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  8004200777:	48 bf 1c 07 20 04 80 	movabs $0x800420071c,%rdi
  800420077e:	00 00 00 
  8004200781:	48 b8 02 10 20 04 80 	movabs $0x8004201002,%rax
  8004200788:	00 00 00 
  800420078b:	ff d0                	callq  *%rax
}
  800420078d:	5d                   	pop    %rbp
  800420078e:	c3                   	retq   

000000800420078f <serial_putc>:

static void
serial_putc(int c)
{
  800420078f:	55                   	push   %rbp
  8004200790:	48 89 e5             	mov    %rsp,%rbp
  8004200793:	48 83 ec 28          	sub    $0x28,%rsp
  8004200797:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int i;

	for (i = 0;
  800420079a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042007a1:	eb 10                	jmp    80042007b3 <serial_putc+0x24>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  80042007a3:	48 b8 d2 06 20 04 80 	movabs $0x80042006d2,%rax
  80042007aa:	00 00 00 
  80042007ad:	ff d0                	callq  *%rax
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
  80042007af:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042007b3:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042007ba:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042007bd:	89 c2                	mov    %eax,%edx
  80042007bf:	ec                   	in     (%dx),%al
  80042007c0:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  80042007c3:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
serial_putc(int c)
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  80042007c7:	0f b6 c0             	movzbl %al,%eax
  80042007ca:	83 e0 20             	and    $0x20,%eax
static void
serial_putc(int c)
{
	int i;

	for (i = 0;
  80042007cd:	85 c0                	test   %eax,%eax
  80042007cf:	75 09                	jne    80042007da <serial_putc+0x4b>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  80042007d1:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  80042007d8:	7e c9                	jle    80042007a3 <serial_putc+0x14>
	     i++)
		delay();

	outb(COM1 + COM_TX, c);
  80042007da:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042007dd:	0f b6 c0             	movzbl %al,%eax
  80042007e0:	c7 45 f0 f8 03 00 00 	movl   $0x3f8,-0x10(%rbp)
  80042007e7:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042007ea:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042007ee:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042007f1:	ee                   	out    %al,(%dx)
}
  80042007f2:	c9                   	leaveq 
  80042007f3:	c3                   	retq   

00000080042007f4 <serial_init>:

static void
serial_init(void)
{
  80042007f4:	55                   	push   %rbp
  80042007f5:	48 89 e5             	mov    %rsp,%rbp
  80042007f8:	48 83 ec 50          	sub    $0x50,%rsp
  80042007fc:	c7 45 fc fa 03 00 00 	movl   $0x3fa,-0x4(%rbp)
  8004200803:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  8004200807:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  800420080b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420080e:	ee                   	out    %al,(%dx)
  800420080f:	c7 45 f4 fb 03 00 00 	movl   $0x3fb,-0xc(%rbp)
  8004200816:	c6 45 f3 80          	movb   $0x80,-0xd(%rbp)
  800420081a:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  800420081e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004200821:	ee                   	out    %al,(%dx)
  8004200822:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%rbp)
  8004200829:	c6 45 eb 0c          	movb   $0xc,-0x15(%rbp)
  800420082d:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200831:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200834:	ee                   	out    %al,(%dx)
  8004200835:	c7 45 e4 f9 03 00 00 	movl   $0x3f9,-0x1c(%rbp)
  800420083c:	c6 45 e3 00          	movb   $0x0,-0x1d(%rbp)
  8004200840:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200844:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200847:	ee                   	out    %al,(%dx)
  8004200848:	c7 45 dc fb 03 00 00 	movl   $0x3fb,-0x24(%rbp)
  800420084f:	c6 45 db 03          	movb   $0x3,-0x25(%rbp)
  8004200853:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200857:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420085a:	ee                   	out    %al,(%dx)
  800420085b:	c7 45 d4 fc 03 00 00 	movl   $0x3fc,-0x2c(%rbp)
  8004200862:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  8004200866:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  800420086a:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420086d:	ee                   	out    %al,(%dx)
  800420086e:	c7 45 cc f9 03 00 00 	movl   $0x3f9,-0x34(%rbp)
  8004200875:	c6 45 cb 01          	movb   $0x1,-0x35(%rbp)
  8004200879:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  800420087d:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004200880:	ee                   	out    %al,(%dx)
  8004200881:	c7 45 c4 fd 03 00 00 	movl   $0x3fd,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200888:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420088b:	89 c2                	mov    %eax,%edx
  800420088d:	ec                   	in     (%dx),%al
  800420088e:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  8004200891:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  8004200895:	3c ff                	cmp    $0xff,%al
  8004200897:	0f 95 c2             	setne  %dl
  800420089a:	48 b8 00 d0 49 04 80 	movabs $0x800449d000,%rax
  80042008a1:	00 00 00 
  80042008a4:	88 10                	mov    %dl,(%rax)
  80042008a6:	c7 45 bc fa 03 00 00 	movl   $0x3fa,-0x44(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042008ad:	8b 45 bc             	mov    -0x44(%rbp),%eax
  80042008b0:	89 c2                	mov    %eax,%edx
  80042008b2:	ec                   	in     (%dx),%al
  80042008b3:	88 45 bb             	mov    %al,-0x45(%rbp)
  80042008b6:	c7 45 b4 f8 03 00 00 	movl   $0x3f8,-0x4c(%rbp)
  80042008bd:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80042008c0:	89 c2                	mov    %eax,%edx
  80042008c2:	ec                   	in     (%dx),%al
  80042008c3:	88 45 b3             	mov    %al,-0x4d(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	// Enable serial interrupts
	if (serial_exists)
  80042008c6:	48 b8 00 d0 49 04 80 	movabs $0x800449d000,%rax
  80042008cd:	00 00 00 
  80042008d0:	0f b6 00             	movzbl (%rax),%eax
  80042008d3:	84 c0                	test   %al,%al
  80042008d5:	74 23                	je     80042008fa <serial_init+0x106>
		irq_setmask_8259A(irq_mask_8259A & ~(1<<4));
  80042008d7:	48 b8 12 a7 22 04 80 	movabs $0x800422a712,%rax
  80042008de:	00 00 00 
  80042008e1:	0f b7 00             	movzwl (%rax),%eax
  80042008e4:	0f b7 c0             	movzwl %ax,%eax
  80042008e7:	25 ef ff 00 00       	and    $0xffef,%eax
  80042008ec:	89 c7                	mov    %eax,%edi
  80042008ee:	48 b8 90 90 20 04 80 	movabs $0x8004209090,%rax
  80042008f5:	00 00 00 
  80042008f8:	ff d0                	callq  *%rax
}
  80042008fa:	c9                   	leaveq 
  80042008fb:	c3                   	retq   

00000080042008fc <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  80042008fc:	55                   	push   %rbp
  80042008fd:	48 89 e5             	mov    %rsp,%rbp
  8004200900:	48 83 ec 38          	sub    $0x38,%rsp
  8004200904:	89 7d cc             	mov    %edi,-0x34(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200907:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420090e:	eb 10                	jmp    8004200920 <lpt_putc+0x24>
		delay();
  8004200910:	48 b8 d2 06 20 04 80 	movabs $0x80042006d2,%rax
  8004200917:	00 00 00 
  800420091a:	ff d0                	callq  *%rax
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  800420091c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200920:	c7 45 f8 79 03 00 00 	movl   $0x379,-0x8(%rbp)
  8004200927:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420092a:	89 c2                	mov    %eax,%edx
  800420092c:	ec                   	in     (%dx),%al
  800420092d:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  8004200930:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200934:	84 c0                	test   %al,%al
  8004200936:	78 09                	js     8004200941 <lpt_putc+0x45>
  8004200938:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  800420093f:	7e cf                	jle    8004200910 <lpt_putc+0x14>
		delay();
	outb(0x378+0, c);
  8004200941:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200944:	0f b6 c0             	movzbl %al,%eax
  8004200947:	c7 45 f0 78 03 00 00 	movl   $0x378,-0x10(%rbp)
  800420094e:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200951:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200955:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200958:	ee                   	out    %al,(%dx)
  8004200959:	c7 45 e8 7a 03 00 00 	movl   $0x37a,-0x18(%rbp)
  8004200960:	c6 45 e7 0d          	movb   $0xd,-0x19(%rbp)
  8004200964:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200968:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420096b:	ee                   	out    %al,(%dx)
  800420096c:	c7 45 e0 7a 03 00 00 	movl   $0x37a,-0x20(%rbp)
  8004200973:	c6 45 df 08          	movb   $0x8,-0x21(%rbp)
  8004200977:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800420097b:	8b 55 e0             	mov    -0x20(%rbp),%edx
  800420097e:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  800420097f:	c9                   	leaveq 
  8004200980:	c3                   	retq   

0000008004200981 <cga_init>:
static uint16_t *crt_buf;
static uint16_t crt_pos;

static void
cga_init(void)
{
  8004200981:	55                   	push   %rbp
  8004200982:	48 89 e5             	mov    %rsp,%rbp
  8004200985:	48 83 ec 30          	sub    $0x30,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  8004200989:	48 b8 00 80 0b 04 80 	movabs $0x80040b8000,%rax
  8004200990:	00 00 00 
  8004200993:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	was = *cp;
  8004200997:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420099b:	0f b7 00             	movzwl (%rax),%eax
  800420099e:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	*cp = (uint16_t) 0xA55A;
  80042009a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009a6:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  80042009ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009af:	0f b7 00             	movzwl (%rax),%eax
  80042009b2:	66 3d 5a a5          	cmp    $0xa55a,%ax
  80042009b6:	74 20                	je     80042009d8 <cga_init+0x57>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  80042009b8:	48 b8 00 00 0b 04 80 	movabs $0x80040b0000,%rax
  80042009bf:	00 00 00 
  80042009c2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		addr_6845 = MONO_BASE;
  80042009c6:	48 b8 04 d0 49 04 80 	movabs $0x800449d004,%rax
  80042009cd:	00 00 00 
  80042009d0:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  80042009d6:	eb 1b                	jmp    80042009f3 <cga_init+0x72>
	} else {
		*cp = was;
  80042009d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009dc:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80042009e0:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  80042009e3:	48 b8 04 d0 49 04 80 	movabs $0x800449d004,%rax
  80042009ea:	00 00 00 
  80042009ed:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  80042009f3:	48 b8 04 d0 49 04 80 	movabs $0x800449d004,%rax
  80042009fa:	00 00 00 
  80042009fd:	8b 00                	mov    (%rax),%eax
  80042009ff:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004200a02:	c6 45 eb 0e          	movb   $0xe,-0x15(%rbp)
  8004200a06:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200a0a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200a0d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  8004200a0e:	48 b8 04 d0 49 04 80 	movabs $0x800449d004,%rax
  8004200a15:	00 00 00 
  8004200a18:	8b 00                	mov    (%rax),%eax
  8004200a1a:	83 c0 01             	add    $0x1,%eax
  8004200a1d:	89 45 e4             	mov    %eax,-0x1c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a20:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200a23:	89 c2                	mov    %eax,%edx
  8004200a25:	ec                   	in     (%dx),%al
  8004200a26:	88 45 e3             	mov    %al,-0x1d(%rbp)
	return data;
  8004200a29:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200a2d:	0f b6 c0             	movzbl %al,%eax
  8004200a30:	c1 e0 08             	shl    $0x8,%eax
  8004200a33:	89 45 f0             	mov    %eax,-0x10(%rbp)
	outb(addr_6845, 15);
  8004200a36:	48 b8 04 d0 49 04 80 	movabs $0x800449d004,%rax
  8004200a3d:	00 00 00 
  8004200a40:	8b 00                	mov    (%rax),%eax
  8004200a42:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004200a45:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200a49:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200a4d:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200a50:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  8004200a51:	48 b8 04 d0 49 04 80 	movabs $0x800449d004,%rax
  8004200a58:	00 00 00 
  8004200a5b:	8b 00                	mov    (%rax),%eax
  8004200a5d:	83 c0 01             	add    $0x1,%eax
  8004200a60:	89 45 d4             	mov    %eax,-0x2c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a63:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004200a66:	89 c2                	mov    %eax,%edx
  8004200a68:	ec                   	in     (%dx),%al
  8004200a69:	88 45 d3             	mov    %al,-0x2d(%rbp)
	return data;
  8004200a6c:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200a70:	0f b6 c0             	movzbl %al,%eax
  8004200a73:	09 45 f0             	or     %eax,-0x10(%rbp)

	crt_buf = (uint16_t*) cp;
  8004200a76:	48 b8 08 d0 49 04 80 	movabs $0x800449d008,%rax
  8004200a7d:	00 00 00 
  8004200a80:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200a84:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  8004200a87:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004200a8a:	89 c2                	mov    %eax,%edx
  8004200a8c:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200a93:	00 00 00 
  8004200a96:	66 89 10             	mov    %dx,(%rax)
}
  8004200a99:	c9                   	leaveq 
  8004200a9a:	c3                   	retq   

0000008004200a9b <cga_putc>:



static void
cga_putc(int c)
{
  8004200a9b:	55                   	push   %rbp
  8004200a9c:	48 89 e5             	mov    %rsp,%rbp
  8004200a9f:	48 83 ec 40          	sub    $0x40,%rsp
  8004200aa3:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
  8004200aa6:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200aa9:	b0 00                	mov    $0x0,%al
  8004200aab:	85 c0                	test   %eax,%eax
  8004200aad:	75 07                	jne    8004200ab6 <cga_putc+0x1b>
		c |= 0x0700;
  8004200aaf:	81 4d cc 00 07 00 00 	orl    $0x700,-0x34(%rbp)

	switch (c & 0xff) {
  8004200ab6:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200ab9:	0f b6 c0             	movzbl %al,%eax
  8004200abc:	83 f8 09             	cmp    $0x9,%eax
  8004200abf:	0f 84 f6 00 00 00    	je     8004200bbb <cga_putc+0x120>
  8004200ac5:	83 f8 09             	cmp    $0x9,%eax
  8004200ac8:	7f 0a                	jg     8004200ad4 <cga_putc+0x39>
  8004200aca:	83 f8 08             	cmp    $0x8,%eax
  8004200acd:	74 18                	je     8004200ae7 <cga_putc+0x4c>
  8004200acf:	e9 3e 01 00 00       	jmpq   8004200c12 <cga_putc+0x177>
  8004200ad4:	83 f8 0a             	cmp    $0xa,%eax
  8004200ad7:	74 75                	je     8004200b4e <cga_putc+0xb3>
  8004200ad9:	83 f8 0d             	cmp    $0xd,%eax
  8004200adc:	0f 84 89 00 00 00    	je     8004200b6b <cga_putc+0xd0>
  8004200ae2:	e9 2b 01 00 00       	jmpq   8004200c12 <cga_putc+0x177>
	case '\b':
		if (crt_pos > 0) {
  8004200ae7:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200aee:	00 00 00 
  8004200af1:	0f b7 00             	movzwl (%rax),%eax
  8004200af4:	66 85 c0             	test   %ax,%ax
  8004200af7:	74 50                	je     8004200b49 <cga_putc+0xae>
			crt_pos--;
  8004200af9:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200b00:	00 00 00 
  8004200b03:	0f b7 00             	movzwl (%rax),%eax
  8004200b06:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004200b09:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200b10:	00 00 00 
  8004200b13:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200b16:	48 b8 08 d0 49 04 80 	movabs $0x800449d008,%rax
  8004200b1d:	00 00 00 
  8004200b20:	48 8b 10             	mov    (%rax),%rdx
  8004200b23:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200b2a:	00 00 00 
  8004200b2d:	0f b7 00             	movzwl (%rax),%eax
  8004200b30:	0f b7 c0             	movzwl %ax,%eax
  8004200b33:	48 01 c0             	add    %rax,%rax
  8004200b36:	48 01 c2             	add    %rax,%rdx
  8004200b39:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200b3c:	b0 00                	mov    $0x0,%al
  8004200b3e:	83 c8 20             	or     $0x20,%eax
  8004200b41:	66 89 02             	mov    %ax,(%rdx)
		}
		break;
  8004200b44:	e9 04 01 00 00       	jmpq   8004200c4d <cga_putc+0x1b2>
  8004200b49:	e9 ff 00 00 00       	jmpq   8004200c4d <cga_putc+0x1b2>
	case '\n':
		crt_pos += CRT_COLS;
  8004200b4e:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200b55:	00 00 00 
  8004200b58:	0f b7 00             	movzwl (%rax),%eax
  8004200b5b:	8d 50 50             	lea    0x50(%rax),%edx
  8004200b5e:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200b65:	00 00 00 
  8004200b68:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  8004200b6b:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200b72:	00 00 00 
  8004200b75:	0f b7 30             	movzwl (%rax),%esi
  8004200b78:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200b7f:	00 00 00 
  8004200b82:	0f b7 08             	movzwl (%rax),%ecx
  8004200b85:	0f b7 c1             	movzwl %cx,%eax
  8004200b88:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  8004200b8e:	c1 e8 10             	shr    $0x10,%eax
  8004200b91:	89 c2                	mov    %eax,%edx
  8004200b93:	66 c1 ea 06          	shr    $0x6,%dx
  8004200b97:	89 d0                	mov    %edx,%eax
  8004200b99:	c1 e0 02             	shl    $0x2,%eax
  8004200b9c:	01 d0                	add    %edx,%eax
  8004200b9e:	c1 e0 04             	shl    $0x4,%eax
  8004200ba1:	29 c1                	sub    %eax,%ecx
  8004200ba3:	89 ca                	mov    %ecx,%edx
  8004200ba5:	29 d6                	sub    %edx,%esi
  8004200ba7:	89 f2                	mov    %esi,%edx
  8004200ba9:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200bb0:	00 00 00 
  8004200bb3:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200bb6:	e9 92 00 00 00       	jmpq   8004200c4d <cga_putc+0x1b2>
	case '\t':
		cons_putc(' ');
  8004200bbb:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200bc0:	48 b8 3f 11 20 04 80 	movabs $0x800420113f,%rax
  8004200bc7:	00 00 00 
  8004200bca:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200bcc:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200bd1:	48 b8 3f 11 20 04 80 	movabs $0x800420113f,%rax
  8004200bd8:	00 00 00 
  8004200bdb:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200bdd:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200be2:	48 b8 3f 11 20 04 80 	movabs $0x800420113f,%rax
  8004200be9:	00 00 00 
  8004200bec:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200bee:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200bf3:	48 b8 3f 11 20 04 80 	movabs $0x800420113f,%rax
  8004200bfa:	00 00 00 
  8004200bfd:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200bff:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c04:	48 b8 3f 11 20 04 80 	movabs $0x800420113f,%rax
  8004200c0b:	00 00 00 
  8004200c0e:	ff d0                	callq  *%rax
		break;
  8004200c10:	eb 3b                	jmp    8004200c4d <cga_putc+0x1b2>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200c12:	48 b8 08 d0 49 04 80 	movabs $0x800449d008,%rax
  8004200c19:	00 00 00 
  8004200c1c:	48 8b 30             	mov    (%rax),%rsi
  8004200c1f:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200c26:	00 00 00 
  8004200c29:	0f b7 00             	movzwl (%rax),%eax
  8004200c2c:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200c2f:	48 ba 10 d0 49 04 80 	movabs $0x800449d010,%rdx
  8004200c36:	00 00 00 
  8004200c39:	66 89 0a             	mov    %cx,(%rdx)
  8004200c3c:	0f b7 c0             	movzwl %ax,%eax
  8004200c3f:	48 01 c0             	add    %rax,%rax
  8004200c42:	48 8d 14 06          	lea    (%rsi,%rax,1),%rdx
  8004200c46:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200c49:	66 89 02             	mov    %ax,(%rdx)
		break;
  8004200c4c:	90                   	nop
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
  8004200c4d:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200c54:	00 00 00 
  8004200c57:	0f b7 00             	movzwl (%rax),%eax
  8004200c5a:	66 3d cf 07          	cmp    $0x7cf,%ax
  8004200c5e:	0f 86 89 00 00 00    	jbe    8004200ced <cga_putc+0x252>
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  8004200c64:	48 b8 08 d0 49 04 80 	movabs $0x800449d008,%rax
  8004200c6b:	00 00 00 
  8004200c6e:	48 8b 00             	mov    (%rax),%rax
  8004200c71:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  8004200c78:	48 b8 08 d0 49 04 80 	movabs $0x800449d008,%rax
  8004200c7f:	00 00 00 
  8004200c82:	48 8b 00             	mov    (%rax),%rax
  8004200c85:	ba 00 0f 00 00       	mov    $0xf00,%edx
  8004200c8a:	48 89 ce             	mov    %rcx,%rsi
  8004200c8d:	48 89 c7             	mov    %rax,%rdi
  8004200c90:	48 b8 81 db 20 04 80 	movabs $0x800420db81,%rax
  8004200c97:	00 00 00 
  8004200c9a:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200c9c:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200ca3:	eb 22                	jmp    8004200cc7 <cga_putc+0x22c>
			crt_buf[i] = 0x0700 | ' ';
  8004200ca5:	48 b8 08 d0 49 04 80 	movabs $0x800449d008,%rax
  8004200cac:	00 00 00 
  8004200caf:	48 8b 00             	mov    (%rax),%rax
  8004200cb2:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200cb5:	48 63 d2             	movslq %edx,%rdx
  8004200cb8:	48 01 d2             	add    %rdx,%rdx
  8004200cbb:	48 01 d0             	add    %rdx,%rax
  8004200cbe:	66 c7 00 20 07       	movw   $0x720,(%rax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200cc3:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200cc7:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200cce:	7e d5                	jle    8004200ca5 <cga_putc+0x20a>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
  8004200cd0:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200cd7:	00 00 00 
  8004200cda:	0f b7 00             	movzwl (%rax),%eax
  8004200cdd:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200ce0:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200ce7:	00 00 00 
  8004200cea:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  8004200ced:	48 b8 04 d0 49 04 80 	movabs $0x800449d004,%rax
  8004200cf4:	00 00 00 
  8004200cf7:	8b 00                	mov    (%rax),%eax
  8004200cf9:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004200cfc:	c6 45 f7 0e          	movb   $0xe,-0x9(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200d00:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200d04:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200d07:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  8004200d08:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200d0f:	00 00 00 
  8004200d12:	0f b7 00             	movzwl (%rax),%eax
  8004200d15:	66 c1 e8 08          	shr    $0x8,%ax
  8004200d19:	0f b6 c0             	movzbl %al,%eax
  8004200d1c:	48 ba 04 d0 49 04 80 	movabs $0x800449d004,%rdx
  8004200d23:	00 00 00 
  8004200d26:	8b 12                	mov    (%rdx),%edx
  8004200d28:	83 c2 01             	add    $0x1,%edx
  8004200d2b:	89 55 f0             	mov    %edx,-0x10(%rbp)
  8004200d2e:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004200d31:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200d35:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200d38:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  8004200d39:	48 b8 04 d0 49 04 80 	movabs $0x800449d004,%rax
  8004200d40:	00 00 00 
  8004200d43:	8b 00                	mov    (%rax),%eax
  8004200d45:	89 45 e8             	mov    %eax,-0x18(%rbp)
  8004200d48:	c6 45 e7 0f          	movb   $0xf,-0x19(%rbp)
  8004200d4c:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200d50:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200d53:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  8004200d54:	48 b8 10 d0 49 04 80 	movabs $0x800449d010,%rax
  8004200d5b:	00 00 00 
  8004200d5e:	0f b7 00             	movzwl (%rax),%eax
  8004200d61:	0f b6 c0             	movzbl %al,%eax
  8004200d64:	48 ba 04 d0 49 04 80 	movabs $0x800449d004,%rdx
  8004200d6b:	00 00 00 
  8004200d6e:	8b 12                	mov    (%rdx),%edx
  8004200d70:	83 c2 01             	add    $0x1,%edx
  8004200d73:	89 55 e0             	mov    %edx,-0x20(%rbp)
  8004200d76:	88 45 df             	mov    %al,-0x21(%rbp)
  8004200d79:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200d7d:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200d80:	ee                   	out    %al,(%dx)
}
  8004200d81:	c9                   	leaveq 
  8004200d82:	c3                   	retq   

0000008004200d83 <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  8004200d83:	55                   	push   %rbp
  8004200d84:	48 89 e5             	mov    %rsp,%rbp
  8004200d87:	48 83 ec 20          	sub    $0x20,%rsp
  8004200d8b:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200d92:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200d95:	89 c2                	mov    %eax,%edx
  8004200d97:	ec                   	in     (%dx),%al
  8004200d98:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004200d9b:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;
	int r;
	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200d9f:	0f b6 c0             	movzbl %al,%eax
  8004200da2:	83 e0 01             	and    $0x1,%eax
  8004200da5:	85 c0                	test   %eax,%eax
  8004200da7:	75 0a                	jne    8004200db3 <kbd_proc_data+0x30>
		return -1;
  8004200da9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200dae:	e9 fc 01 00 00       	jmpq   8004200faf <kbd_proc_data+0x22c>
  8004200db3:	c7 45 ec 60 00 00 00 	movl   $0x60,-0x14(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200dba:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200dbd:	89 c2                	mov    %eax,%edx
  8004200dbf:	ec                   	in     (%dx),%al
  8004200dc0:	88 45 eb             	mov    %al,-0x15(%rbp)
	return data;
  8004200dc3:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax

	data = inb(KBDATAP);
  8004200dc7:	88 45 fb             	mov    %al,-0x5(%rbp)

	if (data == 0xE0) {
  8004200dca:	80 7d fb e0          	cmpb   $0xe0,-0x5(%rbp)
  8004200dce:	75 27                	jne    8004200df7 <kbd_proc_data+0x74>
		// E0 escape character
		shift |= E0ESC;
  8004200dd0:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200dd7:	00 00 00 
  8004200dda:	8b 00                	mov    (%rax),%eax
  8004200ddc:	83 c8 40             	or     $0x40,%eax
  8004200ddf:	89 c2                	mov    %eax,%edx
  8004200de1:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200de8:	00 00 00 
  8004200deb:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200ded:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200df2:	e9 b8 01 00 00       	jmpq   8004200faf <kbd_proc_data+0x22c>
	} else if (data & 0x80) {
  8004200df7:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200dfb:	84 c0                	test   %al,%al
  8004200dfd:	79 65                	jns    8004200e64 <kbd_proc_data+0xe1>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200dff:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200e06:	00 00 00 
  8004200e09:	8b 00                	mov    (%rax),%eax
  8004200e0b:	83 e0 40             	and    $0x40,%eax
  8004200e0e:	85 c0                	test   %eax,%eax
  8004200e10:	75 09                	jne    8004200e1b <kbd_proc_data+0x98>
  8004200e12:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e16:	83 e0 7f             	and    $0x7f,%eax
  8004200e19:	eb 04                	jmp    8004200e1f <kbd_proc_data+0x9c>
  8004200e1b:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e1f:	88 45 fb             	mov    %al,-0x5(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200e22:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e26:	48 ba 60 a0 22 04 80 	movabs $0x800422a060,%rdx
  8004200e2d:	00 00 00 
  8004200e30:	48 98                	cltq   
  8004200e32:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200e36:	83 c8 40             	or     $0x40,%eax
  8004200e39:	0f b6 c0             	movzbl %al,%eax
  8004200e3c:	f7 d0                	not    %eax
  8004200e3e:	89 c2                	mov    %eax,%edx
  8004200e40:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200e47:	00 00 00 
  8004200e4a:	8b 00                	mov    (%rax),%eax
  8004200e4c:	21 c2                	and    %eax,%edx
  8004200e4e:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200e55:	00 00 00 
  8004200e58:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200e5a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200e5f:	e9 4b 01 00 00       	jmpq   8004200faf <kbd_proc_data+0x22c>
	} else if (shift & E0ESC) {
  8004200e64:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200e6b:	00 00 00 
  8004200e6e:	8b 00                	mov    (%rax),%eax
  8004200e70:	83 e0 40             	and    $0x40,%eax
  8004200e73:	85 c0                	test   %eax,%eax
  8004200e75:	74 21                	je     8004200e98 <kbd_proc_data+0x115>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004200e77:	80 4d fb 80          	orb    $0x80,-0x5(%rbp)
		shift &= ~E0ESC;
  8004200e7b:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200e82:	00 00 00 
  8004200e85:	8b 00                	mov    (%rax),%eax
  8004200e87:	83 e0 bf             	and    $0xffffffbf,%eax
  8004200e8a:	89 c2                	mov    %eax,%edx
  8004200e8c:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200e93:	00 00 00 
  8004200e96:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004200e98:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e9c:	48 ba 60 a0 22 04 80 	movabs $0x800422a060,%rdx
  8004200ea3:	00 00 00 
  8004200ea6:	48 98                	cltq   
  8004200ea8:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200eac:	0f b6 d0             	movzbl %al,%edx
  8004200eaf:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200eb6:	00 00 00 
  8004200eb9:	8b 00                	mov    (%rax),%eax
  8004200ebb:	09 c2                	or     %eax,%edx
  8004200ebd:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200ec4:	00 00 00 
  8004200ec7:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004200ec9:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200ecd:	48 ba 60 a1 22 04 80 	movabs $0x800422a160,%rdx
  8004200ed4:	00 00 00 
  8004200ed7:	48 98                	cltq   
  8004200ed9:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200edd:	0f b6 d0             	movzbl %al,%edx
  8004200ee0:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200ee7:	00 00 00 
  8004200eea:	8b 00                	mov    (%rax),%eax
  8004200eec:	31 c2                	xor    %eax,%edx
  8004200eee:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200ef5:	00 00 00 
  8004200ef8:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  8004200efa:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200f01:	00 00 00 
  8004200f04:	8b 00                	mov    (%rax),%eax
  8004200f06:	83 e0 03             	and    $0x3,%eax
  8004200f09:	89 c2                	mov    %eax,%edx
  8004200f0b:	48 b8 60 a5 22 04 80 	movabs $0x800422a560,%rax
  8004200f12:	00 00 00 
  8004200f15:	89 d2                	mov    %edx,%edx
  8004200f17:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8004200f1b:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f1f:	48 01 d0             	add    %rdx,%rax
  8004200f22:	0f b6 00             	movzbl (%rax),%eax
  8004200f25:	0f b6 c0             	movzbl %al,%eax
  8004200f28:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (shift & CAPSLOCK) {
  8004200f2b:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200f32:	00 00 00 
  8004200f35:	8b 00                	mov    (%rax),%eax
  8004200f37:	83 e0 08             	and    $0x8,%eax
  8004200f3a:	85 c0                	test   %eax,%eax
  8004200f3c:	74 22                	je     8004200f60 <kbd_proc_data+0x1dd>
		if ('a' <= c && c <= 'z')
  8004200f3e:	83 7d fc 60          	cmpl   $0x60,-0x4(%rbp)
  8004200f42:	7e 0c                	jle    8004200f50 <kbd_proc_data+0x1cd>
  8004200f44:	83 7d fc 7a          	cmpl   $0x7a,-0x4(%rbp)
  8004200f48:	7f 06                	jg     8004200f50 <kbd_proc_data+0x1cd>
			c += 'A' - 'a';
  8004200f4a:	83 6d fc 20          	subl   $0x20,-0x4(%rbp)
  8004200f4e:	eb 10                	jmp    8004200f60 <kbd_proc_data+0x1dd>
		else if ('A' <= c && c <= 'Z')
  8004200f50:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
  8004200f54:	7e 0a                	jle    8004200f60 <kbd_proc_data+0x1dd>
  8004200f56:	83 7d fc 5a          	cmpl   $0x5a,-0x4(%rbp)
  8004200f5a:	7f 04                	jg     8004200f60 <kbd_proc_data+0x1dd>
			c += 'a' - 'A';
  8004200f5c:	83 45 fc 20          	addl   $0x20,-0x4(%rbp)
	}

	// Process special keys
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  8004200f60:	48 b8 28 d2 49 04 80 	movabs $0x800449d228,%rax
  8004200f67:	00 00 00 
  8004200f6a:	8b 00                	mov    (%rax),%eax
  8004200f6c:	f7 d0                	not    %eax
  8004200f6e:	83 e0 06             	and    $0x6,%eax
  8004200f71:	85 c0                	test   %eax,%eax
  8004200f73:	75 37                	jne    8004200fac <kbd_proc_data+0x229>
  8004200f75:	81 7d fc e9 00 00 00 	cmpl   $0xe9,-0x4(%rbp)
  8004200f7c:	75 2e                	jne    8004200fac <kbd_proc_data+0x229>
		cprintf("Rebooting!\n");
  8004200f7e:	48 bf 0e 52 21 04 80 	movabs $0x800421520e,%rdi
  8004200f85:	00 00 00 
  8004200f88:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200f8d:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004200f94:	00 00 00 
  8004200f97:	ff d2                	callq  *%rdx
  8004200f99:	c7 45 e4 92 00 00 00 	movl   $0x92,-0x1c(%rbp)
  8004200fa0:	c6 45 e3 03          	movb   $0x3,-0x1d(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200fa4:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200fa8:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200fab:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}
	return c;
  8004200fac:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004200faf:	c9                   	leaveq 
  8004200fb0:	c3                   	retq   

0000008004200fb1 <kbd_intr>:

void
kbd_intr(void)
{
  8004200fb1:	55                   	push   %rbp
  8004200fb2:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  8004200fb5:	48 bf 83 0d 20 04 80 	movabs $0x8004200d83,%rdi
  8004200fbc:	00 00 00 
  8004200fbf:	48 b8 02 10 20 04 80 	movabs $0x8004201002,%rax
  8004200fc6:	00 00 00 
  8004200fc9:	ff d0                	callq  *%rax
}
  8004200fcb:	5d                   	pop    %rbp
  8004200fcc:	c3                   	retq   

0000008004200fcd <kbd_init>:

static void
kbd_init(void)
{
  8004200fcd:	55                   	push   %rbp
  8004200fce:	48 89 e5             	mov    %rsp,%rbp
	// Drain the kbd buffer so that Bochs generates interrupts.
	kbd_intr();
  8004200fd1:	48 b8 b1 0f 20 04 80 	movabs $0x8004200fb1,%rax
  8004200fd8:	00 00 00 
  8004200fdb:	ff d0                	callq  *%rax
	irq_setmask_8259A(irq_mask_8259A & ~(1<<1));
  8004200fdd:	48 b8 12 a7 22 04 80 	movabs $0x800422a712,%rax
  8004200fe4:	00 00 00 
  8004200fe7:	0f b7 00             	movzwl (%rax),%eax
  8004200fea:	0f b7 c0             	movzwl %ax,%eax
  8004200fed:	25 fd ff 00 00       	and    $0xfffd,%eax
  8004200ff2:	89 c7                	mov    %eax,%edi
  8004200ff4:	48 b8 90 90 20 04 80 	movabs $0x8004209090,%rax
  8004200ffb:	00 00 00 
  8004200ffe:	ff d0                	callq  *%rax
}
  8004201000:	5d                   	pop    %rbp
  8004201001:	c3                   	retq   

0000008004201002 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  8004201002:	55                   	push   %rbp
  8004201003:	48 89 e5             	mov    %rsp,%rbp
  8004201006:	48 83 ec 20          	sub    $0x20,%rsp
  800420100a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  800420100e:	eb 6a                	jmp    800420107a <cons_intr+0x78>
		if (c == 0)
  8004201010:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201014:	75 02                	jne    8004201018 <cons_intr+0x16>
			continue;
  8004201016:	eb 62                	jmp    800420107a <cons_intr+0x78>
		cons.buf[cons.wpos++] = c;
  8004201018:	48 b8 20 d0 49 04 80 	movabs $0x800449d020,%rax
  800420101f:	00 00 00 
  8004201022:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004201028:	8d 48 01             	lea    0x1(%rax),%ecx
  800420102b:	48 ba 20 d0 49 04 80 	movabs $0x800449d020,%rdx
  8004201032:	00 00 00 
  8004201035:	89 8a 04 02 00 00    	mov    %ecx,0x204(%rdx)
  800420103b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420103e:	89 d1                	mov    %edx,%ecx
  8004201040:	48 ba 20 d0 49 04 80 	movabs $0x800449d020,%rdx
  8004201047:	00 00 00 
  800420104a:	89 c0                	mov    %eax,%eax
  800420104c:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
		if (cons.wpos == CONSBUFSIZE)
  800420104f:	48 b8 20 d0 49 04 80 	movabs $0x800449d020,%rax
  8004201056:	00 00 00 
  8004201059:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  800420105f:	3d 00 02 00 00       	cmp    $0x200,%eax
  8004201064:	75 14                	jne    800420107a <cons_intr+0x78>
			cons.wpos = 0;
  8004201066:	48 b8 20 d0 49 04 80 	movabs $0x800449d020,%rax
  800420106d:	00 00 00 
  8004201070:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  8004201077:	00 00 00 
static void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
  800420107a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420107e:	ff d0                	callq  *%rax
  8004201080:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004201083:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  8004201087:	75 87                	jne    8004201010 <cons_intr+0xe>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
  8004201089:	c9                   	leaveq 
  800420108a:	c3                   	retq   

000000800420108b <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  800420108b:	55                   	push   %rbp
  800420108c:	48 89 e5             	mov    %rsp,%rbp
  800420108f:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  8004201093:	48 b8 62 07 20 04 80 	movabs $0x8004200762,%rax
  800420109a:	00 00 00 
  800420109d:	ff d0                	callq  *%rax
	kbd_intr();
  800420109f:	48 b8 b1 0f 20 04 80 	movabs $0x8004200fb1,%rax
  80042010a6:	00 00 00 
  80042010a9:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  80042010ab:	48 b8 20 d0 49 04 80 	movabs $0x800449d020,%rax
  80042010b2:	00 00 00 
  80042010b5:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  80042010bb:	48 b8 20 d0 49 04 80 	movabs $0x800449d020,%rax
  80042010c2:	00 00 00 
  80042010c5:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042010cb:	39 c2                	cmp    %eax,%edx
  80042010cd:	74 69                	je     8004201138 <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  80042010cf:	48 b8 20 d0 49 04 80 	movabs $0x800449d020,%rax
  80042010d6:	00 00 00 
  80042010d9:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  80042010df:	8d 48 01             	lea    0x1(%rax),%ecx
  80042010e2:	48 ba 20 d0 49 04 80 	movabs $0x800449d020,%rdx
  80042010e9:	00 00 00 
  80042010ec:	89 8a 00 02 00 00    	mov    %ecx,0x200(%rdx)
  80042010f2:	48 ba 20 d0 49 04 80 	movabs $0x800449d020,%rdx
  80042010f9:	00 00 00 
  80042010fc:	89 c0                	mov    %eax,%eax
  80042010fe:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004201102:	0f b6 c0             	movzbl %al,%eax
  8004201105:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (cons.rpos == CONSBUFSIZE)
  8004201108:	48 b8 20 d0 49 04 80 	movabs $0x800449d020,%rax
  800420110f:	00 00 00 
  8004201112:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004201118:	3d 00 02 00 00       	cmp    $0x200,%eax
  800420111d:	75 14                	jne    8004201133 <cons_getc+0xa8>
			cons.rpos = 0;
  800420111f:	48 b8 20 d0 49 04 80 	movabs $0x800449d020,%rax
  8004201126:	00 00 00 
  8004201129:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  8004201130:	00 00 00 
		return c;
  8004201133:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201136:	eb 05                	jmp    800420113d <cons_getc+0xb2>
	}
	return 0;
  8004201138:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420113d:	c9                   	leaveq 
  800420113e:	c3                   	retq   

000000800420113f <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  800420113f:	55                   	push   %rbp
  8004201140:	48 89 e5             	mov    %rsp,%rbp
  8004201143:	48 83 ec 10          	sub    $0x10,%rsp
  8004201147:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  800420114a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420114d:	89 c7                	mov    %eax,%edi
  800420114f:	48 b8 8f 07 20 04 80 	movabs $0x800420078f,%rax
  8004201156:	00 00 00 
  8004201159:	ff d0                	callq  *%rax
	lpt_putc(c);
  800420115b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420115e:	89 c7                	mov    %eax,%edi
  8004201160:	48 b8 fc 08 20 04 80 	movabs $0x80042008fc,%rax
  8004201167:	00 00 00 
  800420116a:	ff d0                	callq  *%rax
	cga_putc(c);
  800420116c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420116f:	89 c7                	mov    %eax,%edi
  8004201171:	48 b8 9b 0a 20 04 80 	movabs $0x8004200a9b,%rax
  8004201178:	00 00 00 
  800420117b:	ff d0                	callq  *%rax
}
  800420117d:	c9                   	leaveq 
  800420117e:	c3                   	retq   

000000800420117f <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  800420117f:	55                   	push   %rbp
  8004201180:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  8004201183:	48 b8 81 09 20 04 80 	movabs $0x8004200981,%rax
  800420118a:	00 00 00 
  800420118d:	ff d0                	callq  *%rax
	kbd_init();
  800420118f:	48 b8 cd 0f 20 04 80 	movabs $0x8004200fcd,%rax
  8004201196:	00 00 00 
  8004201199:	ff d0                	callq  *%rax
	serial_init();
  800420119b:	48 b8 f4 07 20 04 80 	movabs $0x80042007f4,%rax
  80042011a2:	00 00 00 
  80042011a5:	ff d0                	callq  *%rax

	if (!serial_exists)
  80042011a7:	48 b8 00 d0 49 04 80 	movabs $0x800449d000,%rax
  80042011ae:	00 00 00 
  80042011b1:	0f b6 00             	movzbl (%rax),%eax
  80042011b4:	83 f0 01             	xor    $0x1,%eax
  80042011b7:	84 c0                	test   %al,%al
  80042011b9:	74 1b                	je     80042011d6 <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  80042011bb:	48 bf 1a 52 21 04 80 	movabs $0x800421521a,%rdi
  80042011c2:	00 00 00 
  80042011c5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042011ca:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042011d1:	00 00 00 
  80042011d4:	ff d2                	callq  *%rdx
}
  80042011d6:	5d                   	pop    %rbp
  80042011d7:	c3                   	retq   

00000080042011d8 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  80042011d8:	55                   	push   %rbp
  80042011d9:	48 89 e5             	mov    %rsp,%rbp
  80042011dc:	48 83 ec 10          	sub    $0x10,%rsp
  80042011e0:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  80042011e3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011e6:	89 c7                	mov    %eax,%edi
  80042011e8:	48 b8 3f 11 20 04 80 	movabs $0x800420113f,%rax
  80042011ef:	00 00 00 
  80042011f2:	ff d0                	callq  *%rax
}
  80042011f4:	c9                   	leaveq 
  80042011f5:	c3                   	retq   

00000080042011f6 <getchar>:

int
getchar(void)
{
  80042011f6:	55                   	push   %rbp
  80042011f7:	48 89 e5             	mov    %rsp,%rbp
  80042011fa:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  80042011fe:	48 b8 8b 10 20 04 80 	movabs $0x800420108b,%rax
  8004201205:	00 00 00 
  8004201208:	ff d0                	callq  *%rax
  800420120a:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420120d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201211:	74 eb                	je     80042011fe <getchar+0x8>
		/* do nothing */;
	return c;
  8004201213:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004201216:	c9                   	leaveq 
  8004201217:	c3                   	retq   

0000008004201218 <iscons>:

int
iscons(int fdnum)
{
  8004201218:	55                   	push   %rbp
  8004201219:	48 89 e5             	mov    %rsp,%rbp
  800420121c:	48 83 ec 04          	sub    $0x4,%rsp
  8004201220:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  8004201223:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201228:	c9                   	leaveq 
  8004201229:	c3                   	retq   

000000800420122a <get_pml4e>:
};
#define NCOMMANDS (sizeof(commands)/sizeof(commands[0]))

/***** Implementations of basic kernel monitor commands *****/

pml4e_t* get_pml4e(){
  800420122a:	55                   	push   %rbp
  800420122b:	48 89 e5             	mov    %rsp,%rbp
	if(curenv->env_status == ENV_RUNNING)
  800420122e:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004201235:	00 00 00 
  8004201238:	ff d0                	callq  *%rax
  800420123a:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004201241:	00 00 00 
  8004201244:	48 98                	cltq   
  8004201246:	48 c1 e0 03          	shl    $0x3,%rax
  800420124a:	48 89 c2             	mov    %rax,%rdx
  800420124d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004201251:	48 29 c2             	sub    %rax,%rdx
  8004201254:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004201258:	48 83 c0 08          	add    $0x8,%rax
  800420125c:	48 8b 00             	mov    (%rax),%rax
  800420125f:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004201265:	83 f8 03             	cmp    $0x3,%eax
  8004201268:	75 3a                	jne    80042012a4 <get_pml4e+0x7a>
		return curenv->env_pml4e;
  800420126a:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004201271:	00 00 00 
  8004201274:	ff d0                	callq  *%rax
  8004201276:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420127d:	00 00 00 
  8004201280:	48 98                	cltq   
  8004201282:	48 c1 e0 03          	shl    $0x3,%rax
  8004201286:	48 89 c2             	mov    %rax,%rdx
  8004201289:	48 c1 e2 04          	shl    $0x4,%rdx
  800420128d:	48 29 c2             	sub    %rax,%rdx
  8004201290:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004201294:	48 83 c0 08          	add    $0x8,%rax
  8004201298:	48 8b 00             	mov    (%rax),%rax
  800420129b:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042012a2:	eb 0d                	jmp    80042012b1 <get_pml4e+0x87>
	else
		return boot_pml4e;
  80042012a4:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  80042012ab:	00 00 00 
  80042012ae:	48 8b 00             	mov    (%rax),%rax
}
  80042012b1:	5d                   	pop    %rbp
  80042012b2:	c3                   	retq   

00000080042012b3 <mon_help>:
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  80042012b3:	55                   	push   %rbp
  80042012b4:	48 89 e5             	mov    %rsp,%rbp
  80042012b7:	48 83 ec 30          	sub    $0x30,%rsp
  80042012bb:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042012be:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042012c2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  80042012c6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042012cd:	eb 6c                	jmp    800420133b <mon_help+0x88>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  80042012cf:	48 b9 80 a5 22 04 80 	movabs $0x800422a580,%rcx
  80042012d6:	00 00 00 
  80042012d9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012dc:	48 63 d0             	movslq %eax,%rdx
  80042012df:	48 89 d0             	mov    %rdx,%rax
  80042012e2:	48 01 c0             	add    %rax,%rax
  80042012e5:	48 01 d0             	add    %rdx,%rax
  80042012e8:	48 c1 e0 03          	shl    $0x3,%rax
  80042012ec:	48 01 c8             	add    %rcx,%rax
  80042012ef:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042012f3:	48 be 80 a5 22 04 80 	movabs $0x800422a580,%rsi
  80042012fa:	00 00 00 
  80042012fd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201300:	48 63 d0             	movslq %eax,%rdx
  8004201303:	48 89 d0             	mov    %rdx,%rax
  8004201306:	48 01 c0             	add    %rax,%rax
  8004201309:	48 01 d0             	add    %rdx,%rax
  800420130c:	48 c1 e0 03          	shl    $0x3,%rax
  8004201310:	48 01 f0             	add    %rsi,%rax
  8004201313:	48 8b 00             	mov    (%rax),%rax
  8004201316:	48 89 ca             	mov    %rcx,%rdx
  8004201319:	48 89 c6             	mov    %rax,%rsi
  800420131c:	48 bf 98 56 21 04 80 	movabs $0x8004215698,%rdi
  8004201323:	00 00 00 
  8004201326:	b8 00 00 00 00       	mov    $0x0,%eax
  800420132b:	48 b9 0e 92 20 04 80 	movabs $0x800420920e,%rcx
  8004201332:	00 00 00 
  8004201335:	ff d1                	callq  *%rcx
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004201337:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420133b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420133e:	83 f8 07             	cmp    $0x7,%eax
  8004201341:	76 8c                	jbe    80042012cf <mon_help+0x1c>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
	return 0;
  8004201343:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201348:	c9                   	leaveq 
  8004201349:	c3                   	retq   

000000800420134a <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  800420134a:	55                   	push   %rbp
  800420134b:	48 89 e5             	mov    %rsp,%rbp
  800420134e:	48 83 ec 30          	sub    $0x30,%rsp
  8004201352:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004201355:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004201359:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  800420135d:	48 bf a1 56 21 04 80 	movabs $0x80042156a1,%rdi
  8004201364:	00 00 00 
  8004201367:	b8 00 00 00 00       	mov    $0x0,%eax
  800420136c:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201373:	00 00 00 
  8004201376:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  8004201378:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  800420137f:	00 00 00 
  8004201382:	48 bf c0 56 21 04 80 	movabs $0x80042156c0,%rdi
  8004201389:	00 00 00 
  800420138c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201391:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201398:	00 00 00 
  800420139b:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  800420139d:	48 ba 0c 00 20 00 00 	movabs $0x20000c,%rdx
  80042013a4:	00 00 00 
  80042013a7:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  80042013ae:	00 00 00 
  80042013b1:	48 bf e8 56 21 04 80 	movabs $0x80042156e8,%rdi
  80042013b8:	00 00 00 
  80042013bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013c0:	48 b9 0e 92 20 04 80 	movabs $0x800420920e,%rcx
  80042013c7:	00 00 00 
  80042013ca:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  80042013cc:	48 ba 3d 51 21 00 00 	movabs $0x21513d,%rdx
  80042013d3:	00 00 00 
  80042013d6:	48 be 3d 51 21 04 80 	movabs $0x800421513d,%rsi
  80042013dd:	00 00 00 
  80042013e0:	48 bf 10 57 21 04 80 	movabs $0x8004215710,%rdi
  80042013e7:	00 00 00 
  80042013ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013ef:	48 b9 0e 92 20 04 80 	movabs $0x800420920e,%rcx
  80042013f6:	00 00 00 
  80042013f9:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  80042013fb:	48 ba 2e cc 49 00 00 	movabs $0x49cc2e,%rdx
  8004201402:	00 00 00 
  8004201405:	48 be 2e cc 49 04 80 	movabs $0x800449cc2e,%rsi
  800420140c:	00 00 00 
  800420140f:	48 bf 38 57 21 04 80 	movabs $0x8004215738,%rdi
  8004201416:	00 00 00 
  8004201419:	b8 00 00 00 00       	mov    $0x0,%eax
  800420141e:	48 b9 0e 92 20 04 80 	movabs $0x800420920e,%rcx
  8004201425:	00 00 00 
  8004201428:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  800420142a:	48 ba 10 10 52 00 00 	movabs $0x521010,%rdx
  8004201431:	00 00 00 
  8004201434:	48 be 10 10 52 04 80 	movabs $0x8004521010,%rsi
  800420143b:	00 00 00 
  800420143e:	48 bf 60 57 21 04 80 	movabs $0x8004215760,%rdi
  8004201445:	00 00 00 
  8004201448:	b8 00 00 00 00       	mov    $0x0,%eax
  800420144d:	48 b9 0e 92 20 04 80 	movabs $0x800420920e,%rcx
  8004201454:	00 00 00 
  8004201457:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  8004201459:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  8004201460:	00 
  8004201461:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  8004201468:	00 00 00 
  800420146b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420146f:	48 29 c2             	sub    %rax,%rdx
  8004201472:	48 b8 10 10 52 04 80 	movabs $0x8004521010,%rax
  8004201479:	00 00 00 
  800420147c:	48 83 e8 01          	sub    $0x1,%rax
  8004201480:	48 01 d0             	add    %rdx,%rax
  8004201483:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004201487:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420148b:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201490:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004201494:	48 89 d0             	mov    %rdx,%rax
  8004201497:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420149b:	48 29 c2             	sub    %rax,%rdx
  800420149e:	48 89 d0             	mov    %rdx,%rax
	cprintf("  _start                  %08x (phys)\n", _start);
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
	cprintf("Kernel executable memory footprint: %dKB\n",
  80042014a1:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  80042014a8:	48 85 c0             	test   %rax,%rax
  80042014ab:	48 0f 48 c2          	cmovs  %rdx,%rax
  80042014af:	48 c1 f8 0a          	sar    $0xa,%rax
  80042014b3:	48 89 c6             	mov    %rax,%rsi
  80042014b6:	48 bf 88 57 21 04 80 	movabs $0x8004215788,%rdi
  80042014bd:	00 00 00 
  80042014c0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014c5:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042014cc:	00 00 00 
  80042014cf:	ff d2                	callq  *%rdx
		ROUNDUP(end - entry, 1024) / 1024);
	return 0;
  80042014d1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042014d6:	c9                   	leaveq 
  80042014d7:	c3                   	retq   

00000080042014d8 <mon_backtrace>:
}
*/

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  80042014d8:	55                   	push   %rbp
  80042014d9:	48 89 e5             	mov    %rsp,%rbp
  80042014dc:	48 81 ec 30 05 00 00 	sub    $0x530,%rsp
  80042014e3:	89 bd ec fa ff ff    	mov    %edi,-0x514(%rbp)
  80042014e9:	48 89 b5 e0 fa ff ff 	mov    %rsi,-0x520(%rbp)
  80042014f0:	48 89 95 d8 fa ff ff 	mov    %rdx,-0x528(%rbp)
	//cprintf("mon_backtrace(%016x %016x %016x)\n", argc, argv, tf);
	// Your code here.
	uint64_t rip, *rbp;
	read_rip(rip);
  80042014f7:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 42014fe <_start+0x40014f2>
  80042014fe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

static __inline uint64_t
read_rbp(void)
{
	uint64_t rbp;
	__asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  8004201502:	48 89 e8             	mov    %rbp,%rax
  8004201505:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	return rbp;
  8004201509:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
	rbp = (uint64_t *) read_rbp();
  800420150d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cprintf("Stack backtrace:\n");
  8004201511:	48 bf b2 57 21 04 80 	movabs $0x80042157b2,%rdi
  8004201518:	00 00 00 
  800420151b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201520:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201527:	00 00 00 
  800420152a:	ff d2                	callq  *%rdx
	while (rbp) {
  800420152c:	e9 af 01 00 00       	jmpq   80042016e0 <mon_backtrace+0x208>
		cprintf("  rbp %016x  rip %016x\n", rbp, rip);
  8004201531:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201535:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201539:	48 89 c6             	mov    %rax,%rsi
  800420153c:	48 bf c4 57 21 04 80 	movabs $0x80042157c4,%rdi
  8004201543:	00 00 00 
  8004201546:	b8 00 00 00 00       	mov    $0x0,%eax
  800420154b:	48 b9 0e 92 20 04 80 	movabs $0x800420920e,%rcx
  8004201552:	00 00 00 
  8004201555:	ff d1                	callq  *%rcx

		// print debuginfo_rip()
		char* rbpc = (char*) rbp;
  8004201557:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420155b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		struct Ripdebuginfo info;
		debuginfo_rip((uintptr_t) rip, &info);
  800420155f:	48 8d 95 f0 fa ff ff 	lea    -0x510(%rbp),%rdx
  8004201566:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420156a:	48 89 d6             	mov    %rdx,%rsi
  800420156d:	48 89 c7             	mov    %rax,%rdi
  8004201570:	48 b8 5e c7 20 04 80 	movabs $0x800420c75e,%rax
  8004201577:	00 00 00 
  800420157a:	ff d0                	callq  *%rax

		cprintf("       %s:%d: %s+%016x  args:%d",
  800420157c:	8b b5 18 fb ff ff    	mov    -0x4e8(%rbp),%esi
			info.rip_file, info.rip_line, info.rip_fn_name, rip - info.rip_fn_addr, info.rip_fn_narg);
  8004201582:	48 8b 85 10 fb ff ff 	mov    -0x4f0(%rbp),%rax
		char* rbpc = (char*) rbp;

		struct Ripdebuginfo info;
		debuginfo_rip((uintptr_t) rip, &info);

		cprintf("       %s:%d: %s+%016x  args:%d",
  8004201589:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420158d:	48 89 d7             	mov    %rdx,%rdi
  8004201590:	48 29 c7             	sub    %rax,%rdi
  8004201593:	48 8b 8d 00 fb ff ff 	mov    -0x500(%rbp),%rcx
  800420159a:	8b 95 f8 fa ff ff    	mov    -0x508(%rbp),%edx
  80042015a0:	48 8b 85 f0 fa ff ff 	mov    -0x510(%rbp),%rax
  80042015a7:	41 89 f1             	mov    %esi,%r9d
  80042015aa:	49 89 f8             	mov    %rdi,%r8
  80042015ad:	48 89 c6             	mov    %rax,%rsi
  80042015b0:	48 bf e0 57 21 04 80 	movabs $0x80042157e0,%rdi
  80042015b7:	00 00 00 
  80042015ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015bf:	49 ba 0e 92 20 04 80 	movabs $0x800420920e,%r10
  80042015c6:	00 00 00 
  80042015c9:	41 ff d2             	callq  *%r10
			info.rip_file, info.rip_line, info.rip_fn_name, rip - info.rip_fn_addr, info.rip_fn_narg);
int i;
		for ( i = 0; i < info.rip_fn_narg; ++ i) {
  80042015cc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042015d3:	e9 c7 00 00 00       	jmpq   800420169f <mon_backtrace+0x1c7>
			char* arg_start = &rbpc[info.reg_table.cfa_rule.dw_offset + info.offset_fn_arg[i]];
  80042015d8:	48 8b 95 a0 fb ff ff 	mov    -0x460(%rbp),%rdx
  80042015df:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042015e2:	48 98                	cltq   
  80042015e4:	48 83 c0 0a          	add    $0xa,%rax
  80042015e8:	48 8b 84 c5 f8 fa ff 	mov    -0x508(%rbp,%rax,8),%rax
  80042015ef:	ff 
  80042015f0:	48 01 c2             	add    %rax,%rdx
  80042015f3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042015f7:	48 01 d0             	add    %rdx,%rax
  80042015fa:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
			if (info.size_fn_arg[i] == 8) {
  80042015fe:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201601:	48 98                	cltq   
  8004201603:	48 83 c0 08          	add    $0x8,%rax
  8004201607:	8b 84 85 fc fa ff ff 	mov    -0x504(%rbp,%rax,4),%eax
  800420160e:	83 f8 08             	cmp    $0x8,%eax
  8004201611:	75 27                	jne    800420163a <mon_backtrace+0x162>
				cprintf("  %016x", *(uint64_t *) arg_start);
  8004201613:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201617:	48 8b 00             	mov    (%rax),%rax
  800420161a:	48 89 c6             	mov    %rax,%rsi
  800420161d:	48 bf 00 58 21 04 80 	movabs $0x8004215800,%rdi
  8004201624:	00 00 00 
  8004201627:	b8 00 00 00 00       	mov    $0x0,%eax
  800420162c:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201633:	00 00 00 
  8004201636:	ff d2                	callq  *%rdx
  8004201638:	eb 61                	jmp    800420169b <mon_backtrace+0x1c3>
			} else if (info.size_fn_arg[i] == 4) {
  800420163a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420163d:	48 98                	cltq   
  800420163f:	48 83 c0 08          	add    $0x8,%rax
  8004201643:	8b 84 85 fc fa ff ff 	mov    -0x504(%rbp,%rax,4),%eax
  800420164a:	83 f8 04             	cmp    $0x4,%eax
  800420164d:	75 25                	jne    8004201674 <mon_backtrace+0x19c>
				cprintf("  %016x", *(uint32_t *) arg_start);
  800420164f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201653:	8b 00                	mov    (%rax),%eax
  8004201655:	89 c6                	mov    %eax,%esi
  8004201657:	48 bf 00 58 21 04 80 	movabs $0x8004215800,%rdi
  800420165e:	00 00 00 
  8004201661:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201666:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420166d:	00 00 00 
  8004201670:	ff d2                	callq  *%rdx
  8004201672:	eb 27                	jmp    800420169b <mon_backtrace+0x1c3>
			}
			else cprintf("  %016x", *arg_start);
  8004201674:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201678:	0f b6 00             	movzbl (%rax),%eax
  800420167b:	0f be c0             	movsbl %al,%eax
  800420167e:	89 c6                	mov    %eax,%esi
  8004201680:	48 bf 00 58 21 04 80 	movabs $0x8004215800,%rdi
  8004201687:	00 00 00 
  800420168a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420168f:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201696:	00 00 00 
  8004201699:	ff d2                	callq  *%rdx
		debuginfo_rip((uintptr_t) rip, &info);

		cprintf("       %s:%d: %s+%016x  args:%d",
			info.rip_file, info.rip_line, info.rip_fn_name, rip - info.rip_fn_addr, info.rip_fn_narg);
int i;
		for ( i = 0; i < info.rip_fn_narg; ++ i) {
  800420169b:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  800420169f:	8b 85 18 fb ff ff    	mov    -0x4e8(%rbp),%eax
  80042016a5:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  80042016a8:	0f 8f 2a ff ff ff    	jg     80042015d8 <mon_backtrace+0x100>
				cprintf("  %016x", *(uint32_t *) arg_start);
			}
			else cprintf("  %016x", *arg_start);
		}

    cprintf("\n");
  80042016ae:	48 bf 08 58 21 04 80 	movabs $0x8004215808,%rdi
  80042016b5:	00 00 00 
  80042016b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042016bd:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042016c4:	00 00 00 
  80042016c7:	ff d2                	callq  *%rdx
		}
		cprintf("\nCFA: reg %s off %d\n",
			names_of_regs[info.reg_table.cfa_rule.dw_regnum],
			info.reg_table.cfa_rule.dw_offset);
*/
		rip = rbp[1];
  80042016c9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042016cd:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042016d1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		rbp = (uint64_t *) *rbp;
  80042016d5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042016d9:	48 8b 00             	mov    (%rax),%rax
  80042016dc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	// Your code here.
	uint64_t rip, *rbp;
	read_rip(rip);
	rbp = (uint64_t *) read_rbp();
	cprintf("Stack backtrace:\n");
	while (rbp) {
  80042016e0:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042016e5:	0f 85 46 fe ff ff    	jne    8004201531 <mon_backtrace+0x59>
			info.reg_table.cfa_rule.dw_offset);
*/
		rip = rbp[1];
		rbp = (uint64_t *) *rbp;
	}
	return 0;
  80042016eb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042016f0:	c9                   	leaveq 
  80042016f1:	c3                   	retq   

00000080042016f2 <mon_showmm>:


int
mon_showmm(int argc, char **argv, struct Trapframe *tf){
  80042016f2:	55                   	push   %rbp
  80042016f3:	48 89 e5             	mov    %rsp,%rbp
  80042016f6:	48 83 ec 60          	sub    $0x60,%rsp
  80042016fa:	89 7d bc             	mov    %edi,-0x44(%rbp)
  80042016fd:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004201701:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
	if(argc < 3){
  8004201705:	83 7d bc 02          	cmpl   $0x2,-0x44(%rbp)
  8004201709:	7f 25                	jg     8004201730 <mon_showmm+0x3e>
		cprintf("Usage: showmm [va_start] [va_end]\n");
  800420170b:	48 bf 10 58 21 04 80 	movabs $0x8004215810,%rdi
  8004201712:	00 00 00 
  8004201715:	b8 00 00 00 00       	mov    $0x0,%eax
  800420171a:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201721:	00 00 00 
  8004201724:	ff d2                	callq  *%rdx
		return 1;
  8004201726:	b8 01 00 00 00       	mov    $0x1,%eax
  800420172b:	e9 b2 01 00 00       	jmpq   80042018e2 <mon_showmm+0x1f0>
	}
	uintptr_t start = strtol(argv[1], 0, 16), end = strtol(argv[2], 0, 16);
  8004201730:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004201734:	48 83 c0 08          	add    $0x8,%rax
  8004201738:	48 8b 00             	mov    (%rax),%rax
  800420173b:	ba 10 00 00 00       	mov    $0x10,%edx
  8004201740:	be 00 00 00 00       	mov    $0x0,%esi
  8004201745:	48 89 c7             	mov    %rax,%rdi
  8004201748:	48 b8 89 dd 20 04 80 	movabs $0x800420dd89,%rax
  800420174f:	00 00 00 
  8004201752:	ff d0                	callq  *%rax
  8004201754:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004201758:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420175c:	48 83 c0 10          	add    $0x10,%rax
  8004201760:	48 8b 00             	mov    (%rax),%rax
  8004201763:	ba 10 00 00 00       	mov    $0x10,%edx
  8004201768:	be 00 00 00 00       	mov    $0x0,%esi
  800420176d:	48 89 c7             	mov    %rax,%rdi
  8004201770:	48 b8 89 dd 20 04 80 	movabs $0x800420dd89,%rax
  8004201777:	00 00 00 
  800420177a:	ff d0                	callq  *%rax
  800420177c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	pte_t* pte;
	pml4e_t* pml4e = get_pml4e();
  8004201780:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201785:	48 ba 2a 12 20 04 80 	movabs $0x800420122a,%rdx
  800420178c:	00 00 00 
  800420178f:	ff d2                	callq  *%rdx
  8004201791:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	cprintf("        VA                  PA            PTE_U   PTE_W   PTE_P\n");
  8004201795:	48 bf 38 58 21 04 80 	movabs $0x8004215838,%rdi
  800420179c:	00 00 00 
  800420179f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017a4:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042017ab:	00 00 00 
  80042017ae:	ff d2                	callq  *%rdx
uintptr_t va;
	for(va = ROUNDDOWN(start, PGSIZE); va < ROUNDUP(end + 1, PGSIZE); va += PGSIZE){
  80042017b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042017b4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042017b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042017bc:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042017c2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042017c6:	e9 d7 00 00 00       	jmpq   80042018a2 <mon_showmm+0x1b0>
		cprintf("0x%016x  ", va);
  80042017cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042017cf:	48 89 c6             	mov    %rax,%rsi
  80042017d2:	48 bf 79 58 21 04 80 	movabs $0x8004215879,%rdi
  80042017d9:	00 00 00 
  80042017dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017e1:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042017e8:	00 00 00 
  80042017eb:	ff d2                	callq  *%rdx
		if(!page_lookup(pml4e, (void *)va, &pte)){
  80042017ed:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80042017f1:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80042017f5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042017f9:	48 89 ce             	mov    %rcx,%rsi
  80042017fc:	48 89 c7             	mov    %rax,%rdi
  80042017ff:	48 b8 e0 3c 20 04 80 	movabs $0x8004203ce0,%rax
  8004201806:	00 00 00 
  8004201809:	ff d0                	callq  *%rax
  800420180b:	48 85 c0             	test   %rax,%rax
  800420180e:	75 1d                	jne    800420182d <mon_showmm+0x13b>
			cprintf("        -               -       -       -\n");
  8004201810:	48 bf 88 58 21 04 80 	movabs $0x8004215888,%rdi
  8004201817:	00 00 00 
  800420181a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420181f:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201826:	00 00 00 
  8004201829:	ff d2                	callq  *%rdx
  800420182b:	eb 6d                	jmp    800420189a <mon_showmm+0x1a8>
		} 
		else{
			cprintf("0x%016x      %d       %d       %d\n", PTE_ADDR(*pte), !!(*pte & PTE_U), !!(*pte & PTE_W), !!(*pte & PTE_P));
  800420182d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201831:	48 8b 00             	mov    (%rax),%rax
  8004201834:	83 e0 01             	and    $0x1,%eax
  8004201837:	48 85 c0             	test   %rax,%rax
  800420183a:	0f 95 c0             	setne  %al
  800420183d:	0f b6 f8             	movzbl %al,%edi
  8004201840:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201844:	48 8b 00             	mov    (%rax),%rax
  8004201847:	83 e0 02             	and    $0x2,%eax
  800420184a:	48 85 c0             	test   %rax,%rax
  800420184d:	0f 95 c0             	setne  %al
  8004201850:	0f b6 d0             	movzbl %al,%edx
  8004201853:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201857:	48 8b 00             	mov    (%rax),%rax
  800420185a:	83 e0 04             	and    $0x4,%eax
  800420185d:	48 85 c0             	test   %rax,%rax
  8004201860:	0f 95 c0             	setne  %al
  8004201863:	0f b6 c0             	movzbl %al,%eax
  8004201866:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420186a:	48 8b 09             	mov    (%rcx),%rcx
  800420186d:	48 81 e1 00 f0 ff ff 	and    $0xfffffffffffff000,%rcx
  8004201874:	48 89 ce             	mov    %rcx,%rsi
  8004201877:	41 89 f8             	mov    %edi,%r8d
  800420187a:	89 d1                	mov    %edx,%ecx
  800420187c:	89 c2                	mov    %eax,%edx
  800420187e:	48 bf b8 58 21 04 80 	movabs $0x80042158b8,%rdi
  8004201885:	00 00 00 
  8004201888:	b8 00 00 00 00       	mov    $0x0,%eax
  800420188d:	49 b9 0e 92 20 04 80 	movabs $0x800420920e,%r9
  8004201894:	00 00 00 
  8004201897:	41 ff d1             	callq  *%r9
	uintptr_t start = strtol(argv[1], 0, 16), end = strtol(argv[2], 0, 16);
	pte_t* pte;
	pml4e_t* pml4e = get_pml4e();
	cprintf("        VA                  PA            PTE_U   PTE_W   PTE_P\n");
uintptr_t va;
	for(va = ROUNDDOWN(start, PGSIZE); va < ROUNDUP(end + 1, PGSIZE); va += PGSIZE){
  800420189a:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042018a1:	00 
  80042018a2:	48 c7 45 d0 00 10 00 	movq   $0x1000,-0x30(%rbp)
  80042018a9:	00 
  80042018aa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042018ae:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042018b2:	48 01 d0             	add    %rdx,%rax
  80042018b5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042018b9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042018bd:	ba 00 00 00 00       	mov    $0x0,%edx
  80042018c2:	48 f7 75 d0          	divq   -0x30(%rbp)
  80042018c6:	48 89 d0             	mov    %rdx,%rax
  80042018c9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042018cd:	48 29 c2             	sub    %rax,%rdx
  80042018d0:	48 89 d0             	mov    %rdx,%rax
  80042018d3:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042018d7:	0f 87 ee fe ff ff    	ja     80042017cb <mon_showmm+0xd9>
		} 
		else{
			cprintf("0x%016x      %d       %d       %d\n", PTE_ADDR(*pte), !!(*pte & PTE_U), !!(*pte & PTE_W), !!(*pte & PTE_P));
		}
	}
	return 0;
  80042018dd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042018e2:	c9                   	leaveq 
  80042018e3:	c3                   	retq   

00000080042018e4 <mon_setperm>:


int
mon_setperm(int argc, char **argv, struct Trapframe *tf){
  80042018e4:	55                   	push   %rbp
  80042018e5:	48 89 e5             	mov    %rsp,%rbp
  80042018e8:	48 83 ec 50          	sub    $0x50,%rsp
  80042018ec:	89 7d cc             	mov    %edi,-0x34(%rbp)
  80042018ef:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042018f3:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	if(argc < 3){
  80042018f7:	83 7d cc 02          	cmpl   $0x2,-0x34(%rbp)
  80042018fb:	7f 36                	jg     8004201933 <mon_setperm+0x4f>
		cprintf("Usage: setperm [null|-u|-w|-p] va [all bits|one bit]\n");
  80042018fd:	48 bf e0 58 21 04 80 	movabs $0x80042158e0,%rdi
  8004201904:	00 00 00 
  8004201907:	b8 00 00 00 00       	mov    $0x0,%eax
  800420190c:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201913:	00 00 00 
  8004201916:	ff d2                	callq  *%rdx
		cprintf("The 4th need three bits if you choose null for the 2nd parameter, and need only one if you choose the others.\n");
  8004201918:	48 bf 18 59 21 04 80 	movabs $0x8004215918,%rdi
  800420191f:	00 00 00 
  8004201922:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201927:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420192e:	00 00 00 
  8004201931:	ff d2                	callq  *%rdx
	}
	pml4e_t* pml4e = get_pml4e();
  8004201933:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201938:	48 ba 2a 12 20 04 80 	movabs $0x800420122a,%rdx
  800420193f:	00 00 00 
  8004201942:	ff d2                	callq  *%rdx
  8004201944:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	uintptr_t va;
	pte_t *pte;
	if(argc == 3){
  8004201948:	83 7d cc 03          	cmpl   $0x3,-0x34(%rbp)
  800420194c:	0f 85 ba 00 00 00    	jne    8004201a0c <mon_setperm+0x128>
		va = strtol(argv[1], NULL, 16);
  8004201952:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201956:	48 83 c0 08          	add    $0x8,%rax
  800420195a:	48 8b 00             	mov    (%rax),%rax
  800420195d:	ba 10 00 00 00       	mov    $0x10,%edx
  8004201962:	be 00 00 00 00       	mov    $0x0,%esi
  8004201967:	48 89 c7             	mov    %rax,%rdi
  800420196a:	48 b8 89 dd 20 04 80 	movabs $0x800420dd89,%rax
  8004201971:	00 00 00 
  8004201974:	ff d0                	callq  *%rax
  8004201976:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		int bits = strtol(argv[2], NULL, 2);
  800420197a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420197e:	48 83 c0 10          	add    $0x10,%rax
  8004201982:	48 8b 00             	mov    (%rax),%rax
  8004201985:	ba 02 00 00 00       	mov    $0x2,%edx
  800420198a:	be 00 00 00 00       	mov    $0x0,%esi
  800420198f:	48 89 c7             	mov    %rax,%rdi
  8004201992:	48 b8 89 dd 20 04 80 	movabs $0x800420dd89,%rax
  8004201999:	00 00 00 
  800420199c:	ff d0                	callq  *%rax
  800420199e:	89 45 ec             	mov    %eax,-0x14(%rbp)
		if(!page_lookup(pml4e, (void *)va, &pte)){
  80042019a1:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80042019a5:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80042019a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042019ad:	48 89 ce             	mov    %rcx,%rsi
  80042019b0:	48 89 c7             	mov    %rax,%rdi
  80042019b3:	48 b8 e0 3c 20 04 80 	movabs $0x8004203ce0,%rax
  80042019ba:	00 00 00 
  80042019bd:	ff d0                	callq  *%rax
  80042019bf:	48 85 c0             	test   %rax,%rax
  80042019c2:	75 25                	jne    80042019e9 <mon_setperm+0x105>
			cprintf("Pte not existed!\n");
  80042019c4:	48 bf 87 59 21 04 80 	movabs $0x8004215987,%rdi
  80042019cb:	00 00 00 
  80042019ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80042019d3:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042019da:	00 00 00 
  80042019dd:	ff d2                	callq  *%rdx
			return 1;
  80042019df:	b8 01 00 00 00       	mov    $0x1,%eax
  80042019e4:	e9 bc 01 00 00       	jmpq   8004201ba5 <mon_setperm+0x2c1>
		}
		*pte = ((*pte) & (~0x7)) | bits;
  80042019e9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042019ed:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042019f1:	48 8b 12             	mov    (%rdx),%rdx
  80042019f4:	48 89 d1             	mov    %rdx,%rcx
  80042019f7:	48 83 e1 f8          	and    $0xfffffffffffffff8,%rcx
  80042019fb:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042019fe:	48 63 d2             	movslq %edx,%rdx
  8004201a01:	48 09 ca             	or     %rcx,%rdx
  8004201a04:	48 89 10             	mov    %rdx,(%rax)
  8004201a07:	e9 94 01 00 00       	jmpq   8004201ba0 <mon_setperm+0x2bc>
	}
	else if(argc == 4){
  8004201a0c:	83 7d cc 04          	cmpl   $0x4,-0x34(%rbp)
  8004201a10:	0f 85 8a 01 00 00    	jne    8004201ba0 <mon_setperm+0x2bc>
		char* para = argv[1];
  8004201a16:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201a1a:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004201a1e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		if(para[0] != '-'){
  8004201a22:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201a26:	0f b6 00             	movzbl (%rax),%eax
  8004201a29:	3c 2d                	cmp    $0x2d,%al
  8004201a2b:	74 25                	je     8004201a52 <mon_setperm+0x16e>
			cprintf("Usage: setperm [null|-u|-w|-p] va [all bits|one bit]\n");
  8004201a2d:	48 bf e0 58 21 04 80 	movabs $0x80042158e0,%rdi
  8004201a34:	00 00 00 
  8004201a37:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a3c:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201a43:	00 00 00 
  8004201a46:	ff d2                	callq  *%rdx
			return 1;
  8004201a48:	b8 01 00 00 00       	mov    $0x1,%eax
  8004201a4d:	e9 53 01 00 00       	jmpq   8004201ba5 <mon_setperm+0x2c1>
		}
		va = strtol(argv[2], NULL, 16);
  8004201a52:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201a56:	48 83 c0 10          	add    $0x10,%rax
  8004201a5a:	48 8b 00             	mov    (%rax),%rax
  8004201a5d:	ba 10 00 00 00       	mov    $0x10,%edx
  8004201a62:	be 00 00 00 00       	mov    $0x0,%esi
  8004201a67:	48 89 c7             	mov    %rax,%rdi
  8004201a6a:	48 b8 89 dd 20 04 80 	movabs $0x800420dd89,%rax
  8004201a71:	00 00 00 
  8004201a74:	ff d0                	callq  *%rax
  8004201a76:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		int bit = strtol(argv[3], NULL, 2);
  8004201a7a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201a7e:	48 83 c0 18          	add    $0x18,%rax
  8004201a82:	48 8b 00             	mov    (%rax),%rax
  8004201a85:	ba 02 00 00 00       	mov    $0x2,%edx
  8004201a8a:	be 00 00 00 00       	mov    $0x0,%esi
  8004201a8f:	48 89 c7             	mov    %rax,%rdi
  8004201a92:	48 b8 89 dd 20 04 80 	movabs $0x800420dd89,%rax
  8004201a99:	00 00 00 
  8004201a9c:	ff d0                	callq  *%rax
  8004201a9e:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if(!page_lookup(pml4e, (void *)va, &pte)){
  8004201aa1:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8004201aa5:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004201aa9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201aad:	48 89 ce             	mov    %rcx,%rsi
  8004201ab0:	48 89 c7             	mov    %rax,%rdi
  8004201ab3:	48 b8 e0 3c 20 04 80 	movabs $0x8004203ce0,%rax
  8004201aba:	00 00 00 
  8004201abd:	ff d0                	callq  *%rax
  8004201abf:	48 85 c0             	test   %rax,%rax
  8004201ac2:	75 25                	jne    8004201ae9 <mon_setperm+0x205>
			cprintf("Pte not existed!\n");
  8004201ac4:	48 bf 87 59 21 04 80 	movabs $0x8004215987,%rdi
  8004201acb:	00 00 00 
  8004201ace:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201ad3:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201ada:	00 00 00 
  8004201add:	ff d2                	callq  *%rdx
			return 1;
  8004201adf:	b8 01 00 00 00       	mov    $0x1,%eax
  8004201ae4:	e9 bc 00 00 00       	jmpq   8004201ba5 <mon_setperm+0x2c1>
		}	
		if(para[1] == 'u'){
  8004201ae9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201aed:	48 83 c0 01          	add    $0x1,%rax
  8004201af1:	0f b6 00             	movzbl (%rax),%eax
  8004201af4:	3c 75                	cmp    $0x75,%al
  8004201af6:	75 26                	jne    8004201b1e <mon_setperm+0x23a>
			*pte = ((*pte) & (~PTE_U)) | (bit << 2);
  8004201af8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201afc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004201b00:	48 8b 12             	mov    (%rdx),%rdx
  8004201b03:	48 89 d1             	mov    %rdx,%rcx
  8004201b06:	48 83 e1 fb          	and    $0xfffffffffffffffb,%rcx
  8004201b0a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004201b0d:	c1 e2 02             	shl    $0x2,%edx
  8004201b10:	48 63 d2             	movslq %edx,%rdx
  8004201b13:	48 09 ca             	or     %rcx,%rdx
  8004201b16:	48 89 10             	mov    %rdx,(%rax)
  8004201b19:	e9 82 00 00 00       	jmpq   8004201ba0 <mon_setperm+0x2bc>
		} 
		else if(para[1] == 'w'){
  8004201b1e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201b22:	48 83 c0 01          	add    $0x1,%rax
  8004201b26:	0f b6 00             	movzbl (%rax),%eax
  8004201b29:	3c 77                	cmp    $0x77,%al
  8004201b2b:	75 22                	jne    8004201b4f <mon_setperm+0x26b>
			*pte = ((*pte) & (~PTE_W)) | (bit << 1);
  8004201b2d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201b31:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004201b35:	48 8b 12             	mov    (%rdx),%rdx
  8004201b38:	48 89 d1             	mov    %rdx,%rcx
  8004201b3b:	48 83 e1 fd          	and    $0xfffffffffffffffd,%rcx
  8004201b3f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004201b42:	01 d2                	add    %edx,%edx
  8004201b44:	48 63 d2             	movslq %edx,%rdx
  8004201b47:	48 09 ca             	or     %rcx,%rdx
  8004201b4a:	48 89 10             	mov    %rdx,(%rax)
  8004201b4d:	eb 51                	jmp    8004201ba0 <mon_setperm+0x2bc>
		}
		else if(para[1] == 'p'){
  8004201b4f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201b53:	48 83 c0 01          	add    $0x1,%rax
  8004201b57:	0f b6 00             	movzbl (%rax),%eax
  8004201b5a:	3c 70                	cmp    $0x70,%al
  8004201b5c:	75 20                	jne    8004201b7e <mon_setperm+0x29a>
			*pte = ((*pte) & (~PTE_P)) | bit;
  8004201b5e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201b62:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004201b66:	48 8b 12             	mov    (%rdx),%rdx
  8004201b69:	48 89 d1             	mov    %rdx,%rcx
  8004201b6c:	48 83 e1 fe          	and    $0xfffffffffffffffe,%rcx
  8004201b70:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004201b73:	48 63 d2             	movslq %edx,%rdx
  8004201b76:	48 09 ca             	or     %rcx,%rdx
  8004201b79:	48 89 10             	mov    %rdx,(%rax)
  8004201b7c:	eb 22                	jmp    8004201ba0 <mon_setperm+0x2bc>
		}
		else{
			cprintf("Usage: setperm [null|-u|-w|-p] va [all bits|one bit]\n");
  8004201b7e:	48 bf e0 58 21 04 80 	movabs $0x80042158e0,%rdi
  8004201b85:	00 00 00 
  8004201b88:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b8d:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201b94:	00 00 00 
  8004201b97:	ff d2                	callq  *%rdx
			return 1;
  8004201b99:	b8 01 00 00 00       	mov    $0x1,%eax
  8004201b9e:	eb 05                	jmp    8004201ba5 <mon_setperm+0x2c1>
		}
	}
	return 0;
  8004201ba0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201ba5:	c9                   	leaveq 
  8004201ba6:	c3                   	retq   

0000008004201ba7 <mon_dumpm>:

int
mon_dumpm(int argc, char **argv, struct Trapframe *tf){
  8004201ba7:	55                   	push   %rbp
  8004201ba8:	48 89 e5             	mov    %rsp,%rbp
  8004201bab:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004201baf:	89 7d 9c             	mov    %edi,-0x64(%rbp)
  8004201bb2:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  8004201bb6:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
	if(argc < 3){
  8004201bba:	83 7d 9c 02          	cmpl   $0x2,-0x64(%rbp)
  8004201bbe:	7f 25                	jg     8004201be5 <mon_dumpm+0x3e>
		cprintf("Usage: dumpmm [-v|-p] start end\n");
  8004201bc0:	48 bf a0 59 21 04 80 	movabs $0x80042159a0,%rdi
  8004201bc7:	00 00 00 
  8004201bca:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201bcf:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201bd6:	00 00 00 
  8004201bd9:	ff d2                	callq  *%rdx
		return 1;
  8004201bdb:	b8 01 00 00 00       	mov    $0x1,%eax
  8004201be0:	e9 56 02 00 00       	jmpq   8004201e3b <mon_dumpm+0x294>
	}
	char* para = argv[1];
  8004201be5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201be9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004201bed:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(para[0] != '-' || (para[1] != 'v' && para[1] != 'p')){
  8004201bf1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201bf5:	0f b6 00             	movzbl (%rax),%eax
  8004201bf8:	3c 2d                	cmp    $0x2d,%al
  8004201bfa:	75 1e                	jne    8004201c1a <mon_dumpm+0x73>
  8004201bfc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201c00:	48 83 c0 01          	add    $0x1,%rax
  8004201c04:	0f b6 00             	movzbl (%rax),%eax
  8004201c07:	3c 76                	cmp    $0x76,%al
  8004201c09:	74 34                	je     8004201c3f <mon_dumpm+0x98>
  8004201c0b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201c0f:	48 83 c0 01          	add    $0x1,%rax
  8004201c13:	0f b6 00             	movzbl (%rax),%eax
  8004201c16:	3c 70                	cmp    $0x70,%al
  8004201c18:	74 25                	je     8004201c3f <mon_dumpm+0x98>
		cprintf("Usage: dumpmm [-v|-p] start end\n");
  8004201c1a:	48 bf a0 59 21 04 80 	movabs $0x80042159a0,%rdi
  8004201c21:	00 00 00 
  8004201c24:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c29:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201c30:	00 00 00 
  8004201c33:	ff d2                	callq  *%rdx
		return 1;
  8004201c35:	b8 01 00 00 00       	mov    $0x1,%eax
  8004201c3a:	e9 fc 01 00 00       	jmpq   8004201e3b <mon_dumpm+0x294>
	}
	pml4e_t* pml4e = get_pml4e();
  8004201c3f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c44:	48 ba 2a 12 20 04 80 	movabs $0x800420122a,%rdx
  8004201c4b:	00 00 00 
  8004201c4e:	ff d2                	callq  *%rdx
  8004201c50:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uintptr_t offset = para[1] == 'v' ? 0 : KERNBASE;
  8004201c54:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201c58:	48 83 c0 01          	add    $0x1,%rax
  8004201c5c:	0f b6 00             	movzbl (%rax),%eax
  8004201c5f:	3c 76                	cmp    $0x76,%al
  8004201c61:	75 07                	jne    8004201c6a <mon_dumpm+0xc3>
  8004201c63:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c68:	eb 0a                	jmp    8004201c74 <mon_dumpm+0xcd>
  8004201c6a:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004201c71:	00 00 00 
  8004201c74:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	uintptr_t start = ROUNDDOWN(strtol(argv[2], NULL, 16) + offset, 4), end = argc == 3 ? start + 1 : ROUNDDOWN(strtol(argv[3], NULL, 16) + offset - 1, 4);
  8004201c78:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201c7c:	48 83 c0 10          	add    $0x10,%rax
  8004201c80:	48 8b 00             	mov    (%rax),%rax
  8004201c83:	ba 10 00 00 00       	mov    $0x10,%edx
  8004201c88:	be 00 00 00 00       	mov    $0x0,%esi
  8004201c8d:	48 89 c7             	mov    %rax,%rdi
  8004201c90:	48 b8 89 dd 20 04 80 	movabs $0x800420dd89,%rax
  8004201c97:	00 00 00 
  8004201c9a:	ff d0                	callq  *%rax
  8004201c9c:	48 89 c2             	mov    %rax,%rdx
  8004201c9f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201ca3:	48 01 d0             	add    %rdx,%rax
  8004201ca6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004201caa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201cae:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  8004201cb2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004201cb6:	83 7d 9c 03          	cmpl   $0x3,-0x64(%rbp)
  8004201cba:	75 0a                	jne    8004201cc6 <mon_dumpm+0x11f>
  8004201cbc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201cc0:	48 83 c0 01          	add    $0x1,%rax
  8004201cc4:	eb 3e                	jmp    8004201d04 <mon_dumpm+0x15d>
  8004201cc6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201cca:	48 83 c0 18          	add    $0x18,%rax
  8004201cce:	48 8b 00             	mov    (%rax),%rax
  8004201cd1:	ba 10 00 00 00       	mov    $0x10,%edx
  8004201cd6:	be 00 00 00 00       	mov    $0x0,%esi
  8004201cdb:	48 89 c7             	mov    %rax,%rdi
  8004201cde:	48 b8 89 dd 20 04 80 	movabs $0x800420dd89,%rax
  8004201ce5:	00 00 00 
  8004201ce8:	ff d0                	callq  *%rax
  8004201cea:	48 89 c2             	mov    %rax,%rdx
  8004201ced:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201cf1:	48 01 d0             	add    %rdx,%rax
  8004201cf4:	48 83 e8 01          	sub    $0x1,%rax
  8004201cf8:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004201cfc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201d00:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  8004201d04:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  int count = ((end - start) >> 2) + 1;
  8004201d08:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201d0c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004201d10:	48 29 c2             	sub    %rax,%rdx
  8004201d13:	48 89 d0             	mov    %rdx,%rax
  8004201d16:	48 c1 e8 02          	shr    $0x2,%rax
  8004201d1a:	83 c0 01             	add    $0x1,%eax
  8004201d1d:	89 45 bc             	mov    %eax,-0x44(%rbp)
	cprintf("Memory dump of [%s, %s), word aligned:", argv[2], argv[3]);
  8004201d20:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201d24:	48 83 c0 18          	add    $0x18,%rax
  8004201d28:	48 8b 10             	mov    (%rax),%rdx
  8004201d2b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201d2f:	48 83 c0 10          	add    $0x10,%rax
  8004201d33:	48 8b 00             	mov    (%rax),%rax
  8004201d36:	48 89 c6             	mov    %rax,%rsi
  8004201d39:	48 bf c8 59 21 04 80 	movabs $0x80042159c8,%rdi
  8004201d40:	00 00 00 
  8004201d43:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201d48:	48 b9 0e 92 20 04 80 	movabs $0x800420920e,%rcx
  8004201d4f:	00 00 00 
  8004201d52:	ff d1                	callq  *%rcx
//	for(uint32_t* p = start;p <= end; p++){
	//	cprintf("%016x: %08x\n", (uintptr_t)p - offset, *p);
	//}
	pte_t * pte;
int i;
	for( i = 0; i < count; i++){
  8004201d54:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004201d5b:	e9 af 00 00 00       	jmpq   8004201e0f <mon_dumpm+0x268>
		uint32_t* va = ((uint32_t*) start) + i;
  8004201d60:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201d63:	48 98                	cltq   
  8004201d65:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  8004201d6c:	00 
  8004201d6d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201d71:	48 01 d0             	add    %rdx,%rax
  8004201d74:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		if(i % 8 == 0)
  8004201d78:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201d7b:	83 e0 07             	and    $0x7,%eax
  8004201d7e:	85 c0                	test   %eax,%eax
  8004201d80:	75 26                	jne    8004201da8 <mon_dumpm+0x201>
			cprintf("\n%016x", (uintptr_t)va - offset);
  8004201d82:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004201d86:	48 2b 45 e0          	sub    -0x20(%rbp),%rax
  8004201d8a:	48 89 c6             	mov    %rax,%rsi
  8004201d8d:	48 bf ef 59 21 04 80 	movabs $0x80042159ef,%rdi
  8004201d94:	00 00 00 
  8004201d97:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201d9c:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201da3:	00 00 00 
  8004201da6:	ff d2                	callq  *%rdx
		if(!page_lookup(pml4e, va, &pte)){
  8004201da8:	48 8d 55 a8          	lea    -0x58(%rbp),%rdx
  8004201dac:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004201db0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201db4:	48 89 ce             	mov    %rcx,%rsi
  8004201db7:	48 89 c7             	mov    %rax,%rdi
  8004201dba:	48 b8 e0 3c 20 04 80 	movabs $0x8004203ce0,%rax
  8004201dc1:	00 00 00 
  8004201dc4:	ff d0                	callq  *%rax
  8004201dc6:	48 85 c0             	test   %rax,%rax
  8004201dc9:	75 1d                	jne    8004201de8 <mon_dumpm+0x241>
			cprintf(" --------");
  8004201dcb:	48 bf f6 59 21 04 80 	movabs $0x80042159f6,%rdi
  8004201dd2:	00 00 00 
  8004201dd5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201dda:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201de1:	00 00 00 
  8004201de4:	ff d2                	callq  *%rdx
  8004201de6:	eb 23                	jmp    8004201e0b <mon_dumpm+0x264>
		} 
		else{
			cprintf(" %08x", *va);
  8004201de8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004201dec:	8b 00                	mov    (%rax),%eax
  8004201dee:	89 c6                	mov    %eax,%esi
  8004201df0:	48 bf 00 5a 21 04 80 	movabs $0x8004215a00,%rdi
  8004201df7:	00 00 00 
  8004201dfa:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201dff:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201e06:	00 00 00 
  8004201e09:	ff d2                	callq  *%rdx
//	for(uint32_t* p = start;p <= end; p++){
	//	cprintf("%016x: %08x\n", (uintptr_t)p - offset, *p);
	//}
	pte_t * pte;
int i;
	for( i = 0; i < count; i++){
  8004201e0b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004201e0f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201e12:	3b 45 bc             	cmp    -0x44(%rbp),%eax
  8004201e15:	0f 8c 45 ff ff ff    	jl     8004201d60 <mon_dumpm+0x1b9>
		} 
		else{
			cprintf(" %08x", *va);
		}
	}
	cprintf("\n");
  8004201e1b:	48 bf 08 58 21 04 80 	movabs $0x8004215808,%rdi
  8004201e22:	00 00 00 
  8004201e25:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201e2a:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201e31:	00 00 00 
  8004201e34:	ff d2                	callq  *%rdx
	return 0;
  8004201e36:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201e3b:	c9                   	leaveq 
  8004201e3c:	c3                   	retq   

0000008004201e3d <mon_continue>:


int
mon_continue(int argc, char **argv, struct Trapframe *tf){
  8004201e3d:	55                   	push   %rbp
  8004201e3e:	48 89 e5             	mov    %rsp,%rbp
  8004201e41:	48 83 ec 20          	sub    $0x20,%rsp
  8004201e45:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201e48:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004201e4c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	if(!tf){
  8004201e50:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201e55:	75 22                	jne    8004201e79 <mon_continue+0x3c>
		cprintf("No env running\n");
  8004201e57:	48 bf 06 5a 21 04 80 	movabs $0x8004215a06,%rdi
  8004201e5e:	00 00 00 
  8004201e61:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201e66:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201e6d:	00 00 00 
  8004201e70:	ff d2                	callq  *%rdx
		return 0;
  8004201e72:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201e77:	eb 5c                	jmp    8004201ed5 <mon_continue+0x98>
	} else{
		tf->tf_eflags &= ~FL_TF;
  8004201e79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201e7d:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8004201e84:	80 e4 fe             	and    $0xfe,%ah
  8004201e87:	48 89 c2             	mov    %rax,%rdx
  8004201e8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201e8e:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
		env_run(curenv);
  8004201e95:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004201e9c:	00 00 00 
  8004201e9f:	ff d0                	callq  *%rax
  8004201ea1:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004201ea8:	00 00 00 
  8004201eab:	48 98                	cltq   
  8004201ead:	48 c1 e0 03          	shl    $0x3,%rax
  8004201eb1:	48 89 c2             	mov    %rax,%rdx
  8004201eb4:	48 c1 e2 04          	shl    $0x4,%rdx
  8004201eb8:	48 29 c2             	sub    %rax,%rdx
  8004201ebb:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004201ebf:	48 83 c0 08          	add    $0x8,%rax
  8004201ec3:	48 8b 00             	mov    (%rax),%rax
  8004201ec6:	48 89 c7             	mov    %rax,%rdi
  8004201ec9:	48 b8 ca 8c 20 04 80 	movabs $0x8004208cca,%rax
  8004201ed0:	00 00 00 
  8004201ed3:	ff d0                	callq  *%rax
		panic("Env unsucessfully exited\n");
		return -1;
	}
}
  8004201ed5:	c9                   	leaveq 
  8004201ed6:	c3                   	retq   

0000008004201ed7 <mon_si>:
int
mon_si(int argc, char **argv, struct Trapframe *tf){
  8004201ed7:	55                   	push   %rbp
  8004201ed8:	48 89 e5             	mov    %rsp,%rbp
  8004201edb:	48 83 ec 20          	sub    $0x20,%rsp
  8004201edf:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201ee2:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004201ee6:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	if(!tf){
  8004201eea:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201eef:	75 25                	jne    8004201f16 <mon_si+0x3f>
		cprintf("No env running\n");
  8004201ef1:	48 bf 06 5a 21 04 80 	movabs $0x8004215a06,%rdi
  8004201ef8:	00 00 00 
  8004201efb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201f00:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004201f07:	00 00 00 
  8004201f0a:	ff d2                	callq  *%rdx
		return 0;
  8004201f0c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201f11:	e9 93 00 00 00       	jmpq   8004201fa9 <mon_si+0xd2>
	} else{
		tf->tf_eflags |= FL_TF;
  8004201f16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201f1a:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8004201f21:	80 cc 01             	or     $0x1,%ah
  8004201f24:	48 89 c2             	mov    %rax,%rdx
  8004201f27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201f2b:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
		cprintf("Step at 0x%016x: %016x\n", tf->tf_rip, *(uint64_t*)(tf->tf_rip));
  8004201f32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201f36:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  8004201f3d:	48 8b 10             	mov    (%rax),%rdx
  8004201f40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201f44:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  8004201f4b:	48 89 c6             	mov    %rax,%rsi
  8004201f4e:	48 bf 16 5a 21 04 80 	movabs $0x8004215a16,%rdi
  8004201f55:	00 00 00 
  8004201f58:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201f5d:	48 b9 0e 92 20 04 80 	movabs $0x800420920e,%rcx
  8004201f64:	00 00 00 
  8004201f67:	ff d1                	callq  *%rcx
		env_run(curenv);
  8004201f69:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004201f70:	00 00 00 
  8004201f73:	ff d0                	callq  *%rax
  8004201f75:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004201f7c:	00 00 00 
  8004201f7f:	48 98                	cltq   
  8004201f81:	48 c1 e0 03          	shl    $0x3,%rax
  8004201f85:	48 89 c2             	mov    %rax,%rdx
  8004201f88:	48 c1 e2 04          	shl    $0x4,%rdx
  8004201f8c:	48 29 c2             	sub    %rax,%rdx
  8004201f8f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004201f93:	48 83 c0 08          	add    $0x8,%rax
  8004201f97:	48 8b 00             	mov    (%rax),%rax
  8004201f9a:	48 89 c7             	mov    %rax,%rdi
  8004201f9d:	48 b8 ca 8c 20 04 80 	movabs $0x8004208cca,%rax
  8004201fa4:	00 00 00 
  8004201fa7:	ff d0                	callq  *%rax
		panic("Env unsucessfully exited\n");
		return -1;
	}
}
  8004201fa9:	c9                   	leaveq 
  8004201faa:	c3                   	retq   

0000008004201fab <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  8004201fab:	55                   	push   %rbp
  8004201fac:	48 89 e5             	mov    %rsp,%rbp
  8004201faf:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004201fb6:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004201fbd:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  8004201fc4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  8004201fcb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201fce:	48 98                	cltq   
  8004201fd0:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004201fd7:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201fdc:	eb 15                	jmp    8004201ff3 <runcmd+0x48>
			*buf++ = 0;
  8004201fde:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201fe5:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004201fe9:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
  8004201ff0:	c6 00 00             	movb   $0x0,(%rax)
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201ff3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201ffa:	0f b6 00             	movzbl (%rax),%eax
  8004201ffd:	84 c0                	test   %al,%al
  8004201fff:	74 2a                	je     800420202b <runcmd+0x80>
  8004202001:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004202008:	0f b6 00             	movzbl (%rax),%eax
  800420200b:	0f be c0             	movsbl %al,%eax
  800420200e:	89 c6                	mov    %eax,%esi
  8004202010:	48 bf 2e 5a 21 04 80 	movabs $0x8004215a2e,%rdi
  8004202017:	00 00 00 
  800420201a:	48 b8 83 da 20 04 80 	movabs $0x800420da83,%rax
  8004202021:	00 00 00 
  8004202024:	ff d0                	callq  *%rax
  8004202026:	48 85 c0             	test   %rax,%rax
  8004202029:	75 b3                	jne    8004201fde <runcmd+0x33>
			*buf++ = 0;
		if (*buf == 0)
  800420202b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004202032:	0f b6 00             	movzbl (%rax),%eax
  8004202035:	84 c0                	test   %al,%al
  8004202037:	75 21                	jne    800420205a <runcmd+0xaf>
			break;
  8004202039:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  800420203a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420203d:	48 98                	cltq   
  800420203f:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004202046:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  800420204b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420204f:	0f 85 a1 00 00 00    	jne    80042020f6 <runcmd+0x14b>
  8004202055:	e9 92 00 00 00       	jmpq   80042020ec <runcmd+0x141>
			*buf++ = 0;
		if (*buf == 0)
			break;

		// save and scan past next arg
		if (argc == MAXARGS-1) {
  800420205a:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  800420205e:	75 2a                	jne    800420208a <runcmd+0xdf>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  8004202060:	be 10 00 00 00       	mov    $0x10,%esi
  8004202065:	48 bf 33 5a 21 04 80 	movabs $0x8004215a33,%rdi
  800420206c:	00 00 00 
  800420206f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202074:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420207b:	00 00 00 
  800420207e:	ff d2                	callq  *%rdx
			return 0;
  8004202080:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202085:	e9 30 01 00 00       	jmpq   80042021ba <runcmd+0x20f>
		}
		argv[argc++] = buf;
  800420208a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420208d:	8d 50 01             	lea    0x1(%rax),%edx
  8004202090:	89 55 fc             	mov    %edx,-0x4(%rbp)
  8004202093:	48 98                	cltq   
  8004202095:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  800420209c:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  80042020a3:	ff 
		while (*buf && !strchr(WHITESPACE, *buf))
  80042020a4:	eb 08                	jmp    80042020ae <runcmd+0x103>
			buf++;
  80042020a6:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  80042020ad:	01 
		if (argc == MAXARGS-1) {
			cprintf("Too many arguments (max %d)\n", MAXARGS);
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
  80042020ae:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042020b5:	0f b6 00             	movzbl (%rax),%eax
  80042020b8:	84 c0                	test   %al,%al
  80042020ba:	74 2a                	je     80042020e6 <runcmd+0x13b>
  80042020bc:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042020c3:	0f b6 00             	movzbl (%rax),%eax
  80042020c6:	0f be c0             	movsbl %al,%eax
  80042020c9:	89 c6                	mov    %eax,%esi
  80042020cb:	48 bf 2e 5a 21 04 80 	movabs $0x8004215a2e,%rdi
  80042020d2:	00 00 00 
  80042020d5:	48 b8 83 da 20 04 80 	movabs $0x800420da83,%rax
  80042020dc:	00 00 00 
  80042020df:	ff d0                	callq  *%rax
  80042020e1:	48 85 c0             	test   %rax,%rax
  80042020e4:	74 c0                	je     80042020a6 <runcmd+0xfb>
			buf++;
	}
  80042020e6:	90                   	nop
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  80042020e7:	e9 07 ff ff ff       	jmpq   8004201ff3 <runcmd+0x48>
	}
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
  80042020ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042020f1:	e9 c4 00 00 00       	jmpq   80042021ba <runcmd+0x20f>
	for (i = 0; i < NCOMMANDS; i++) {
  80042020f6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  80042020fd:	e9 82 00 00 00       	jmpq   8004202184 <runcmd+0x1d9>
		if (strcmp(argv[0], commands[i].name) == 0)
  8004202102:	48 b9 80 a5 22 04 80 	movabs $0x800422a580,%rcx
  8004202109:	00 00 00 
  800420210c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420210f:	48 63 d0             	movslq %eax,%rdx
  8004202112:	48 89 d0             	mov    %rdx,%rax
  8004202115:	48 01 c0             	add    %rax,%rax
  8004202118:	48 01 d0             	add    %rdx,%rax
  800420211b:	48 c1 e0 03          	shl    $0x3,%rax
  800420211f:	48 01 c8             	add    %rcx,%rax
  8004202122:	48 8b 10             	mov    (%rax),%rdx
  8004202125:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420212c:	48 89 d6             	mov    %rdx,%rsi
  800420212f:	48 89 c7             	mov    %rax,%rdi
  8004202132:	48 b8 bf d9 20 04 80 	movabs $0x800420d9bf,%rax
  8004202139:	00 00 00 
  800420213c:	ff d0                	callq  *%rax
  800420213e:	85 c0                	test   %eax,%eax
  8004202140:	75 3e                	jne    8004202180 <runcmd+0x1d5>
			return commands[i].func(argc, argv, tf);
  8004202142:	48 b9 80 a5 22 04 80 	movabs $0x800422a580,%rcx
  8004202149:	00 00 00 
  800420214c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420214f:	48 63 d0             	movslq %eax,%rdx
  8004202152:	48 89 d0             	mov    %rdx,%rax
  8004202155:	48 01 c0             	add    %rax,%rax
  8004202158:	48 01 d0             	add    %rdx,%rax
  800420215b:	48 c1 e0 03          	shl    $0x3,%rax
  800420215f:	48 01 c8             	add    %rcx,%rax
  8004202162:	48 83 c0 10          	add    $0x10,%rax
  8004202166:	48 8b 00             	mov    (%rax),%rax
  8004202169:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004202170:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
  8004202177:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800420217a:	89 cf                	mov    %ecx,%edi
  800420217c:	ff d0                	callq  *%rax
  800420217e:	eb 3a                	jmp    80042021ba <runcmd+0x20f>
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
	for (i = 0; i < NCOMMANDS; i++) {
  8004202180:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004202184:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004202187:	83 f8 07             	cmp    $0x7,%eax
  800420218a:	0f 86 72 ff ff ff    	jbe    8004202102 <runcmd+0x157>
		if (strcmp(argv[0], commands[i].name) == 0)
			return commands[i].func(argc, argv, tf);
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  8004202190:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202197:	48 89 c6             	mov    %rax,%rsi
  800420219a:	48 bf 50 5a 21 04 80 	movabs $0x8004215a50,%rdi
  80042021a1:	00 00 00 
  80042021a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042021a9:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042021b0:	00 00 00 
  80042021b3:	ff d2                	callq  *%rdx
	return 0;
  80042021b5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042021ba:	c9                   	leaveq 
  80042021bb:	c3                   	retq   

00000080042021bc <monitor>:

void
monitor(struct Trapframe *tf)
{
  80042021bc:	55                   	push   %rbp
  80042021bd:	48 89 e5             	mov    %rsp,%rbp
  80042021c0:	48 83 ec 20          	sub    $0x20,%rsp
  80042021c4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  80042021c8:	48 bf 68 5a 21 04 80 	movabs $0x8004215a68,%rdi
  80042021cf:	00 00 00 
  80042021d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042021d7:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042021de:	00 00 00 
  80042021e1:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  80042021e3:	48 bf 90 5a 21 04 80 	movabs $0x8004215a90,%rdi
  80042021ea:	00 00 00 
  80042021ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042021f2:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042021f9:	00 00 00 
  80042021fc:	ff d2                	callq  *%rdx

	cprintf(RED "RED" GREEN"GREEN"YELLOW"YELLOW"BLUE"BLUE"MAGNETA"MAGNETA"CYAN"CYAN\n" RESET);
  80042021fe:	48 bf b8 5a 21 04 80 	movabs $0x8004215ab8,%rdi
  8004202205:	00 00 00 
  8004202208:	b8 00 00 00 00       	mov    $0x0,%eax
  800420220d:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004202214:	00 00 00 
  8004202217:	ff d2                	callq  *%rdx
	if (tf != NULL)
  8004202219:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420221e:	74 13                	je     8004202233 <monitor+0x77>
		print_trapframe(tf);
  8004202220:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202224:	48 89 c7             	mov    %rax,%rdi
  8004202227:	48 b8 f9 a0 20 04 80 	movabs $0x800420a0f9,%rax
  800420222e:	00 00 00 
  8004202231:	ff d0                	callq  *%rax
	while (1) {
		buf = readline("K> ");
  8004202233:	48 bf f9 5a 21 04 80 	movabs $0x8004215af9,%rdi
  800420223a:	00 00 00 
  800420223d:	48 b8 9c d6 20 04 80 	movabs $0x800420d69c,%rax
  8004202244:	00 00 00 
  8004202247:	ff d0                	callq  *%rax
  8004202249:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  800420224d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202252:	74 20                	je     8004202274 <monitor+0xb8>
			if (runcmd(buf, tf) < 0)
  8004202254:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202258:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420225c:	48 89 d6             	mov    %rdx,%rsi
  800420225f:	48 89 c7             	mov    %rax,%rdi
  8004202262:	48 b8 ab 1f 20 04 80 	movabs $0x8004201fab,%rax
  8004202269:	00 00 00 
  800420226c:	ff d0                	callq  *%rax
  800420226e:	85 c0                	test   %eax,%eax
  8004202270:	79 02                	jns    8004202274 <monitor+0xb8>
				break;
  8004202272:	eb 02                	jmp    8004202276 <monitor+0xba>
	}
  8004202274:	eb bd                	jmp    8004202233 <monitor+0x77>
}
  8004202276:	c9                   	leaveq 
  8004202277:	c3                   	retq   

0000008004202278 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004202278:	55                   	push   %rbp
  8004202279:	48 89 e5             	mov    %rsp,%rbp
  800420227c:	48 83 ec 08          	sub    $0x8,%rsp
  8004202280:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004202284:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202288:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  800420228f:	00 00 00 
  8004202292:	48 8b 00             	mov    (%rax),%rax
  8004202295:	48 29 c2             	sub    %rax,%rdx
  8004202298:	48 89 d0             	mov    %rdx,%rax
  800420229b:	48 c1 f8 04          	sar    $0x4,%rax
}
  800420229f:	c9                   	leaveq 
  80042022a0:	c3                   	retq   

00000080042022a1 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  80042022a1:	55                   	push   %rbp
  80042022a2:	48 89 e5             	mov    %rsp,%rbp
  80042022a5:	48 83 ec 08          	sub    $0x8,%rsp
  80042022a9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  80042022ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042022b1:	48 89 c7             	mov    %rax,%rdi
  80042022b4:	48 b8 78 22 20 04 80 	movabs $0x8004202278,%rax
  80042022bb:	00 00 00 
  80042022be:	ff d0                	callq  *%rax
  80042022c0:	48 c1 e0 0c          	shl    $0xc,%rax
}
  80042022c4:	c9                   	leaveq 
  80042022c5:	c3                   	retq   

00000080042022c6 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  80042022c6:	55                   	push   %rbp
  80042022c7:	48 89 e5             	mov    %rsp,%rbp
  80042022ca:	48 83 ec 10          	sub    $0x10,%rsp
  80042022ce:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  80042022d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042022d6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042022da:	48 89 c2             	mov    %rax,%rdx
  80042022dd:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  80042022e4:	00 00 00 
  80042022e7:	48 8b 00             	mov    (%rax),%rax
  80042022ea:	48 39 c2             	cmp    %rax,%rdx
  80042022ed:	72 2a                	jb     8004202319 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  80042022ef:	48 ba 00 5b 21 04 80 	movabs $0x8004215b00,%rdx
  80042022f6:	00 00 00 
  80042022f9:	be 54 00 00 00       	mov    $0x54,%esi
  80042022fe:	48 bf 1f 5b 21 04 80 	movabs $0x8004215b1f,%rdi
  8004202305:	00 00 00 
  8004202308:	b8 00 00 00 00       	mov    $0x0,%eax
  800420230d:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  8004202314:	00 00 00 
  8004202317:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004202319:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  8004202320:	00 00 00 
  8004202323:	48 8b 00             	mov    (%rax),%rax
  8004202326:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420232a:	48 c1 ea 0c          	shr    $0xc,%rdx
  800420232e:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202332:	48 01 d0             	add    %rdx,%rax
}
  8004202335:	c9                   	leaveq 
  8004202336:	c3                   	retq   

0000008004202337 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004202337:	55                   	push   %rbp
  8004202338:	48 89 e5             	mov    %rsp,%rbp
  800420233b:	48 83 ec 20          	sub    $0x20,%rsp
  800420233f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004202343:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202347:	48 89 c7             	mov    %rax,%rdi
  800420234a:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  8004202351:	00 00 00 
  8004202354:	ff d0                	callq  *%rax
  8004202356:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420235a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420235e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202362:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004202365:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004202368:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  800420236f:	00 00 00 
  8004202372:	48 8b 00             	mov    (%rax),%rax
  8004202375:	48 39 c2             	cmp    %rax,%rdx
  8004202378:	72 32                	jb     80042023ac <page2kva+0x75>
  800420237a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420237e:	48 89 c1             	mov    %rax,%rcx
  8004202381:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  8004202388:	00 00 00 
  800420238b:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004202390:	48 bf 1f 5b 21 04 80 	movabs $0x8004215b1f,%rdi
  8004202397:	00 00 00 
  800420239a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420239f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042023a6:	00 00 00 
  80042023a9:	41 ff d0             	callq  *%r8
  80042023ac:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042023b3:	00 00 00 
  80042023b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042023ba:	48 01 d0             	add    %rdx,%rax
}
  80042023bd:	c9                   	leaveq 
  80042023be:	c3                   	retq   

00000080042023bf <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

static __inline uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  80042023bf:	55                   	push   %rbp
  80042023c0:	48 89 e5             	mov    %rsp,%rbp
  80042023c3:	48 83 ec 08          	sub    $0x8,%rsp
  80042023c7:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80042023ca:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  80042023cd:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  80042023d1:	74 06                	je     80042023d9 <restrictive_type+0x1a>
  80042023d3:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  80042023d7:	75 07                	jne    80042023e0 <restrictive_type+0x21>
    return MB_TYPE_BAD;
  80042023d9:	b8 05 00 00 00       	mov    $0x5,%eax
  80042023de:	eb 3e                	jmp    800420241e <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  80042023e0:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  80042023e4:	74 06                	je     80042023ec <restrictive_type+0x2d>
  80042023e6:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  80042023ea:	75 07                	jne    80042023f3 <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  80042023ec:	b8 04 00 00 00       	mov    $0x4,%eax
  80042023f1:	eb 2b                	jmp    800420241e <restrictive_type+0x5f>
  else if(t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  80042023f3:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  80042023f7:	74 06                	je     80042023ff <restrictive_type+0x40>
  80042023f9:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  80042023fd:	75 07                	jne    8004202406 <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  80042023ff:	b8 02 00 00 00       	mov    $0x2,%eax
  8004202404:	eb 18                	jmp    800420241e <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  8004202406:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  800420240a:	74 06                	je     8004202412 <restrictive_type+0x53>
  800420240c:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  8004202410:	75 07                	jne    8004202419 <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  8004202412:	b8 03 00 00 00       	mov    $0x3,%eax
  8004202417:	eb 05                	jmp    800420241e <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  8004202419:	b8 01 00 00 00       	mov    $0x1,%eax
}
  800420241e:	c9                   	leaveq 
  800420241f:	c3                   	retq   

0000008004202420 <check_pc>:
static struct PageInfo *page_free_list;	// Free list of physical pages

// --------------------------------------------------------------
// Detect machine's physical memory setup.
// --------------------------------------------------------------
void check_pc(){
  8004202420:	55                   	push   %rbp
  8004202421:	48 89 e5             	mov    %rsp,%rbp
  8004202424:	48 83 ec 10          	sub    $0x10,%rsp
	int count = 0;struct PageInfo* p;
  8004202428:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	for( p = page_free_list;p != NULL; p = p->pp_link){
  800420242f:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004202436:	00 00 00 
  8004202439:	48 8b 00             	mov    (%rax),%rax
  800420243c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202440:	eb 0f                	jmp    8004202451 <check_pc+0x31>
		count++;
  8004202442:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
// --------------------------------------------------------------
// Detect machine's physical memory setup.
// --------------------------------------------------------------
void check_pc(){
	int count = 0;struct PageInfo* p;
	for( p = page_free_list;p != NULL; p = p->pp_link){
  8004202446:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420244a:	48 8b 00             	mov    (%rax),%rax
  800420244d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202451:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004202456:	75 ea                	jne    8004202442 <check_pc+0x22>
		count++;
	}
	cprintf("page count is %d\n", count);
  8004202458:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420245b:	89 c6                	mov    %eax,%esi
  800420245d:	48 bf 53 5b 21 04 80 	movabs $0x8004215b53,%rdi
  8004202464:	00 00 00 
  8004202467:	b8 00 00 00 00       	mov    $0x0,%eax
  800420246c:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004202473:	00 00 00 
  8004202476:	ff d2                	callq  *%rdx

}
  8004202478:	c9                   	leaveq 
  8004202479:	c3                   	retq   

000000800420247a <nvram_read>:
static int
nvram_read(int r)
{
  800420247a:	55                   	push   %rbp
  800420247b:	48 89 e5             	mov    %rsp,%rbp
  800420247e:	53                   	push   %rbx
  800420247f:	48 83 ec 18          	sub    $0x18,%rsp
  8004202483:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  8004202486:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202489:	89 c7                	mov    %eax,%edi
  800420248b:	48 b8 c2 8e 20 04 80 	movabs $0x8004208ec2,%rax
  8004202492:	00 00 00 
  8004202495:	ff d0                	callq  *%rax
  8004202497:	89 c3                	mov    %eax,%ebx
  8004202499:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420249c:	83 c0 01             	add    $0x1,%eax
  800420249f:	89 c7                	mov    %eax,%edi
  80042024a1:	48 b8 c2 8e 20 04 80 	movabs $0x8004208ec2,%rax
  80042024a8:	00 00 00 
  80042024ab:	ff d0                	callq  *%rax
  80042024ad:	c1 e0 08             	shl    $0x8,%eax
  80042024b0:	09 d8                	or     %ebx,%eax
}
  80042024b2:	48 83 c4 18          	add    $0x18,%rsp
  80042024b6:	5b                   	pop    %rbx
  80042024b7:	5d                   	pop    %rbp
  80042024b8:	c3                   	retq   

00000080042024b9 <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  80042024b9:	55                   	push   %rbp
  80042024ba:	48 89 e5             	mov    %rsp,%rbp
  80042024bd:	41 54                	push   %r12
  80042024bf:	53                   	push   %rbx
  80042024c0:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  80042024c7:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  80042024ce:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  80042024d5:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  80042024dc:	48 89 e0             	mov    %rsp,%rax
  80042024df:	49 89 c4             	mov    %rax,%r12
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  80042024e2:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042024e9:	8b 40 30             	mov    0x30(%rax),%eax
  80042024ec:	89 c0                	mov    %eax,%eax
  80042024ee:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  80042024f2:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042024f9:	8b 40 2c             	mov    0x2c(%rax),%eax
  80042024fc:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202501:	f7 e2                	mul    %edx
  8004202503:	89 d0                	mov    %edx,%eax
  8004202505:	c1 e8 04             	shr    $0x4,%eax
  8004202508:	89 c0                	mov    %eax,%eax
  800420250a:	48 89 c2             	mov    %rax,%rdx
  800420250d:	48 83 ea 01          	sub    $0x1,%rdx
  8004202511:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004202515:	49 89 c0             	mov    %rax,%r8
  8004202518:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420251e:	48 89 c1             	mov    %rax,%rcx
  8004202521:	bb 00 00 00 00       	mov    $0x0,%ebx
  8004202526:	48 c1 e0 03          	shl    $0x3,%rax
  800420252a:	48 8d 50 07          	lea    0x7(%rax),%rdx
  800420252e:	b8 10 00 00 00       	mov    $0x10,%eax
  8004202533:	48 83 e8 01          	sub    $0x1,%rax
  8004202537:	48 01 d0             	add    %rdx,%rax
  800420253a:	bb 10 00 00 00       	mov    $0x10,%ebx
  800420253f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202544:	48 f7 f3             	div    %rbx
  8004202547:	48 6b c0 10          	imul   $0x10,%rax,%rax
  800420254b:	48 29 c4             	sub    %rax,%rsp
  800420254e:	48 89 e0             	mov    %rsp,%rax
  8004202551:	48 83 c0 07          	add    $0x7,%rax
  8004202555:	48 c1 e8 03          	shr    $0x3,%rax
  8004202559:	48 c1 e0 03          	shl    $0x3,%rax
  800420255d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	cprintf("\ne820 MEMORY MAP\n");
  8004202561:	48 bf 65 5b 21 04 80 	movabs $0x8004215b65,%rdi
  8004202568:	00 00 00 
  800420256b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202570:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004202577:	00 00 00 
  800420257a:	ff d2                	callq  *%rdx
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  800420257c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004202583:	e9 6c 01 00 00       	jmpq   80042026f4 <multiboot_read+0x23b>
		memory_map_t* mmap = &mmap_base[i];
  8004202588:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420258b:	48 63 d0             	movslq %eax,%rdx
  800420258e:	48 89 d0             	mov    %rdx,%rax
  8004202591:	48 01 c0             	add    %rax,%rax
  8004202594:	48 01 d0             	add    %rdx,%rax
  8004202597:	48 c1 e0 03          	shl    $0x3,%rax
  800420259b:	48 89 c2             	mov    %rax,%rdx
  800420259e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042025a2:	48 01 d0             	add    %rdx,%rax
  80042025a5:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

		uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  80042025a9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042025ad:	8b 40 08             	mov    0x8(%rax),%eax
  80042025b0:	89 c0                	mov    %eax,%eax
  80042025b2:	48 c1 e0 20          	shl    $0x20,%rax
  80042025b6:	48 89 c2             	mov    %rax,%rdx
  80042025b9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042025bd:	8b 40 04             	mov    0x4(%rax),%eax
  80042025c0:	89 c0                	mov    %eax,%eax
  80042025c2:	48 01 d0             	add    %rdx,%rax
  80042025c5:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  80042025c9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042025cd:	8b 40 10             	mov    0x10(%rax),%eax
  80042025d0:	89 c0                	mov    %eax,%eax
  80042025d2:	48 c1 e0 20          	shl    $0x20,%rax
  80042025d6:	48 89 c2             	mov    %rax,%rdx
  80042025d9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042025dd:	8b 40 0c             	mov    0xc(%rax),%eax
  80042025e0:	89 c0                	mov    %eax,%eax
  80042025e2:	48 01 d0             	add    %rdx,%rax
  80042025e5:	48 89 45 b0          	mov    %rax,-0x50(%rbp)

		cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size,
  80042025e9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042025ed:	8b 70 14             	mov    0x14(%rax),%esi
  80042025f0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042025f4:	8b 00                	mov    (%rax),%eax
  80042025f6:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042025fa:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042025fe:	41 89 f0             	mov    %esi,%r8d
  8004202601:	89 c6                	mov    %eax,%esi
  8004202603:	48 bf 78 5b 21 04 80 	movabs $0x8004215b78,%rdi
  800420260a:	00 00 00 
  800420260d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202612:	49 b9 0e 92 20 04 80 	movabs $0x800420920e,%r9
  8004202619:	00 00 00 
  800420261c:	41 ff d1             	callq  *%r9
			addr, len, mmap->type);

		if(mmap->type > 5 || mmap->type < 1)
  800420261f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202623:	8b 40 14             	mov    0x14(%rax),%eax
  8004202626:	83 f8 05             	cmp    $0x5,%eax
  8004202629:	77 0b                	ja     8004202636 <multiboot_read+0x17d>
  800420262b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420262f:	8b 40 14             	mov    0x14(%rax),%eax
  8004202632:	85 c0                	test   %eax,%eax
  8004202634:	75 0b                	jne    8004202641 <multiboot_read+0x188>
			mmap->type = MB_TYPE_RESERVED;
  8004202636:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420263a:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)

		//Insert into the sorted list
		int j = 0;
  8004202641:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
		for(;j<i;j++) {
  8004202648:	e9 85 00 00 00       	jmpq   80042026d2 <multiboot_read+0x219>
			memory_map_t* this = mmap_list[j];
  800420264d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202651:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004202654:	48 63 d2             	movslq %edx,%rdx
  8004202657:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  800420265b:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  800420265f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202663:	8b 40 08             	mov    0x8(%rax),%eax
  8004202666:	89 c0                	mov    %eax,%eax
  8004202668:	48 c1 e0 20          	shl    $0x20,%rax
  800420266c:	48 89 c2             	mov    %rax,%rdx
  800420266f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202673:	8b 40 04             	mov    0x4(%rax),%eax
  8004202676:	89 c0                	mov    %eax,%eax
  8004202678:	48 01 d0             	add    %rdx,%rax
  800420267b:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			if(this_addr > addr) {
  800420267f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202683:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004202687:	76 45                	jbe    80042026ce <multiboot_read+0x215>
				int last = i+1;
  8004202689:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420268c:	83 c0 01             	add    $0x1,%eax
  800420268f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				while(last != j) {
  8004202692:	eb 30                	jmp    80042026c4 <multiboot_read+0x20b>
					*(mmap_list + last) = *(mmap_list + last - 1);
  8004202694:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202698:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800420269b:	48 63 d2             	movslq %edx,%rdx
  800420269e:	48 c1 e2 03          	shl    $0x3,%rdx
  80042026a2:	48 01 c2             	add    %rax,%rdx
  80042026a5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042026a9:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  80042026ac:	48 63 c9             	movslq %ecx,%rcx
  80042026af:	48 c1 e1 03          	shl    $0x3,%rcx
  80042026b3:	48 83 e9 08          	sub    $0x8,%rcx
  80042026b7:	48 01 c8             	add    %rcx,%rax
  80042026ba:	48 8b 00             	mov    (%rax),%rax
  80042026bd:	48 89 02             	mov    %rax,(%rdx)
					last--;
  80042026c0:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
		for(;j<i;j++) {
			memory_map_t* this = mmap_list[j];
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
			if(this_addr > addr) {
				int last = i+1;
				while(last != j) {
  80042026c4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042026c7:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  80042026ca:	75 c8                	jne    8004202694 <multiboot_read+0x1db>
					*(mmap_list + last) = *(mmap_list + last - 1);
					last--;
				}
				break;
  80042026cc:	eb 10                	jmp    80042026de <multiboot_read+0x225>
		if(mmap->type > 5 || mmap->type < 1)
			mmap->type = MB_TYPE_RESERVED;

		//Insert into the sorted list
		int j = 0;
		for(;j<i;j++) {
  80042026ce:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  80042026d2:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042026d5:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  80042026d8:	0f 8c 6f ff ff ff    	jl     800420264d <multiboot_read+0x194>
					last--;
				}
				break;
			}
		}
		mmap_list[j] = mmap;
  80042026de:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042026e2:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042026e5:	48 63 d2             	movslq %edx,%rdx
  80042026e8:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80042026ec:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];

	cprintf("\ne820 MEMORY MAP\n");
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042026f0:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042026f4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042026f7:	48 63 c8             	movslq %eax,%rcx
  80042026fa:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004202701:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202704:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202709:	f7 e2                	mul    %edx
  800420270b:	89 d0                	mov    %edx,%eax
  800420270d:	c1 e8 04             	shr    $0x4,%eax
  8004202710:	89 c0                	mov    %eax,%eax
  8004202712:	48 39 c1             	cmp    %rax,%rcx
  8004202715:	0f 82 6d fe ff ff    	jb     8004202588 <multiboot_read+0xcf>
				break;
			}
		}
		mmap_list[j] = mmap;
	}
	cprintf("\n");
  800420271b:	48 bf af 5b 21 04 80 	movabs $0x8004215baf,%rdi
  8004202722:	00 00 00 
  8004202725:	b8 00 00 00 00       	mov    $0x0,%eax
  800420272a:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004202731:	00 00 00 
  8004202734:	ff d2                	callq  *%rdx

	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202736:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  800420273d:	e9 93 01 00 00       	jmpq   80042028d5 <multiboot_read+0x41c>
		memory_map_t* prev = mmap_list[i-1];
  8004202742:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202745:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202748:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420274c:	48 63 d2             	movslq %edx,%rdx
  800420274f:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202753:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  8004202757:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420275b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420275e:	48 63 d2             	movslq %edx,%rdx
  8004202761:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202765:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004202769:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420276d:	8b 40 08             	mov    0x8(%rax),%eax
  8004202770:	89 c0                	mov    %eax,%eax
  8004202772:	48 c1 e0 20          	shl    $0x20,%rax
  8004202776:	48 89 c2             	mov    %rax,%rdx
  8004202779:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420277d:	8b 40 04             	mov    0x4(%rax),%eax
  8004202780:	89 c0                	mov    %eax,%eax
  8004202782:	48 01 d0             	add    %rdx,%rax
  8004202785:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  8004202789:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420278d:	8b 40 08             	mov    0x8(%rax),%eax
  8004202790:	89 c0                	mov    %eax,%eax
  8004202792:	48 c1 e0 20          	shl    $0x20,%rax
  8004202796:	48 89 c2             	mov    %rax,%rdx
  8004202799:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420279d:	8b 40 04             	mov    0x4(%rax),%eax
  80042027a0:	89 c0                	mov    %eax,%eax
  80042027a2:	48 01 d0             	add    %rdx,%rax
  80042027a5:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  80042027a9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042027ad:	8b 40 10             	mov    0x10(%rax),%eax
  80042027b0:	89 c0                	mov    %eax,%eax
  80042027b2:	48 c1 e0 20          	shl    $0x20,%rax
  80042027b6:	48 89 c2             	mov    %rax,%rdx
  80042027b9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042027bd:	8b 40 0c             	mov    0xc(%rax),%eax
  80042027c0:	89 c0                	mov    %eax,%eax
  80042027c2:	48 01 d0             	add    %rdx,%rax
  80042027c5:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  80042027cc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042027d0:	8b 40 10             	mov    0x10(%rax),%eax
  80042027d3:	89 c0                	mov    %eax,%eax
  80042027d5:	48 c1 e0 20          	shl    $0x20,%rax
  80042027d9:	48 89 c2             	mov    %rax,%rdx
  80042027dc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042027e0:	8b 40 0c             	mov    0xc(%rax),%eax
  80042027e3:	89 c0                	mov    %eax,%eax
  80042027e5:	48 01 d0             	add    %rdx,%rax
  80042027e8:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if(prev_addr + prev_length == this_addr && prev->type == this->type) {
  80042027ef:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042027f6:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  80042027fa:	48 01 d0             	add    %rdx,%rax
  80042027fd:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004202801:	75 7c                	jne    800420287f <multiboot_read+0x3c6>
  8004202803:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202807:	8b 50 14             	mov    0x14(%rax),%edx
  800420280a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420280e:	8b 40 14             	mov    0x14(%rax),%eax
  8004202811:	39 c2                	cmp    %eax,%edx
  8004202813:	75 6a                	jne    800420287f <multiboot_read+0x3c6>
			this->length_low = (uint32_t)prev_length + this_length;
  8004202815:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420281c:	89 c2                	mov    %eax,%edx
  800420281e:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202825:	01 c2                	add    %eax,%edx
  8004202827:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420282b:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  800420282e:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202835:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  800420283c:	48 01 d0             	add    %rdx,%rax
  800420283f:	48 c1 e8 20          	shr    $0x20,%rax
  8004202843:	89 c2                	mov    %eax,%edx
  8004202845:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202849:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  800420284c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202850:	8b 50 04             	mov    0x4(%rax),%edx
  8004202853:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202857:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  800420285a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420285e:	8b 50 08             	mov    0x8(%rax),%edx
  8004202861:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202865:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  8004202868:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420286b:	8d 50 ff             	lea    -0x1(%rax),%edx
  800420286e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202872:	48 63 d2             	movslq %edx,%rdx
  8004202875:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  800420287c:	00 
  800420287d:	eb 52                	jmp    80042028d1 <multiboot_read+0x418>
		} else if(prev_addr + prev_length > this_addr) {
  800420287f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004202886:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  800420288a:	48 01 d0             	add    %rdx,%rax
  800420288d:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004202891:	76 3e                	jbe    80042028d1 <multiboot_read+0x418>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  8004202893:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202897:	8b 50 14             	mov    0x14(%rax),%edx
  800420289a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420289e:	8b 40 14             	mov    0x14(%rax),%eax
  80042028a1:	89 d6                	mov    %edx,%esi
  80042028a3:	89 c7                	mov    %eax,%edi
  80042028a5:	48 b8 bf 23 20 04 80 	movabs $0x80042023bf,%rax
  80042028ac:	00 00 00 
  80042028af:	ff d0                	callq  *%rax
  80042028b1:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  80042028b7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042028bb:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  80042028c1:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  80042028c4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042028c8:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  80042028ce:	89 50 14             	mov    %edx,0x14(%rax)
		mmap_list[j] = mmap;
	}
	cprintf("\n");

	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042028d1:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042028d5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042028d8:	48 63 c8             	movslq %eax,%rcx
  80042028db:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042028e2:	8b 40 2c             	mov    0x2c(%rax),%eax
  80042028e5:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  80042028ea:	f7 e2                	mul    %edx
  80042028ec:	89 d0                	mov    %edx,%eax
  80042028ee:	c1 e8 04             	shr    $0x4,%eax
  80042028f1:	89 c0                	mov    %eax,%eax
  80042028f3:	48 39 c1             	cmp    %rax,%rcx
  80042028f6:	0f 82 46 fe ff ff    	jb     8004202742 <multiboot_read+0x289>
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042028fc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004202903:	e9 dc 00 00 00       	jmpq   80042029e4 <multiboot_read+0x52b>
		memory_map_t* mmap = mmap_list[i];
  8004202908:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420290c:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420290f:	48 63 d2             	movslq %edx,%rdx
  8004202912:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202916:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if(mmap) {
  800420291d:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004202924:	00 
  8004202925:	0f 84 b5 00 00 00    	je     80042029e0 <multiboot_read+0x527>
			if(mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  800420292b:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202932:	8b 40 14             	mov    0x14(%rax),%eax
  8004202935:	83 f8 01             	cmp    $0x1,%eax
  8004202938:	74 13                	je     800420294d <multiboot_read+0x494>
  800420293a:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202941:	8b 40 14             	mov    0x14(%rax),%eax
  8004202944:	83 f8 03             	cmp    $0x3,%eax
  8004202947:	0f 85 93 00 00 00    	jne    80042029e0 <multiboot_read+0x527>
				if(mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  800420294d:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202954:	8b 40 04             	mov    0x4(%rax),%eax
  8004202957:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  800420295c:	77 49                	ja     80042029a7 <multiboot_read+0x4ee>
  800420295e:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202965:	8b 40 08             	mov    0x8(%rax),%eax
  8004202968:	85 c0                	test   %eax,%eax
  800420296a:	75 3b                	jne    80042029a7 <multiboot_read+0x4ee>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  800420296c:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004202973:	48 8b 10             	mov    (%rax),%rdx
  8004202976:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420297d:	8b 40 10             	mov    0x10(%rax),%eax
  8004202980:	89 c0                	mov    %eax,%eax
  8004202982:	48 c1 e0 20          	shl    $0x20,%rax
  8004202986:	48 89 c1             	mov    %rax,%rcx
  8004202989:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202990:	8b 40 0c             	mov    0xc(%rax),%eax
  8004202993:	89 c0                	mov    %eax,%eax
  8004202995:	48 01 c8             	add    %rcx,%rax
  8004202998:	48 01 c2             	add    %rax,%rdx
  800420299b:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042029a2:	48 89 10             	mov    %rdx,(%rax)
  80042029a5:	eb 39                	jmp    80042029e0 <multiboot_read+0x527>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  80042029a7:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042029ae:	48 8b 10             	mov    (%rax),%rdx
  80042029b1:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042029b8:	8b 40 10             	mov    0x10(%rax),%eax
  80042029bb:	89 c0                	mov    %eax,%eax
  80042029bd:	48 c1 e0 20          	shl    $0x20,%rax
  80042029c1:	48 89 c1             	mov    %rax,%rcx
  80042029c4:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042029cb:	8b 40 0c             	mov    0xc(%rax),%eax
  80042029ce:	89 c0                	mov    %eax,%eax
  80042029d0:	48 01 c8             	add    %rcx,%rax
  80042029d3:	48 01 c2             	add    %rax,%rdx
  80042029d6:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042029dd:	48 89 10             	mov    %rdx,(%rax)
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042029e0:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042029e4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042029e7:	48 63 c8             	movslq %eax,%rcx
  80042029ea:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042029f1:	8b 40 2c             	mov    0x2c(%rax),%eax
  80042029f4:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  80042029f9:	f7 e2                	mul    %edx
  80042029fb:	89 d0                	mov    %edx,%eax
  80042029fd:	c1 e8 04             	shr    $0x4,%eax
  8004202a00:	89 c0                	mov    %eax,%eax
  8004202a02:	48 39 c1             	cmp    %rax,%rcx
  8004202a05:	0f 82 fd fe ff ff    	jb     8004202908 <multiboot_read+0x44f>
  8004202a0b:	4c 89 e4             	mov    %r12,%rsp
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
			}
		}
	}
}
  8004202a0e:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  8004202a12:	5b                   	pop    %rbx
  8004202a13:	41 5c                	pop    %r12
  8004202a15:	5d                   	pop    %rbp
  8004202a16:	c3                   	retq   

0000008004202a17 <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  8004202a17:	55                   	push   %rbp
  8004202a18:	48 89 e5             	mov    %rsp,%rbp
  8004202a1b:	48 83 ec 50          	sub    $0x50,%rsp
	size_t npages_extmem;
	size_t basemem = 0;
  8004202a1f:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8004202a26:	00 
	size_t extmem = 0;
  8004202a27:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004202a2e:	00 

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  8004202a2f:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  8004202a36:	00 00 00 
  8004202a39:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  8004202a3d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202a41:	48 8b 00             	mov    (%rax),%rax
  8004202a44:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if(mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  8004202a48:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202a4d:	74 2d                	je     8004202a7c <i386_detect_memory+0x65>
  8004202a4f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202a53:	8b 00                	mov    (%rax),%eax
  8004202a55:	83 e0 40             	and    $0x40,%eax
  8004202a58:	85 c0                	test   %eax,%eax
  8004202a5a:	74 20                	je     8004202a7c <i386_detect_memory+0x65>
		multiboot_read(mbinfo, &basemem, &extmem);
  8004202a5c:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  8004202a60:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  8004202a64:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202a68:	48 89 ce             	mov    %rcx,%rsi
  8004202a6b:	48 89 c7             	mov    %rax,%rdi
  8004202a6e:	48 b8 b9 24 20 04 80 	movabs $0x80042024b9,%rax
  8004202a75:	00 00 00 
  8004202a78:	ff d0                	callq  *%rax
  8004202a7a:	eb 34                	jmp    8004202ab0 <i386_detect_memory+0x99>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  8004202a7c:	bf 15 00 00 00       	mov    $0x15,%edi
  8004202a81:	48 b8 7a 24 20 04 80 	movabs $0x800420247a,%rax
  8004202a88:	00 00 00 
  8004202a8b:	ff d0                	callq  *%rax
  8004202a8d:	c1 e0 0a             	shl    $0xa,%eax
  8004202a90:	48 98                	cltq   
  8004202a92:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  8004202a96:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202a9b:	48 b8 7a 24 20 04 80 	movabs $0x800420247a,%rax
  8004202aa2:	00 00 00 
  8004202aa5:	ff d0                	callq  *%rax
  8004202aa7:	c1 e0 0a             	shl    $0xa,%eax
  8004202aaa:	48 98                	cltq   
  8004202aac:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	}

	assert(basemem);
  8004202ab0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202ab4:	48 85 c0             	test   %rax,%rax
  8004202ab7:	75 35                	jne    8004202aee <i386_detect_memory+0xd7>
  8004202ab9:	48 b9 b1 5b 21 04 80 	movabs $0x8004215bb1,%rcx
  8004202ac0:	00 00 00 
  8004202ac3:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004202aca:	00 00 00 
  8004202acd:	be 90 00 00 00       	mov    $0x90,%esi
  8004202ad2:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004202ad9:	00 00 00 
  8004202adc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ae1:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004202ae8:	00 00 00 
  8004202aeb:	41 ff d0             	callq  *%r8

	npages_basemem = basemem / PGSIZE;
  8004202aee:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202af2:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202af6:	48 89 c2             	mov    %rax,%rdx
  8004202af9:	48 b8 30 d2 49 04 80 	movabs $0x800449d230,%rax
  8004202b00:	00 00 00 
  8004202b03:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  8004202b06:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202b0a:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202b0e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if(nvram_read(NVRAM_EXTLO) == 0xffff) {
  8004202b12:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202b17:	48 b8 7a 24 20 04 80 	movabs $0x800420247a,%rax
  8004202b1e:	00 00 00 
  8004202b21:	ff d0                	callq  *%rax
  8004202b23:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004202b28:	75 2c                	jne    8004202b56 <i386_detect_memory+0x13f>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  8004202b2a:	bf 34 00 00 00       	mov    $0x34,%edi
  8004202b2f:	48 b8 7a 24 20 04 80 	movabs $0x800420247a,%rax
  8004202b36:	00 00 00 
  8004202b39:	ff d0                	callq  *%rax
  8004202b3b:	c1 e0 10             	shl    $0x10,%eax
  8004202b3e:	48 98                	cltq   
  8004202b40:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  8004202b44:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202b48:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  8004202b4e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202b52:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}

	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  8004202b56:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202b5b:	74 1a                	je     8004202b77 <i386_detect_memory+0x160>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  8004202b5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202b61:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  8004202b68:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004202b6f:	00 00 00 
  8004202b72:	48 89 10             	mov    %rdx,(%rax)
  8004202b75:	eb 1a                	jmp    8004202b91 <i386_detect_memory+0x17a>
	else
		npages = npages_basemem;
  8004202b77:	48 b8 30 d2 49 04 80 	movabs $0x800449d230,%rax
  8004202b7e:	00 00 00 
  8004202b81:	48 8b 10             	mov    (%rax),%rdx
  8004202b84:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004202b8b:	00 00 00 
  8004202b8e:	48 89 10             	mov    %rdx,(%rax)

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202b91:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004202b98:	00 00 00 
  8004202b9b:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  8004202b9e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202ba2:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202ba6:	48 c1 e8 0a          	shr    $0xa,%rax
  8004202baa:	48 89 c1             	mov    %rax,%rcx
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
  8004202bad:	48 b8 30 d2 49 04 80 	movabs $0x800449d230,%rax
  8004202bb4:	00 00 00 
  8004202bb7:	48 8b 00             	mov    (%rax),%rax
  8004202bba:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202bbe:	48 c1 e8 0a          	shr    $0xa,%rax
  8004202bc2:	48 89 c2             	mov    %rax,%rdx
		npages * PGSIZE / (1024 * 1024),
  8004202bc5:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004202bcc:	00 00 00 
  8004202bcf:	48 8b 00             	mov    (%rax),%rax
  8004202bd2:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202bd6:	48 c1 e8 14          	shr    $0x14,%rax
  8004202bda:	49 89 f0             	mov    %rsi,%r8
  8004202bdd:	48 89 c6             	mov    %rax,%rsi
  8004202be0:	48 bf e0 5b 21 04 80 	movabs $0x8004215be0,%rdi
  8004202be7:	00 00 00 
  8004202bea:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202bef:	49 b9 0e 92 20 04 80 	movabs $0x800420920e,%r9
  8004202bf6:	00 00 00 
  8004202bf9:	41 ff d1             	callq  *%r9
	//JOS 64 pages are limited by the size of both the UPAGES
	//  virtual address space, and the range from KERNBASE to UVPT.
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
  8004202bfc:	48 c7 45 d8 00 00 32 	movq   $0x320000,-0x28(%rbp)
  8004202c03:	00 
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
  8004202c04:	48 c7 45 d0 00 c0 ff 	movq   $0x7ffc000,-0x30(%rbp)
  8004202c0b:	07 
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n",
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
  8004202c0c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202c10:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n",
  8004202c14:	48 c1 e8 14          	shr    $0x14,%rax
  8004202c18:	48 89 c1             	mov    %rax,%rcx
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
  8004202c1b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202c1f:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n",
  8004202c23:	48 c1 e8 14          	shr    $0x14,%rax
  8004202c27:	48 89 c6             	mov    %rax,%rsi
  8004202c2a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004202c2e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202c32:	49 89 c8             	mov    %rcx,%r8
  8004202c35:	48 89 d1             	mov    %rdx,%rcx
  8004202c38:	48 89 f2             	mov    %rsi,%rdx
  8004202c3b:	48 89 c6             	mov    %rax,%rsi
  8004202c3e:	48 bf 30 5c 21 04 80 	movabs $0x8004215c30,%rdi
  8004202c45:	00 00 00 
  8004202c48:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202c4d:	49 b9 0e 92 20 04 80 	movabs $0x800420920e,%r9
  8004202c54:	00 00 00 
  8004202c57:	41 ff d1             	callq  *%r9
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
	uint64_t max_npages = upages_max < kern_mem_max ? upages_max : kern_mem_max;
  8004202c5a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202c5e:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  8004202c62:	48 0f 46 45 d0       	cmovbe -0x30(%rbp),%rax
  8004202c67:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if(npages > max_npages) {
  8004202c6b:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004202c72:	00 00 00 
  8004202c75:	48 8b 00             	mov    (%rax),%rax
  8004202c78:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004202c7c:	76 3a                	jbe    8004202cb8 <i386_detect_memory+0x2a1>
		npages = max_npages - 1024;
  8004202c7e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202c82:	48 8d 90 00 fc ff ff 	lea    -0x400(%rax),%rdx
  8004202c89:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004202c90:	00 00 00 
  8004202c93:	48 89 10             	mov    %rdx,(%rax)
		cprintf("Using only %uK of the available memory.\n", max_npages);
  8004202c96:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202c9a:	48 89 c6             	mov    %rax,%rsi
  8004202c9d:	48 bf 98 5c 21 04 80 	movabs $0x8004215c98,%rdi
  8004202ca4:	00 00 00 
  8004202ca7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202cac:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004202cb3:	00 00 00 
  8004202cb6:	ff d2                	callq  *%rdx
	}
}
  8004202cb8:	c9                   	leaveq 
  8004202cb9:	c3                   	retq   

0000008004202cba <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  8004202cba:	55                   	push   %rbp
  8004202cbb:	48 89 e5             	mov    %rsp,%rbp
  8004202cbe:	48 83 ec 40          	sub    $0x40,%rsp
  8004202cc2:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  8004202cc5:	48 b8 48 d2 49 04 80 	movabs $0x800449d248,%rax
  8004202ccc:	00 00 00 
  8004202ccf:	48 8b 00             	mov    (%rax),%rax
  8004202cd2:	48 85 c0             	test   %rax,%rax
  8004202cd5:	75 4b                	jne    8004202d22 <boot_alloc+0x68>
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
  8004202cd7:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  8004202cde:	00 
  8004202cdf:	48 b8 10 10 52 04 80 	movabs $0x8004521010,%rax
  8004202ce6:	00 00 00 
  8004202ce9:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  8004202ced:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202cf1:	48 01 d0             	add    %rdx,%rax
  8004202cf4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202cf8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202cfc:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202d01:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004202d05:	48 89 d0             	mov    %rdx,%rax
  8004202d08:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004202d0c:	48 29 c2             	sub    %rax,%rdx
  8004202d0f:	48 89 d0             	mov    %rdx,%rax
  8004202d12:	48 89 c2             	mov    %rax,%rdx
  8004202d15:	48 b8 48 d2 49 04 80 	movabs $0x800449d248,%rax
  8004202d1c:	00 00 00 
  8004202d1f:	48 89 10             	mov    %rdx,(%rax)
	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
	if(n == 0)return nextfree;
  8004202d22:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004202d26:	75 12                	jne    8004202d3a <boot_alloc+0x80>
  8004202d28:	48 b8 48 d2 49 04 80 	movabs $0x800449d248,%rax
  8004202d2f:	00 00 00 
  8004202d32:	48 8b 00             	mov    (%rax),%rax
  8004202d35:	e9 c2 00 00 00       	jmpq   8004202dfc <boot_alloc+0x142>
	result = nextfree;
  8004202d3a:	48 b8 48 d2 49 04 80 	movabs $0x800449d248,%rax
  8004202d41:	00 00 00 
  8004202d44:	48 8b 00             	mov    (%rax),%rax
  8004202d47:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	nextfree = ROUNDUP((char *)(nextfree + n), PGSIZE);
  8004202d4b:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8004202d52:	00 
  8004202d53:	48 b8 48 d2 49 04 80 	movabs $0x800449d248,%rax
  8004202d5a:	00 00 00 
  8004202d5d:	48 8b 10             	mov    (%rax),%rdx
  8004202d60:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004202d63:	48 01 d0             	add    %rdx,%rax
  8004202d66:	48 89 c2             	mov    %rax,%rdx
  8004202d69:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202d6d:	48 01 d0             	add    %rdx,%rax
  8004202d70:	48 83 e8 01          	sub    $0x1,%rax
  8004202d74:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004202d78:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202d7c:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202d81:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004202d85:	48 89 d0             	mov    %rdx,%rax
  8004202d88:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004202d8c:	48 29 c2             	sub    %rax,%rdx
  8004202d8f:	48 89 d0             	mov    %rdx,%rax
  8004202d92:	48 89 c2             	mov    %rax,%rdx
  8004202d95:	48 b8 48 d2 49 04 80 	movabs $0x800449d248,%rax
  8004202d9c:	00 00 00 
  8004202d9f:	48 89 10             	mov    %rdx,(%rax)
	if(nextfree > (char *)(KERNBASE + PGSIZE * npages)){
  8004202da2:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004202da9:	00 00 00 
  8004202dac:	48 8b 00             	mov    (%rax),%rax
  8004202daf:	48 05 00 40 00 08    	add    $0x8004000,%rax
  8004202db5:	48 c1 e0 0c          	shl    $0xc,%rax
  8004202db9:	48 89 c2             	mov    %rax,%rdx
  8004202dbc:	48 b8 48 d2 49 04 80 	movabs $0x800449d248,%rax
  8004202dc3:	00 00 00 
  8004202dc6:	48 8b 00             	mov    (%rax),%rax
  8004202dc9:	48 39 c2             	cmp    %rax,%rdx
  8004202dcc:	73 2a                	jae    8004202df8 <boot_alloc+0x13e>
		panic("not enough memory");
  8004202dce:	48 ba c1 5c 21 04 80 	movabs $0x8004215cc1,%rdx
  8004202dd5:	00 00 00 
  8004202dd8:	be ec 00 00 00       	mov    $0xec,%esi
  8004202ddd:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004202de4:	00 00 00 
  8004202de7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202dec:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  8004202df3:	00 00 00 
  8004202df6:	ff d1                	callq  *%rcx
	}
	return result;
  8004202df8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004202dfc:	c9                   	leaveq 
  8004202dfd:	c3                   	retq   

0000008004202dfe <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  8004202dfe:	55                   	push   %rbp
  8004202dff:	48 89 e5             	mov    %rsp,%rbp
  8004202e02:	48 83 ec 60          	sub    $0x60,%rsp
	pml4e_t* pml4e;
	uint32_t cr0;
	uint64_t n;
	int r;
	struct Env *env;
	i386_detect_memory();
  8004202e06:	48 b8 17 2a 20 04 80 	movabs $0x8004202a17,%rax
  8004202e0d:	00 00 00 
  8004202e10:	ff d0                	callq  *%rax
	//panic("i386_vm_init: This function is not finished\n");
	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	//panic("x64_vm_init: this function is not finished\n");
	pml4e = boot_alloc(PGSIZE);
  8004202e12:	bf 00 10 00 00       	mov    $0x1000,%edi
  8004202e17:	48 b8 ba 2c 20 04 80 	movabs $0x8004202cba,%rax
  8004202e1e:	00 00 00 
  8004202e21:	ff d0                	callq  *%rax
  8004202e23:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  8004202e27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202e2b:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202e30:	be 00 00 00 00       	mov    $0x0,%esi
  8004202e35:	48 89 c7             	mov    %rax,%rdi
  8004202e38:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  8004202e3f:	00 00 00 
  8004202e42:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  8004202e44:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004202e4b:	00 00 00 
  8004202e4e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202e52:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  8004202e55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202e59:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202e5d:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202e64:	00 00 00 
  8004202e67:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  8004202e6b:	77 32                	ja     8004202e9f <x64_vm_init+0xa1>
  8004202e6d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202e71:	48 89 c1             	mov    %rax,%rcx
  8004202e74:	48 ba d8 5c 21 04 80 	movabs $0x8004215cd8,%rdx
  8004202e7b:	00 00 00 
  8004202e7e:	be 0a 01 00 00       	mov    $0x10a,%esi
  8004202e83:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004202e8a:	00 00 00 
  8004202e8d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202e92:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004202e99:	00 00 00 
  8004202e9c:	41 ff d0             	callq  *%r8
  8004202e9f:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202ea6:	ff ff ff 
  8004202ea9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202ead:	48 01 c2             	add    %rax,%rdx
  8004202eb0:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  8004202eb7:	00 00 00 
  8004202eba:	48 89 10             	mov    %rdx,(%rax)
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:
	pages = (struct PageInfo*) boot_alloc(PISIZE * npages);
  8004202ebd:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004202ec4:	00 00 00 
  8004202ec7:	48 8b 00             	mov    (%rax),%rax
  8004202eca:	c1 e0 04             	shl    $0x4,%eax
  8004202ecd:	89 c7                	mov    %eax,%edi
  8004202ecf:	48 b8 ba 2c 20 04 80 	movabs $0x8004202cba,%rax
  8004202ed6:	00 00 00 
  8004202ed9:	ff d0                	callq  *%rax
  8004202edb:	48 ba 38 e7 49 04 80 	movabs $0x800449e738,%rdx
  8004202ee2:	00 00 00 
  8004202ee5:	48 89 02             	mov    %rax,(%rdx)
	memset(pages, 0, PISIZE * npages);
  8004202ee8:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004202eef:	00 00 00 
  8004202ef2:	48 8b 00             	mov    (%rax),%rax
  8004202ef5:	48 c1 e0 04          	shl    $0x4,%rax
  8004202ef9:	48 89 c2             	mov    %rax,%rdx
  8004202efc:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  8004202f03:	00 00 00 
  8004202f06:	48 8b 00             	mov    (%rax),%rax
  8004202f09:	be 00 00 00 00       	mov    $0x0,%esi
  8004202f0e:	48 89 c7             	mov    %rax,%rdi
  8004202f11:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  8004202f18:	00 00 00 
  8004202f1b:	ff d0                	callq  *%rax
	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.
	envs = (struct Env*) boot_alloc(sizeof(struct Env) * NENV);
  8004202f1d:	bf 00 80 04 00       	mov    $0x48000,%edi
  8004202f22:	48 b8 ba 2c 20 04 80 	movabs $0x8004202cba,%rax
  8004202f29:	00 00 00 
  8004202f2c:	ff d0                	callq  *%rax
  8004202f2e:	48 ba 50 d2 49 04 80 	movabs $0x800449d250,%rdx
  8004202f35:	00 00 00 
  8004202f38:	48 89 02             	mov    %rax,(%rdx)
	memset(envs, 0, sizeof(struct Env) * NENV);
  8004202f3b:	48 b8 50 d2 49 04 80 	movabs $0x800449d250,%rax
  8004202f42:	00 00 00 
  8004202f45:	48 8b 00             	mov    (%rax),%rax
  8004202f48:	ba 00 80 04 00       	mov    $0x48000,%edx
  8004202f4d:	be 00 00 00 00       	mov    $0x0,%esi
  8004202f52:	48 89 c7             	mov    %rax,%rdi
  8004202f55:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  8004202f5c:	00 00 00 
  8004202f5f:	ff d0                	callq  *%rax
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	page_init();
  8004202f61:	48 b8 46 33 20 04 80 	movabs $0x8004203346,%rax
  8004202f68:	00 00 00 
  8004202f6b:	ff d0                	callq  *%rax
	//    - the new image at UPAGES -- kernel R, us/er R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:

	boot_map_region(boot_pml4e, UPAGES, npages * PISIZE, PADDR(pages), PTE_U);
  8004202f6d:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  8004202f74:	00 00 00 
  8004202f77:	48 8b 00             	mov    (%rax),%rax
  8004202f7a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202f7e:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202f85:	00 00 00 
  8004202f88:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004202f8c:	77 32                	ja     8004202fc0 <x64_vm_init+0x1c2>
  8004202f8e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202f92:	48 89 c1             	mov    %rax,%rcx
  8004202f95:	48 ba d8 5c 21 04 80 	movabs $0x8004215cd8,%rdx
  8004202f9c:	00 00 00 
  8004202f9f:	be 29 01 00 00       	mov    $0x129,%esi
  8004202fa4:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004202fab:	00 00 00 
  8004202fae:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202fb3:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004202fba:	00 00 00 
  8004202fbd:	41 ff d0             	callq  *%r8
  8004202fc0:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202fc7:	ff ff ff 
  8004202fca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202fce:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004202fd2:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004202fd9:	00 00 00 
  8004202fdc:	48 8b 00             	mov    (%rax),%rax
  8004202fdf:	48 c1 e0 04          	shl    $0x4,%rax
  8004202fe3:	48 89 c2             	mov    %rax,%rdx
  8004202fe6:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004202fed:	00 00 00 
  8004202ff0:	48 8b 00             	mov    (%rax),%rax
  8004202ff3:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  8004202ff9:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  8004203000:	00 00 00 
  8004203003:	48 89 c7             	mov    %rax,%rdi
  8004203006:	48 b8 f4 3a 20 04 80 	movabs $0x8004203af4,%rax
  800420300d:	00 00 00 
  8004203010:	ff d0                	callq  *%rax
	// (ie. perm = PTE_U | PTE_P).
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.
	boot_map_region(boot_pml4e, UENVS, NENV * sizeof(struct Env), PADDR(envs), PTE_U);
  8004203012:	48 b8 50 d2 49 04 80 	movabs $0x800449d250,%rax
  8004203019:	00 00 00 
  800420301c:	48 8b 00             	mov    (%rax),%rax
  800420301f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203023:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420302a:	00 00 00 
  800420302d:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004203031:	77 32                	ja     8004203065 <x64_vm_init+0x267>
  8004203033:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203037:	48 89 c1             	mov    %rax,%rcx
  800420303a:	48 ba d8 5c 21 04 80 	movabs $0x8004215cd8,%rdx
  8004203041:	00 00 00 
  8004203044:	be 31 01 00 00       	mov    $0x131,%esi
  8004203049:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004203050:	00 00 00 
  8004203053:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203058:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420305f:	00 00 00 
  8004203062:	41 ff d0             	callq  *%r8
  8004203065:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420306c:	ff ff ff 
  800420306f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203073:	48 01 c2             	add    %rax,%rdx
  8004203076:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  800420307d:	00 00 00 
  8004203080:	48 8b 00             	mov    (%rax),%rax
  8004203083:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  8004203089:	48 89 d1             	mov    %rdx,%rcx
  800420308c:	ba 00 80 04 00       	mov    $0x48000,%edx
  8004203091:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  8004203098:	00 00 00 
  800420309b:	48 89 c7             	mov    %rax,%rdi
  800420309e:	48 b8 f4 3a 20 04 80 	movabs $0x8004203af4,%rax
  80042030a5:	00 00 00 
  80042030a8:	ff d0                	callq  *%rax
	//      the PA range [0, npages*PGSIZE)
	// Permissions: kernel RW, user NONE
	// Your code goes here:
	// Check that the initial page directory has been set up correctly.
	// Initialize the SMP-related parts of the memory map
	mem_init_mp();
  80042030aa:	48 b8 5f 32 20 04 80 	movabs $0x800420325f,%rax
  80042030b1:	00 00 00 
  80042030b4:	ff d0                	callq  *%rax

	boot_map_region(boot_pml4e, KERNBASE, npages * PGSIZE, 0, PTE_W);
  80042030b6:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  80042030bd:	00 00 00 
  80042030c0:	48 8b 00             	mov    (%rax),%rax
  80042030c3:	48 c1 e0 0c          	shl    $0xc,%rax
  80042030c7:	48 89 c2             	mov    %rax,%rdx
  80042030ca:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  80042030d1:	00 00 00 
  80042030d4:	48 8b 00             	mov    (%rax),%rax
  80042030d7:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  80042030dd:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042030e2:	48 be 00 00 00 04 80 	movabs $0x8004000000,%rsi
  80042030e9:	00 00 00 
  80042030ec:	48 89 c7             	mov    %rax,%rdi
  80042030ef:	48 b8 f4 3a 20 04 80 	movabs $0x8004203af4,%rax
  80042030f6:	00 00 00 
  80042030f9:	ff d0                	callq  *%rax
	check_page_free_list(1);
  80042030fb:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203100:	48 b8 41 41 20 04 80 	movabs $0x8004204141,%rax
  8004203107:	00 00 00 
  800420310a:	ff d0                	callq  *%rax
	check_page_alloc();
  800420310c:	48 b8 6e 46 20 04 80 	movabs $0x800420466e,%rax
  8004203113:	00 00 00 
  8004203116:	ff d0                	callq  *%rax
	page_check();
  8004203118:	48 b8 22 5a 20 04 80 	movabs $0x8004205a22,%rax
  800420311f:	00 00 00 
  8004203122:	ff d0                	callq  *%rax
	check_page_free_list(0);
  8004203124:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203129:	48 b8 41 41 20 04 80 	movabs $0x8004204141,%rax
  8004203130:	00 00 00 
  8004203133:	ff d0                	callq  *%rax
	check_boot_pml4e(boot_pml4e);
  8004203135:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  800420313c:	00 00 00 
  800420313f:	48 8b 00             	mov    (%rax),%rax
  8004203142:	48 89 c7             	mov    %rax,%rdi
  8004203145:	48 b8 5a 50 20 04 80 	movabs $0x800420505a,%rax
  800420314c:	00 00 00 
  800420314f:	ff d0                	callq  *%rax

	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE
	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  8004203151:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203155:	48 83 c0 08          	add    $0x8,%rax
  8004203159:	48 8b 00             	mov    (%rax),%rax
  800420315c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203162:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004203166:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420316a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420316e:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  8004203171:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203174:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  800420317b:	00 00 00 
  800420317e:	48 8b 00             	mov    (%rax),%rax
  8004203181:	48 39 c2             	cmp    %rax,%rdx
  8004203184:	72 32                	jb     80042031b8 <x64_vm_init+0x3ba>
  8004203186:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420318a:	48 89 c1             	mov    %rax,%rcx
  800420318d:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  8004203194:	00 00 00 
  8004203197:	be 53 01 00 00       	mov    $0x153,%esi
  800420319c:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042031a3:	00 00 00 
  80042031a6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042031ab:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042031b2:	00 00 00 
  80042031b5:	41 ff d0             	callq  *%r8
  80042031b8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042031bf:	00 00 00 
  80042031c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042031c6:	48 01 d0             	add    %rdx,%rax
  80042031c9:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  80042031cd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042031d1:	48 8b 00             	mov    (%rax),%rax
  80042031d4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042031da:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042031de:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042031e2:	48 c1 e8 0c          	shr    $0xc,%rax
  80042031e6:	89 45 bc             	mov    %eax,-0x44(%rbp)
  80042031e9:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042031ec:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  80042031f3:	00 00 00 
  80042031f6:	48 8b 00             	mov    (%rax),%rax
  80042031f9:	48 39 c2             	cmp    %rax,%rdx
  80042031fc:	72 32                	jb     8004203230 <x64_vm_init+0x432>
  80042031fe:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203202:	48 89 c1             	mov    %rax,%rcx
  8004203205:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  800420320c:	00 00 00 
  800420320f:	be 54 01 00 00       	mov    $0x154,%esi
  8004203214:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420321b:	00 00 00 
  800420321e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203223:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420322a:	00 00 00 
  800420322d:	41 ff d0             	callq  *%r8
  8004203230:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203237:	00 00 00 
  800420323a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420323e:	48 01 d0             	add    %rdx,%rax
  8004203241:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	lcr3(boot_cr3);
  8004203245:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  800420324c:	00 00 00 
  800420324f:	48 8b 00             	mov    (%rax),%rax
  8004203252:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004203256:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420325a:	0f 22 d8             	mov    %rax,%cr3
	
  //check_pc();
}
  800420325d:	c9                   	leaveq 
  800420325e:	c3                   	retq   

000000800420325f <mem_init_mp>:
// Modify mappings in boot_pml4e to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
static void
mem_init_mp(void)
{
  800420325f:	55                   	push   %rbp
  8004203260:	48 89 e5             	mov    %rsp,%rbp
  8004203263:	48 83 ec 10          	sub    $0x10,%rsp
	//             Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
int i;
	for( i = 0; i < NCPU; i++){
  8004203267:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420326e:	e9 c7 00 00 00       	jmpq   800420333a <mem_init_mp+0xdb>
		boot_map_region(boot_pml4e, KSTACKTOP - (i + 1) * KSTKSIZE - i * KSTKGAP, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W);
  8004203273:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004203276:	48 98                	cltq   
  8004203278:	48 c1 e0 10          	shl    $0x10,%rax
  800420327c:	48 89 c2             	mov    %rax,%rdx
  800420327f:	48 b8 00 10 4a 04 80 	movabs $0x80044a1000,%rax
  8004203286:	00 00 00 
  8004203289:	48 01 d0             	add    %rdx,%rax
  800420328c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004203290:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004203297:	00 00 00 
  800420329a:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420329e:	77 32                	ja     80042032d2 <mem_init_mp+0x73>
  80042032a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042032a4:	48 89 c1             	mov    %rax,%rcx
  80042032a7:	48 ba d8 5c 21 04 80 	movabs $0x8004215cd8,%rdx
  80042032ae:	00 00 00 
  80042032b1:	be 73 01 00 00       	mov    $0x173,%esi
  80042032b6:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042032bd:	00 00 00 
  80042032c0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042032c5:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042032cc:	00 00 00 
  80042032cf:	41 ff d0             	callq  *%r8
  80042032d2:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042032d9:	ff ff ff 
  80042032dc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042032e0:	48 01 c2             	add    %rax,%rdx
  80042032e3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042032e6:	83 c0 01             	add    $0x1,%eax
  80042032e9:	c1 e0 10             	shl    $0x10,%eax
  80042032ec:	48 98                	cltq   
  80042032ee:	48 b9 00 00 00 04 80 	movabs $0x8004000000,%rcx
  80042032f5:	00 00 00 
  80042032f8:	48 29 c1             	sub    %rax,%rcx
  80042032fb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042032fe:	c1 e0 0f             	shl    $0xf,%eax
  8004203301:	48 98                	cltq   
  8004203303:	48 29 c1             	sub    %rax,%rcx
  8004203306:	48 89 c8             	mov    %rcx,%rax
  8004203309:	48 89 c6             	mov    %rax,%rsi
  800420330c:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004203313:	00 00 00 
  8004203316:	48 8b 00             	mov    (%rax),%rax
  8004203319:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  800420331f:	48 89 d1             	mov    %rdx,%rcx
  8004203322:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004203327:	48 89 c7             	mov    %rax,%rdi
  800420332a:	48 b8 f4 3a 20 04 80 	movabs $0x8004203af4,%rax
  8004203331:	00 00 00 
  8004203334:	ff d0                	callq  *%rax
	//             Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
int i;
	for( i = 0; i < NCPU; i++){
  8004203336:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420333a:	83 7d fc 07          	cmpl   $0x7,-0x4(%rbp)
  800420333e:	0f 8e 2f ff ff ff    	jle    8004203273 <mem_init_mp+0x14>
		boot_map_region(boot_pml4e, KSTACKTOP - (i + 1) * KSTKSIZE - i * KSTKGAP, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W);
	}
}
  8004203344:	c9                   	leaveq 
  8004203345:	c3                   	retq   

0000008004203346 <page_init>:
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
  8004203346:	55                   	push   %rbp
  8004203347:	48 89 e5             	mov    %rsp,%rbp
  800420334a:	41 54                	push   %r12
  800420334c:	53                   	push   %rbx
  800420334d:	48 83 ec 20          	sub    $0x20,%rsp
	// free pages!
	// NB: Make sure you preserve the direction in which your page_free_list
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)
	size_t i;
	struct PageInfo* last = NULL;
  8004203351:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004203358:	00 
	//for(i = 0; i < npages;i++){
	//	page_initpp(&pages[i]);
	//}
	//int count = 0;
	for (i = 0; i < npages; i++) {
  8004203359:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203360:	00 
  8004203361:	e9 95 00 00 00       	jmpq   80042033fb <page_init+0xb5>
		page_initpp(&pages[i]);
  8004203366:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  800420336d:	00 00 00 
  8004203370:	48 8b 00             	mov    (%rax),%rax
  8004203373:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203377:	48 c1 e2 04          	shl    $0x4,%rdx
  800420337b:	48 01 d0             	add    %rdx,%rax
  800420337e:	48 89 c7             	mov    %rax,%rdi
  8004203381:	48 b8 84 35 20 04 80 	movabs $0x8004203584,%rax
  8004203388:	00 00 00 
  800420338b:	ff d0                	callq  *%rax
		if(last)
  800420338d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004203392:	74 21                	je     80042033b5 <page_init+0x6f>
			last->pp_link = &pages[i];
  8004203394:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  800420339b:	00 00 00 
  800420339e:	48 8b 00             	mov    (%rax),%rax
  80042033a1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042033a5:	48 c1 e2 04          	shl    $0x4,%rdx
  80042033a9:	48 01 c2             	add    %rax,%rdx
  80042033ac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042033b0:	48 89 10             	mov    %rdx,(%rax)
  80042033b3:	eb 25                	jmp    80042033da <page_init+0x94>
		else
			page_free_list = &pages[i];
  80042033b5:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  80042033bc:	00 00 00 
  80042033bf:	48 8b 00             	mov    (%rax),%rax
  80042033c2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042033c6:	48 c1 e2 04          	shl    $0x4,%rdx
  80042033ca:	48 01 c2             	add    %rax,%rdx
  80042033cd:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  80042033d4:	00 00 00 
  80042033d7:	48 89 10             	mov    %rdx,(%rax)
		last = &pages[i];
  80042033da:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  80042033e1:	00 00 00 
  80042033e4:	48 8b 00             	mov    (%rax),%rax
  80042033e7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042033eb:	48 c1 e2 04          	shl    $0x4,%rdx
  80042033ef:	48 01 d0             	add    %rdx,%rax
  80042033f2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	struct PageInfo* last = NULL;
	//for(i = 0; i < npages;i++){
	//	page_initpp(&pages[i]);
	//}
	//int count = 0;
	for (i = 0; i < npages; i++) {
  80042033f6:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  80042033fb:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004203402:	00 00 00 
  8004203405:	48 8b 00             	mov    (%rax),%rax
  8004203408:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420340c:	0f 82 54 ff ff ff    	jb     8004203366 <page_init+0x20>
			last->pp_link = &pages[i];
		else
			page_free_list = &pages[i];
		last = &pages[i];
	}
	page_free_list = page_free_list->pp_link;
  8004203412:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004203419:	00 00 00 
  800420341c:	48 8b 00             	mov    (%rax),%rax
  800420341f:	48 8b 10             	mov    (%rax),%rdx
  8004203422:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004203429:	00 00 00 
  800420342c:	48 89 10             	mov    %rdx,(%rax)
	pages[(MPENTRY_PADDR >> PGSHIFT) - 1].pp_link = &pages[(MPENTRY_PADDR >> PGSHIFT) + 1];
  800420342f:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  8004203436:	00 00 00 
  8004203439:	48 8b 00             	mov    (%rax),%rax
  800420343c:	48 8d 50 60          	lea    0x60(%rax),%rdx
  8004203440:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  8004203447:	00 00 00 
  800420344a:	48 8b 00             	mov    (%rax),%rax
  800420344d:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
  8004203451:	48 89 02             	mov    %rax,(%rdx)
	pages[(IOPHYSMEM	>> PGSHIFT) - 1].pp_link = &pages[PADDR(boot_alloc(0)) >> PGSHIFT];
  8004203454:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  800420345b:	00 00 00 
  800420345e:	48 8b 00             	mov    (%rax),%rax
  8004203461:	48 8d 98 f0 09 00 00 	lea    0x9f0(%rax),%rbx
  8004203468:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  800420346f:	00 00 00 
  8004203472:	4c 8b 20             	mov    (%rax),%r12
  8004203475:	bf 00 00 00 00       	mov    $0x0,%edi
  800420347a:	48 b8 ba 2c 20 04 80 	movabs $0x8004202cba,%rax
  8004203481:	00 00 00 
  8004203484:	ff d0                	callq  *%rax
  8004203486:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420348a:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004203491:	00 00 00 
  8004203494:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004203498:	77 32                	ja     80042034cc <page_init+0x186>
  800420349a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420349e:	48 89 c1             	mov    %rax,%rcx
  80042034a1:	48 ba d8 5c 21 04 80 	movabs $0x8004215cd8,%rdx
  80042034a8:	00 00 00 
  80042034ab:	be ae 01 00 00       	mov    $0x1ae,%esi
  80042034b0:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042034b7:	00 00 00 
  80042034ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80042034bf:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042034c6:	00 00 00 
  80042034c9:	41 ff d0             	callq  *%r8
  80042034cc:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042034d3:	ff ff ff 
  80042034d6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042034da:	48 01 d0             	add    %rdx,%rax
  80042034dd:	48 c1 e8 0c          	shr    $0xc,%rax
  80042034e1:	48 c1 e0 04          	shl    $0x4,%rax
  80042034e5:	4c 01 e0             	add    %r12,%rax
  80042034e8:	48 89 03             	mov    %rax,(%rbx)
				page_free_list = &pages[i];
			last = &pages[i];
			//count++;
		}
	}*/
}
  80042034eb:	48 83 c4 20          	add    $0x20,%rsp
  80042034ef:	5b                   	pop    %rbx
  80042034f0:	41 5c                	pop    %r12
  80042034f2:	5d                   	pop    %rbp
  80042034f3:	c3                   	retq   

00000080042034f4 <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  80042034f4:	55                   	push   %rbp
  80042034f5:	48 89 e5             	mov    %rsp,%rbp
  80042034f8:	48 83 ec 20          	sub    $0x20,%rsp
  80042034fc:	89 7d ec             	mov    %edi,-0x14(%rbp)
	// Fill this function in
	if(!page_free_list) return NULL;
  80042034ff:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004203506:	00 00 00 
  8004203509:	48 8b 00             	mov    (%rax),%rax
  800420350c:	48 85 c0             	test   %rax,%rax
  800420350f:	75 07                	jne    8004203518 <page_alloc+0x24>
  8004203511:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203516:	eb 6a                	jmp    8004203582 <page_alloc+0x8e>
	//check_pc();
	struct PageInfo* to_alloc = page_free_list;
  8004203518:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  800420351f:	00 00 00 
  8004203522:	48 8b 00             	mov    (%rax),%rax
  8004203525:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	page_free_list = to_alloc->pp_link;
  8004203529:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420352d:	48 8b 10             	mov    (%rax),%rdx
  8004203530:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004203537:	00 00 00 
  800420353a:	48 89 10             	mov    %rdx,(%rax)
	to_alloc->pp_link = NULL;
  800420353d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203541:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	if(alloc_flags & ALLOC_ZERO) memset(page2kva(to_alloc), '\0', PGSIZE);
  8004203548:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420354b:	83 e0 01             	and    $0x1,%eax
  800420354e:	85 c0                	test   %eax,%eax
  8004203550:	74 2c                	je     800420357e <page_alloc+0x8a>
  8004203552:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203556:	48 89 c7             	mov    %rax,%rdi
  8004203559:	48 b8 37 23 20 04 80 	movabs $0x8004202337,%rax
  8004203560:	00 00 00 
  8004203563:	ff d0                	callq  *%rax
  8004203565:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420356a:	be 00 00 00 00       	mov    $0x0,%esi
  800420356f:	48 89 c7             	mov    %rax,%rdi
  8004203572:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  8004203579:	00 00 00 
  800420357c:	ff d0                	callq  *%rax
	return to_alloc;
  800420357e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004203582:	c9                   	leaveq 
  8004203583:	c3                   	retq   

0000008004203584 <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!
//
static void
page_initpp(struct PageInfo *pp)
{
  8004203584:	55                   	push   %rbp
  8004203585:	48 89 e5             	mov    %rsp,%rbp
  8004203588:	48 83 ec 10          	sub    $0x10,%rsp
  800420358c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	memset(pp, 0, sizeof(*pp));
  8004203590:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203594:	ba 10 00 00 00       	mov    $0x10,%edx
  8004203599:	be 00 00 00 00       	mov    $0x0,%esi
  800420359e:	48 89 c7             	mov    %rax,%rdi
  80042035a1:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  80042035a8:	00 00 00 
  80042035ab:	ff d0                	callq  *%rax
}
  80042035ad:	c9                   	leaveq 
  80042035ae:	c3                   	retq   

00000080042035af <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  80042035af:	55                   	push   %rbp
  80042035b0:	48 89 e5             	mov    %rsp,%rbp
  80042035b3:	48 83 ec 10          	sub    $0x10,%rsp
  80042035b7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if(!pp) return;
  80042035bb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042035c0:	75 02                	jne    80042035c4 <page_free+0x15>
  80042035c2:	eb 68                	jmp    800420362c <page_free+0x7d>
	if(pp->pp_ref || pp->pp_link){
  80042035c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042035c8:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042035cc:	66 85 c0             	test   %ax,%ax
  80042035cf:	75 0c                	jne    80042035dd <page_free+0x2e>
  80042035d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042035d5:	48 8b 00             	mov    (%rax),%rax
  80042035d8:	48 85 c0             	test   %rax,%rax
  80042035db:	74 2a                	je     8004203607 <page_free+0x58>
		panic("page_free fault");
  80042035dd:	48 ba fc 5c 21 04 80 	movabs $0x8004215cfc,%rdx
  80042035e4:	00 00 00 
  80042035e7:	be ec 01 00 00       	mov    $0x1ec,%esi
  80042035ec:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042035f3:	00 00 00 
  80042035f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042035fb:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  8004203602:	00 00 00 
  8004203605:	ff d1                	callq  *%rcx
	}
	pp->pp_link = page_free_list;
  8004203607:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  800420360e:	00 00 00 
  8004203611:	48 8b 10             	mov    (%rax),%rdx
  8004203614:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203618:	48 89 10             	mov    %rdx,(%rax)
	page_free_list = pp;
  800420361b:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004203622:	00 00 00 
  8004203625:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203629:	48 89 10             	mov    %rdx,(%rax)
}
  800420362c:	c9                   	leaveq 
  800420362d:	c3                   	retq   

000000800420362e <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  800420362e:	55                   	push   %rbp
  800420362f:	48 89 e5             	mov    %rsp,%rbp
  8004203632:	48 83 ec 10          	sub    $0x10,%rsp
  8004203636:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (--pp->pp_ref == 0)
  800420363a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420363e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203642:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004203645:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203649:	66 89 50 08          	mov    %dx,0x8(%rax)
  800420364d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203651:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203655:	66 85 c0             	test   %ax,%ax
  8004203658:	75 13                	jne    800420366d <page_decref+0x3f>
		page_free(pp);
  800420365a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420365e:	48 89 c7             	mov    %rax,%rdi
  8004203661:	48 b8 af 35 20 04 80 	movabs $0x80042035af,%rax
  8004203668:	00 00 00 
  800420366b:	ff d0                	callq  *%rax
}
  800420366d:	c9                   	leaveq 
  800420366e:	c3                   	retq   

000000800420366f <pml4e_walk>:
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *
pml4e_walk(pml4e_t *pml4e, const void *va, int create)
{
  800420366f:	55                   	push   %rbp
  8004203670:	48 89 e5             	mov    %rsp,%rbp
  8004203673:	48 83 ec 50          	sub    $0x50,%rsp
  8004203677:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420367b:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420367f:	89 55 bc             	mov    %edx,-0x44(%rbp)
	pml4e_t *entry = &pml4e[PML4(va)];
  8004203682:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203686:	48 c1 e8 27          	shr    $0x27,%rax
  800420368a:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420368f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203696:	00 
  8004203697:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420369b:	48 01 d0             	add    %rdx,%rax
  800420369e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	//pdpe_t *pdpe = &pml4e[PDPE(va)];
	int allocate = !(*entry & PTE_P);
  80042036a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042036a6:	48 8b 00             	mov    (%rax),%rax
  80042036a9:	83 e0 01             	and    $0x1,%eax
  80042036ac:	48 85 c0             	test   %rax,%rax
  80042036af:	0f 94 c0             	sete   %al
  80042036b2:	0f b6 c0             	movzbl %al,%eax
  80042036b5:	89 45 ec             	mov    %eax,-0x14(%rbp)
	struct PageInfo* pml4e_info;
	if(allocate){
  80042036b8:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80042036bc:	0f 84 ad 00 00 00    	je     800420376f <pml4e_walk+0x100>
		if(!create) return NULL;
  80042036c2:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  80042036c6:	75 0a                	jne    80042036d2 <pml4e_walk+0x63>
  80042036c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042036cd:	e9 5d 01 00 00       	jmpq   800420382f <pml4e_walk+0x1c0>
		pml4e_info = page_alloc(ALLOC_ZERO);
  80042036d2:	bf 01 00 00 00       	mov    $0x1,%edi
  80042036d7:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  80042036de:	00 00 00 
  80042036e1:	ff d0                	callq  *%rax
  80042036e3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	  //assert(!pml4e_info->pp_link);
		if(!pml4e_info) return NULL;
  80042036e7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042036ec:	75 0a                	jne    80042036f8 <pml4e_walk+0x89>
  80042036ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80042036f3:	e9 37 01 00 00       	jmpq   800420382f <pml4e_walk+0x1c0>
		assert(!pml4e_info->pp_link);
  80042036f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042036fc:	48 8b 00             	mov    (%rax),%rax
  80042036ff:	48 85 c0             	test   %rax,%rax
  8004203702:	74 35                	je     8004203739 <pml4e_walk+0xca>
  8004203704:	48 b9 0c 5d 21 04 80 	movabs $0x8004215d0c,%rcx
  800420370b:	00 00 00 
  800420370e:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004203715:	00 00 00 
  8004203718:	be 21 02 00 00       	mov    $0x221,%esi
  800420371d:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004203724:	00 00 00 
  8004203727:	b8 00 00 00 00       	mov    $0x0,%eax
  800420372c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203733:	00 00 00 
  8004203736:	41 ff d0             	callq  *%r8
		pml4e_info->pp_ref++;
  8004203739:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420373d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203741:	8d 50 01             	lea    0x1(%rax),%edx
  8004203744:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203748:	66 89 50 08          	mov    %dx,0x8(%rax)
		*entry = (pml4e_t)(page2pa(pml4e_info) | PTE_USER);
  800420374c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203750:	48 89 c7             	mov    %rax,%rdi
  8004203753:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  800420375a:	00 00 00 
  800420375d:	ff d0                	callq  *%rax
  800420375f:	48 0d 07 0e 00 00    	or     $0xe07,%rax
  8004203765:	48 89 c2             	mov    %rax,%rdx
  8004203768:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420376c:	48 89 10             	mov    %rdx,(%rax)
	}
	pte_t *pte = pdpe_walk(KADDR(PTE_ADDR(*entry)), va, create);
  800420376f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203773:	48 8b 00             	mov    (%rax),%rax
  8004203776:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420377c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203780:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203784:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203788:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420378b:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420378e:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004203795:	00 00 00 
  8004203798:	48 8b 00             	mov    (%rax),%rax
  800420379b:	48 39 c2             	cmp    %rax,%rdx
  800420379e:	72 32                	jb     80042037d2 <pml4e_walk+0x163>
  80042037a0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042037a4:	48 89 c1             	mov    %rax,%rcx
  80042037a7:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  80042037ae:	00 00 00 
  80042037b1:	be 25 02 00 00       	mov    $0x225,%esi
  80042037b6:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042037bd:	00 00 00 
  80042037c0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042037c5:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042037cc:	00 00 00 
  80042037cf:	41 ff d0             	callq  *%r8
  80042037d2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042037d9:	00 00 00 
  80042037dc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042037e0:	48 01 d0             	add    %rdx,%rax
  80042037e3:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042037e6:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80042037ea:	48 89 ce             	mov    %rcx,%rsi
  80042037ed:	48 89 c7             	mov    %rax,%rdi
  80042037f0:	48 b8 31 38 20 04 80 	movabs $0x8004203831,%rax
  80042037f7:	00 00 00 
  80042037fa:	ff d0                	callq  *%rax
  80042037fc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	if(!pte && allocate){	
  8004203800:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004203805:	75 24                	jne    800420382b <pml4e_walk+0x1bc>
  8004203807:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420380b:	74 1e                	je     800420382b <pml4e_walk+0x1bc>
		page_decref(pml4e_info);
  800420380d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203811:	48 89 c7             	mov    %rax,%rdi
  8004203814:	48 b8 2e 36 20 04 80 	movabs $0x800420362e,%rax
  800420381b:	00 00 00 
  800420381e:	ff d0                	callq  *%rax
		*entry = 0;
  8004203820:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203824:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	}
	return pte;
  800420382b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
}
  800420382f:	c9                   	leaveq 
  8004203830:	c3                   	retq   

0000008004203831 <pdpe_walk>:
// Given a pdpe i.e page directory pointer pdpe_walk returns the pointer to page table entry
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create){
  8004203831:	55                   	push   %rbp
  8004203832:	48 89 e5             	mov    %rsp,%rbp
  8004203835:	48 83 ec 50          	sub    $0x50,%rsp
  8004203839:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420383d:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004203841:	89 55 bc             	mov    %edx,-0x44(%rbp)
	pdpe_t *entry = &pdpe[PDPE(va)];
  8004203844:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203848:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420384c:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203851:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203858:	00 
  8004203859:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420385d:	48 01 d0             	add    %rdx,%rax
  8004203860:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	int allocate = !(*entry & PTE_P);
  8004203864:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203868:	48 8b 00             	mov    (%rax),%rax
  800420386b:	83 e0 01             	and    $0x1,%eax
  800420386e:	48 85 c0             	test   %rax,%rax
  8004203871:	0f 94 c0             	sete   %al
  8004203874:	0f b6 c0             	movzbl %al,%eax
  8004203877:	89 45 ec             	mov    %eax,-0x14(%rbp)
	struct PageInfo* pdpe_info;
	if(allocate){
  800420387a:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420387e:	74 6c                	je     80042038ec <pdpe_walk+0xbb>
		if(!create) return NULL;
  8004203880:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  8004203884:	75 0a                	jne    8004203890 <pdpe_walk+0x5f>
  8004203886:	b8 00 00 00 00       	mov    $0x0,%eax
  800420388b:	e9 1c 01 00 00       	jmpq   80042039ac <pdpe_walk+0x17b>
		pdpe_info = page_alloc(ALLOC_ZERO);
  8004203890:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203895:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  800420389c:	00 00 00 
  800420389f:	ff d0                	callq  *%rax
  80042038a1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if(!pdpe_info) return NULL;
  80042038a5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042038aa:	75 0a                	jne    80042038b6 <pdpe_walk+0x85>
  80042038ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80042038b1:	e9 f6 00 00 00       	jmpq   80042039ac <pdpe_walk+0x17b>
		pdpe_info->pp_ref++;
  80042038b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042038ba:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042038be:	8d 50 01             	lea    0x1(%rax),%edx
  80042038c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042038c5:	66 89 50 08          	mov    %dx,0x8(%rax)
		*entry = (pdpe_t)(page2pa(pdpe_info) | PTE_USER);
  80042038c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042038cd:	48 89 c7             	mov    %rax,%rdi
  80042038d0:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  80042038d7:	00 00 00 
  80042038da:	ff d0                	callq  *%rax
  80042038dc:	48 0d 07 0e 00 00    	or     $0xe07,%rax
  80042038e2:	48 89 c2             	mov    %rax,%rdx
  80042038e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042038e9:	48 89 10             	mov    %rdx,(%rax)
	}
	pte_t *pte = pgdir_walk(KADDR(PTE_ADDR(*entry)), va, create);
  80042038ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042038f0:	48 8b 00             	mov    (%rax),%rax
  80042038f3:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042038f9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042038fd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203901:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203905:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004203908:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420390b:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004203912:	00 00 00 
  8004203915:	48 8b 00             	mov    (%rax),%rax
  8004203918:	48 39 c2             	cmp    %rax,%rdx
  800420391b:	72 32                	jb     800420394f <pdpe_walk+0x11e>
  800420391d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203921:	48 89 c1             	mov    %rax,%rcx
  8004203924:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  800420392b:	00 00 00 
  800420392e:	be 3e 02 00 00       	mov    $0x23e,%esi
  8004203933:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420393a:	00 00 00 
  800420393d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203942:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203949:	00 00 00 
  800420394c:	41 ff d0             	callq  *%r8
  800420394f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203956:	00 00 00 
  8004203959:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420395d:	48 01 d0             	add    %rdx,%rax
  8004203960:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004203963:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004203967:	48 89 ce             	mov    %rcx,%rsi
  800420396a:	48 89 c7             	mov    %rax,%rdi
  800420396d:	48 b8 ae 39 20 04 80 	movabs $0x80042039ae,%rax
  8004203974:	00 00 00 
  8004203977:	ff d0                	callq  *%rax
  8004203979:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	if(!pte && allocate){
  800420397d:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004203982:	75 24                	jne    80042039a8 <pdpe_walk+0x177>
  8004203984:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004203988:	74 1e                	je     80042039a8 <pdpe_walk+0x177>
		page_decref(pdpe_info);
  800420398a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420398e:	48 89 c7             	mov    %rax,%rdi
  8004203991:	48 b8 2e 36 20 04 80 	movabs $0x800420362e,%rax
  8004203998:	00 00 00 
  800420399b:	ff d0                	callq  *%rax
		*entry = 0;
  800420399d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042039a1:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	}
	return pte;
  80042039a8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
}
  80042039ac:	c9                   	leaveq 
  80042039ad:	c3                   	retq   

00000080042039ae <pgdir_walk>:
// The logic here is slightly different, in that it needs to look
// not just at the page directory, but also get the last-level page table entry.

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
  80042039ae:	55                   	push   %rbp
  80042039af:	48 89 e5             	mov    %rsp,%rbp
  80042039b2:	48 83 ec 50          	sub    $0x50,%rsp
  80042039b6:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042039ba:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042039be:	89 55 bc             	mov    %edx,-0x44(%rbp)
	// Fill this function in
	pte_t *entry = &pgdir[PDX(va)];
  80042039c1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042039c5:	48 c1 e8 15          	shr    $0x15,%rax
  80042039c9:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042039ce:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042039d5:	00 
  80042039d6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042039da:	48 01 d0             	add    %rdx,%rax
  80042039dd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	int allocate = !(*entry & PTE_P);
  80042039e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042039e5:	48 8b 00             	mov    (%rax),%rax
  80042039e8:	83 e0 01             	and    $0x1,%eax
  80042039eb:	48 85 c0             	test   %rax,%rax
  80042039ee:	0f 94 c0             	sete   %al
  80042039f1:	0f b6 c0             	movzbl %al,%eax
  80042039f4:	89 45 f4             	mov    %eax,-0xc(%rbp)
	struct PageInfo* pde_info;
	if(allocate){
  80042039f7:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  80042039fb:	74 6c                	je     8004203a69 <pgdir_walk+0xbb>
		if(!create) return NULL;
  80042039fd:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  8004203a01:	75 0a                	jne    8004203a0d <pgdir_walk+0x5f>
  8004203a03:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203a08:	e9 e5 00 00 00       	jmpq   8004203af2 <pgdir_walk+0x144>
		pde_info = page_alloc(ALLOC_ZERO);
  8004203a0d:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203a12:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  8004203a19:	00 00 00 
  8004203a1c:	ff d0                	callq  *%rax
  8004203a1e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if(!pde_info) return NULL;
  8004203a22:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203a27:	75 0a                	jne    8004203a33 <pgdir_walk+0x85>
  8004203a29:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203a2e:	e9 bf 00 00 00       	jmpq   8004203af2 <pgdir_walk+0x144>
		pde_info->pp_ref++;
  8004203a33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203a37:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203a3b:	8d 50 01             	lea    0x1(%rax),%edx
  8004203a3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203a42:	66 89 50 08          	mov    %dx,0x8(%rax)
		*entry = (pde_t)(page2pa(pde_info) | PTE_USER);
  8004203a46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203a4a:	48 89 c7             	mov    %rax,%rdi
  8004203a4d:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  8004203a54:	00 00 00 
  8004203a57:	ff d0                	callq  *%rax
  8004203a59:	48 0d 07 0e 00 00    	or     $0xe07,%rax
  8004203a5f:	48 89 c2             	mov    %rax,%rdx
  8004203a62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a66:	48 89 10             	mov    %rdx,(%rax)
	}
	return &((pte_t *)KADDR(PTE_ADDR(*entry)))[PTX(va)];
  8004203a69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a6d:	48 8b 00             	mov    (%rax),%rax
  8004203a70:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203a76:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203a7a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203a7e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203a82:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004203a85:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004203a88:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004203a8f:	00 00 00 
  8004203a92:	48 8b 00             	mov    (%rax),%rax
  8004203a95:	48 39 c2             	cmp    %rax,%rdx
  8004203a98:	72 32                	jb     8004203acc <pgdir_walk+0x11e>
  8004203a9a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203a9e:	48 89 c1             	mov    %rax,%rcx
  8004203aa1:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  8004203aa8:	00 00 00 
  8004203aab:	be 5b 02 00 00       	mov    $0x25b,%esi
  8004203ab0:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004203ab7:	00 00 00 
  8004203aba:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203abf:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203ac6:	00 00 00 
  8004203ac9:	41 ff d0             	callq  *%r8
  8004203acc:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203ad3:	00 00 00 
  8004203ad6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203ada:	48 01 d0             	add    %rdx,%rax
  8004203add:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004203ae1:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004203ae5:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203aeb:	48 c1 e2 03          	shl    $0x3,%rdx
  8004203aef:	48 01 d0             	add    %rdx,%rax
}
  8004203af2:	c9                   	leaveq 
  8004203af3:	c3                   	retq   

0000008004203af4 <boot_map_region>:
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  8004203af4:	55                   	push   %rbp
  8004203af5:	48 89 e5             	mov    %rsp,%rbp
  8004203af8:	48 83 ec 40          	sub    $0x40,%rsp
  8004203afc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203b00:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004203b04:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004203b08:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004203b0c:	44 89 45 cc          	mov    %r8d,-0x34(%rbp)
	// Fill this function in
size_t i;
	for(i = 0; i < size; i += PGSIZE){
  8004203b10:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004203b17:	00 
  8004203b18:	e9 87 00 00 00       	jmpq   8004203ba4 <boot_map_region+0xb0>
		pte_t *pte = pml4e_walk(pml4e, (const void*) (i + la), 1);
  8004203b1d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203b21:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203b25:	48 01 d0             	add    %rdx,%rax
  8004203b28:	48 89 c1             	mov    %rax,%rcx
  8004203b2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203b2f:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203b34:	48 89 ce             	mov    %rcx,%rsi
  8004203b37:	48 89 c7             	mov    %rax,%rdi
  8004203b3a:	48 b8 6f 36 20 04 80 	movabs $0x800420366f,%rax
  8004203b41:	00 00 00 
  8004203b44:	ff d0                	callq  *%rax
  8004203b46:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if(!pte) panic("unable to bootmap");
  8004203b4a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004203b4f:	75 2a                	jne    8004203b7b <boot_map_region+0x87>
  8004203b51:	48 ba 21 5d 21 04 80 	movabs $0x8004215d21,%rdx
  8004203b58:	00 00 00 
  8004203b5b:	be 6f 02 00 00       	mov    $0x26f,%esi
  8004203b60:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004203b67:	00 00 00 
  8004203b6a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203b6f:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  8004203b76:	00 00 00 
  8004203b79:	ff d1                	callq  *%rcx
		*pte = (pa + i) | perm | PTE_P;
  8004203b7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b7f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203b83:	48 01 c2             	add    %rax,%rdx
  8004203b86:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004203b89:	48 98                	cltq   
  8004203b8b:	48 09 d0             	or     %rdx,%rax
  8004203b8e:	48 83 c8 01          	or     $0x1,%rax
  8004203b92:	48 89 c2             	mov    %rax,%rdx
  8004203b95:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203b99:	48 89 10             	mov    %rdx,(%rax)
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
size_t i;
	for(i = 0; i < size; i += PGSIZE){
  8004203b9c:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004203ba3:	00 
  8004203ba4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ba8:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004203bac:	0f 82 6b ff ff ff    	jb     8004203b1d <boot_map_region+0x29>
		pte_t *pte = pml4e_walk(pml4e, (const void*) (i + la), 1);
		if(!pte) panic("unable to bootmap");
		*pte = (pa + i) | perm | PTE_P;
	}
}
  8004203bb2:	c9                   	leaveq 
  8004203bb3:	c3                   	retq   

0000008004203bb4 <page_insert>:
// Hint: The TA solution is implemented using pml4e_walk, page_remove,
// and page2pa.
//
int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  8004203bb4:	55                   	push   %rbp
  8004203bb5:	48 89 e5             	mov    %rsp,%rbp
  8004203bb8:	53                   	push   %rbx
  8004203bb9:	48 83 ec 38          	sub    $0x38,%rsp
  8004203bbd:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004203bc1:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004203bc5:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004203bc9:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
	// Fill this function in
	pte_t *pte = pml4e_walk(pml4e, va, 1);
  8004203bcc:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004203bd0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203bd4:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203bd9:	48 89 ce             	mov    %rcx,%rsi
  8004203bdc:	48 89 c7             	mov    %rax,%rdi
  8004203bdf:	48 b8 6f 36 20 04 80 	movabs $0x800420366f,%rax
  8004203be6:	00 00 00 
  8004203be9:	ff d0                	callq  *%rax
  8004203beb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if(!pte) return -E_NO_MEM;
  8004203bef:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203bf4:	75 0a                	jne    8004203c00 <page_insert+0x4c>
  8004203bf6:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004203bfb:	e9 d9 00 00 00       	jmpq   8004203cd9 <page_insert+0x125>
	if(PTE_ADDR(*pte) == page2pa(pp)){
  8004203c00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203c04:	48 8b 00             	mov    (%rax),%rax
  8004203c07:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203c0d:	48 89 c3             	mov    %rax,%rbx
  8004203c10:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203c14:	48 89 c7             	mov    %rax,%rdi
  8004203c17:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  8004203c1e:	00 00 00 
  8004203c21:	ff d0                	callq  *%rax
  8004203c23:	48 39 c3             	cmp    %rax,%rbx
  8004203c26:	75 2c                	jne    8004203c54 <page_insert+0xa0>
		*pte = page2pa(pp) | perm | PTE_P;
  8004203c28:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203c2c:	48 89 c7             	mov    %rax,%rdi
  8004203c2f:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  8004203c36:	00 00 00 
  8004203c39:	ff d0                	callq  *%rax
  8004203c3b:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004203c3e:	48 63 d2             	movslq %edx,%rdx
  8004203c41:	48 09 d0             	or     %rdx,%rax
  8004203c44:	48 83 c8 01          	or     $0x1,%rax
  8004203c48:	48 89 c2             	mov    %rax,%rdx
  8004203c4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203c4f:	48 89 10             	mov    %rdx,(%rax)
  8004203c52:	eb 66                	jmp    8004203cba <page_insert+0x106>
	}
	else{
		if((*pte) & PTE_P) page_remove(pml4e, va);
  8004203c54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203c58:	48 8b 00             	mov    (%rax),%rax
  8004203c5b:	83 e0 01             	and    $0x1,%eax
  8004203c5e:	48 85 c0             	test   %rax,%rax
  8004203c61:	74 1a                	je     8004203c7d <page_insert+0xc9>
  8004203c63:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203c67:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203c6b:	48 89 d6             	mov    %rdx,%rsi
  8004203c6e:	48 89 c7             	mov    %rax,%rdi
  8004203c71:	48 b8 64 3d 20 04 80 	movabs $0x8004203d64,%rax
  8004203c78:	00 00 00 
  8004203c7b:	ff d0                	callq  *%rax
		*pte = page2pa(pp) | perm | PTE_P;
  8004203c7d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203c81:	48 89 c7             	mov    %rax,%rdi
  8004203c84:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  8004203c8b:	00 00 00 
  8004203c8e:	ff d0                	callq  *%rax
  8004203c90:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004203c93:	48 63 d2             	movslq %edx,%rdx
  8004203c96:	48 09 d0             	or     %rdx,%rax
  8004203c99:	48 83 c8 01          	or     $0x1,%rax
  8004203c9d:	48 89 c2             	mov    %rax,%rdx
  8004203ca0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203ca4:	48 89 10             	mov    %rdx,(%rax)
		(pp->pp_ref)++;
  8004203ca7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203cab:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203caf:	8d 50 01             	lea    0x1(%rax),%edx
  8004203cb2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203cb6:	66 89 50 08          	mov    %dx,0x8(%rax)
	}
	tlb_invalidate(pml4e, va);
  8004203cba:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203cbe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203cc2:	48 89 d6             	mov    %rdx,%rsi
  8004203cc5:	48 89 c7             	mov    %rax,%rdi
  8004203cc8:	48 b8 e4 3d 20 04 80 	movabs $0x8004203de4,%rax
  8004203ccf:	00 00 00 
  8004203cd2:	ff d0                	callq  *%rax
	return 0;
  8004203cd4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004203cd9:	48 83 c4 38          	add    $0x38,%rsp
  8004203cdd:	5b                   	pop    %rbx
  8004203cde:	5d                   	pop    %rbp
  8004203cdf:	c3                   	retq   

0000008004203ce0 <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  8004203ce0:	55                   	push   %rbp
  8004203ce1:	48 89 e5             	mov    %rsp,%rbp
  8004203ce4:	48 83 ec 30          	sub    $0x30,%rsp
  8004203ce8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203cec:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004203cf0:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// Fill this function in
	pte_t *pte = pml4e_walk(pml4e, va, 0);
  8004203cf4:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203cf8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203cfc:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203d01:	48 89 ce             	mov    %rcx,%rsi
  8004203d04:	48 89 c7             	mov    %rax,%rdi
  8004203d07:	48 b8 6f 36 20 04 80 	movabs $0x800420366f,%rax
  8004203d0e:	00 00 00 
  8004203d11:	ff d0                	callq  *%rax
  8004203d13:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(!pte || !((*pte) & PTE_P)) return NULL;
  8004203d17:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203d1c:	74 0f                	je     8004203d2d <page_lookup+0x4d>
  8004203d1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d22:	48 8b 00             	mov    (%rax),%rax
  8004203d25:	83 e0 01             	and    $0x1,%eax
  8004203d28:	48 85 c0             	test   %rax,%rax
  8004203d2b:	75 07                	jne    8004203d34 <page_lookup+0x54>
  8004203d2d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d32:	eb 2e                	jmp    8004203d62 <page_lookup+0x82>
	if(pte_store) *pte_store = pte;
  8004203d34:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004203d39:	74 0b                	je     8004203d46 <page_lookup+0x66>
  8004203d3b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203d3f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203d43:	48 89 10             	mov    %rdx,(%rax)
	return pa2page(PTE_ADDR(*pte));
  8004203d46:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d4a:	48 8b 00             	mov    (%rax),%rax
  8004203d4d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203d53:	48 89 c7             	mov    %rax,%rdi
  8004203d56:	48 b8 c6 22 20 04 80 	movabs $0x80042022c6,%rax
  8004203d5d:	00 00 00 
  8004203d60:	ff d0                	callq  *%rax
}
  8004203d62:	c9                   	leaveq 
  8004203d63:	c3                   	retq   

0000008004203d64 <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  8004203d64:	55                   	push   %rbp
  8004203d65:	48 89 e5             	mov    %rsp,%rbp
  8004203d68:	48 83 ec 20          	sub    $0x20,%rsp
  8004203d6c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203d70:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Fill this function in
	pte_t *pte;
	struct PageInfo *page = page_lookup(pml4e, va, &pte);
  8004203d74:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8004203d78:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203d7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203d80:	48 89 ce             	mov    %rcx,%rsi
  8004203d83:	48 89 c7             	mov    %rax,%rdi
  8004203d86:	48 b8 e0 3c 20 04 80 	movabs $0x8004203ce0,%rax
  8004203d8d:	00 00 00 
  8004203d90:	ff d0                	callq  *%rax
  8004203d92:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(!page) return;
  8004203d96:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203d9b:	75 02                	jne    8004203d9f <page_remove+0x3b>
  8004203d9d:	eb 43                	jmp    8004203de2 <page_remove+0x7e>
	page_decref(page);
  8004203d9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203da3:	48 89 c7             	mov    %rax,%rdi
  8004203da6:	48 b8 2e 36 20 04 80 	movabs $0x800420362e,%rax
  8004203dad:	00 00 00 
  8004203db0:	ff d0                	callq  *%rax
	if(!pte) return;
  8004203db2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203db6:	48 85 c0             	test   %rax,%rax
  8004203db9:	75 02                	jne    8004203dbd <page_remove+0x59>
  8004203dbb:	eb 25                	jmp    8004203de2 <page_remove+0x7e>
	*pte = 0;
  8004203dbd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203dc1:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	tlb_invalidate(pml4e, va);
  8004203dc8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203dcc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203dd0:	48 89 d6             	mov    %rdx,%rsi
  8004203dd3:	48 89 c7             	mov    %rax,%rdi
  8004203dd6:	48 b8 e4 3d 20 04 80 	movabs $0x8004203de4,%rax
  8004203ddd:	00 00 00 
  8004203de0:	ff d0                	callq  *%rax
}
  8004203de2:	c9                   	leaveq 
  8004203de3:	c3                   	retq   

0000008004203de4 <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  8004203de4:	55                   	push   %rbp
  8004203de5:	48 89 e5             	mov    %rsp,%rbp
  8004203de8:	48 83 ec 20          	sub    $0x20,%rsp
  8004203dec:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203df0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Flush the entry only if we're modifying the current address space.
	assert(pml4e!=NULL);
  8004203df4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203df9:	75 35                	jne    8004203e30 <tlb_invalidate+0x4c>
  8004203dfb:	48 b9 33 5d 21 04 80 	movabs $0x8004215d33,%rcx
  8004203e02:	00 00 00 
  8004203e05:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004203e0c:	00 00 00 
  8004203e0f:	be d8 02 00 00       	mov    $0x2d8,%esi
  8004203e14:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004203e1b:	00 00 00 
  8004203e1e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e23:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004203e2a:	00 00 00 
  8004203e2d:	41 ff d0             	callq  *%r8
	if (!curenv || curenv->env_pml4e == pml4e)
  8004203e30:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004203e37:	00 00 00 
  8004203e3a:	ff d0                	callq  *%rax
  8004203e3c:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004203e43:	00 00 00 
  8004203e46:	48 98                	cltq   
  8004203e48:	48 c1 e0 03          	shl    $0x3,%rax
  8004203e4c:	48 89 c2             	mov    %rax,%rdx
  8004203e4f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203e53:	48 29 c2             	sub    %rax,%rdx
  8004203e56:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004203e5a:	48 83 c0 08          	add    $0x8,%rax
  8004203e5e:	48 8b 00             	mov    (%rax),%rax
  8004203e61:	48 85 c0             	test   %rax,%rax
  8004203e64:	74 3e                	je     8004203ea4 <tlb_invalidate+0xc0>
  8004203e66:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004203e6d:	00 00 00 
  8004203e70:	ff d0                	callq  *%rax
  8004203e72:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004203e79:	00 00 00 
  8004203e7c:	48 98                	cltq   
  8004203e7e:	48 c1 e0 03          	shl    $0x3,%rax
  8004203e82:	48 89 c2             	mov    %rax,%rdx
  8004203e85:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203e89:	48 29 c2             	sub    %rax,%rdx
  8004203e8c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004203e90:	48 83 c0 08          	add    $0x8,%rax
  8004203e94:	48 8b 00             	mov    (%rax),%rax
  8004203e97:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004203e9e:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004203ea2:	75 0f                	jne    8004203eb3 <tlb_invalidate+0xcf>
  8004203ea4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203ea8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void 
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  8004203eac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203eb0:	0f 01 38             	invlpg (%rax)
		invlpg(va);
}
  8004203eb3:	c9                   	leaveq 
  8004203eb4:	c3                   	retq   

0000008004203eb5 <mmio_map_region>:
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
void *
mmio_map_region(physaddr_t pa, size_t size)
{
  8004203eb5:	55                   	push   %rbp
  8004203eb6:	48 89 e5             	mov    %rsp,%rbp
  8004203eb9:	48 83 ec 30          	sub    $0x30,%rsp
  8004203ebd:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004203ec1:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// okay to simply panic if this happens).
	//
	// Hint: The staff solution uses boot_map_region.
	//
	// Your code here:
	size_t size_alloc = ROUNDUP(size, PGSIZE);
  8004203ec5:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  8004203ecc:	00 
  8004203ecd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ed1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203ed5:	48 01 d0             	add    %rdx,%rax
  8004203ed8:	48 83 e8 01          	sub    $0x1,%rax
  8004203edc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004203ee0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203ee4:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203ee9:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004203eed:	48 89 d0             	mov    %rdx,%rax
  8004203ef0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004203ef4:	48 29 c2             	sub    %rax,%rdx
  8004203ef7:	48 89 d0             	mov    %rdx,%rax
  8004203efa:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uintptr_t low = base;
  8004203efe:	48 b8 40 a6 22 04 80 	movabs $0x800422a640,%rax
  8004203f05:	00 00 00 
  8004203f08:	48 8b 00             	mov    (%rax),%rax
  8004203f0b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	base += size_alloc;
  8004203f0f:	48 b8 40 a6 22 04 80 	movabs $0x800422a640,%rax
  8004203f16:	00 00 00 
  8004203f19:	48 8b 10             	mov    (%rax),%rdx
  8004203f1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203f20:	48 01 c2             	add    %rax,%rdx
  8004203f23:	48 b8 40 a6 22 04 80 	movabs $0x800422a640,%rax
  8004203f2a:	00 00 00 
  8004203f2d:	48 89 10             	mov    %rdx,(%rax)
	if(base >= MMIOLIM) 
  8004203f30:	48 b8 40 a6 22 04 80 	movabs $0x800422a640,%rax
  8004203f37:	00 00 00 
  8004203f3a:	48 8b 10             	mov    (%rax),%rdx
  8004203f3d:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004203f44:	00 00 00 
  8004203f47:	48 39 c2             	cmp    %rax,%rdx
  8004203f4a:	76 2a                	jbe    8004203f76 <mmio_map_region+0xc1>
		panic("Exceeding MMIOLIM\n");
  8004203f4c:	48 ba 3f 5d 21 04 80 	movabs $0x8004215d3f,%rdx
  8004203f53:	00 00 00 
  8004203f56:	be 01 03 00 00       	mov    $0x301,%esi
  8004203f5b:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004203f62:	00 00 00 
  8004203f65:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f6a:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  8004203f71:	00 00 00 
  8004203f74:	ff d1                	callq  *%rcx
	boot_map_region(boot_pml4e, low, size_alloc, pa, PTE_W | PTE_PCD | PTE_PWT);
  8004203f76:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004203f7d:	00 00 00 
  8004203f80:	48 8b 00             	mov    (%rax),%rax
  8004203f83:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004203f87:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203f8b:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8004203f8f:	41 b8 1a 00 00 00    	mov    $0x1a,%r8d
  8004203f95:	48 89 c7             	mov    %rax,%rdi
  8004203f98:	48 b8 f4 3a 20 04 80 	movabs $0x8004203af4,%rax
  8004203f9f:	00 00 00 
  8004203fa2:	ff d0                	callq  *%rax
	return (void *)low;
  8004203fa4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
	//panic("mmio_map_region not implemented");
}
  8004203fa8:	c9                   	leaveq 
  8004203fa9:	c3                   	retq   

0000008004203faa <user_mem_check>:
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  8004203faa:	55                   	push   %rbp
  8004203fab:	48 89 e5             	mov    %rsp,%rbp
  8004203fae:	48 83 ec 50          	sub    $0x50,%rsp
  8004203fb2:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004203fb6:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004203fba:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004203fbe:	89 4d b4             	mov    %ecx,-0x4c(%rbp)
	// LAB 3: Your code here.
	pte_t *pte = NULL;
  8004203fc1:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004203fc8:	00 
void* addr;
	for(addr= (void *) ROUNDDOWN(va, PGSIZE); addr < ROUNDUP(va + len, PGSIZE);addr += PGSIZE){
  8004203fc9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203fcd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004203fd1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203fd5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203fdb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203fdf:	e9 86 00 00 00       	jmpq   800420406a <user_mem_check+0xc0>
		if(((size_t)addr >= ULIM) || !(page_lookup(env->env_pml4e, addr, &pte)) || (*pte & perm) != perm){
  8004203fe4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203fe8:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004203fef:	00 00 00 
  8004203ff2:	48 39 c2             	cmp    %rax,%rdx
  8004203ff5:	77 43                	ja     800420403a <user_mem_check+0x90>
  8004203ff7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203ffb:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004204002:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  8004204006:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420400a:	48 89 ce             	mov    %rcx,%rsi
  800420400d:	48 89 c7             	mov    %rax,%rdi
  8004204010:	48 b8 e0 3c 20 04 80 	movabs $0x8004203ce0,%rax
  8004204017:	00 00 00 
  800420401a:	ff d0                	callq  *%rax
  800420401c:	48 85 c0             	test   %rax,%rax
  800420401f:	74 19                	je     800420403a <user_mem_check+0x90>
  8004204021:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204025:	48 8b 10             	mov    (%rax),%rdx
  8004204028:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420402b:	48 98                	cltq   
  800420402d:	48 21 c2             	and    %rax,%rdx
  8004204030:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004204033:	48 98                	cltq   
  8004204035:	48 39 c2             	cmp    %rax,%rdx
  8004204038:	74 28                	je     8004204062 <user_mem_check+0xb8>
			user_mem_check_addr = addr < va ? (size_t)va : (size_t)addr;
  800420403a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420403e:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004204042:	73 06                	jae    800420404a <user_mem_check+0xa0>
  8004204044:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004204048:	eb 04                	jmp    800420404e <user_mem_check+0xa4>
  800420404a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420404e:	48 ba 40 d2 49 04 80 	movabs $0x800449d240,%rdx
  8004204055:	00 00 00 
  8004204058:	48 89 02             	mov    %rax,(%rdx)
			return -E_FAULT;
  800420405b:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8004204060:	eb 56                	jmp    80042040b8 <user_mem_check+0x10e>
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
	// LAB 3: Your code here.
	pte_t *pte = NULL;
void* addr;
	for(addr= (void *) ROUNDDOWN(va, PGSIZE); addr < ROUNDUP(va + len, PGSIZE);addr += PGSIZE){
  8004204062:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204069:	00 
  800420406a:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004204071:	00 
  8004204072:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004204076:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420407a:	48 01 d0             	add    %rdx,%rax
  800420407d:	48 89 c2             	mov    %rax,%rdx
  8004204080:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204084:	48 01 d0             	add    %rdx,%rax
  8004204087:	48 83 e8 01          	sub    $0x1,%rax
  800420408b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420408f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204093:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204098:	48 f7 75 e8          	divq   -0x18(%rbp)
  800420409c:	48 89 d0             	mov    %rdx,%rax
  800420409f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042040a3:	48 29 c2             	sub    %rax,%rdx
  80042040a6:	48 89 d0             	mov    %rdx,%rax
  80042040a9:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042040ad:	0f 87 31 ff ff ff    	ja     8004203fe4 <user_mem_check+0x3a>
		if(((size_t)addr >= ULIM) || !(page_lookup(env->env_pml4e, addr, &pte)) || (*pte & perm) != perm){
			user_mem_check_addr = addr < va ? (size_t)va : (size_t)addr;
			return -E_FAULT;
		}
	}
	return 0;
  80042040b3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042040b8:	c9                   	leaveq 
  80042040b9:	c3                   	retq   

00000080042040ba <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  80042040ba:	55                   	push   %rbp
  80042040bb:	48 89 e5             	mov    %rsp,%rbp
  80042040be:	48 83 ec 20          	sub    $0x20,%rsp
  80042040c2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80042040c6:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80042040ca:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042040ce:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  80042040d1:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042040d4:	83 c8 04             	or     $0x4,%eax
  80042040d7:	89 c1                	mov    %eax,%ecx
  80042040d9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042040dd:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042040e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042040e5:	48 89 c7             	mov    %rax,%rdi
  80042040e8:	48 b8 aa 3f 20 04 80 	movabs $0x8004203faa,%rax
  80042040ef:	00 00 00 
  80042040f2:	ff d0                	callq  *%rax
  80042040f4:	85 c0                	test   %eax,%eax
  80042040f6:	79 47                	jns    800420413f <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  80042040f8:	48 b8 40 d2 49 04 80 	movabs $0x800449d240,%rax
  80042040ff:	00 00 00 
  8004204102:	48 8b 10             	mov    (%rax),%rdx
  8004204105:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204109:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420410f:	89 c6                	mov    %eax,%esi
  8004204111:	48 bf 58 5d 21 04 80 	movabs $0x8004215d58,%rdi
  8004204118:	00 00 00 
  800420411b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204120:	48 b9 0e 92 20 04 80 	movabs $0x800420920e,%rcx
  8004204127:	00 00 00 
  800420412a:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  800420412c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204130:	48 89 c7             	mov    %rax,%rdi
  8004204133:	48 b8 fb 8a 20 04 80 	movabs $0x8004208afb,%rax
  800420413a:	00 00 00 
  800420413d:	ff d0                	callq  *%rax
	}
}
  800420413f:	c9                   	leaveq 
  8004204140:	c3                   	retq   

0000008004204141 <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  8004204141:	55                   	push   %rbp
  8004204142:	48 89 e5             	mov    %rsp,%rbp
  8004204145:	48 83 ec 60          	sub    $0x60,%rsp
  8004204149:	89 f8                	mov    %edi,%eax
  800420414b:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  800420414e:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004204152:	74 07                	je     800420415b <check_page_free_list+0x1a>
  8004204154:	b8 01 00 00 00       	mov    $0x1,%eax
  8004204159:	eb 05                	jmp    8004204160 <check_page_free_list+0x1f>
  800420415b:	b8 00 02 00 00       	mov    $0x200,%eax
  8004204160:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  8004204163:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420416a:	00 
  800420416b:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204172:	00 
	char *first_free_page;

	if (!page_free_list)
  8004204173:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  800420417a:	00 00 00 
  800420417d:	48 8b 00             	mov    (%rax),%rax
  8004204180:	48 85 c0             	test   %rax,%rax
  8004204183:	75 2a                	jne    80042041af <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  8004204185:	48 ba 90 5d 21 04 80 	movabs $0x8004215d90,%rdx
  800420418c:	00 00 00 
  800420418f:	be 4d 03 00 00       	mov    $0x34d,%esi
  8004204194:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420419b:	00 00 00 
  800420419e:	b8 00 00 00 00       	mov    $0x0,%eax
  80042041a3:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  80042041aa:	00 00 00 
  80042041ad:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  80042041af:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  80042041b3:	0f 84 a9 00 00 00    	je     8004204262 <check_page_free_list+0x121>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  80042041b9:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  80042041bd:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042041c1:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  80042041c5:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042041c9:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  80042041d0:	00 00 00 
  80042041d3:	48 8b 00             	mov    (%rax),%rax
  80042041d6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042041da:	eb 58                	jmp    8004204234 <check_page_free_list+0xf3>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  80042041dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042041e0:	48 89 c7             	mov    %rax,%rdi
  80042041e3:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  80042041ea:	00 00 00 
  80042041ed:	ff d0                	callq  *%rax
  80042041ef:	48 c1 e8 15          	shr    $0x15,%rax
  80042041f3:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042041f8:	48 89 c2             	mov    %rax,%rdx
  80042041fb:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042041fe:	48 39 c2             	cmp    %rax,%rdx
  8004204201:	0f 93 c0             	setae  %al
  8004204204:	0f b6 c0             	movzbl %al,%eax
  8004204207:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  800420420a:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800420420d:	48 98                	cltq   
  800420420f:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  8004204214:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204218:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  800420421b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420421f:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004204222:	48 98                	cltq   
  8004204224:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004204229:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420422d:	48 8b 00             	mov    (%rax),%rax
  8004204230:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204234:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204239:	75 a1                	jne    80042041dc <check_page_free_list+0x9b>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
  800420423b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420423f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  8004204246:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420424a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420424e:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  8004204251:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204255:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  800420425c:	00 00 00 
  800420425f:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004204262:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004204269:	00 00 00 
  800420426c:	48 8b 00             	mov    (%rax),%rax
  800420426f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204273:	eb 5e                	jmp    80042042d3 <check_page_free_list+0x192>
		if (PDX(page2pa(pp)) < pdx_limit)
  8004204275:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204279:	48 89 c7             	mov    %rax,%rdi
  800420427c:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  8004204283:	00 00 00 
  8004204286:	ff d0                	callq  *%rax
  8004204288:	48 c1 e8 15          	shr    $0x15,%rax
  800420428c:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204291:	48 89 c2             	mov    %rax,%rdx
  8004204294:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004204297:	48 39 c2             	cmp    %rax,%rdx
  800420429a:	73 2c                	jae    80042042c8 <check_page_free_list+0x187>
			memset(page2kva(pp), 0x97, 128);
  800420429c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042042a0:	48 89 c7             	mov    %rax,%rdi
  80042042a3:	48 b8 37 23 20 04 80 	movabs $0x8004202337,%rax
  80042042aa:	00 00 00 
  80042042ad:	ff d0                	callq  *%rax
  80042042af:	ba 80 00 00 00       	mov    $0x80,%edx
  80042042b4:	be 97 00 00 00       	mov    $0x97,%esi
  80042042b9:	48 89 c7             	mov    %rax,%rdi
  80042042bc:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  80042042c3:	00 00 00 
  80042042c6:	ff d0                	callq  *%rax
		page_free_list = pp1;
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  80042042c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042042cc:	48 8b 00             	mov    (%rax),%rax
  80042042cf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042042d3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042042d8:	75 9b                	jne    8004204275 <check_page_free_list+0x134>
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = boot_alloc(0);
  80042042da:	bf 00 00 00 00       	mov    $0x0,%edi
  80042042df:	48 b8 ba 2c 20 04 80 	movabs $0x8004202cba,%rax
  80042042e6:	00 00 00 
  80042042e9:	ff d0                	callq  *%rax
  80042042eb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042042ef:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  80042042f6:	00 00 00 
  80042042f9:	48 8b 00             	mov    (%rax),%rax
  80042042fc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204300:	e9 20 03 00 00       	jmpq   8004204625 <check_page_free_list+0x4e4>
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
  8004204305:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  800420430c:	00 00 00 
  800420430f:	48 8b 00             	mov    (%rax),%rax
  8004204312:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004204316:	73 35                	jae    800420434d <check_page_free_list+0x20c>
  8004204318:	48 b9 b4 5d 21 04 80 	movabs $0x8004215db4,%rcx
  800420431f:	00 00 00 
  8004204322:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204329:	00 00 00 
  800420432c:	be 67 03 00 00       	mov    $0x367,%esi
  8004204331:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204338:	00 00 00 
  800420433b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204340:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204347:	00 00 00 
  800420434a:	41 ff d0             	callq  *%r8
		assert(pp < pages + npages);
  800420434d:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  8004204354:	00 00 00 
  8004204357:	48 8b 10             	mov    (%rax),%rdx
  800420435a:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004204361:	00 00 00 
  8004204364:	48 8b 00             	mov    (%rax),%rax
  8004204367:	48 c1 e0 04          	shl    $0x4,%rax
  800420436b:	48 01 d0             	add    %rdx,%rax
  800420436e:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204372:	77 35                	ja     80042043a9 <check_page_free_list+0x268>
  8004204374:	48 b9 c0 5d 21 04 80 	movabs $0x8004215dc0,%rcx
  800420437b:	00 00 00 
  800420437e:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204385:	00 00 00 
  8004204388:	be 68 03 00 00       	mov    $0x368,%esi
  800420438d:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204394:	00 00 00 
  8004204397:	b8 00 00 00 00       	mov    $0x0,%eax
  800420439c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042043a3:	00 00 00 
  80042043a6:	41 ff d0             	callq  *%r8
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  80042043a9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042043ad:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  80042043b4:	00 00 00 
  80042043b7:	48 8b 00             	mov    (%rax),%rax
  80042043ba:	48 29 c2             	sub    %rax,%rdx
  80042043bd:	48 89 d0             	mov    %rdx,%rax
  80042043c0:	83 e0 0f             	and    $0xf,%eax
  80042043c3:	48 85 c0             	test   %rax,%rax
  80042043c6:	74 35                	je     80042043fd <check_page_free_list+0x2bc>
  80042043c8:	48 b9 d8 5d 21 04 80 	movabs $0x8004215dd8,%rcx
  80042043cf:	00 00 00 
  80042043d2:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042043d9:	00 00 00 
  80042043dc:	be 69 03 00 00       	mov    $0x369,%esi
  80042043e1:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042043e8:	00 00 00 
  80042043eb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042043f0:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042043f7:	00 00 00 
  80042043fa:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
  80042043fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204401:	48 89 c7             	mov    %rax,%rdi
  8004204404:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  800420440b:	00 00 00 
  800420440e:	ff d0                	callq  *%rax
  8004204410:	48 85 c0             	test   %rax,%rax
  8004204413:	75 35                	jne    800420444a <check_page_free_list+0x309>
  8004204415:	48 b9 0a 5e 21 04 80 	movabs $0x8004215e0a,%rcx
  800420441c:	00 00 00 
  800420441f:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204426:	00 00 00 
  8004204429:	be 6c 03 00 00       	mov    $0x36c,%esi
  800420442e:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204435:	00 00 00 
  8004204438:	b8 00 00 00 00       	mov    $0x0,%eax
  800420443d:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204444:	00 00 00 
  8004204447:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != IOPHYSMEM);
  800420444a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420444e:	48 89 c7             	mov    %rax,%rdi
  8004204451:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  8004204458:	00 00 00 
  800420445b:	ff d0                	callq  *%rax
  800420445d:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004204463:	75 35                	jne    800420449a <check_page_free_list+0x359>
  8004204465:	48 b9 1b 5e 21 04 80 	movabs $0x8004215e1b,%rcx
  800420446c:	00 00 00 
  800420446f:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204476:	00 00 00 
  8004204479:	be 6d 03 00 00       	mov    $0x36d,%esi
  800420447e:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204485:	00 00 00 
  8004204488:	b8 00 00 00 00       	mov    $0x0,%eax
  800420448d:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204494:	00 00 00 
  8004204497:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  800420449a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420449e:	48 89 c7             	mov    %rax,%rdi
  80042044a1:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  80042044a8:	00 00 00 
  80042044ab:	ff d0                	callq  *%rax
  80042044ad:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  80042044b3:	75 35                	jne    80042044ea <check_page_free_list+0x3a9>
  80042044b5:	48 b9 38 5e 21 04 80 	movabs $0x8004215e38,%rcx
  80042044bc:	00 00 00 
  80042044bf:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042044c6:	00 00 00 
  80042044c9:	be 6e 03 00 00       	mov    $0x36e,%esi
  80042044ce:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042044d5:	00 00 00 
  80042044d8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042044dd:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042044e4:	00 00 00 
  80042044e7:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM);
  80042044ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042044ee:	48 89 c7             	mov    %rax,%rdi
  80042044f1:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  80042044f8:	00 00 00 
  80042044fb:	ff d0                	callq  *%rax
  80042044fd:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004204503:	75 35                	jne    800420453a <check_page_free_list+0x3f9>
  8004204505:	48 b9 5b 5e 21 04 80 	movabs $0x8004215e5b,%rcx
  800420450c:	00 00 00 
  800420450f:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204516:	00 00 00 
  8004204519:	be 6f 03 00 00       	mov    $0x36f,%esi
  800420451e:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204525:	00 00 00 
  8004204528:	b8 00 00 00 00       	mov    $0x0,%eax
  800420452d:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204534:	00 00 00 
  8004204537:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
  800420453a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420453e:	48 89 c7             	mov    %rax,%rdi
  8004204541:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  8004204548:	00 00 00 
  800420454b:	ff d0                	callq  *%rax
  800420454d:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004204553:	76 4e                	jbe    80042045a3 <check_page_free_list+0x462>
  8004204555:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204559:	48 89 c7             	mov    %rax,%rdi
  800420455c:	48 b8 37 23 20 04 80 	movabs $0x8004202337,%rax
  8004204563:	00 00 00 
  8004204566:	ff d0                	callq  *%rax
  8004204568:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420456c:	73 35                	jae    80042045a3 <check_page_free_list+0x462>
  800420456e:	48 b9 78 5e 21 04 80 	movabs $0x8004215e78,%rcx
  8004204575:	00 00 00 
  8004204578:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420457f:	00 00 00 
  8004204582:	be 70 03 00 00       	mov    $0x370,%esi
  8004204587:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420458e:	00 00 00 
  8004204591:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204596:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420459d:	00 00 00 
  80042045a0:	41 ff d0             	callq  *%r8
		// (new test for lab 4)
		assert(page2pa(pp) != MPENTRY_PADDR);
  80042045a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042045a7:	48 89 c7             	mov    %rax,%rdi
  80042045aa:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  80042045b1:	00 00 00 
  80042045b4:	ff d0                	callq  *%rax
  80042045b6:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  80042045bc:	75 35                	jne    80042045f3 <check_page_free_list+0x4b2>
  80042045be:	48 b9 bd 5e 21 04 80 	movabs $0x8004215ebd,%rcx
  80042045c5:	00 00 00 
  80042045c8:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042045cf:	00 00 00 
  80042045d2:	be 72 03 00 00       	mov    $0x372,%esi
  80042045d7:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042045de:	00 00 00 
  80042045e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045e6:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042045ed:	00 00 00 
  80042045f0:	41 ff d0             	callq  *%r8

		if (page2pa(pp) < EXTPHYSMEM)
  80042045f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042045f7:	48 89 c7             	mov    %rax,%rdi
  80042045fa:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  8004204601:	00 00 00 
  8004204604:	ff d0                	callq  *%rax
  8004204606:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  800420460c:	77 07                	ja     8004204615 <check_page_free_list+0x4d4>
			++nfree_basemem;
  800420460e:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004204613:	eb 05                	jmp    800420461a <check_page_free_list+0x4d9>
		else
			++nfree_extmem;
  8004204615:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link)
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = boot_alloc(0);
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  800420461a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420461e:	48 8b 00             	mov    (%rax),%rax
  8004204621:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204625:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420462a:	0f 85 d5 fc ff ff    	jne    8004204305 <check_page_free_list+0x1c4>
			++nfree_basemem;
		else
			++nfree_extmem;
	}

	assert(nfree_extmem > 0);
  8004204630:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204635:	75 35                	jne    800420466c <check_page_free_list+0x52b>
  8004204637:	48 b9 da 5e 21 04 80 	movabs $0x8004215eda,%rcx
  800420463e:	00 00 00 
  8004204641:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204648:	00 00 00 
  800420464b:	be 7a 03 00 00       	mov    $0x37a,%esi
  8004204650:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204657:	00 00 00 
  800420465a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420465f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204666:	00 00 00 
  8004204669:	41 ff d0             	callq  *%r8
}
  800420466c:	c9                   	leaveq 
  800420466d:	c3                   	retq   

000000800420466e <check_page_alloc>:
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
  800420466e:	55                   	push   %rbp
  800420466f:	48 89 e5             	mov    %rsp,%rbp
  8004204672:	48 83 ec 40          	sub    $0x40,%rsp
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204676:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  800420467d:	00 00 00 
  8004204680:	48 8b 00             	mov    (%rax),%rax
  8004204683:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204687:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  800420468e:	eb 37                	jmp    80042046c7 <check_page_alloc+0x59>
		memset(page2kva(pp0), 0x97, PGSIZE);
  8004204690:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204694:	48 89 c7             	mov    %rax,%rdi
  8004204697:	48 b8 37 23 20 04 80 	movabs $0x8004202337,%rax
  800420469e:	00 00 00 
  80042046a1:	ff d0                	callq  *%rax
  80042046a3:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042046a8:	be 97 00 00 00       	mov    $0x97,%esi
  80042046ad:	48 89 c7             	mov    %rax,%rdi
  80042046b0:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  80042046b7:	00 00 00 
  80042046ba:	ff d0                	callq  *%rax
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  80042046bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042046c0:	48 8b 00             	mov    (%rax),%rax
  80042046c3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042046c7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042046cc:	75 c2                	jne    8004204690 <check_page_alloc+0x22>
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  80042046ce:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  80042046d5:	00 00 00 
  80042046d8:	48 8b 00             	mov    (%rax),%rax
  80042046db:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042046df:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  80042046e6:	e9 ec 01 00 00       	jmpq   80042048d7 <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
		assert(pp0 >= pages);
  80042046eb:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  80042046f2:	00 00 00 
  80042046f5:	48 8b 00             	mov    (%rax),%rax
  80042046f8:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042046fc:	73 35                	jae    8004204733 <check_page_alloc+0xc5>
  80042046fe:	48 b9 eb 5e 21 04 80 	movabs $0x8004215eeb,%rcx
  8004204705:	00 00 00 
  8004204708:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420470f:	00 00 00 
  8004204712:	be 94 03 00 00       	mov    $0x394,%esi
  8004204717:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420471e:	00 00 00 
  8004204721:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204726:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420472d:	00 00 00 
  8004204730:	41 ff d0             	callq  *%r8
		assert(pp0 < pages + npages);
  8004204733:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  800420473a:	00 00 00 
  800420473d:	48 8b 10             	mov    (%rax),%rdx
  8004204740:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004204747:	00 00 00 
  800420474a:	48 8b 00             	mov    (%rax),%rax
  800420474d:	48 c1 e0 04          	shl    $0x4,%rax
  8004204751:	48 01 d0             	add    %rdx,%rax
  8004204754:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204758:	77 35                	ja     800420478f <check_page_alloc+0x121>
  800420475a:	48 b9 f8 5e 21 04 80 	movabs $0x8004215ef8,%rcx
  8004204761:	00 00 00 
  8004204764:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420476b:	00 00 00 
  800420476e:	be 95 03 00 00       	mov    $0x395,%esi
  8004204773:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420477a:	00 00 00 
  800420477d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204782:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204789:	00 00 00 
  800420478c:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp0) != 0);
  800420478f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204793:	48 89 c7             	mov    %rax,%rdi
  8004204796:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  800420479d:	00 00 00 
  80042047a0:	ff d0                	callq  *%rax
  80042047a2:	48 85 c0             	test   %rax,%rax
  80042047a5:	75 35                	jne    80042047dc <check_page_alloc+0x16e>
  80042047a7:	48 b9 0d 5f 21 04 80 	movabs $0x8004215f0d,%rcx
  80042047ae:	00 00 00 
  80042047b1:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042047b8:	00 00 00 
  80042047bb:	be 98 03 00 00       	mov    $0x398,%esi
  80042047c0:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042047c7:	00 00 00 
  80042047ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80042047cf:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042047d6:	00 00 00 
  80042047d9:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != IOPHYSMEM);
  80042047dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042047e0:	48 89 c7             	mov    %rax,%rdi
  80042047e3:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  80042047ea:	00 00 00 
  80042047ed:	ff d0                	callq  *%rax
  80042047ef:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  80042047f5:	75 35                	jne    800420482c <check_page_alloc+0x1be>
  80042047f7:	48 b9 1f 5f 21 04 80 	movabs $0x8004215f1f,%rcx
  80042047fe:	00 00 00 
  8004204801:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204808:	00 00 00 
  800420480b:	be 99 03 00 00       	mov    $0x399,%esi
  8004204810:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204817:	00 00 00 
  800420481a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420481f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204826:	00 00 00 
  8004204829:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  800420482c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204830:	48 89 c7             	mov    %rax,%rdi
  8004204833:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  800420483a:	00 00 00 
  800420483d:	ff d0                	callq  *%rax
  800420483f:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004204845:	75 35                	jne    800420487c <check_page_alloc+0x20e>
  8004204847:	48 b9 40 5f 21 04 80 	movabs $0x8004215f40,%rcx
  800420484e:	00 00 00 
  8004204851:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204858:	00 00 00 
  800420485b:	be 9a 03 00 00       	mov    $0x39a,%esi
  8004204860:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204867:	00 00 00 
  800420486a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420486f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204876:	00 00 00 
  8004204879:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM);
  800420487c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204880:	48 89 c7             	mov    %rax,%rdi
  8004204883:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  800420488a:	00 00 00 
  800420488d:	ff d0                	callq  *%rax
  800420488f:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004204895:	75 35                	jne    80042048cc <check_page_alloc+0x25e>
  8004204897:	48 b9 64 5f 21 04 80 	movabs $0x8004215f64,%rcx
  800420489e:	00 00 00 
  80042048a1:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042048a8:	00 00 00 
  80042048ab:	be 9b 03 00 00       	mov    $0x39b,%esi
  80042048b0:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042048b7:	00 00 00 
  80042048ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80042048bf:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042048c6:	00 00 00 
  80042048c9:	41 ff d0             	callq  *%r8
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  80042048cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042048d0:	48 8b 00             	mov    (%rax),%rax
  80042048d3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042048d7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042048dc:	0f 85 09 fe ff ff    	jne    80042046eb <check_page_alloc+0x7d>
		assert(page2pa(pp0) != IOPHYSMEM);
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
		assert(page2pa(pp0) != EXTPHYSMEM);
	}
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
  80042048e2:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042048e9:	00 
  80042048ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042048ee:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042048f2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042048f6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  80042048fa:	bf 00 00 00 00       	mov    $0x0,%edi
  80042048ff:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  8004204906:	00 00 00 
  8004204909:	ff d0                	callq  *%rax
  800420490b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420490f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204914:	75 35                	jne    800420494b <check_page_alloc+0x2dd>
  8004204916:	48 b9 7f 5f 21 04 80 	movabs $0x8004215f7f,%rcx
  800420491d:	00 00 00 
  8004204920:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204927:	00 00 00 
  800420492a:	be 9f 03 00 00       	mov    $0x39f,%esi
  800420492f:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204936:	00 00 00 
  8004204939:	b8 00 00 00 00       	mov    $0x0,%eax
  800420493e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204945:	00 00 00 
  8004204948:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  800420494b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204950:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  8004204957:	00 00 00 
  800420495a:	ff d0                	callq  *%rax
  800420495c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204960:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204965:	75 35                	jne    800420499c <check_page_alloc+0x32e>
  8004204967:	48 b9 95 5f 21 04 80 	movabs $0x8004215f95,%rcx
  800420496e:	00 00 00 
  8004204971:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204978:	00 00 00 
  800420497b:	be a0 03 00 00       	mov    $0x3a0,%esi
  8004204980:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204987:	00 00 00 
  800420498a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420498f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204996:	00 00 00 
  8004204999:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  800420499c:	bf 00 00 00 00       	mov    $0x0,%edi
  80042049a1:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  80042049a8:	00 00 00 
  80042049ab:	ff d0                	callq  *%rax
  80042049ad:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042049b1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042049b6:	75 35                	jne    80042049ed <check_page_alloc+0x37f>
  80042049b8:	48 b9 ab 5f 21 04 80 	movabs $0x8004215fab,%rcx
  80042049bf:	00 00 00 
  80042049c2:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042049c9:	00 00 00 
  80042049cc:	be a1 03 00 00       	mov    $0x3a1,%esi
  80042049d1:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042049d8:	00 00 00 
  80042049db:	b8 00 00 00 00       	mov    $0x0,%eax
  80042049e0:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042049e7:	00 00 00 
  80042049ea:	41 ff d0             	callq  *%r8
	assert(pp0);
  80042049ed:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042049f2:	75 35                	jne    8004204a29 <check_page_alloc+0x3bb>
  80042049f4:	48 b9 c1 5f 21 04 80 	movabs $0x8004215fc1,%rcx
  80042049fb:	00 00 00 
  80042049fe:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204a05:	00 00 00 
  8004204a08:	be a2 03 00 00       	mov    $0x3a2,%esi
  8004204a0d:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204a14:	00 00 00 
  8004204a17:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a1c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204a23:	00 00 00 
  8004204a26:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204a29:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204a2e:	74 0a                	je     8004204a3a <check_page_alloc+0x3cc>
  8004204a30:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204a34:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204a38:	75 35                	jne    8004204a6f <check_page_alloc+0x401>
  8004204a3a:	48 b9 c5 5f 21 04 80 	movabs $0x8004215fc5,%rcx
  8004204a41:	00 00 00 
  8004204a44:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204a4b:	00 00 00 
  8004204a4e:	be a3 03 00 00       	mov    $0x3a3,%esi
  8004204a53:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204a5a:	00 00 00 
  8004204a5d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a62:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204a69:	00 00 00 
  8004204a6c:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204a6f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204a74:	74 14                	je     8004204a8a <check_page_alloc+0x41c>
  8004204a76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204a7a:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204a7e:	74 0a                	je     8004204a8a <check_page_alloc+0x41c>
  8004204a80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204a84:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204a88:	75 35                	jne    8004204abf <check_page_alloc+0x451>
  8004204a8a:	48 b9 d8 5f 21 04 80 	movabs $0x8004215fd8,%rcx
  8004204a91:	00 00 00 
  8004204a94:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204a9b:	00 00 00 
  8004204a9e:	be a4 03 00 00       	mov    $0x3a4,%esi
  8004204aa3:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204aaa:	00 00 00 
  8004204aad:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ab2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204ab9:	00 00 00 
  8004204abc:	41 ff d0             	callq  *%r8
	assert(page2pa(pp0) < npages*PGSIZE);
  8004204abf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204ac3:	48 89 c7             	mov    %rax,%rdi
  8004204ac6:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  8004204acd:	00 00 00 
  8004204ad0:	ff d0                	callq  *%rax
  8004204ad2:	48 ba 30 e7 49 04 80 	movabs $0x800449e730,%rdx
  8004204ad9:	00 00 00 
  8004204adc:	48 8b 12             	mov    (%rdx),%rdx
  8004204adf:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204ae3:	48 39 d0             	cmp    %rdx,%rax
  8004204ae6:	72 35                	jb     8004204b1d <check_page_alloc+0x4af>
  8004204ae8:	48 b9 f8 5f 21 04 80 	movabs $0x8004215ff8,%rcx
  8004204aef:	00 00 00 
  8004204af2:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204af9:	00 00 00 
  8004204afc:	be a5 03 00 00       	mov    $0x3a5,%esi
  8004204b01:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204b08:	00 00 00 
  8004204b0b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b10:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204b17:	00 00 00 
  8004204b1a:	41 ff d0             	callq  *%r8
	assert(page2pa(pp1) < npages*PGSIZE);
  8004204b1d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204b21:	48 89 c7             	mov    %rax,%rdi
  8004204b24:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  8004204b2b:	00 00 00 
  8004204b2e:	ff d0                	callq  *%rax
  8004204b30:	48 ba 30 e7 49 04 80 	movabs $0x800449e730,%rdx
  8004204b37:	00 00 00 
  8004204b3a:	48 8b 12             	mov    (%rdx),%rdx
  8004204b3d:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204b41:	48 39 d0             	cmp    %rdx,%rax
  8004204b44:	72 35                	jb     8004204b7b <check_page_alloc+0x50d>
  8004204b46:	48 b9 15 60 21 04 80 	movabs $0x8004216015,%rcx
  8004204b4d:	00 00 00 
  8004204b50:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204b57:	00 00 00 
  8004204b5a:	be a6 03 00 00       	mov    $0x3a6,%esi
  8004204b5f:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204b66:	00 00 00 
  8004204b69:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b6e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204b75:	00 00 00 
  8004204b78:	41 ff d0             	callq  *%r8
	assert(page2pa(pp2) < npages*PGSIZE);
  8004204b7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204b7f:	48 89 c7             	mov    %rax,%rdi
  8004204b82:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  8004204b89:	00 00 00 
  8004204b8c:	ff d0                	callq  *%rax
  8004204b8e:	48 ba 30 e7 49 04 80 	movabs $0x800449e730,%rdx
  8004204b95:	00 00 00 
  8004204b98:	48 8b 12             	mov    (%rdx),%rdx
  8004204b9b:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204b9f:	48 39 d0             	cmp    %rdx,%rax
  8004204ba2:	72 35                	jb     8004204bd9 <check_page_alloc+0x56b>
  8004204ba4:	48 b9 32 60 21 04 80 	movabs $0x8004216032,%rcx
  8004204bab:	00 00 00 
  8004204bae:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204bb5:	00 00 00 
  8004204bb8:	be a7 03 00 00       	mov    $0x3a7,%esi
  8004204bbd:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204bc4:	00 00 00 
  8004204bc7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204bcc:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204bd3:	00 00 00 
  8004204bd6:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004204bd9:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004204be0:	00 00 00 
  8004204be3:	48 8b 00             	mov    (%rax),%rax
  8004204be6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	page_free_list = 0;
  8004204bea:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004204bf1:	00 00 00 
  8004204bf4:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004204bfb:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204c00:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  8004204c07:	00 00 00 
  8004204c0a:	ff d0                	callq  *%rax
  8004204c0c:	48 85 c0             	test   %rax,%rax
  8004204c0f:	74 35                	je     8004204c46 <check_page_alloc+0x5d8>
  8004204c11:	48 b9 4f 60 21 04 80 	movabs $0x800421604f,%rcx
  8004204c18:	00 00 00 
  8004204c1b:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204c22:	00 00 00 
  8004204c25:	be ae 03 00 00       	mov    $0x3ae,%esi
  8004204c2a:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204c31:	00 00 00 
  8004204c34:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c39:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204c40:	00 00 00 
  8004204c43:	41 ff d0             	callq  *%r8

	// free and re-allocate?
	page_free(pp0);
  8004204c46:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204c4a:	48 89 c7             	mov    %rax,%rdi
  8004204c4d:	48 b8 af 35 20 04 80 	movabs $0x80042035af,%rax
  8004204c54:	00 00 00 
  8004204c57:	ff d0                	callq  *%rax
	page_free(pp1);
  8004204c59:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204c5d:	48 89 c7             	mov    %rax,%rdi
  8004204c60:	48 b8 af 35 20 04 80 	movabs $0x80042035af,%rax
  8004204c67:	00 00 00 
  8004204c6a:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204c6c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204c70:	48 89 c7             	mov    %rax,%rdi
  8004204c73:	48 b8 af 35 20 04 80 	movabs $0x80042035af,%rax
  8004204c7a:	00 00 00 
  8004204c7d:	ff d0                	callq  *%rax
	pp0 = pp1 = pp2 = 0;
  8004204c7f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204c86:	00 
  8004204c87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204c8b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204c8f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204c93:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204c97:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204c9c:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  8004204ca3:	00 00 00 
  8004204ca6:	ff d0                	callq  *%rax
  8004204ca8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204cac:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204cb1:	75 35                	jne    8004204ce8 <check_page_alloc+0x67a>
  8004204cb3:	48 b9 7f 5f 21 04 80 	movabs $0x8004215f7f,%rcx
  8004204cba:	00 00 00 
  8004204cbd:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204cc4:	00 00 00 
  8004204cc7:	be b5 03 00 00       	mov    $0x3b5,%esi
  8004204ccc:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204cd3:	00 00 00 
  8004204cd6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204cdb:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204ce2:	00 00 00 
  8004204ce5:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004204ce8:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204ced:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  8004204cf4:	00 00 00 
  8004204cf7:	ff d0                	callq  *%rax
  8004204cf9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204cfd:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204d02:	75 35                	jne    8004204d39 <check_page_alloc+0x6cb>
  8004204d04:	48 b9 95 5f 21 04 80 	movabs $0x8004215f95,%rcx
  8004204d0b:	00 00 00 
  8004204d0e:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204d15:	00 00 00 
  8004204d18:	be b6 03 00 00       	mov    $0x3b6,%esi
  8004204d1d:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204d24:	00 00 00 
  8004204d27:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d2c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204d33:	00 00 00 
  8004204d36:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004204d39:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204d3e:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  8004204d45:	00 00 00 
  8004204d48:	ff d0                	callq  *%rax
  8004204d4a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204d4e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204d53:	75 35                	jne    8004204d8a <check_page_alloc+0x71c>
  8004204d55:	48 b9 ab 5f 21 04 80 	movabs $0x8004215fab,%rcx
  8004204d5c:	00 00 00 
  8004204d5f:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204d66:	00 00 00 
  8004204d69:	be b7 03 00 00       	mov    $0x3b7,%esi
  8004204d6e:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204d75:	00 00 00 
  8004204d78:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d7d:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204d84:	00 00 00 
  8004204d87:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204d8a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204d8f:	75 35                	jne    8004204dc6 <check_page_alloc+0x758>
  8004204d91:	48 b9 c1 5f 21 04 80 	movabs $0x8004215fc1,%rcx
  8004204d98:	00 00 00 
  8004204d9b:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204da2:	00 00 00 
  8004204da5:	be b8 03 00 00       	mov    $0x3b8,%esi
  8004204daa:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204db1:	00 00 00 
  8004204db4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204db9:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204dc0:	00 00 00 
  8004204dc3:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204dc6:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204dcb:	74 0a                	je     8004204dd7 <check_page_alloc+0x769>
  8004204dcd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204dd1:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204dd5:	75 35                	jne    8004204e0c <check_page_alloc+0x79e>
  8004204dd7:	48 b9 c5 5f 21 04 80 	movabs $0x8004215fc5,%rcx
  8004204dde:	00 00 00 
  8004204de1:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204de8:	00 00 00 
  8004204deb:	be b9 03 00 00       	mov    $0x3b9,%esi
  8004204df0:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204df7:	00 00 00 
  8004204dfa:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204dff:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204e06:	00 00 00 
  8004204e09:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204e0c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204e11:	74 14                	je     8004204e27 <check_page_alloc+0x7b9>
  8004204e13:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204e17:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204e1b:	74 0a                	je     8004204e27 <check_page_alloc+0x7b9>
  8004204e1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204e21:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204e25:	75 35                	jne    8004204e5c <check_page_alloc+0x7ee>
  8004204e27:	48 b9 d8 5f 21 04 80 	movabs $0x8004215fd8,%rcx
  8004204e2e:	00 00 00 
  8004204e31:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204e38:	00 00 00 
  8004204e3b:	be ba 03 00 00       	mov    $0x3ba,%esi
  8004204e40:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204e47:	00 00 00 
  8004204e4a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e4f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204e56:	00 00 00 
  8004204e59:	41 ff d0             	callq  *%r8
	assert(!page_alloc(0));
  8004204e5c:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204e61:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  8004204e68:	00 00 00 
  8004204e6b:	ff d0                	callq  *%rax
  8004204e6d:	48 85 c0             	test   %rax,%rax
  8004204e70:	74 35                	je     8004204ea7 <check_page_alloc+0x839>
  8004204e72:	48 b9 4f 60 21 04 80 	movabs $0x800421604f,%rcx
  8004204e79:	00 00 00 
  8004204e7c:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204e83:	00 00 00 
  8004204e86:	be bb 03 00 00       	mov    $0x3bb,%esi
  8004204e8b:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204e92:	00 00 00 
  8004204e95:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e9a:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204ea1:	00 00 00 
  8004204ea4:	41 ff d0             	callq  *%r8

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
  8004204ea7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204eab:	48 89 c7             	mov    %rax,%rdi
  8004204eae:	48 b8 37 23 20 04 80 	movabs $0x8004202337,%rax
  8004204eb5:	00 00 00 
  8004204eb8:	ff d0                	callq  *%rax
  8004204eba:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204ebf:	be 01 00 00 00       	mov    $0x1,%esi
  8004204ec4:	48 89 c7             	mov    %rax,%rdi
  8004204ec7:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  8004204ece:	00 00 00 
  8004204ed1:	ff d0                	callq  *%rax
	page_free(pp0);
  8004204ed3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204ed7:	48 89 c7             	mov    %rax,%rdi
  8004204eda:	48 b8 af 35 20 04 80 	movabs $0x80042035af,%rax
  8004204ee1:	00 00 00 
  8004204ee4:	ff d0                	callq  *%rax
	assert((pp = page_alloc(ALLOC_ZERO)));
  8004204ee6:	bf 01 00 00 00       	mov    $0x1,%edi
  8004204eeb:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  8004204ef2:	00 00 00 
  8004204ef5:	ff d0                	callq  *%rax
  8004204ef7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004204efb:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004204f00:	75 35                	jne    8004204f37 <check_page_alloc+0x8c9>
  8004204f02:	48 b9 5e 60 21 04 80 	movabs $0x800421605e,%rcx
  8004204f09:	00 00 00 
  8004204f0c:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204f13:	00 00 00 
  8004204f16:	be c0 03 00 00       	mov    $0x3c0,%esi
  8004204f1b:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204f22:	00 00 00 
  8004204f25:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f2a:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204f31:	00 00 00 
  8004204f34:	41 ff d0             	callq  *%r8
	assert(pp && pp0 == pp);
  8004204f37:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004204f3c:	74 0a                	je     8004204f48 <check_page_alloc+0x8da>
  8004204f3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204f42:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004204f46:	74 35                	je     8004204f7d <check_page_alloc+0x90f>
  8004204f48:	48 b9 7c 60 21 04 80 	movabs $0x800421607c,%rcx
  8004204f4f:	00 00 00 
  8004204f52:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204f59:	00 00 00 
  8004204f5c:	be c1 03 00 00       	mov    $0x3c1,%esi
  8004204f61:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204f68:	00 00 00 
  8004204f6b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f70:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204f77:	00 00 00 
  8004204f7a:	41 ff d0             	callq  *%r8
	c = page2kva(pp);
  8004204f7d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204f81:	48 89 c7             	mov    %rax,%rdi
  8004204f84:	48 b8 37 23 20 04 80 	movabs $0x8004202337,%rax
  8004204f8b:	00 00 00 
  8004204f8e:	ff d0                	callq  *%rax
  8004204f90:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < PGSIZE; i++)
  8004204f94:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004204f9b:	eb 4d                	jmp    8004204fea <check_page_alloc+0x97c>
		assert(c[i] == 0);
  8004204f9d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004204fa0:	48 63 d0             	movslq %eax,%rdx
  8004204fa3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204fa7:	48 01 d0             	add    %rdx,%rax
  8004204faa:	0f b6 00             	movzbl (%rax),%eax
  8004204fad:	84 c0                	test   %al,%al
  8004204faf:	74 35                	je     8004204fe6 <check_page_alloc+0x978>
  8004204fb1:	48 b9 8c 60 21 04 80 	movabs $0x800421608c,%rcx
  8004204fb8:	00 00 00 
  8004204fbb:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004204fc2:	00 00 00 
  8004204fc5:	be c4 03 00 00       	mov    $0x3c4,%esi
  8004204fca:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004204fd1:	00 00 00 
  8004204fd4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204fd9:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004204fe0:	00 00 00 
  8004204fe3:	41 ff d0             	callq  *%r8
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
  8004204fe6:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004204fea:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  8004204ff1:	7e aa                	jle    8004204f9d <check_page_alloc+0x92f>
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;
  8004204ff3:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004204ffa:	00 00 00 
  8004204ffd:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004205001:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_free(pp0);
  8004205004:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205008:	48 89 c7             	mov    %rax,%rdi
  800420500b:	48 b8 af 35 20 04 80 	movabs $0x80042035af,%rax
  8004205012:	00 00 00 
  8004205015:	ff d0                	callq  *%rax
	page_free(pp1);
  8004205017:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420501b:	48 89 c7             	mov    %rax,%rdi
  800420501e:	48 b8 af 35 20 04 80 	movabs $0x80042035af,%rax
  8004205025:	00 00 00 
  8004205028:	ff d0                	callq  *%rax
	page_free(pp2);
  800420502a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420502e:	48 89 c7             	mov    %rax,%rdi
  8004205031:	48 b8 af 35 20 04 80 	movabs $0x80042035af,%rax
  8004205038:	00 00 00 
  800420503b:	ff d0                	callq  *%rax

	cprintf("check_page_alloc() succeeded!\n");
  800420503d:	48 bf 98 60 21 04 80 	movabs $0x8004216098,%rdi
  8004205044:	00 00 00 
  8004205047:	b8 00 00 00 00       	mov    $0x0,%eax
  800420504c:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004205053:	00 00 00 
  8004205056:	ff d2                	callq  *%rdx
}
  8004205058:	c9                   	leaveq 
  8004205059:	c3                   	retq   

000000800420505a <check_boot_pml4e>:
// but it is a pretty good sanity check.
//

static void
check_boot_pml4e(pml4e_t *pml4e)
{
  800420505a:	55                   	push   %rbp
  800420505b:	48 89 e5             	mov    %rsp,%rbp
  800420505e:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004205065:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
	uint64_t i, n;

	pml4e = boot_pml4e;
  800420506c:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004205073:	00 00 00 
  8004205076:	48 8b 00             	mov    (%rax),%rax
  8004205079:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  800420507d:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8004205084:	00 
  8004205085:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  800420508c:	00 00 00 
  800420508f:	48 8b 00             	mov    (%rax),%rax
  8004205092:	48 c1 e0 04          	shl    $0x4,%rax
  8004205096:	48 89 c2             	mov    %rax,%rdx
  8004205099:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420509d:	48 01 d0             	add    %rdx,%rax
  80042050a0:	48 83 e8 01          	sub    $0x1,%rax
  80042050a4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042050a8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042050ac:	ba 00 00 00 00       	mov    $0x0,%edx
  80042050b1:	48 f7 75 e0          	divq   -0x20(%rbp)
  80042050b5:	48 89 d0             	mov    %rdx,%rax
  80042050b8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042050bc:	48 29 c2             	sub    %rax,%rdx
  80042050bf:	48 89 d0             	mov    %rdx,%rax
  80042050c2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE) {
  80042050c6:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042050cd:	00 
  80042050ce:	e9 d4 00 00 00       	jmpq   80042051a7 <check_boot_pml4e+0x14d>
		// cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  80042050d3:	48 ba 00 00 a0 00 80 	movabs $0x8000a00000,%rdx
  80042050da:	00 00 00 
  80042050dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042050e1:	48 01 c2             	add    %rax,%rdx
  80042050e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042050e8:	48 89 d6             	mov    %rdx,%rsi
  80042050eb:	48 89 c7             	mov    %rax,%rdi
  80042050ee:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  80042050f5:	00 00 00 
  80042050f8:	ff d0                	callq  *%rax
  80042050fa:	48 ba 38 e7 49 04 80 	movabs $0x800449e738,%rdx
  8004205101:	00 00 00 
  8004205104:	48 8b 12             	mov    (%rdx),%rdx
  8004205107:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420510b:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004205112:	00 00 00 
  8004205115:	48 39 55 d0          	cmp    %rdx,-0x30(%rbp)
  8004205119:	77 32                	ja     800420514d <check_boot_pml4e+0xf3>
  800420511b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420511f:	48 89 c1             	mov    %rax,%rcx
  8004205122:	48 ba d8 5c 21 04 80 	movabs $0x8004215cd8,%rdx
  8004205129:	00 00 00 
  800420512c:	be e4 03 00 00       	mov    $0x3e4,%esi
  8004205131:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205138:	00 00 00 
  800420513b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205140:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205147:	00 00 00 
  800420514a:	41 ff d0             	callq  *%r8
  800420514d:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004205154:	ff ff ff 
  8004205157:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420515b:	48 01 d1             	add    %rdx,%rcx
  800420515e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004205162:	48 01 ca             	add    %rcx,%rdx
  8004205165:	48 39 d0             	cmp    %rdx,%rax
  8004205168:	74 35                	je     800420519f <check_boot_pml4e+0x145>
  800420516a:	48 b9 b8 60 21 04 80 	movabs $0x80042160b8,%rcx
  8004205171:	00 00 00 
  8004205174:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420517b:	00 00 00 
  800420517e:	be e4 03 00 00       	mov    $0x3e4,%esi
  8004205183:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420518a:	00 00 00 
  800420518d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205192:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205199:	00 00 00 
  800420519c:	41 ff d0             	callq  *%r8

	pml4e = boot_pml4e;

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
	for (i = 0; i < n; i += PGSIZE) {
  800420519f:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042051a6:	00 
  80042051a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042051ab:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80042051af:	0f 82 1e ff ff ff    	jb     80042050d3 <check_boot_pml4e+0x79>
		// cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  80042051b5:	48 c7 45 c8 00 10 00 	movq   $0x1000,-0x38(%rbp)
  80042051bc:	00 
  80042051bd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042051c1:	48 05 ff 7f 04 00    	add    $0x47fff,%rax
  80042051c7:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042051cb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042051cf:	ba 00 00 00 00       	mov    $0x0,%edx
  80042051d4:	48 f7 75 c8          	divq   -0x38(%rbp)
  80042051d8:	48 89 d0             	mov    %rdx,%rax
  80042051db:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042051df:	48 29 c2             	sub    %rax,%rdx
  80042051e2:	48 89 d0             	mov    %rdx,%rax
  80042051e5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE)
  80042051e9:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042051f0:	00 
  80042051f1:	e9 d4 00 00 00       	jmpq   80042052ca <check_boot_pml4e+0x270>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  80042051f6:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  80042051fd:	00 00 00 
  8004205200:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205204:	48 01 c2             	add    %rax,%rdx
  8004205207:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420520b:	48 89 d6             	mov    %rdx,%rsi
  800420520e:	48 89 c7             	mov    %rax,%rdi
  8004205211:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  8004205218:	00 00 00 
  800420521b:	ff d0                	callq  *%rax
  800420521d:	48 ba 50 d2 49 04 80 	movabs $0x800449d250,%rdx
  8004205224:	00 00 00 
  8004205227:	48 8b 12             	mov    (%rdx),%rdx
  800420522a:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420522e:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004205235:	00 00 00 
  8004205238:	48 39 55 b8          	cmp    %rdx,-0x48(%rbp)
  800420523c:	77 32                	ja     8004205270 <check_boot_pml4e+0x216>
  800420523e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205242:	48 89 c1             	mov    %rax,%rcx
  8004205245:	48 ba d8 5c 21 04 80 	movabs $0x8004215cd8,%rdx
  800420524c:	00 00 00 
  800420524f:	be ea 03 00 00       	mov    $0x3ea,%esi
  8004205254:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420525b:	00 00 00 
  800420525e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205263:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420526a:	00 00 00 
  800420526d:	41 ff d0             	callq  *%r8
  8004205270:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004205277:	ff ff ff 
  800420527a:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420527e:	48 01 d1             	add    %rdx,%rcx
  8004205281:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004205285:	48 01 ca             	add    %rcx,%rdx
  8004205288:	48 39 d0             	cmp    %rdx,%rax
  800420528b:	74 35                	je     80042052c2 <check_boot_pml4e+0x268>
  800420528d:	48 b9 f0 60 21 04 80 	movabs $0x80042160f0,%rcx
  8004205294:	00 00 00 
  8004205297:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420529e:	00 00 00 
  80042052a1:	be ea 03 00 00       	mov    $0x3ea,%esi
  80042052a6:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042052ad:	00 00 00 
  80042052b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042052b5:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042052bc:	00 00 00 
  80042052bf:	41 ff d0             	callq  *%r8
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
  80042052c2:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042052c9:	00 
  80042052ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042052ce:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80042052d2:	0f 82 1e ff ff ff    	jb     80042051f6 <check_boot_pml4e+0x19c>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  80042052d8:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042052df:	00 
  80042052e0:	eb 6a                	jmp    800420534c <check_boot_pml4e+0x2f2>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);
  80042052e2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042052e9:	00 00 00 
  80042052ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042052f0:	48 01 c2             	add    %rax,%rdx
  80042052f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042052f7:	48 89 d6             	mov    %rdx,%rsi
  80042052fa:	48 89 c7             	mov    %rax,%rdi
  80042052fd:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  8004205304:	00 00 00 
  8004205307:	ff d0                	callq  *%rax
  8004205309:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420530d:	74 35                	je     8004205344 <check_boot_pml4e+0x2ea>
  800420530f:	48 b9 28 61 21 04 80 	movabs $0x8004216128,%rcx
  8004205316:	00 00 00 
  8004205319:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205320:	00 00 00 
  8004205323:	be ee 03 00 00       	mov    $0x3ee,%esi
  8004205328:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420532f:	00 00 00 
  8004205332:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205337:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420533e:	00 00 00 
  8004205341:	41 ff d0             	callq  *%r8
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004205344:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  800420534b:	00 
  800420534c:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004205353:	00 00 00 
  8004205356:	48 8b 00             	mov    (%rax),%rax
  8004205359:	48 c1 e0 0c          	shl    $0xc,%rax
  800420535d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004205361:	0f 87 7b ff ff ff    	ja     80042052e2 <check_boot_pml4e+0x288>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004205367:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420536e:	00 
  800420536f:	e9 a1 01 00 00       	jmpq   8004205515 <check_boot_pml4e+0x4bb>
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
  8004205374:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004205378:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420537c:	48 89 d0             	mov    %rdx,%rax
  800420537f:	48 01 c0             	add    %rax,%rax
  8004205382:	48 01 d0             	add    %rdx,%rax
  8004205385:	48 c1 e0 0f          	shl    $0xf,%rax
  8004205389:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205390:	00 00 00 
  8004205393:	48 29 c2             	sub    %rax,%rdx
  8004205396:	48 89 d0             	mov    %rdx,%rax
  8004205399:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  800420539d:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042053a4:	00 
  80042053a5:	e9 e0 00 00 00       	jmpq   800420548a <check_boot_pml4e+0x430>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
  80042053aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042053ae:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042053b2:	48 01 d0             	add    %rdx,%rax
  80042053b5:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  80042053bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042053c0:	48 89 d6             	mov    %rdx,%rsi
  80042053c3:	48 89 c7             	mov    %rax,%rdi
  80042053c6:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  80042053cd:	00 00 00 
  80042053d0:	ff d0                	callq  *%rax
  80042053d2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042053d6:	48 89 d1             	mov    %rdx,%rcx
  80042053d9:	48 c1 e1 10          	shl    $0x10,%rcx
  80042053dd:	48 ba 00 10 4a 04 80 	movabs $0x80044a1000,%rdx
  80042053e4:	00 00 00 
  80042053e7:	48 01 ca             	add    %rcx,%rdx
  80042053ea:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  80042053ee:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  80042053f5:	00 00 00 
  80042053f8:	48 39 55 a8          	cmp    %rdx,-0x58(%rbp)
  80042053fc:	77 32                	ja     8004205430 <check_boot_pml4e+0x3d6>
  80042053fe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205402:	48 89 c1             	mov    %rax,%rcx
  8004205405:	48 ba d8 5c 21 04 80 	movabs $0x8004215cd8,%rdx
  800420540c:	00 00 00 
  800420540f:	be f6 03 00 00       	mov    $0x3f6,%esi
  8004205414:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420541b:	00 00 00 
  800420541e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205423:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420542a:	00 00 00 
  800420542d:	41 ff d0             	callq  *%r8
  8004205430:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004205437:	ff ff ff 
  800420543a:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420543e:	48 01 d1             	add    %rdx,%rcx
  8004205441:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004205445:	48 01 ca             	add    %rcx,%rdx
  8004205448:	48 39 d0             	cmp    %rdx,%rax
  800420544b:	74 35                	je     8004205482 <check_boot_pml4e+0x428>
  800420544d:	48 b9 50 61 21 04 80 	movabs $0x8004216150,%rcx
  8004205454:	00 00 00 
  8004205457:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420545e:	00 00 00 
  8004205461:	be f6 03 00 00       	mov    $0x3f6,%esi
  8004205466:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420546d:	00 00 00 
  8004205470:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205475:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420547c:	00 00 00 
  800420547f:	41 ff d0             	callq  *%r8

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004205482:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205489:	00 
  800420548a:	48 81 7d f8 ff ff 00 	cmpq   $0xffff,-0x8(%rbp)
  8004205491:	00 
  8004205492:	0f 86 12 ff ff ff    	jbe    80042053aa <check_boot_pml4e+0x350>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004205498:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420549f:	00 
  80042054a0:	eb 64                	jmp    8004205506 <check_boot_pml4e+0x4ac>
			assert(check_va2pa(pml4e, base + i) == ~0);
  80042054a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042054a6:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042054aa:	48 01 c2             	add    %rax,%rdx
  80042054ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042054b1:	48 89 d6             	mov    %rdx,%rsi
  80042054b4:	48 89 c7             	mov    %rax,%rdi
  80042054b7:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  80042054be:	00 00 00 
  80042054c1:	ff d0                	callq  *%rax
  80042054c3:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  80042054c7:	74 35                	je     80042054fe <check_boot_pml4e+0x4a4>
  80042054c9:	48 b9 98 61 21 04 80 	movabs $0x8004216198,%rcx
  80042054d0:	00 00 00 
  80042054d3:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042054da:	00 00 00 
  80042054dd:	be f8 03 00 00       	mov    $0x3f8,%esi
  80042054e2:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042054e9:	00 00 00 
  80042054ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054f1:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042054f8:	00 00 00 
  80042054fb:	41 ff d0             	callq  *%r8
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  80042054fe:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205505:	00 
  8004205506:	48 81 7d f8 ff 7f 00 	cmpq   $0x7fff,-0x8(%rbp)
  800420550d:	00 
  800420550e:	76 92                	jbe    80042054a2 <check_boot_pml4e+0x448>
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004205510:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004205515:	48 83 7d f0 07       	cmpq   $0x7,-0x10(%rbp)
  800420551a:	0f 86 54 fe ff ff    	jbe    8004205374 <check_boot_pml4e+0x31a>
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
			assert(check_va2pa(pml4e, base + i) == ~0);
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  8004205520:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004205527:	00 00 00 
  800420552a:	48 8b 00             	mov    (%rax),%rax
  800420552d:	48 83 c0 08          	add    $0x8,%rax
  8004205531:	48 8b 00             	mov    (%rax),%rax
  8004205534:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420553a:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  800420553e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205542:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205546:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004205549:	8b 55 9c             	mov    -0x64(%rbp),%edx
  800420554c:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004205553:	00 00 00 
  8004205556:	48 8b 00             	mov    (%rax),%rax
  8004205559:	48 39 c2             	cmp    %rax,%rdx
  800420555c:	72 32                	jb     8004205590 <check_boot_pml4e+0x536>
  800420555e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205562:	48 89 c1             	mov    %rax,%rcx
  8004205565:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  800420556c:	00 00 00 
  800420556f:	be fb 03 00 00       	mov    $0x3fb,%esi
  8004205574:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420557b:	00 00 00 
  800420557e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205583:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420558a:	00 00 00 
  800420558d:	41 ff d0             	callq  *%r8
  8004205590:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205597:	00 00 00 
  800420559a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420559e:	48 01 d0             	add    %rdx,%rax
  80042055a1:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  80042055a5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042055a9:	48 8b 00             	mov    (%rax),%rax
  80042055ac:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042055b2:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  80042055b6:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042055ba:	48 c1 e8 0c          	shr    $0xc,%rax
  80042055be:	89 45 84             	mov    %eax,-0x7c(%rbp)
  80042055c1:	8b 55 84             	mov    -0x7c(%rbp),%edx
  80042055c4:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  80042055cb:	00 00 00 
  80042055ce:	48 8b 00             	mov    (%rax),%rax
  80042055d1:	48 39 c2             	cmp    %rax,%rdx
  80042055d4:	72 32                	jb     8004205608 <check_boot_pml4e+0x5ae>
  80042055d6:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042055da:	48 89 c1             	mov    %rax,%rcx
  80042055dd:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  80042055e4:	00 00 00 
  80042055e7:	be fc 03 00 00       	mov    $0x3fc,%esi
  80042055ec:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042055f3:	00 00 00 
  80042055f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042055fb:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205602:	00 00 00 
  8004205605:	41 ff d0             	callq  *%r8
  8004205608:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420560f:	00 00 00 
  8004205612:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004205616:	48 01 d0             	add    %rdx,%rax
  8004205619:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004205620:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205627:	00 
  8004205628:	e9 50 01 00 00       	jmpq   800420577d <check_boot_pml4e+0x723>
		switch (i) {
  800420562d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205631:	48 83 f8 04          	cmp    $0x4,%rax
  8004205635:	72 67                	jb     800420569e <check_boot_pml4e+0x644>
  8004205637:	48 83 f8 05          	cmp    $0x5,%rax
  800420563b:	76 06                	jbe    8004205643 <check_boot_pml4e+0x5e9>
  800420563d:	48 83 f8 1f          	cmp    $0x1f,%rax
  8004205641:	75 5b                	jne    800420569e <check_boot_pml4e+0x644>
			//case PDX(UVPT):
		case PDX(KSTACKTOP - 1):
		case PDX(UPAGES):
		case PDX(UENVS):
			assert(pgdir[i] & PTE_P);
  8004205643:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205647:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420564e:	00 
  800420564f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205656:	48 01 d0             	add    %rdx,%rax
  8004205659:	48 8b 00             	mov    (%rax),%rax
  800420565c:	83 e0 01             	and    $0x1,%eax
  800420565f:	48 85 c0             	test   %rax,%rax
  8004205662:	75 35                	jne    8004205699 <check_boot_pml4e+0x63f>
  8004205664:	48 b9 bb 61 21 04 80 	movabs $0x80042161bb,%rcx
  800420566b:	00 00 00 
  800420566e:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205675:	00 00 00 
  8004205678:	be 04 04 00 00       	mov    $0x404,%esi
  800420567d:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205684:	00 00 00 
  8004205687:	b8 00 00 00 00       	mov    $0x0,%eax
  800420568c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205693:	00 00 00 
  8004205696:	41 ff d0             	callq  *%r8
			break;
  8004205699:	e9 da 00 00 00       	jmpq   8004205778 <check_boot_pml4e+0x71e>
		default:
			if (i >= PDX(KERNBASE)) {
  800420569e:	48 83 7d f8 1f       	cmpq   $0x1f,-0x8(%rbp)
  80042056a3:	0f 86 ce 00 00 00    	jbe    8004205777 <check_boot_pml4e+0x71d>
				if (pgdir[i] & PTE_P)
  80042056a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042056ad:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042056b4:	00 
  80042056b5:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042056bc:	48 01 d0             	add    %rdx,%rax
  80042056bf:	48 8b 00             	mov    (%rax),%rax
  80042056c2:	83 e0 01             	and    $0x1,%eax
  80042056c5:	48 85 c0             	test   %rax,%rax
  80042056c8:	74 5a                	je     8004205724 <check_boot_pml4e+0x6ca>
					assert(pgdir[i] & PTE_W);
  80042056ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042056ce:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042056d5:	00 
  80042056d6:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042056dd:	48 01 d0             	add    %rdx,%rax
  80042056e0:	48 8b 00             	mov    (%rax),%rax
  80042056e3:	83 e0 02             	and    $0x2,%eax
  80042056e6:	48 85 c0             	test   %rax,%rax
  80042056e9:	0f 85 88 00 00 00    	jne    8004205777 <check_boot_pml4e+0x71d>
  80042056ef:	48 b9 cc 61 21 04 80 	movabs $0x80042161cc,%rcx
  80042056f6:	00 00 00 
  80042056f9:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205700:	00 00 00 
  8004205703:	be 09 04 00 00       	mov    $0x409,%esi
  8004205708:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420570f:	00 00 00 
  8004205712:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205717:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420571e:	00 00 00 
  8004205721:	41 ff d0             	callq  *%r8
				else
					assert(pgdir[i] == 0);
  8004205724:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205728:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420572f:	00 
  8004205730:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205737:	48 01 d0             	add    %rdx,%rax
  800420573a:	48 8b 00             	mov    (%rax),%rax
  800420573d:	48 85 c0             	test   %rax,%rax
  8004205740:	74 35                	je     8004205777 <check_boot_pml4e+0x71d>
  8004205742:	48 b9 dd 61 21 04 80 	movabs $0x80042161dd,%rcx
  8004205749:	00 00 00 
  800420574c:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205753:	00 00 00 
  8004205756:	be 0b 04 00 00       	mov    $0x40b,%esi
  800420575b:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205762:	00 00 00 
  8004205765:	b8 00 00 00 00       	mov    $0x0,%eax
  800420576a:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205771:	00 00 00 
  8004205774:	41 ff d0             	callq  *%r8
			}
			break;
  8004205777:	90                   	nop
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004205778:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420577d:	48 81 7d f8 ff 01 00 	cmpq   $0x1ff,-0x8(%rbp)
  8004205784:	00 
  8004205785:	0f 86 a2 fe ff ff    	jbe    800420562d <check_boot_pml4e+0x5d3>
					assert(pgdir[i] == 0);
			}
			break;
		}
	}
	cprintf("check_boot_pml4e() succeeded!\n");
  800420578b:	48 bf f0 61 21 04 80 	movabs $0x80042161f0,%rdi
  8004205792:	00 00 00 
  8004205795:	b8 00 00 00 00       	mov    $0x0,%eax
  800420579a:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042057a1:	00 00 00 
  80042057a4:	ff d2                	callq  *%rdx
}
  80042057a6:	c9                   	leaveq 
  80042057a7:	c3                   	retq   

00000080042057a8 <check_va2pa>:
// this functionality for us!  We define our own version to help check
// the check_boot_pml4e() function; it shouldn't be used elsewhere.

static physaddr_t
check_va2pa(pml4e_t *pml4e, uintptr_t va)
{
  80042057a8:	55                   	push   %rbp
  80042057a9:	48 89 e5             	mov    %rsp,%rbp
  80042057ac:	48 83 ec 60          	sub    $0x60,%rsp
  80042057b0:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80042057b4:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	pte_t *pte;
	pdpe_t *pdpe;
	pde_t *pde;
	// cprintf("%x", va);
	pml4e = &pml4e[PML4(va)];
  80042057b8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042057bc:	48 c1 e8 27          	shr    $0x27,%rax
  80042057c0:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042057c5:	48 c1 e0 03          	shl    $0x3,%rax
  80042057c9:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	// cprintf(" %x %x " , PML4(va), *pml4e);
	if(!(*pml4e & PTE_P))
  80042057cd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042057d1:	48 8b 00             	mov    (%rax),%rax
  80042057d4:	83 e0 01             	and    $0x1,%eax
  80042057d7:	48 85 c0             	test   %rax,%rax
  80042057da:	75 0c                	jne    80042057e8 <check_va2pa+0x40>
		return ~0;
  80042057dc:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80042057e3:	e9 38 02 00 00       	jmpq   8004205a20 <check_va2pa+0x278>
	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  80042057e8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042057ec:	48 8b 00             	mov    (%rax),%rax
  80042057ef:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042057f5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042057f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042057fd:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205801:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004205804:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004205807:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  800420580e:	00 00 00 
  8004205811:	48 8b 00             	mov    (%rax),%rax
  8004205814:	48 39 c2             	cmp    %rax,%rdx
  8004205817:	72 32                	jb     800420584b <check_va2pa+0xa3>
  8004205819:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420581d:	48 89 c1             	mov    %rax,%rcx
  8004205820:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  8004205827:	00 00 00 
  800420582a:	be 23 04 00 00       	mov    $0x423,%esi
  800420582f:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205836:	00 00 00 
  8004205839:	b8 00 00 00 00       	mov    $0x0,%eax
  800420583e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205845:	00 00 00 
  8004205848:	41 ff d0             	callq  *%r8
  800420584b:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205852:	00 00 00 
  8004205855:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205859:	48 01 d0             	add    %rdx,%rax
  800420585c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// cprintf(" %x %x " , pdpe, *pdpe);
	if (!(pdpe[PDPE(va)] & PTE_P))
  8004205860:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205864:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205868:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420586d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205874:	00 
  8004205875:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205879:	48 01 d0             	add    %rdx,%rax
  800420587c:	48 8b 00             	mov    (%rax),%rax
  800420587f:	83 e0 01             	and    $0x1,%eax
  8004205882:	48 85 c0             	test   %rax,%rax
  8004205885:	75 0c                	jne    8004205893 <check_va2pa+0xeb>
		return ~0;
  8004205887:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  800420588e:	e9 8d 01 00 00       	jmpq   8004205a20 <check_va2pa+0x278>
	pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004205893:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205897:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420589b:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042058a0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042058a7:	00 
  80042058a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042058ac:	48 01 d0             	add    %rdx,%rax
  80042058af:	48 8b 00             	mov    (%rax),%rax
  80042058b2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042058b8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042058bc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042058c0:	48 c1 e8 0c          	shr    $0xc,%rax
  80042058c4:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042058c7:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042058ca:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  80042058d1:	00 00 00 
  80042058d4:	48 8b 00             	mov    (%rax),%rax
  80042058d7:	48 39 c2             	cmp    %rax,%rdx
  80042058da:	72 32                	jb     800420590e <check_va2pa+0x166>
  80042058dc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042058e0:	48 89 c1             	mov    %rax,%rcx
  80042058e3:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  80042058ea:	00 00 00 
  80042058ed:	be 27 04 00 00       	mov    $0x427,%esi
  80042058f2:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042058f9:	00 00 00 
  80042058fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205901:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205908:	00 00 00 
  800420590b:	41 ff d0             	callq  *%r8
  800420590e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205915:	00 00 00 
  8004205918:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420591c:	48 01 d0             	add    %rdx,%rax
  800420591f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	// cprintf(" %x %x " , pde, *pde);
	pde = &pde[PDX(va)];
  8004205923:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205927:	48 c1 e8 15          	shr    $0x15,%rax
  800420592b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205930:	48 c1 e0 03          	shl    $0x3,%rax
  8004205934:	48 01 45 d0          	add    %rax,-0x30(%rbp)
	if (!(*pde & PTE_P))
  8004205938:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420593c:	48 8b 00             	mov    (%rax),%rax
  800420593f:	83 e0 01             	and    $0x1,%eax
  8004205942:	48 85 c0             	test   %rax,%rax
  8004205945:	75 0c                	jne    8004205953 <check_va2pa+0x1ab>
		return ~0;
  8004205947:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  800420594e:	e9 cd 00 00 00       	jmpq   8004205a20 <check_va2pa+0x278>
	pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  8004205953:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205957:	48 8b 00             	mov    (%rax),%rax
  800420595a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205960:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205964:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205968:	48 c1 e8 0c          	shr    $0xc,%rax
  800420596c:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  800420596f:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004205972:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004205979:	00 00 00 
  800420597c:	48 8b 00             	mov    (%rax),%rax
  800420597f:	48 39 c2             	cmp    %rax,%rdx
  8004205982:	72 32                	jb     80042059b6 <check_va2pa+0x20e>
  8004205984:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205988:	48 89 c1             	mov    %rax,%rcx
  800420598b:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  8004205992:	00 00 00 
  8004205995:	be 2c 04 00 00       	mov    $0x42c,%esi
  800420599a:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042059a1:	00 00 00 
  80042059a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042059a9:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042059b0:	00 00 00 
  80042059b3:	41 ff d0             	callq  *%r8
  80042059b6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042059bd:	00 00 00 
  80042059c0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042059c4:	48 01 d0             	add    %rdx,%rax
  80042059c7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	// cprintf(" %x %x " , pte, *pte);
	if (!(pte[PTX(va)] & PTE_P))
  80042059cb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042059cf:	48 c1 e8 0c          	shr    $0xc,%rax
  80042059d3:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042059d8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042059df:	00 
  80042059e0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042059e4:	48 01 d0             	add    %rdx,%rax
  80042059e7:	48 8b 00             	mov    (%rax),%rax
  80042059ea:	83 e0 01             	and    $0x1,%eax
  80042059ed:	48 85 c0             	test   %rax,%rax
  80042059f0:	75 09                	jne    80042059fb <check_va2pa+0x253>
		return ~0;
  80042059f2:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80042059f9:	eb 25                	jmp    8004205a20 <check_va2pa+0x278>
	// cprintf(" %x %x\n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
	return PTE_ADDR(pte[PTX(va)]);
  80042059fb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042059ff:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205a03:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205a08:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205a0f:	00 
  8004205a10:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205a14:	48 01 d0             	add    %rdx,%rax
  8004205a17:	48 8b 00             	mov    (%rax),%rax
  8004205a1a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  8004205a20:	c9                   	leaveq 
  8004205a21:	c3                   	retq   

0000008004205a22 <page_check>:


// check page_insert, page_remove, &c
static void
page_check(void)
{
  8004205a22:	55                   	push   %rbp
  8004205a23:	48 89 e5             	mov    %rsp,%rbp
  8004205a26:	53                   	push   %rbx
  8004205a27:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
	pdpe_t *pdpe;
	pde_t *pde;
	void *va;
	int i;
	uintptr_t mm1, mm2;
	pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  8004205a2e:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004205a35:	00 
  8004205a36:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a3a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205a3e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205a42:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004205a46:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205a4a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205a4e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205a52:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004205a56:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205a5a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	assert(pp0 = page_alloc(0));
  8004205a5e:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205a63:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  8004205a6a:	00 00 00 
  8004205a6d:	ff d0                	callq  *%rax
  8004205a6f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004205a73:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205a78:	75 35                	jne    8004205aaf <page_check+0x8d>
  8004205a7a:	48 b9 0f 62 21 04 80 	movabs $0x800421620f,%rcx
  8004205a81:	00 00 00 
  8004205a84:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205a8b:	00 00 00 
  8004205a8e:	be 42 04 00 00       	mov    $0x442,%esi
  8004205a93:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205a9a:	00 00 00 
  8004205a9d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205aa2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205aa9:	00 00 00 
  8004205aac:	41 ff d0             	callq  *%r8
	assert(pp1 = page_alloc(0));
  8004205aaf:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205ab4:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  8004205abb:	00 00 00 
  8004205abe:	ff d0                	callq  *%rax
  8004205ac0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004205ac4:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205ac9:	75 35                	jne    8004205b00 <page_check+0xde>
  8004205acb:	48 b9 23 62 21 04 80 	movabs $0x8004216223,%rcx
  8004205ad2:	00 00 00 
  8004205ad5:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205adc:	00 00 00 
  8004205adf:	be 43 04 00 00       	mov    $0x443,%esi
  8004205ae4:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205aeb:	00 00 00 
  8004205aee:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205af3:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205afa:	00 00 00 
  8004205afd:	41 ff d0             	callq  *%r8
	assert(pp2 = page_alloc(0));
  8004205b00:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205b05:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  8004205b0c:	00 00 00 
  8004205b0f:	ff d0                	callq  *%rax
  8004205b11:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205b15:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205b1a:	75 35                	jne    8004205b51 <page_check+0x12f>
  8004205b1c:	48 b9 37 62 21 04 80 	movabs $0x8004216237,%rcx
  8004205b23:	00 00 00 
  8004205b26:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205b2d:	00 00 00 
  8004205b30:	be 44 04 00 00       	mov    $0x444,%esi
  8004205b35:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205b3c:	00 00 00 
  8004205b3f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b44:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205b4b:	00 00 00 
  8004205b4e:	41 ff d0             	callq  *%r8
	assert(pp3 = page_alloc(0));
  8004205b51:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205b56:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  8004205b5d:	00 00 00 
  8004205b60:	ff d0                	callq  *%rax
  8004205b62:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004205b66:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205b6b:	75 35                	jne    8004205ba2 <page_check+0x180>
  8004205b6d:	48 b9 4b 62 21 04 80 	movabs $0x800421624b,%rcx
  8004205b74:	00 00 00 
  8004205b77:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205b7e:	00 00 00 
  8004205b81:	be 45 04 00 00       	mov    $0x445,%esi
  8004205b86:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205b8d:	00 00 00 
  8004205b90:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b95:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205b9c:	00 00 00 
  8004205b9f:	41 ff d0             	callq  *%r8
	assert(pp4 = page_alloc(0));
  8004205ba2:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205ba7:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  8004205bae:	00 00 00 
  8004205bb1:	ff d0                	callq  *%rax
  8004205bb3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205bb7:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205bbc:	75 35                	jne    8004205bf3 <page_check+0x1d1>
  8004205bbe:	48 b9 5f 62 21 04 80 	movabs $0x800421625f,%rcx
  8004205bc5:	00 00 00 
  8004205bc8:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205bcf:	00 00 00 
  8004205bd2:	be 46 04 00 00       	mov    $0x446,%esi
  8004205bd7:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205bde:	00 00 00 
  8004205be1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205be6:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205bed:	00 00 00 
  8004205bf0:	41 ff d0             	callq  *%r8
	assert(pp5 = page_alloc(0));
  8004205bf3:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205bf8:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  8004205bff:	00 00 00 
  8004205c02:	ff d0                	callq  *%rax
  8004205c04:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205c08:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205c0d:	75 35                	jne    8004205c44 <page_check+0x222>
  8004205c0f:	48 b9 73 62 21 04 80 	movabs $0x8004216273,%rcx
  8004205c16:	00 00 00 
  8004205c19:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205c20:	00 00 00 
  8004205c23:	be 47 04 00 00       	mov    $0x447,%esi
  8004205c28:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205c2f:	00 00 00 
  8004205c32:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c37:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205c3e:	00 00 00 
  8004205c41:	41 ff d0             	callq  *%r8

	assert(pp0);
  8004205c44:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205c49:	75 35                	jne    8004205c80 <page_check+0x25e>
  8004205c4b:	48 b9 c1 5f 21 04 80 	movabs $0x8004215fc1,%rcx
  8004205c52:	00 00 00 
  8004205c55:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205c5c:	00 00 00 
  8004205c5f:	be 49 04 00 00       	mov    $0x449,%esi
  8004205c64:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205c6b:	00 00 00 
  8004205c6e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c73:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205c7a:	00 00 00 
  8004205c7d:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004205c80:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205c85:	74 0a                	je     8004205c91 <page_check+0x26f>
  8004205c87:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205c8b:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205c8f:	75 35                	jne    8004205cc6 <page_check+0x2a4>
  8004205c91:	48 b9 c5 5f 21 04 80 	movabs $0x8004215fc5,%rcx
  8004205c98:	00 00 00 
  8004205c9b:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205ca2:	00 00 00 
  8004205ca5:	be 4a 04 00 00       	mov    $0x44a,%esi
  8004205caa:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205cb1:	00 00 00 
  8004205cb4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205cb9:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205cc0:	00 00 00 
  8004205cc3:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004205cc6:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205ccb:	74 14                	je     8004205ce1 <page_check+0x2bf>
  8004205ccd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205cd1:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205cd5:	74 0a                	je     8004205ce1 <page_check+0x2bf>
  8004205cd7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205cdb:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205cdf:	75 35                	jne    8004205d16 <page_check+0x2f4>
  8004205ce1:	48 b9 d8 5f 21 04 80 	movabs $0x8004215fd8,%rcx
  8004205ce8:	00 00 00 
  8004205ceb:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205cf2:	00 00 00 
  8004205cf5:	be 4b 04 00 00       	mov    $0x44b,%esi
  8004205cfa:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205d01:	00 00 00 
  8004205d04:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d09:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205d10:	00 00 00 
  8004205d13:	41 ff d0             	callq  *%r8
	assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  8004205d16:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205d1b:	74 1e                	je     8004205d3b <page_check+0x319>
  8004205d1d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205d21:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205d25:	74 14                	je     8004205d3b <page_check+0x319>
  8004205d27:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205d2b:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205d2f:	74 0a                	je     8004205d3b <page_check+0x319>
  8004205d31:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205d35:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205d39:	75 35                	jne    8004205d70 <page_check+0x34e>
  8004205d3b:	48 b9 88 62 21 04 80 	movabs $0x8004216288,%rcx
  8004205d42:	00 00 00 
  8004205d45:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205d4c:	00 00 00 
  8004205d4f:	be 4c 04 00 00       	mov    $0x44c,%esi
  8004205d54:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205d5b:	00 00 00 
  8004205d5e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d63:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205d6a:	00 00 00 
  8004205d6d:	41 ff d0             	callq  *%r8
	assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  8004205d70:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205d75:	74 28                	je     8004205d9f <page_check+0x37d>
  8004205d77:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205d7b:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205d7f:	74 1e                	je     8004205d9f <page_check+0x37d>
  8004205d81:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205d85:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205d89:	74 14                	je     8004205d9f <page_check+0x37d>
  8004205d8b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205d8f:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205d93:	74 0a                	je     8004205d9f <page_check+0x37d>
  8004205d95:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205d99:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205d9d:	75 35                	jne    8004205dd4 <page_check+0x3b2>
  8004205d9f:	48 b9 b8 62 21 04 80 	movabs $0x80042162b8,%rcx
  8004205da6:	00 00 00 
  8004205da9:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205db0:	00 00 00 
  8004205db3:	be 4d 04 00 00       	mov    $0x44d,%esi
  8004205db8:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205dbf:	00 00 00 
  8004205dc2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205dc7:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205dce:	00 00 00 
  8004205dd1:	41 ff d0             	callq  *%r8
	assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  8004205dd4:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205dd9:	74 32                	je     8004205e0d <page_check+0x3eb>
  8004205ddb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205ddf:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004205de3:	74 28                	je     8004205e0d <page_check+0x3eb>
  8004205de5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205de9:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205ded:	74 1e                	je     8004205e0d <page_check+0x3eb>
  8004205def:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205df3:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205df7:	74 14                	je     8004205e0d <page_check+0x3eb>
  8004205df9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205dfd:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205e01:	74 0a                	je     8004205e0d <page_check+0x3eb>
  8004205e03:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205e07:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205e0b:	75 35                	jne    8004205e42 <page_check+0x420>
  8004205e0d:	48 b9 f8 62 21 04 80 	movabs $0x80042162f8,%rcx
  8004205e14:	00 00 00 
  8004205e17:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205e1e:	00 00 00 
  8004205e21:	be 4e 04 00 00       	mov    $0x44e,%esi
  8004205e26:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205e2d:	00 00 00 
  8004205e30:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e35:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205e3c:	00 00 00 
  8004205e3f:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004205e42:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004205e49:	00 00 00 
  8004205e4c:	48 8b 00             	mov    (%rax),%rax
  8004205e4f:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	page_free_list = NULL;
  8004205e53:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004205e5a:	00 00 00 
  8004205e5d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004205e64:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205e69:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  8004205e70:	00 00 00 
  8004205e73:	ff d0                	callq  *%rax
  8004205e75:	48 85 c0             	test   %rax,%rax
  8004205e78:	74 35                	je     8004205eaf <page_check+0x48d>
  8004205e7a:	48 b9 4f 60 21 04 80 	movabs $0x800421604f,%rcx
  8004205e81:	00 00 00 
  8004205e84:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205e8b:	00 00 00 
  8004205e8e:	be 55 04 00 00       	mov    $0x455,%esi
  8004205e93:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205e9a:	00 00 00 
  8004205e9d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ea2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205ea9:	00 00 00 
  8004205eac:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
	assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  8004205eaf:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004205eb6:	00 00 00 
  8004205eb9:	48 8b 00             	mov    (%rax),%rax
  8004205ebc:	48 8d 95 e0 fe ff ff 	lea    -0x120(%rbp),%rdx
  8004205ec3:	be 00 00 00 00       	mov    $0x0,%esi
  8004205ec8:	48 89 c7             	mov    %rax,%rdi
  8004205ecb:	48 b8 e0 3c 20 04 80 	movabs $0x8004203ce0,%rax
  8004205ed2:	00 00 00 
  8004205ed5:	ff d0                	callq  *%rax
  8004205ed7:	48 85 c0             	test   %rax,%rax
  8004205eda:	74 35                	je     8004205f11 <page_check+0x4ef>
  8004205edc:	48 b9 48 63 21 04 80 	movabs $0x8004216348,%rcx
  8004205ee3:	00 00 00 
  8004205ee6:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205eed:	00 00 00 
  8004205ef0:	be 58 04 00 00       	mov    $0x458,%esi
  8004205ef5:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205efc:	00 00 00 
  8004205eff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f04:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205f0b:	00 00 00 
  8004205f0e:	41 ff d0             	callq  *%r8

	// there is no free memory, so we can't allocate a page table
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004205f11:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004205f18:	00 00 00 
  8004205f1b:	48 8b 00             	mov    (%rax),%rax
  8004205f1e:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205f22:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205f27:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205f2c:	48 89 c7             	mov    %rax,%rdi
  8004205f2f:	48 b8 b4 3b 20 04 80 	movabs $0x8004203bb4,%rax
  8004205f36:	00 00 00 
  8004205f39:	ff d0                	callq  *%rax
  8004205f3b:	85 c0                	test   %eax,%eax
  8004205f3d:	78 35                	js     8004205f74 <page_check+0x552>
  8004205f3f:	48 b9 80 63 21 04 80 	movabs $0x8004216380,%rcx
  8004205f46:	00 00 00 
  8004205f49:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205f50:	00 00 00 
  8004205f53:	be 5b 04 00 00       	mov    $0x45b,%esi
  8004205f58:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205f5f:	00 00 00 
  8004205f62:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f67:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205f6e:	00 00 00 
  8004205f71:	41 ff d0             	callq  *%r8

	// free pp0 and try again: pp0 should be used for page table
	page_free(pp0);
  8004205f74:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205f78:	48 89 c7             	mov    %rax,%rdi
  8004205f7b:	48 b8 af 35 20 04 80 	movabs $0x80042035af,%rax
  8004205f82:	00 00 00 
  8004205f85:	ff d0                	callq  *%rax
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004205f87:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004205f8e:	00 00 00 
  8004205f91:	48 8b 00             	mov    (%rax),%rax
  8004205f94:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205f98:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205f9d:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205fa2:	48 89 c7             	mov    %rax,%rdi
  8004205fa5:	48 b8 b4 3b 20 04 80 	movabs $0x8004203bb4,%rax
  8004205fac:	00 00 00 
  8004205faf:	ff d0                	callq  *%rax
  8004205fb1:	85 c0                	test   %eax,%eax
  8004205fb3:	78 35                	js     8004205fea <page_check+0x5c8>
  8004205fb5:	48 b9 80 63 21 04 80 	movabs $0x8004216380,%rcx
  8004205fbc:	00 00 00 
  8004205fbf:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004205fc6:	00 00 00 
  8004205fc9:	be 5f 04 00 00       	mov    $0x45f,%esi
  8004205fce:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004205fd5:	00 00 00 
  8004205fd8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205fdd:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004205fe4:	00 00 00 
  8004205fe7:	41 ff d0             	callq  *%r8
	page_free(pp2);
  8004205fea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205fee:	48 89 c7             	mov    %rax,%rdi
  8004205ff1:	48 b8 af 35 20 04 80 	movabs $0x80042035af,%rax
  8004205ff8:	00 00 00 
  8004205ffb:	ff d0                	callq  *%rax
	page_free(pp3);
  8004205ffd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206001:	48 89 c7             	mov    %rax,%rdi
  8004206004:	48 b8 af 35 20 04 80 	movabs $0x80042035af,%rax
  800420600b:	00 00 00 
  800420600e:	ff d0                	callq  *%rax
	//cprintf("pp2 ref count = %d\n",pp2->pp_ref);
	/*int x = 0;
	struct PageInfo* ii = page_free_list;
	for(;ii != NULL;ii = ii -> pp_link) x++;
	cprintf("free page count = %d\n", x);*/
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  8004206010:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206017:	00 00 00 
  800420601a:	48 8b 00             	mov    (%rax),%rax
  800420601d:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206021:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206026:	ba 00 00 00 00       	mov    $0x0,%edx
  800420602b:	48 89 c7             	mov    %rax,%rdi
  800420602e:	48 b8 b4 3b 20 04 80 	movabs $0x8004203bb4,%rax
  8004206035:	00 00 00 
  8004206038:	ff d0                	callq  *%rax
  800420603a:	85 c0                	test   %eax,%eax
  800420603c:	74 35                	je     8004206073 <page_check+0x651>
  800420603e:	48 b9 b0 63 21 04 80 	movabs $0x80042163b0,%rcx
  8004206045:	00 00 00 
  8004206048:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420604f:	00 00 00 
  8004206052:	be 69 04 00 00       	mov    $0x469,%esi
  8004206057:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420605e:	00 00 00 
  8004206061:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206066:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420606d:	00 00 00 
  8004206070:	41 ff d0             	callq  *%r8
	assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  8004206073:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  800420607a:	00 00 00 
  800420607d:	48 8b 00             	mov    (%rax),%rax
  8004206080:	48 8b 00             	mov    (%rax),%rax
  8004206083:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206089:	48 89 c3             	mov    %rax,%rbx
  800420608c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206090:	48 89 c7             	mov    %rax,%rdi
  8004206093:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  800420609a:	00 00 00 
  800420609d:	ff d0                	callq  *%rax
  800420609f:	48 39 c3             	cmp    %rax,%rbx
  80042060a2:	0f 84 97 00 00 00    	je     800420613f <page_check+0x71d>
  80042060a8:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  80042060af:	00 00 00 
  80042060b2:	48 8b 00             	mov    (%rax),%rax
  80042060b5:	48 8b 00             	mov    (%rax),%rax
  80042060b8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042060be:	48 89 c3             	mov    %rax,%rbx
  80042060c1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042060c5:	48 89 c7             	mov    %rax,%rdi
  80042060c8:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  80042060cf:	00 00 00 
  80042060d2:	ff d0                	callq  *%rax
  80042060d4:	48 39 c3             	cmp    %rax,%rbx
  80042060d7:	74 66                	je     800420613f <page_check+0x71d>
  80042060d9:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  80042060e0:	00 00 00 
  80042060e3:	48 8b 00             	mov    (%rax),%rax
  80042060e6:	48 8b 00             	mov    (%rax),%rax
  80042060e9:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042060ef:	48 89 c3             	mov    %rax,%rbx
  80042060f2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042060f6:	48 89 c7             	mov    %rax,%rdi
  80042060f9:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  8004206100:	00 00 00 
  8004206103:	ff d0                	callq  *%rax
  8004206105:	48 39 c3             	cmp    %rax,%rbx
  8004206108:	74 35                	je     800420613f <page_check+0x71d>
  800420610a:	48 b9 e0 63 21 04 80 	movabs $0x80042163e0,%rcx
  8004206111:	00 00 00 
  8004206114:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420611b:	00 00 00 
  800420611e:	be 6a 04 00 00       	mov    $0x46a,%esi
  8004206123:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420612a:	00 00 00 
  800420612d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206132:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206139:	00 00 00 
  800420613c:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  800420613f:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206146:	00 00 00 
  8004206149:	48 8b 00             	mov    (%rax),%rax
  800420614c:	be 00 00 00 00       	mov    $0x0,%esi
  8004206151:	48 89 c7             	mov    %rax,%rdi
  8004206154:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  800420615b:	00 00 00 
  800420615e:	ff d0                	callq  *%rax
  8004206160:	48 89 c3             	mov    %rax,%rbx
  8004206163:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206167:	48 89 c7             	mov    %rax,%rdi
  800420616a:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  8004206171:	00 00 00 
  8004206174:	ff d0                	callq  *%rax
  8004206176:	48 39 c3             	cmp    %rax,%rbx
  8004206179:	74 35                	je     80042061b0 <page_check+0x78e>
  800420617b:	48 b9 68 64 21 04 80 	movabs $0x8004216468,%rcx
  8004206182:	00 00 00 
  8004206185:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420618c:	00 00 00 
  800420618f:	be 6b 04 00 00       	mov    $0x46b,%esi
  8004206194:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420619b:	00 00 00 
  800420619e:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061a3:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042061aa:	00 00 00 
  80042061ad:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  80042061b0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042061b4:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042061b8:	66 83 f8 01          	cmp    $0x1,%ax
  80042061bc:	74 35                	je     80042061f3 <page_check+0x7d1>
  80042061be:	48 b9 95 64 21 04 80 	movabs $0x8004216495,%rcx
  80042061c5:	00 00 00 
  80042061c8:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042061cf:	00 00 00 
  80042061d2:	be 6c 04 00 00       	mov    $0x46c,%esi
  80042061d7:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042061de:	00 00 00 
  80042061e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061e6:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042061ed:	00 00 00 
  80042061f0:	41 ff d0             	callq  *%r8
	assert(pp0->pp_ref == 1);
  80042061f3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042061f7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042061fb:	66 83 f8 01          	cmp    $0x1,%ax
  80042061ff:	74 35                	je     8004206236 <page_check+0x814>
  8004206201:	48 b9 a6 64 21 04 80 	movabs $0x80042164a6,%rcx
  8004206208:	00 00 00 
  800420620b:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206212:	00 00 00 
  8004206215:	be 6d 04 00 00       	mov    $0x46d,%esi
  800420621a:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206221:	00 00 00 
  8004206224:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206229:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206230:	00 00 00 
  8004206233:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 1);
  8004206236:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420623a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420623e:	66 83 f8 01          	cmp    $0x1,%ax
  8004206242:	74 35                	je     8004206279 <page_check+0x857>
  8004206244:	48 b9 b7 64 21 04 80 	movabs $0x80042164b7,%rcx
  800420624b:	00 00 00 
  800420624e:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206255:	00 00 00 
  8004206258:	be 6e 04 00 00       	mov    $0x46e,%esi
  800420625d:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206264:	00 00 00 
  8004206267:	b8 00 00 00 00       	mov    $0x0,%eax
  800420626c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206273:	00 00 00 
  8004206276:	41 ff d0             	callq  *%r8
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004206279:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206280:	00 00 00 
  8004206283:	48 8b 00             	mov    (%rax),%rax
  8004206286:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420628a:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420628f:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206294:	48 89 c7             	mov    %rax,%rdi
  8004206297:	48 b8 b4 3b 20 04 80 	movabs $0x8004203bb4,%rax
  800420629e:	00 00 00 
  80042062a1:	ff d0                	callq  *%rax
  80042062a3:	85 c0                	test   %eax,%eax
  80042062a5:	74 35                	je     80042062dc <page_check+0x8ba>
  80042062a7:	48 b9 c8 64 21 04 80 	movabs $0x80042164c8,%rcx
  80042062ae:	00 00 00 
  80042062b1:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042062b8:	00 00 00 
  80042062bb:	be 70 04 00 00       	mov    $0x470,%esi
  80042062c0:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042062c7:	00 00 00 
  80042062ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80042062cf:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042062d6:	00 00 00 
  80042062d9:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  80042062dc:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  80042062e3:	00 00 00 
  80042062e6:	48 8b 00             	mov    (%rax),%rax
  80042062e9:	be 00 10 00 00       	mov    $0x1000,%esi
  80042062ee:	48 89 c7             	mov    %rax,%rdi
  80042062f1:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  80042062f8:	00 00 00 
  80042062fb:	ff d0                	callq  *%rax
  80042062fd:	48 89 c3             	mov    %rax,%rbx
  8004206300:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206304:	48 89 c7             	mov    %rax,%rdi
  8004206307:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  800420630e:	00 00 00 
  8004206311:	ff d0                	callq  *%rax
  8004206313:	48 39 c3             	cmp    %rax,%rbx
  8004206316:	74 35                	je     800420634d <page_check+0x92b>
  8004206318:	48 b9 00 65 21 04 80 	movabs $0x8004216500,%rcx
  800420631f:	00 00 00 
  8004206322:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206329:	00 00 00 
  800420632c:	be 71 04 00 00       	mov    $0x471,%esi
  8004206331:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206338:	00 00 00 
  800420633b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206340:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206347:	00 00 00 
  800420634a:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  800420634d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206351:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206355:	66 83 f8 02          	cmp    $0x2,%ax
  8004206359:	74 35                	je     8004206390 <page_check+0x96e>
  800420635b:	48 b9 30 65 21 04 80 	movabs $0x8004216530,%rcx
  8004206362:	00 00 00 
  8004206365:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420636c:	00 00 00 
  800420636f:	be 72 04 00 00       	mov    $0x472,%esi
  8004206374:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420637b:	00 00 00 
  800420637e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206383:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420638a:	00 00 00 
  800420638d:	41 ff d0             	callq  *%r8

	// should be no free memory
	assert(!page_alloc(0));
  8004206390:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206395:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  800420639c:	00 00 00 
  800420639f:	ff d0                	callq  *%rax
  80042063a1:	48 85 c0             	test   %rax,%rax
  80042063a4:	74 35                	je     80042063db <page_check+0x9b9>
  80042063a6:	48 b9 4f 60 21 04 80 	movabs $0x800421604f,%rcx
  80042063ad:	00 00 00 
  80042063b0:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042063b7:	00 00 00 
  80042063ba:	be 75 04 00 00       	mov    $0x475,%esi
  80042063bf:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042063c6:	00 00 00 
  80042063c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063ce:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042063d5:	00 00 00 
  80042063d8:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  80042063db:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  80042063e2:	00 00 00 
  80042063e5:	48 8b 00             	mov    (%rax),%rax
  80042063e8:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042063ec:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042063f1:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042063f6:	48 89 c7             	mov    %rax,%rdi
  80042063f9:	48 b8 b4 3b 20 04 80 	movabs $0x8004203bb4,%rax
  8004206400:	00 00 00 
  8004206403:	ff d0                	callq  *%rax
  8004206405:	85 c0                	test   %eax,%eax
  8004206407:	74 35                	je     800420643e <page_check+0xa1c>
  8004206409:	48 b9 c8 64 21 04 80 	movabs $0x80042164c8,%rcx
  8004206410:	00 00 00 
  8004206413:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420641a:	00 00 00 
  800420641d:	be 78 04 00 00       	mov    $0x478,%esi
  8004206422:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206429:	00 00 00 
  800420642c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206431:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206438:	00 00 00 
  800420643b:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  800420643e:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206445:	00 00 00 
  8004206448:	48 8b 00             	mov    (%rax),%rax
  800420644b:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206450:	48 89 c7             	mov    %rax,%rdi
  8004206453:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  800420645a:	00 00 00 
  800420645d:	ff d0                	callq  *%rax
  800420645f:	48 89 c3             	mov    %rax,%rbx
  8004206462:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206466:	48 89 c7             	mov    %rax,%rdi
  8004206469:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  8004206470:	00 00 00 
  8004206473:	ff d0                	callq  *%rax
  8004206475:	48 39 c3             	cmp    %rax,%rbx
  8004206478:	74 35                	je     80042064af <page_check+0xa8d>
  800420647a:	48 b9 00 65 21 04 80 	movabs $0x8004216500,%rcx
  8004206481:	00 00 00 
  8004206484:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420648b:	00 00 00 
  800420648e:	be 79 04 00 00       	mov    $0x479,%esi
  8004206493:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420649a:	00 00 00 
  800420649d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064a2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042064a9:	00 00 00 
  80042064ac:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  80042064af:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042064b3:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042064b7:	66 83 f8 02          	cmp    $0x2,%ax
  80042064bb:	74 35                	je     80042064f2 <page_check+0xad0>
  80042064bd:	48 b9 30 65 21 04 80 	movabs $0x8004216530,%rcx
  80042064c4:	00 00 00 
  80042064c7:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042064ce:	00 00 00 
  80042064d1:	be 7a 04 00 00       	mov    $0x47a,%esi
  80042064d6:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042064dd:	00 00 00 
  80042064e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064e5:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042064ec:	00 00 00 
  80042064ef:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));
  80042064f2:	bf 00 00 00 00       	mov    $0x0,%edi
  80042064f7:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  80042064fe:	00 00 00 
  8004206501:	ff d0                	callq  *%rax
  8004206503:	48 85 c0             	test   %rax,%rax
  8004206506:	74 35                	je     800420653d <page_check+0xb1b>
  8004206508:	48 b9 4f 60 21 04 80 	movabs $0x800421604f,%rcx
  800420650f:	00 00 00 
  8004206512:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206519:	00 00 00 
  800420651c:	be 7e 04 00 00       	mov    $0x47e,%esi
  8004206521:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206528:	00 00 00 
  800420652b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206530:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206537:	00 00 00 
  800420653a:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  800420653d:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206544:	00 00 00 
  8004206547:	48 8b 00             	mov    (%rax),%rax
  800420654a:	48 8b 00             	mov    (%rax),%rax
  800420654d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206553:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  8004206557:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420655b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420655f:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  8004206562:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004206565:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  800420656c:	00 00 00 
  800420656f:	48 8b 00             	mov    (%rax),%rax
  8004206572:	48 39 c2             	cmp    %rax,%rdx
  8004206575:	72 32                	jb     80042065a9 <page_check+0xb87>
  8004206577:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420657b:	48 89 c1             	mov    %rax,%rcx
  800420657e:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  8004206585:	00 00 00 
  8004206588:	be 80 04 00 00       	mov    $0x480,%esi
  800420658d:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206594:	00 00 00 
  8004206597:	b8 00 00 00 00       	mov    $0x0,%eax
  800420659c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042065a3:	00 00 00 
  80042065a6:	41 ff d0             	callq  *%r8
  80042065a9:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042065b0:	00 00 00 
  80042065b3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042065b7:	48 01 d0             	add    %rdx,%rax
  80042065ba:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  80042065be:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042065c2:	48 8b 00             	mov    (%rax),%rax
  80042065c5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042065cb:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  80042065cf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042065d3:	48 c1 e8 0c          	shr    $0xc,%rax
  80042065d7:	89 45 8c             	mov    %eax,-0x74(%rbp)
  80042065da:	8b 55 8c             	mov    -0x74(%rbp),%edx
  80042065dd:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  80042065e4:	00 00 00 
  80042065e7:	48 8b 00             	mov    (%rax),%rax
  80042065ea:	48 39 c2             	cmp    %rax,%rdx
  80042065ed:	72 32                	jb     8004206621 <page_check+0xbff>
  80042065ef:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042065f3:	48 89 c1             	mov    %rax,%rcx
  80042065f6:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  80042065fd:	00 00 00 
  8004206600:	be 81 04 00 00       	mov    $0x481,%esi
  8004206605:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420660c:	00 00 00 
  800420660f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206614:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420661b:	00 00 00 
  800420661e:	41 ff d0             	callq  *%r8
  8004206621:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206628:	00 00 00 
  800420662b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420662f:	48 01 d0             	add    %rdx,%rax
  8004206632:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  8004206636:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800420663a:	48 8b 00             	mov    (%rax),%rax
  800420663d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206643:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  800420664a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206651:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206655:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  800420665b:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  8004206661:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004206668:	00 00 00 
  800420666b:	48 8b 00             	mov    (%rax),%rax
  800420666e:	48 39 c2             	cmp    %rax,%rdx
  8004206671:	72 35                	jb     80042066a8 <page_check+0xc86>
  8004206673:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420667a:	48 89 c1             	mov    %rax,%rcx
  800420667d:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  8004206684:	00 00 00 
  8004206687:	be 82 04 00 00       	mov    $0x482,%esi
  800420668c:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206693:	00 00 00 
  8004206696:	b8 00 00 00 00       	mov    $0x0,%eax
  800420669b:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042066a2:	00 00 00 
  80042066a5:	41 ff d0             	callq  *%r8
  80042066a8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042066af:	00 00 00 
  80042066b2:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042066b9:	48 01 d0             	add    %rdx,%rax
  80042066bc:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  80042066c3:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  80042066ca:	00 00 00 
  80042066cd:	48 8b 00             	mov    (%rax),%rax
  80042066d0:	ba 00 00 00 00       	mov    $0x0,%edx
  80042066d5:	be 00 10 00 00       	mov    $0x1000,%esi
  80042066da:	48 89 c7             	mov    %rax,%rdi
  80042066dd:	48 b8 6f 36 20 04 80 	movabs $0x800420366f,%rax
  80042066e4:	00 00 00 
  80042066e7:	ff d0                	callq  *%rax
  80042066e9:	48 8b 95 e0 fe ff ff 	mov    -0x120(%rbp),%rdx
  80042066f0:	48 83 c2 08          	add    $0x8,%rdx
  80042066f4:	48 39 d0             	cmp    %rdx,%rax
  80042066f7:	74 35                	je     800420672e <page_check+0xd0c>
  80042066f9:	48 b9 48 65 21 04 80 	movabs $0x8004216548,%rcx
  8004206700:	00 00 00 
  8004206703:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420670a:	00 00 00 
  800420670d:	be 83 04 00 00       	mov    $0x483,%esi
  8004206712:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206719:	00 00 00 
  800420671c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206721:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206728:	00 00 00 
  800420672b:	41 ff d0             	callq  *%r8

	// should be able to change permissions too.
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  800420672e:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206735:	00 00 00 
  8004206738:	48 8b 00             	mov    (%rax),%rax
  800420673b:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420673f:	b9 04 00 00 00       	mov    $0x4,%ecx
  8004206744:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206749:	48 89 c7             	mov    %rax,%rdi
  800420674c:	48 b8 b4 3b 20 04 80 	movabs $0x8004203bb4,%rax
  8004206753:	00 00 00 
  8004206756:	ff d0                	callq  *%rax
  8004206758:	85 c0                	test   %eax,%eax
  800420675a:	74 35                	je     8004206791 <page_check+0xd6f>
  800420675c:	48 b9 88 65 21 04 80 	movabs $0x8004216588,%rcx
  8004206763:	00 00 00 
  8004206766:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420676d:	00 00 00 
  8004206770:	be 86 04 00 00       	mov    $0x486,%esi
  8004206775:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420677c:	00 00 00 
  800420677f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206784:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420678b:	00 00 00 
  800420678e:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004206791:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206798:	00 00 00 
  800420679b:	48 8b 00             	mov    (%rax),%rax
  800420679e:	be 00 10 00 00       	mov    $0x1000,%esi
  80042067a3:	48 89 c7             	mov    %rax,%rdi
  80042067a6:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  80042067ad:	00 00 00 
  80042067b0:	ff d0                	callq  *%rax
  80042067b2:	48 89 c3             	mov    %rax,%rbx
  80042067b5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042067b9:	48 89 c7             	mov    %rax,%rdi
  80042067bc:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  80042067c3:	00 00 00 
  80042067c6:	ff d0                	callq  *%rax
  80042067c8:	48 39 c3             	cmp    %rax,%rbx
  80042067cb:	74 35                	je     8004206802 <page_check+0xde0>
  80042067cd:	48 b9 00 65 21 04 80 	movabs $0x8004216500,%rcx
  80042067d4:	00 00 00 
  80042067d7:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042067de:	00 00 00 
  80042067e1:	be 87 04 00 00       	mov    $0x487,%esi
  80042067e6:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042067ed:	00 00 00 
  80042067f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042067f5:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042067fc:	00 00 00 
  80042067ff:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004206802:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206806:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420680a:	66 83 f8 02          	cmp    $0x2,%ax
  800420680e:	74 35                	je     8004206845 <page_check+0xe23>
  8004206810:	48 b9 30 65 21 04 80 	movabs $0x8004216530,%rcx
  8004206817:	00 00 00 
  800420681a:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206821:	00 00 00 
  8004206824:	be 88 04 00 00       	mov    $0x488,%esi
  8004206829:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206830:	00 00 00 
  8004206833:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206838:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420683f:	00 00 00 
  8004206842:	41 ff d0             	callq  *%r8
	assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  8004206845:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  800420684c:	00 00 00 
  800420684f:	48 8b 00             	mov    (%rax),%rax
  8004206852:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206857:	be 00 10 00 00       	mov    $0x1000,%esi
  800420685c:	48 89 c7             	mov    %rax,%rdi
  800420685f:	48 b8 6f 36 20 04 80 	movabs $0x800420366f,%rax
  8004206866:	00 00 00 
  8004206869:	ff d0                	callq  *%rax
  800420686b:	48 8b 00             	mov    (%rax),%rax
  800420686e:	83 e0 04             	and    $0x4,%eax
  8004206871:	48 85 c0             	test   %rax,%rax
  8004206874:	75 35                	jne    80042068ab <page_check+0xe89>
  8004206876:	48 b9 c8 65 21 04 80 	movabs $0x80042165c8,%rcx
  800420687d:	00 00 00 
  8004206880:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206887:	00 00 00 
  800420688a:	be 89 04 00 00       	mov    $0x489,%esi
  800420688f:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206896:	00 00 00 
  8004206899:	b8 00 00 00 00       	mov    $0x0,%eax
  800420689e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042068a5:	00 00 00 
  80042068a8:	41 ff d0             	callq  *%r8
	assert(boot_pml4e[0] & PTE_U);
  80042068ab:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  80042068b2:	00 00 00 
  80042068b5:	48 8b 00             	mov    (%rax),%rax
  80042068b8:	48 8b 00             	mov    (%rax),%rax
  80042068bb:	83 e0 04             	and    $0x4,%eax
  80042068be:	48 85 c0             	test   %rax,%rax
  80042068c1:	75 35                	jne    80042068f8 <page_check+0xed6>
  80042068c3:	48 b9 fb 65 21 04 80 	movabs $0x80042165fb,%rcx
  80042068ca:	00 00 00 
  80042068cd:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042068d4:	00 00 00 
  80042068d7:	be 8a 04 00 00       	mov    $0x48a,%esi
  80042068dc:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042068e3:	00 00 00 
  80042068e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042068eb:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042068f2:	00 00 00 
  80042068f5:	41 ff d0             	callq  *%r8


	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  80042068f8:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  80042068ff:	00 00 00 
  8004206902:	48 8b 00             	mov    (%rax),%rax
  8004206905:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004206909:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420690e:	ba 00 00 20 00       	mov    $0x200000,%edx
  8004206913:	48 89 c7             	mov    %rax,%rdi
  8004206916:	48 b8 b4 3b 20 04 80 	movabs $0x8004203bb4,%rax
  800420691d:	00 00 00 
  8004206920:	ff d0                	callq  *%rax
  8004206922:	85 c0                	test   %eax,%eax
  8004206924:	78 35                	js     800420695b <page_check+0xf39>
  8004206926:	48 b9 18 66 21 04 80 	movabs $0x8004216618,%rcx
  800420692d:	00 00 00 
  8004206930:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206937:	00 00 00 
  800420693a:	be 8e 04 00 00       	mov    $0x48e,%esi
  800420693f:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206946:	00 00 00 
  8004206949:	b8 00 00 00 00       	mov    $0x0,%eax
  800420694e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206955:	00 00 00 
  8004206958:	41 ff d0             	callq  *%r8

	// insert pp1 at PGSIZE (replacing pp3)
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  800420695b:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206962:	00 00 00 
  8004206965:	48 8b 00             	mov    (%rax),%rax
  8004206968:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420696c:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206971:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206976:	48 89 c7             	mov    %rax,%rdi
  8004206979:	48 b8 b4 3b 20 04 80 	movabs $0x8004203bb4,%rax
  8004206980:	00 00 00 
  8004206983:	ff d0                	callq  *%rax
  8004206985:	85 c0                	test   %eax,%eax
  8004206987:	74 35                	je     80042069be <page_check+0xf9c>
  8004206989:	48 b9 50 66 21 04 80 	movabs $0x8004216650,%rcx
  8004206990:	00 00 00 
  8004206993:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420699a:	00 00 00 
  800420699d:	be 91 04 00 00       	mov    $0x491,%esi
  80042069a2:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042069a9:	00 00 00 
  80042069ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80042069b1:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042069b8:	00 00 00 
  80042069bb:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  80042069be:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  80042069c5:	00 00 00 
  80042069c8:	48 8b 00             	mov    (%rax),%rax
  80042069cb:	ba 00 00 00 00       	mov    $0x0,%edx
  80042069d0:	be 00 10 00 00       	mov    $0x1000,%esi
  80042069d5:	48 89 c7             	mov    %rax,%rdi
  80042069d8:	48 b8 6f 36 20 04 80 	movabs $0x800420366f,%rax
  80042069df:	00 00 00 
  80042069e2:	ff d0                	callq  *%rax
  80042069e4:	48 8b 00             	mov    (%rax),%rax
  80042069e7:	83 e0 04             	and    $0x4,%eax
  80042069ea:	48 85 c0             	test   %rax,%rax
  80042069ed:	74 35                	je     8004206a24 <page_check+0x1002>
  80042069ef:	48 b9 88 66 21 04 80 	movabs $0x8004216688,%rcx
  80042069f6:	00 00 00 
  80042069f9:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206a00:	00 00 00 
  8004206a03:	be 92 04 00 00       	mov    $0x492,%esi
  8004206a08:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206a0f:	00 00 00 
  8004206a12:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a17:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206a1e:	00 00 00 
  8004206a21:	41 ff d0             	callq  *%r8

	// should have pp1 at both 0 and PGSIZE
	assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  8004206a24:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206a2b:	00 00 00 
  8004206a2e:	48 8b 00             	mov    (%rax),%rax
  8004206a31:	be 00 00 00 00       	mov    $0x0,%esi
  8004206a36:	48 89 c7             	mov    %rax,%rdi
  8004206a39:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  8004206a40:	00 00 00 
  8004206a43:	ff d0                	callq  *%rax
  8004206a45:	48 89 c3             	mov    %rax,%rbx
  8004206a48:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206a4c:	48 89 c7             	mov    %rax,%rdi
  8004206a4f:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  8004206a56:	00 00 00 
  8004206a59:	ff d0                	callq  *%rax
  8004206a5b:	48 39 c3             	cmp    %rax,%rbx
  8004206a5e:	74 35                	je     8004206a95 <page_check+0x1073>
  8004206a60:	48 b9 c0 66 21 04 80 	movabs $0x80042166c0,%rcx
  8004206a67:	00 00 00 
  8004206a6a:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206a71:	00 00 00 
  8004206a74:	be 95 04 00 00       	mov    $0x495,%esi
  8004206a79:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206a80:	00 00 00 
  8004206a83:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a88:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206a8f:	00 00 00 
  8004206a92:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206a95:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206a9c:	00 00 00 
  8004206a9f:	48 8b 00             	mov    (%rax),%rax
  8004206aa2:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206aa7:	48 89 c7             	mov    %rax,%rdi
  8004206aaa:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  8004206ab1:	00 00 00 
  8004206ab4:	ff d0                	callq  *%rax
  8004206ab6:	48 89 c3             	mov    %rax,%rbx
  8004206ab9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206abd:	48 89 c7             	mov    %rax,%rdi
  8004206ac0:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  8004206ac7:	00 00 00 
  8004206aca:	ff d0                	callq  *%rax
  8004206acc:	48 39 c3             	cmp    %rax,%rbx
  8004206acf:	74 35                	je     8004206b06 <page_check+0x10e4>
  8004206ad1:	48 b9 f0 66 21 04 80 	movabs $0x80042166f0,%rcx
  8004206ad8:	00 00 00 
  8004206adb:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206ae2:	00 00 00 
  8004206ae5:	be 96 04 00 00       	mov    $0x496,%esi
  8004206aea:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206af1:	00 00 00 
  8004206af4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206af9:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206b00:	00 00 00 
  8004206b03:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
  8004206b06:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206b0a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206b0e:	66 83 f8 02          	cmp    $0x2,%ax
  8004206b12:	74 35                	je     8004206b49 <page_check+0x1127>
  8004206b14:	48 b9 20 67 21 04 80 	movabs $0x8004216720,%rcx
  8004206b1b:	00 00 00 
  8004206b1e:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206b25:	00 00 00 
  8004206b28:	be 98 04 00 00       	mov    $0x498,%esi
  8004206b2d:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206b34:	00 00 00 
  8004206b37:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b3c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206b43:	00 00 00 
  8004206b46:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206b49:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206b4d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206b51:	66 83 f8 01          	cmp    $0x1,%ax
  8004206b55:	74 35                	je     8004206b8c <page_check+0x116a>
  8004206b57:	48 b9 31 67 21 04 80 	movabs $0x8004216731,%rcx
  8004206b5e:	00 00 00 
  8004206b61:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206b68:	00 00 00 
  8004206b6b:	be 99 04 00 00       	mov    $0x499,%esi
  8004206b70:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206b77:	00 00 00 
  8004206b7a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b7f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206b86:	00 00 00 
  8004206b89:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(boot_pml4e, 0x0);
  8004206b8c:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206b93:	00 00 00 
  8004206b96:	48 8b 00             	mov    (%rax),%rax
  8004206b99:	be 00 00 00 00       	mov    $0x0,%esi
  8004206b9e:	48 89 c7             	mov    %rax,%rdi
  8004206ba1:	48 b8 64 3d 20 04 80 	movabs $0x8004203d64,%rax
  8004206ba8:	00 00 00 
  8004206bab:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206bad:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206bb4:	00 00 00 
  8004206bb7:	48 8b 00             	mov    (%rax),%rax
  8004206bba:	be 00 00 00 00       	mov    $0x0,%esi
  8004206bbf:	48 89 c7             	mov    %rax,%rdi
  8004206bc2:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  8004206bc9:	00 00 00 
  8004206bcc:	ff d0                	callq  *%rax
  8004206bce:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206bd2:	74 35                	je     8004206c09 <page_check+0x11e7>
  8004206bd4:	48 b9 48 67 21 04 80 	movabs $0x8004216748,%rcx
  8004206bdb:	00 00 00 
  8004206bde:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206be5:	00 00 00 
  8004206be8:	be 9e 04 00 00       	mov    $0x49e,%esi
  8004206bed:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206bf4:	00 00 00 
  8004206bf7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206bfc:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206c03:	00 00 00 
  8004206c06:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206c09:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206c10:	00 00 00 
  8004206c13:	48 8b 00             	mov    (%rax),%rax
  8004206c16:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206c1b:	48 89 c7             	mov    %rax,%rdi
  8004206c1e:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  8004206c25:	00 00 00 
  8004206c28:	ff d0                	callq  *%rax
  8004206c2a:	48 89 c3             	mov    %rax,%rbx
  8004206c2d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206c31:	48 89 c7             	mov    %rax,%rdi
  8004206c34:	48 b8 a1 22 20 04 80 	movabs $0x80042022a1,%rax
  8004206c3b:	00 00 00 
  8004206c3e:	ff d0                	callq  *%rax
  8004206c40:	48 39 c3             	cmp    %rax,%rbx
  8004206c43:	74 35                	je     8004206c7a <page_check+0x1258>
  8004206c45:	48 b9 f0 66 21 04 80 	movabs $0x80042166f0,%rcx
  8004206c4c:	00 00 00 
  8004206c4f:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206c56:	00 00 00 
  8004206c59:	be 9f 04 00 00       	mov    $0x49f,%esi
  8004206c5e:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206c65:	00 00 00 
  8004206c68:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c6d:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206c74:	00 00 00 
  8004206c77:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004206c7a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206c7e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206c82:	66 83 f8 01          	cmp    $0x1,%ax
  8004206c86:	74 35                	je     8004206cbd <page_check+0x129b>
  8004206c88:	48 b9 95 64 21 04 80 	movabs $0x8004216495,%rcx
  8004206c8f:	00 00 00 
  8004206c92:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206c99:	00 00 00 
  8004206c9c:	be a0 04 00 00       	mov    $0x4a0,%esi
  8004206ca1:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206ca8:	00 00 00 
  8004206cab:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206cb0:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206cb7:	00 00 00 
  8004206cba:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206cbd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206cc1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206cc5:	66 83 f8 01          	cmp    $0x1,%ax
  8004206cc9:	74 35                	je     8004206d00 <page_check+0x12de>
  8004206ccb:	48 b9 31 67 21 04 80 	movabs $0x8004216731,%rcx
  8004206cd2:	00 00 00 
  8004206cd5:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206cdc:	00 00 00 
  8004206cdf:	be a1 04 00 00       	mov    $0x4a1,%esi
  8004206ce4:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206ceb:	00 00 00 
  8004206cee:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206cf3:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206cfa:	00 00 00 
  8004206cfd:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004206d00:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206d07:	00 00 00 
  8004206d0a:	48 8b 00             	mov    (%rax),%rax
  8004206d0d:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206d11:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206d16:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206d1b:	48 89 c7             	mov    %rax,%rdi
  8004206d1e:	48 b8 b4 3b 20 04 80 	movabs $0x8004203bb4,%rax
  8004206d25:	00 00 00 
  8004206d28:	ff d0                	callq  *%rax
  8004206d2a:	85 c0                	test   %eax,%eax
  8004206d2c:	74 35                	je     8004206d63 <page_check+0x1341>
  8004206d2e:	48 b9 50 66 21 04 80 	movabs $0x8004216650,%rcx
  8004206d35:	00 00 00 
  8004206d38:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206d3f:	00 00 00 
  8004206d42:	be a5 04 00 00       	mov    $0x4a5,%esi
  8004206d47:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206d4e:	00 00 00 
  8004206d51:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d56:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206d5d:	00 00 00 
  8004206d60:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref);
  8004206d63:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206d67:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206d6b:	66 85 c0             	test   %ax,%ax
  8004206d6e:	75 35                	jne    8004206da5 <page_check+0x1383>
  8004206d70:	48 b9 6b 67 21 04 80 	movabs $0x800421676b,%rcx
  8004206d77:	00 00 00 
  8004206d7a:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206d81:	00 00 00 
  8004206d84:	be a6 04 00 00       	mov    $0x4a6,%esi
  8004206d89:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206d90:	00 00 00 
  8004206d93:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d98:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206d9f:	00 00 00 
  8004206da2:	41 ff d0             	callq  *%r8
	assert(pp1->pp_link == NULL);
  8004206da5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206da9:	48 8b 00             	mov    (%rax),%rax
  8004206dac:	48 85 c0             	test   %rax,%rax
  8004206daf:	74 35                	je     8004206de6 <page_check+0x13c4>
  8004206db1:	48 b9 77 67 21 04 80 	movabs $0x8004216777,%rcx
  8004206db8:	00 00 00 
  8004206dbb:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206dc2:	00 00 00 
  8004206dc5:	be a7 04 00 00       	mov    $0x4a7,%esi
  8004206dca:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206dd1:	00 00 00 
  8004206dd4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206dd9:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206de0:	00 00 00 
  8004206de3:	41 ff d0             	callq  *%r8

	// unmapping pp1 at PGSIZE should free it
	page_remove(boot_pml4e, (void*) PGSIZE);
  8004206de6:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206ded:	00 00 00 
  8004206df0:	48 8b 00             	mov    (%rax),%rax
  8004206df3:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206df8:	48 89 c7             	mov    %rax,%rdi
  8004206dfb:	48 b8 64 3d 20 04 80 	movabs $0x8004203d64,%rax
  8004206e02:	00 00 00 
  8004206e05:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206e07:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206e0e:	00 00 00 
  8004206e11:	48 8b 00             	mov    (%rax),%rax
  8004206e14:	be 00 00 00 00       	mov    $0x0,%esi
  8004206e19:	48 89 c7             	mov    %rax,%rdi
  8004206e1c:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  8004206e23:	00 00 00 
  8004206e26:	ff d0                	callq  *%rax
  8004206e28:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206e2c:	74 35                	je     8004206e63 <page_check+0x1441>
  8004206e2e:	48 b9 48 67 21 04 80 	movabs $0x8004216748,%rcx
  8004206e35:	00 00 00 
  8004206e38:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206e3f:	00 00 00 
  8004206e42:	be ab 04 00 00       	mov    $0x4ab,%esi
  8004206e47:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206e4e:	00 00 00 
  8004206e51:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e56:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206e5d:	00 00 00 
  8004206e60:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  8004206e63:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206e6a:	00 00 00 
  8004206e6d:	48 8b 00             	mov    (%rax),%rax
  8004206e70:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206e75:	48 89 c7             	mov    %rax,%rdi
  8004206e78:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  8004206e7f:	00 00 00 
  8004206e82:	ff d0                	callq  *%rax
  8004206e84:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206e88:	74 35                	je     8004206ebf <page_check+0x149d>
  8004206e8a:	48 b9 90 67 21 04 80 	movabs $0x8004216790,%rcx
  8004206e91:	00 00 00 
  8004206e94:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206e9b:	00 00 00 
  8004206e9e:	be ac 04 00 00       	mov    $0x4ac,%esi
  8004206ea3:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206eaa:	00 00 00 
  8004206ead:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206eb2:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206eb9:	00 00 00 
  8004206ebc:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  8004206ebf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206ec3:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206ec7:	66 85 c0             	test   %ax,%ax
  8004206eca:	74 35                	je     8004206f01 <page_check+0x14df>
  8004206ecc:	48 b9 b6 67 21 04 80 	movabs $0x80042167b6,%rcx
  8004206ed3:	00 00 00 
  8004206ed6:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206edd:	00 00 00 
  8004206ee0:	be ad 04 00 00       	mov    $0x4ad,%esi
  8004206ee5:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206eec:	00 00 00 
  8004206eef:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ef4:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206efb:	00 00 00 
  8004206efe:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206f01:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206f05:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206f09:	66 83 f8 01          	cmp    $0x1,%ax
  8004206f0d:	74 35                	je     8004206f44 <page_check+0x1522>
  8004206f0f:	48 b9 31 67 21 04 80 	movabs $0x8004216731,%rcx
  8004206f16:	00 00 00 
  8004206f19:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206f20:	00 00 00 
  8004206f23:	be ae 04 00 00       	mov    $0x4ae,%esi
  8004206f28:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206f2f:	00 00 00 
  8004206f32:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f37:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206f3e:	00 00 00 
  8004206f41:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif

	// forcibly take pp3 back
	struct PageInfo *pp_l1 = pa2page(PTE_ADDR(boot_pml4e[0]));
  8004206f44:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206f4b:	00 00 00 
  8004206f4e:	48 8b 00             	mov    (%rax),%rax
  8004206f51:	48 8b 00             	mov    (%rax),%rax
  8004206f54:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206f5a:	48 89 c7             	mov    %rax,%rdi
  8004206f5d:	48 b8 c6 22 20 04 80 	movabs $0x80042022c6,%rax
  8004206f64:	00 00 00 
  8004206f67:	ff d0                	callq  *%rax
  8004206f69:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
	boot_pml4e[0] = 0;
  8004206f70:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004206f77:	00 00 00 
  8004206f7a:	48 8b 00             	mov    (%rax),%rax
  8004206f7d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  8004206f84:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206f88:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206f8c:	66 83 f8 01          	cmp    $0x1,%ax
  8004206f90:	74 35                	je     8004206fc7 <page_check+0x15a5>
  8004206f92:	48 b9 31 67 21 04 80 	movabs $0x8004216731,%rcx
  8004206f99:	00 00 00 
  8004206f9c:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004206fa3:	00 00 00 
  8004206fa6:	be c4 04 00 00       	mov    $0x4c4,%esi
  8004206fab:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004206fb2:	00 00 00 
  8004206fb5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206fba:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004206fc1:	00 00 00 
  8004206fc4:	41 ff d0             	callq  *%r8
	page_decref(pp_l1);
  8004206fc7:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206fce:	48 89 c7             	mov    %rax,%rdi
  8004206fd1:	48 b8 2e 36 20 04 80 	movabs $0x800420362e,%rax
  8004206fd8:	00 00 00 
  8004206fdb:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	if (pp_l1 != pp3) page_decref(pp3);
  8004206fdd:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206fe4:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004206fe8:	74 13                	je     8004206ffd <page_check+0x15db>
  8004206fea:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206fee:	48 89 c7             	mov    %rax,%rdi
  8004206ff1:	48 b8 2e 36 20 04 80 	movabs $0x800420362e,%rax
  8004206ff8:	00 00 00 
  8004206ffb:	ff d0                	callq  *%rax
	if (pp_l1 != pp2) page_decref(pp2);
  8004206ffd:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004207004:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004207008:	74 13                	je     800420701d <page_check+0x15fb>
  800420700a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420700e:	48 89 c7             	mov    %rax,%rdi
  8004207011:	48 b8 2e 36 20 04 80 	movabs $0x800420362e,%rax
  8004207018:	00 00 00 
  800420701b:	ff d0                	callq  *%rax
	if (pp_l1 != pp0) page_decref(pp0);
  800420701d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004207024:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004207028:	74 13                	je     800420703d <page_check+0x161b>
  800420702a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420702e:	48 89 c7             	mov    %rax,%rdi
  8004207031:	48 b8 2e 36 20 04 80 	movabs $0x800420362e,%rax
  8004207038:	00 00 00 
  800420703b:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  800420703d:	48 c7 85 60 ff ff ff 	movq   $0x64000,-0xa0(%rbp)
  8004207044:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  8004207048:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  800420704f:	00 00 00 
  8004207052:	48 8b 00             	mov    (%rax),%rax
  8004207055:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420705c:	ba 01 00 00 00       	mov    $0x1,%edx
  8004207061:	48 89 ce             	mov    %rcx,%rsi
  8004207064:	48 89 c7             	mov    %rax,%rdi
  8004207067:	48 b8 6f 36 20 04 80 	movabs $0x800420366f,%rax
  800420706e:	00 00 00 
  8004207071:	ff d0                	callq  *%rax
  8004207073:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  800420707a:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004207081:	00 00 00 
  8004207084:	48 8b 00             	mov    (%rax),%rax
  8004207087:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420708e:	48 c1 ea 27          	shr    $0x27,%rdx
  8004207092:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004207098:	48 c1 e2 03          	shl    $0x3,%rdx
  800420709c:	48 01 d0             	add    %rdx,%rax
  800420709f:	48 8b 00             	mov    (%rax),%rax
  80042070a2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042070a8:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  80042070af:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042070b6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042070ba:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
  80042070c0:	8b 95 54 ff ff ff    	mov    -0xac(%rbp),%edx
  80042070c6:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  80042070cd:	00 00 00 
  80042070d0:	48 8b 00             	mov    (%rax),%rax
  80042070d3:	48 39 c2             	cmp    %rax,%rdx
  80042070d6:	72 35                	jb     800420710d <page_check+0x16eb>
  80042070d8:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042070df:	48 89 c1             	mov    %rax,%rcx
  80042070e2:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  80042070e9:	00 00 00 
  80042070ec:	be cc 04 00 00       	mov    $0x4cc,%esi
  80042070f1:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042070f8:	00 00 00 
  80042070fb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207100:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207107:	00 00 00 
  800420710a:	41 ff d0             	callq  *%r8
  800420710d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207114:	00 00 00 
  8004207117:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420711e:	48 01 d0             	add    %rdx,%rax
  8004207121:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004207125:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420712c:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004207130:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004207135:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420713c:	00 
  800420713d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004207141:	48 01 d0             	add    %rdx,%rax
  8004207144:	48 8b 00             	mov    (%rax),%rax
  8004207147:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420714d:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
  8004207154:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420715b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420715f:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
  8004207165:	8b 95 44 ff ff ff    	mov    -0xbc(%rbp),%edx
  800420716b:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004207172:	00 00 00 
  8004207175:	48 8b 00             	mov    (%rax),%rax
  8004207178:	48 39 c2             	cmp    %rax,%rdx
  800420717b:	72 35                	jb     80042071b2 <page_check+0x1790>
  800420717d:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004207184:	48 89 c1             	mov    %rax,%rcx
  8004207187:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  800420718e:	00 00 00 
  8004207191:	be cd 04 00 00       	mov    $0x4cd,%esi
  8004207196:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420719d:	00 00 00 
  80042071a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042071a5:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042071ac:	00 00 00 
  80042071af:	41 ff d0             	callq  *%r8
  80042071b2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042071b9:	00 00 00 
  80042071bc:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042071c3:	48 01 d0             	add    %rdx,%rax
  80042071c6:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  80042071ca:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042071d1:	48 c1 e8 15          	shr    $0x15,%rax
  80042071d5:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042071da:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042071e1:	00 
  80042071e2:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042071e6:	48 01 d0             	add    %rdx,%rax
  80042071e9:	48 8b 00             	mov    (%rax),%rax
  80042071ec:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042071f2:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  80042071f9:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004207200:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207204:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)
  800420720a:	8b 95 34 ff ff ff    	mov    -0xcc(%rbp),%edx
  8004207210:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004207217:	00 00 00 
  800420721a:	48 8b 00             	mov    (%rax),%rax
  800420721d:	48 39 c2             	cmp    %rax,%rdx
  8004207220:	72 35                	jb     8004207257 <page_check+0x1835>
  8004207222:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004207229:	48 89 c1             	mov    %rax,%rcx
  800420722c:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  8004207233:	00 00 00 
  8004207236:	be ce 04 00 00       	mov    $0x4ce,%esi
  800420723b:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004207242:	00 00 00 
  8004207245:	b8 00 00 00 00       	mov    $0x0,%eax
  800420724a:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207251:	00 00 00 
  8004207254:	41 ff d0             	callq  *%r8
  8004207257:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420725e:	00 00 00 
  8004207261:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004207268:	48 01 d0             	add    %rdx,%rax
  800420726b:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	assert(ptep == ptep1 + PTX(va));
  8004207272:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004207279:	48 c1 e8 0c          	shr    $0xc,%rax
  800420727d:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004207282:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207289:	00 
  800420728a:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004207291:	48 01 c2             	add    %rax,%rdx
  8004207294:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  800420729b:	48 39 c2             	cmp    %rax,%rdx
  800420729e:	74 35                	je     80042072d5 <page_check+0x18b3>
  80042072a0:	48 b9 c7 67 21 04 80 	movabs $0x80042167c7,%rcx
  80042072a7:	00 00 00 
  80042072aa:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042072b1:	00 00 00 
  80042072b4:	be cf 04 00 00       	mov    $0x4cf,%esi
  80042072b9:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042072c0:	00 00 00 
  80042072c3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042072c8:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042072cf:	00 00 00 
  80042072d2:	41 ff d0             	callq  *%r8

	// check that new page tables get cleared
	memset(page2kva(pp4), 0xFF, PGSIZE);
  80042072d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042072d9:	48 89 c7             	mov    %rax,%rdi
  80042072dc:	48 b8 37 23 20 04 80 	movabs $0x8004202337,%rax
  80042072e3:	00 00 00 
  80042072e6:	ff d0                	callq  *%rax
  80042072e8:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042072ed:	be ff 00 00 00       	mov    $0xff,%esi
  80042072f2:	48 89 c7             	mov    %rax,%rdi
  80042072f5:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  80042072fc:	00 00 00 
  80042072ff:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  8004207301:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004207308:	00 00 00 
  800420730b:	48 8b 00             	mov    (%rax),%rax
  800420730e:	ba 01 00 00 00       	mov    $0x1,%edx
  8004207313:	be 00 00 00 00       	mov    $0x0,%esi
  8004207318:	48 89 c7             	mov    %rax,%rdi
  800420731b:	48 b8 6f 36 20 04 80 	movabs $0x800420366f,%rax
  8004207322:	00 00 00 
  8004207325:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  8004207327:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  800420732e:	00 00 00 
  8004207331:	48 8b 00             	mov    (%rax),%rax
  8004207334:	48 8b 00             	mov    (%rax),%rax
  8004207337:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420733d:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  8004207344:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  800420734b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420734f:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
  8004207355:	8b 95 1c ff ff ff    	mov    -0xe4(%rbp),%edx
  800420735b:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004207362:	00 00 00 
  8004207365:	48 8b 00             	mov    (%rax),%rax
  8004207368:	48 39 c2             	cmp    %rax,%rdx
  800420736b:	72 35                	jb     80042073a2 <page_check+0x1980>
  800420736d:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  8004207374:	48 89 c1             	mov    %rax,%rcx
  8004207377:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  800420737e:	00 00 00 
  8004207381:	be d4 04 00 00       	mov    $0x4d4,%esi
  8004207386:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420738d:	00 00 00 
  8004207390:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207395:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420739c:	00 00 00 
  800420739f:	41 ff d0             	callq  *%r8
  80042073a2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042073a9:	00 00 00 
  80042073ac:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  80042073b3:	48 01 d0             	add    %rdx,%rax
  80042073b6:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[0]));
  80042073ba:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042073be:	48 8b 00             	mov    (%rax),%rax
  80042073c1:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042073c7:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  80042073ce:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042073d5:	48 c1 e8 0c          	shr    $0xc,%rax
  80042073d9:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
  80042073df:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  80042073e5:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  80042073ec:	00 00 00 
  80042073ef:	48 8b 00             	mov    (%rax),%rax
  80042073f2:	48 39 c2             	cmp    %rax,%rdx
  80042073f5:	72 35                	jb     800420742c <page_check+0x1a0a>
  80042073f7:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042073fe:	48 89 c1             	mov    %rax,%rcx
  8004207401:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  8004207408:	00 00 00 
  800420740b:	be d5 04 00 00       	mov    $0x4d5,%esi
  8004207410:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004207417:	00 00 00 
  800420741a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420741f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207426:	00 00 00 
  8004207429:	41 ff d0             	callq  *%r8
  800420742c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207433:	00 00 00 
  8004207436:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  800420743d:	48 01 d0             	add    %rdx,%rax
  8004207440:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep  = KADDR(PTE_ADDR(pde[0]));
  8004207444:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004207448:	48 8b 00             	mov    (%rax),%rax
  800420744b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207451:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  8004207458:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  800420745f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207463:	89 85 fc fe ff ff    	mov    %eax,-0x104(%rbp)
  8004207469:	8b 95 fc fe ff ff    	mov    -0x104(%rbp),%edx
  800420746f:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004207476:	00 00 00 
  8004207479:	48 8b 00             	mov    (%rax),%rax
  800420747c:	48 39 c2             	cmp    %rax,%rdx
  800420747f:	72 35                	jb     80042074b6 <page_check+0x1a94>
  8004207481:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  8004207488:	48 89 c1             	mov    %rax,%rcx
  800420748b:	48 ba 30 5b 21 04 80 	movabs $0x8004215b30,%rdx
  8004207492:	00 00 00 
  8004207495:	be d6 04 00 00       	mov    $0x4d6,%esi
  800420749a:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042074a1:	00 00 00 
  80042074a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042074a9:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042074b0:	00 00 00 
  80042074b3:	41 ff d0             	callq  *%r8
  80042074b6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042074bd:	00 00 00 
  80042074c0:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  80042074c7:	48 01 d0             	add    %rdx,%rax
  80042074ca:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	for(i=0; i<NPTENTRIES; i++)
  80042074d1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042074d8:	eb 58                	jmp    8004207532 <page_check+0x1b10>
		assert((ptep[i] & PTE_P) == 0);
  80042074da:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  80042074e1:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042074e4:	48 63 d2             	movslq %edx,%rdx
  80042074e7:	48 c1 e2 03          	shl    $0x3,%rdx
  80042074eb:	48 01 d0             	add    %rdx,%rax
  80042074ee:	48 8b 00             	mov    (%rax),%rax
  80042074f1:	83 e0 01             	and    $0x1,%eax
  80042074f4:	48 85 c0             	test   %rax,%rax
  80042074f7:	74 35                	je     800420752e <page_check+0x1b0c>
  80042074f9:	48 b9 df 67 21 04 80 	movabs $0x80042167df,%rcx
  8004207500:	00 00 00 
  8004207503:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420750a:	00 00 00 
  800420750d:	be d8 04 00 00       	mov    $0x4d8,%esi
  8004207512:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004207519:	00 00 00 
  800420751c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207521:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207528:	00 00 00 
  800420752b:	41 ff d0             	callq  *%r8
	memset(page2kva(pp4), 0xFF, PGSIZE);
	pml4e_walk(boot_pml4e, 0x0, 1);
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
	pde  = KADDR(PTE_ADDR(pdpe[0]));
	ptep  = KADDR(PTE_ADDR(pde[0]));
	for(i=0; i<NPTENTRIES; i++)
  800420752e:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004207532:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  8004207539:	7e 9f                	jle    80042074da <page_check+0x1ab8>
		assert((ptep[i] & PTE_P) == 0);
	boot_pml4e[0] = 0;
  800420753b:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004207542:	00 00 00 
  8004207545:	48 8b 00             	mov    (%rax),%rax
  8004207548:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  800420754f:	48 b8 38 d2 49 04 80 	movabs $0x800449d238,%rax
  8004207556:	00 00 00 
  8004207559:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420755d:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  8004207560:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207564:	48 89 c7             	mov    %rax,%rdi
  8004207567:	48 b8 2e 36 20 04 80 	movabs $0x800420362e,%rax
  800420756e:	00 00 00 
  8004207571:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004207573:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207577:	48 89 c7             	mov    %rax,%rdi
  800420757a:	48 b8 2e 36 20 04 80 	movabs $0x800420362e,%rax
  8004207581:	00 00 00 
  8004207584:	ff d0                	callq  *%rax
	page_decref(pp3);
  8004207586:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420758a:	48 89 c7             	mov    %rax,%rdi
  800420758d:	48 b8 2e 36 20 04 80 	movabs $0x800420362e,%rax
  8004207594:	00 00 00 
  8004207597:	ff d0                	callq  *%rax

	// Triple check that we got the ref counts right
	assert(pp0->pp_ref == 0);
  8004207599:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420759d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042075a1:	66 85 c0             	test   %ax,%ax
  80042075a4:	74 35                	je     80042075db <page_check+0x1bb9>
  80042075a6:	48 b9 f6 67 21 04 80 	movabs $0x80042167f6,%rcx
  80042075ad:	00 00 00 
  80042075b0:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042075b7:	00 00 00 
  80042075ba:	be e4 04 00 00       	mov    $0x4e4,%esi
  80042075bf:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042075c6:	00 00 00 
  80042075c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042075ce:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042075d5:	00 00 00 
  80042075d8:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  80042075db:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042075df:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042075e3:	66 85 c0             	test   %ax,%ax
  80042075e6:	74 35                	je     800420761d <page_check+0x1bfb>
  80042075e8:	48 b9 b6 67 21 04 80 	movabs $0x80042167b6,%rcx
  80042075ef:	00 00 00 
  80042075f2:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042075f9:	00 00 00 
  80042075fc:	be e5 04 00 00       	mov    $0x4e5,%esi
  8004207601:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004207608:	00 00 00 
  800420760b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207610:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207617:	00 00 00 
  800420761a:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 0);
  800420761d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207621:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207625:	66 85 c0             	test   %ax,%ax
  8004207628:	74 35                	je     800420765f <page_check+0x1c3d>
  800420762a:	48 b9 07 68 21 04 80 	movabs $0x8004216807,%rcx
  8004207631:	00 00 00 
  8004207634:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420763b:	00 00 00 
  800420763e:	be e6 04 00 00       	mov    $0x4e6,%esi
  8004207643:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420764a:	00 00 00 
  800420764d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207652:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207659:	00 00 00 
  800420765c:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 0);
  800420765f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207663:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207667:	66 85 c0             	test   %ax,%ax
  800420766a:	74 35                	je     80042076a1 <page_check+0x1c7f>
  800420766c:	48 b9 18 68 21 04 80 	movabs $0x8004216818,%rcx
  8004207673:	00 00 00 
  8004207676:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420767d:	00 00 00 
  8004207680:	be e7 04 00 00       	mov    $0x4e7,%esi
  8004207685:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420768c:	00 00 00 
  800420768f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207694:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420769b:	00 00 00 
  800420769e:	41 ff d0             	callq  *%r8
	assert(pp4->pp_ref == 0);
  80042076a1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042076a5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042076a9:	66 85 c0             	test   %ax,%ax
  80042076ac:	74 35                	je     80042076e3 <page_check+0x1cc1>
  80042076ae:	48 b9 29 68 21 04 80 	movabs $0x8004216829,%rcx
  80042076b5:	00 00 00 
  80042076b8:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042076bf:	00 00 00 
  80042076c2:	be e8 04 00 00       	mov    $0x4e8,%esi
  80042076c7:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042076ce:	00 00 00 
  80042076d1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042076d6:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042076dd:	00 00 00 
  80042076e0:	41 ff d0             	callq  *%r8
	assert(pp5->pp_ref == 0);
  80042076e3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042076e7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042076eb:	66 85 c0             	test   %ax,%ax
  80042076ee:	74 35                	je     8004207725 <page_check+0x1d03>
  80042076f0:	48 b9 3a 68 21 04 80 	movabs $0x800421683a,%rcx
  80042076f7:	00 00 00 
  80042076fa:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004207701:	00 00 00 
  8004207704:	be e9 04 00 00       	mov    $0x4e9,%esi
  8004207709:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004207710:	00 00 00 
  8004207713:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207718:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420771f:	00 00 00 
  8004207722:	41 ff d0             	callq  *%r8

	// test mmio_map_region
	mm1 = (uintptr_t) mmio_map_region(0, 4097);
  8004207725:	be 01 10 00 00       	mov    $0x1001,%esi
  800420772a:	bf 00 00 00 00       	mov    $0x0,%edi
  800420772f:	48 b8 b5 3e 20 04 80 	movabs $0x8004203eb5,%rax
  8004207736:	00 00 00 
  8004207739:	ff d0                	callq  *%rax
  800420773b:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	mm2 = (uintptr_t) mmio_map_region(0, 4096);
  8004207742:	be 00 10 00 00       	mov    $0x1000,%esi
  8004207747:	bf 00 00 00 00       	mov    $0x0,%edi
  800420774c:	48 b8 b5 3e 20 04 80 	movabs $0x8004203eb5,%rax
  8004207753:	00 00 00 
  8004207756:	ff d0                	callq  *%rax
  8004207758:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	// check that they're in the right region
	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
  800420775f:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004207766:	00 00 00 
  8004207769:	48 39 85 f0 fe ff ff 	cmp    %rax,-0x110(%rbp)
  8004207770:	76 1d                	jbe    800420778f <page_check+0x1d6d>
  8004207772:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207779:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004207780:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004207787:	00 00 00 
  800420778a:	48 39 c2             	cmp    %rax,%rdx
  800420778d:	76 35                	jbe    80042077c4 <page_check+0x1da2>
  800420778f:	48 b9 50 68 21 04 80 	movabs $0x8004216850,%rcx
  8004207796:	00 00 00 
  8004207799:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042077a0:	00 00 00 
  80042077a3:	be ef 04 00 00       	mov    $0x4ef,%esi
  80042077a8:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042077af:	00 00 00 
  80042077b2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042077b7:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042077be:	00 00 00 
  80042077c1:	41 ff d0             	callq  *%r8
	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
  80042077c4:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  80042077cb:	00 00 00 
  80042077ce:	48 39 85 e8 fe ff ff 	cmp    %rax,-0x118(%rbp)
  80042077d5:	76 1d                	jbe    80042077f4 <page_check+0x1dd2>
  80042077d7:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  80042077de:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  80042077e5:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  80042077ec:	00 00 00 
  80042077ef:	48 39 c2             	cmp    %rax,%rdx
  80042077f2:	76 35                	jbe    8004207829 <page_check+0x1e07>
  80042077f4:	48 b9 78 68 21 04 80 	movabs $0x8004216878,%rcx
  80042077fb:	00 00 00 
  80042077fe:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004207805:	00 00 00 
  8004207808:	be f0 04 00 00       	mov    $0x4f0,%esi
  800420780d:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004207814:	00 00 00 
  8004207817:	b8 00 00 00 00       	mov    $0x0,%eax
  800420781c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207823:	00 00 00 
  8004207826:	41 ff d0             	callq  *%r8
	// check that they're page-aligned
	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
  8004207829:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207830:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004207835:	48 85 c0             	test   %rax,%rax
  8004207838:	75 11                	jne    800420784b <page_check+0x1e29>
  800420783a:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004207841:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004207846:	48 85 c0             	test   %rax,%rax
  8004207849:	74 35                	je     8004207880 <page_check+0x1e5e>
  800420784b:	48 b9 a0 68 21 04 80 	movabs $0x80042168a0,%rcx
  8004207852:	00 00 00 
  8004207855:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  800420785c:	00 00 00 
  800420785f:	be f2 04 00 00       	mov    $0x4f2,%esi
  8004207864:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  800420786b:	00 00 00 
  800420786e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207873:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420787a:	00 00 00 
  800420787d:	41 ff d0             	callq  *%r8
	// check that they don't overlap
	assert(mm1 + 8096 <= mm2);
  8004207880:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207887:	48 05 a0 1f 00 00    	add    $0x1fa0,%rax
  800420788d:	48 3b 85 e8 fe ff ff 	cmp    -0x118(%rbp),%rax
  8004207894:	76 35                	jbe    80042078cb <page_check+0x1ea9>
  8004207896:	48 b9 c7 68 21 04 80 	movabs $0x80042168c7,%rcx
  800420789d:	00 00 00 
  80042078a0:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042078a7:	00 00 00 
  80042078aa:	be f4 04 00 00       	mov    $0x4f4,%esi
  80042078af:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042078b6:	00 00 00 
  80042078b9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042078be:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042078c5:	00 00 00 
  80042078c8:	41 ff d0             	callq  *%r8
	// check page mappings

	assert(check_va2pa(boot_pml4e, mm1) == 0);
  80042078cb:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  80042078d2:	00 00 00 
  80042078d5:	48 8b 00             	mov    (%rax),%rax
  80042078d8:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  80042078df:	48 89 d6             	mov    %rdx,%rsi
  80042078e2:	48 89 c7             	mov    %rax,%rdi
  80042078e5:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  80042078ec:	00 00 00 
  80042078ef:	ff d0                	callq  *%rax
  80042078f1:	48 85 c0             	test   %rax,%rax
  80042078f4:	74 35                	je     800420792b <page_check+0x1f09>
  80042078f6:	48 b9 e0 68 21 04 80 	movabs $0x80042168e0,%rcx
  80042078fd:	00 00 00 
  8004207900:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004207907:	00 00 00 
  800420790a:	be f7 04 00 00       	mov    $0x4f7,%esi
  800420790f:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004207916:	00 00 00 
  8004207919:	b8 00 00 00 00       	mov    $0x0,%eax
  800420791e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207925:	00 00 00 
  8004207928:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm1+PGSIZE) == PGSIZE);
  800420792b:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207932:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207939:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004207940:	00 00 00 
  8004207943:	48 8b 00             	mov    (%rax),%rax
  8004207946:	48 89 d6             	mov    %rdx,%rsi
  8004207949:	48 89 c7             	mov    %rax,%rdi
  800420794c:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  8004207953:	00 00 00 
  8004207956:	ff d0                	callq  *%rax
  8004207958:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  800420795e:	74 35                	je     8004207995 <page_check+0x1f73>
  8004207960:	48 b9 08 69 21 04 80 	movabs $0x8004216908,%rcx
  8004207967:	00 00 00 
  800420796a:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004207971:	00 00 00 
  8004207974:	be f8 04 00 00       	mov    $0x4f8,%esi
  8004207979:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004207980:	00 00 00 
  8004207983:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207988:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420798f:	00 00 00 
  8004207992:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2) == 0);
  8004207995:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  800420799c:	00 00 00 
  800420799f:	48 8b 00             	mov    (%rax),%rax
  80042079a2:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
  80042079a9:	48 89 d6             	mov    %rdx,%rsi
  80042079ac:	48 89 c7             	mov    %rax,%rdi
  80042079af:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  80042079b6:	00 00 00 
  80042079b9:	ff d0                	callq  *%rax
  80042079bb:	48 85 c0             	test   %rax,%rax
  80042079be:	74 35                	je     80042079f5 <page_check+0x1fd3>
  80042079c0:	48 b9 38 69 21 04 80 	movabs $0x8004216938,%rcx
  80042079c7:	00 00 00 
  80042079ca:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  80042079d1:	00 00 00 
  80042079d4:	be f9 04 00 00       	mov    $0x4f9,%esi
  80042079d9:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  80042079e0:	00 00 00 
  80042079e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042079e8:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042079ef:	00 00 00 
  80042079f2:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2+PGSIZE) == ~0);
  80042079f5:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  80042079fc:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207a03:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004207a0a:	00 00 00 
  8004207a0d:	48 8b 00             	mov    (%rax),%rax
  8004207a10:	48 89 d6             	mov    %rdx,%rsi
  8004207a13:	48 89 c7             	mov    %rax,%rdi
  8004207a16:	48 b8 a8 57 20 04 80 	movabs $0x80042057a8,%rax
  8004207a1d:	00 00 00 
  8004207a20:	ff d0                	callq  *%rax
  8004207a22:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004207a26:	74 35                	je     8004207a5d <page_check+0x203b>
  8004207a28:	48 b9 60 69 21 04 80 	movabs $0x8004216960,%rcx
  8004207a2f:	00 00 00 
  8004207a32:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004207a39:	00 00 00 
  8004207a3c:	be fa 04 00 00       	mov    $0x4fa,%esi
  8004207a41:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004207a48:	00 00 00 
  8004207a4b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207a50:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207a57:	00 00 00 
  8004207a5a:	41 ff d0             	callq  *%r8
	// check permissions
	assert(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
  8004207a5d:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207a64:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004207a6b:	00 00 00 
  8004207a6e:	48 8b 00             	mov    (%rax),%rax
  8004207a71:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207a76:	48 89 ce             	mov    %rcx,%rsi
  8004207a79:	48 89 c7             	mov    %rax,%rdi
  8004207a7c:	48 b8 6f 36 20 04 80 	movabs $0x800420366f,%rax
  8004207a83:	00 00 00 
  8004207a86:	ff d0                	callq  *%rax
  8004207a88:	48 8b 00             	mov    (%rax),%rax
  8004207a8b:	83 e0 1a             	and    $0x1a,%eax
  8004207a8e:	48 85 c0             	test   %rax,%rax
  8004207a91:	75 35                	jne    8004207ac8 <page_check+0x20a6>
  8004207a93:	48 b9 90 69 21 04 80 	movabs $0x8004216990,%rcx
  8004207a9a:	00 00 00 
  8004207a9d:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004207aa4:	00 00 00 
  8004207aa7:	be fc 04 00 00       	mov    $0x4fc,%esi
  8004207aac:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004207ab3:	00 00 00 
  8004207ab6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207abb:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207ac2:	00 00 00 
  8004207ac5:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & PTE_U));
  8004207ac8:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207acf:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004207ad6:	00 00 00 
  8004207ad9:	48 8b 00             	mov    (%rax),%rax
  8004207adc:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207ae1:	48 89 ce             	mov    %rcx,%rsi
  8004207ae4:	48 89 c7             	mov    %rax,%rdi
  8004207ae7:	48 b8 6f 36 20 04 80 	movabs $0x800420366f,%rax
  8004207aee:	00 00 00 
  8004207af1:	ff d0                	callq  *%rax
  8004207af3:	48 8b 00             	mov    (%rax),%rax
  8004207af6:	83 e0 04             	and    $0x4,%eax
  8004207af9:	48 85 c0             	test   %rax,%rax
  8004207afc:	74 35                	je     8004207b33 <page_check+0x2111>
  8004207afe:	48 b9 d8 69 21 04 80 	movabs $0x80042169d8,%rcx
  8004207b05:	00 00 00 
  8004207b08:	48 ba b9 5b 21 04 80 	movabs $0x8004215bb9,%rdx
  8004207b0f:	00 00 00 
  8004207b12:	be fd 04 00 00       	mov    $0x4fd,%esi
  8004207b17:	48 bf ce 5b 21 04 80 	movabs $0x8004215bce,%rdi
  8004207b1e:	00 00 00 
  8004207b21:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207b26:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207b2d:	00 00 00 
  8004207b30:	41 ff d0             	callq  *%r8
	// clear the mappings
	*pml4e_walk(boot_pml4e, (void*) mm1, 0) = 0;
  8004207b33:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207b3a:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004207b41:	00 00 00 
  8004207b44:	48 8b 00             	mov    (%rax),%rax
  8004207b47:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207b4c:	48 89 ce             	mov    %rcx,%rsi
  8004207b4f:	48 89 c7             	mov    %rax,%rdi
  8004207b52:	48 b8 6f 36 20 04 80 	movabs $0x800420366f,%rax
  8004207b59:	00 00 00 
  8004207b5c:	ff d0                	callq  *%rax
  8004207b5e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm1 + PGSIZE, 0) = 0;
  8004207b65:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207b6c:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004207b72:	48 89 c1             	mov    %rax,%rcx
  8004207b75:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004207b7c:	00 00 00 
  8004207b7f:	48 8b 00             	mov    (%rax),%rax
  8004207b82:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207b87:	48 89 ce             	mov    %rcx,%rsi
  8004207b8a:	48 89 c7             	mov    %rax,%rdi
  8004207b8d:	48 b8 6f 36 20 04 80 	movabs $0x800420366f,%rax
  8004207b94:	00 00 00 
  8004207b97:	ff d0                	callq  *%rax
  8004207b99:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm2, 0) = 0;
  8004207ba0:	48 8b 8d e8 fe ff ff 	mov    -0x118(%rbp),%rcx
  8004207ba7:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  8004207bae:	00 00 00 
  8004207bb1:	48 8b 00             	mov    (%rax),%rax
  8004207bb4:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207bb9:	48 89 ce             	mov    %rcx,%rsi
  8004207bbc:	48 89 c7             	mov    %rax,%rdi
  8004207bbf:	48 b8 6f 36 20 04 80 	movabs $0x800420366f,%rax
  8004207bc6:	00 00 00 
  8004207bc9:	ff d0                	callq  *%rax
  8004207bcb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	cprintf("check_page() succeeded!\n");
  8004207bd2:	48 bf 0b 6a 21 04 80 	movabs $0x8004216a0b,%rdi
  8004207bd9:	00 00 00 
  8004207bdc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207be1:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004207be8:	00 00 00 
  8004207beb:	ff d2                	callq  *%rdx
}
  8004207bed:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  8004207bf4:	5b                   	pop    %rbx
  8004207bf5:	5d                   	pop    %rbp
  8004207bf6:	c3                   	retq   

0000008004207bf7 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004207bf7:	55                   	push   %rbp
  8004207bf8:	48 89 e5             	mov    %rsp,%rbp
  8004207bfb:	48 83 ec 08          	sub    $0x8,%rsp
  8004207bff:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004207c03:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207c07:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  8004207c0e:	00 00 00 
  8004207c11:	48 8b 00             	mov    (%rax),%rax
  8004207c14:	48 29 c2             	sub    %rax,%rdx
  8004207c17:	48 89 d0             	mov    %rdx,%rax
  8004207c1a:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004207c1e:	c9                   	leaveq 
  8004207c1f:	c3                   	retq   

0000008004207c20 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004207c20:	55                   	push   %rbp
  8004207c21:	48 89 e5             	mov    %rsp,%rbp
  8004207c24:	48 83 ec 08          	sub    $0x8,%rsp
  8004207c28:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004207c2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207c30:	48 89 c7             	mov    %rax,%rdi
  8004207c33:	48 b8 f7 7b 20 04 80 	movabs $0x8004207bf7,%rax
  8004207c3a:	00 00 00 
  8004207c3d:	ff d0                	callq  *%rax
  8004207c3f:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004207c43:	c9                   	leaveq 
  8004207c44:	c3                   	retq   

0000008004207c45 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004207c45:	55                   	push   %rbp
  8004207c46:	48 89 e5             	mov    %rsp,%rbp
  8004207c49:	48 83 ec 10          	sub    $0x10,%rsp
  8004207c4d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004207c51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207c55:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207c59:	48 89 c2             	mov    %rax,%rdx
  8004207c5c:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004207c63:	00 00 00 
  8004207c66:	48 8b 00             	mov    (%rax),%rax
  8004207c69:	48 39 c2             	cmp    %rax,%rdx
  8004207c6c:	72 2a                	jb     8004207c98 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004207c6e:	48 ba 28 6a 21 04 80 	movabs $0x8004216a28,%rdx
  8004207c75:	00 00 00 
  8004207c78:	be 54 00 00 00       	mov    $0x54,%esi
  8004207c7d:	48 bf 47 6a 21 04 80 	movabs $0x8004216a47,%rdi
  8004207c84:	00 00 00 
  8004207c87:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207c8c:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  8004207c93:	00 00 00 
  8004207c96:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004207c98:	48 b8 38 e7 49 04 80 	movabs $0x800449e738,%rax
  8004207c9f:	00 00 00 
  8004207ca2:	48 8b 00             	mov    (%rax),%rax
  8004207ca5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207ca9:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004207cad:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207cb1:	48 01 d0             	add    %rdx,%rax
}
  8004207cb4:	c9                   	leaveq 
  8004207cb5:	c3                   	retq   

0000008004207cb6 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004207cb6:	55                   	push   %rbp
  8004207cb7:	48 89 e5             	mov    %rsp,%rbp
  8004207cba:	48 83 ec 20          	sub    $0x20,%rsp
  8004207cbe:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004207cc2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207cc6:	48 89 c7             	mov    %rax,%rdi
  8004207cc9:	48 b8 20 7c 20 04 80 	movabs $0x8004207c20,%rax
  8004207cd0:	00 00 00 
  8004207cd3:	ff d0                	callq  *%rax
  8004207cd5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207cd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207cdd:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207ce1:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004207ce4:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004207ce7:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004207cee:	00 00 00 
  8004207cf1:	48 8b 00             	mov    (%rax),%rax
  8004207cf4:	48 39 c2             	cmp    %rax,%rdx
  8004207cf7:	72 32                	jb     8004207d2b <page2kva+0x75>
  8004207cf9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207cfd:	48 89 c1             	mov    %rax,%rcx
  8004207d00:	48 ba 58 6a 21 04 80 	movabs $0x8004216a58,%rdx
  8004207d07:	00 00 00 
  8004207d0a:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004207d0f:	48 bf 47 6a 21 04 80 	movabs $0x8004216a47,%rdi
  8004207d16:	00 00 00 
  8004207d19:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207d1e:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004207d25:	00 00 00 
  8004207d28:	41 ff d0             	callq  *%r8
  8004207d2b:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207d32:	00 00 00 
  8004207d35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d39:	48 01 d0             	add    %rdx,%rax
}
  8004207d3c:	c9                   	leaveq 
  8004207d3d:	c3                   	retq   

0000008004207d3e <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  8004207d3e:	55                   	push   %rbp
  8004207d3f:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  8004207d42:	48 bf 20 a9 22 04 80 	movabs $0x800422a920,%rdi
  8004207d49:	00 00 00 
  8004207d4c:	48 b8 f3 4e 21 04 80 	movabs $0x8004214ef3,%rax
  8004207d53:	00 00 00 
  8004207d56:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  8004207d58:	f3 90                	pause  
}
  8004207d5a:	5d                   	pop    %rbp
  8004207d5b:	c3                   	retq   

0000008004207d5c <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  8004207d5c:	55                   	push   %rbp
  8004207d5d:	48 89 e5             	mov    %rsp,%rbp
  8004207d60:	53                   	push   %rbx
  8004207d61:	48 83 ec 28          	sub    $0x28,%rsp
  8004207d65:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8004207d68:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004207d6c:	89 d0                	mov    %edx,%eax
  8004207d6e:	88 45 d8             	mov    %al,-0x28(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  8004207d71:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004207d75:	75 42                	jne    8004207db9 <envid2env+0x5d>
		*env_store = curenv;
  8004207d77:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004207d7e:	00 00 00 
  8004207d81:	ff d0                	callq  *%rax
  8004207d83:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004207d8a:	00 00 00 
  8004207d8d:	48 98                	cltq   
  8004207d8f:	48 c1 e0 03          	shl    $0x3,%rax
  8004207d93:	48 89 c2             	mov    %rax,%rdx
  8004207d96:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207d9a:	48 29 c2             	sub    %rax,%rdx
  8004207d9d:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207da1:	48 83 c0 08          	add    $0x8,%rax
  8004207da5:	48 8b 10             	mov    (%rax),%rdx
  8004207da8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207dac:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  8004207daf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207db4:	e9 09 01 00 00       	jmpq   8004207ec2 <envid2env+0x166>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  8004207db9:	48 b8 50 d2 49 04 80 	movabs $0x800449d250,%rax
  8004207dc0:	00 00 00 
  8004207dc3:	48 8b 08             	mov    (%rax),%rcx
  8004207dc6:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004207dc9:	48 98                	cltq   
  8004207dcb:	25 ff 03 00 00       	and    $0x3ff,%eax
  8004207dd0:	48 89 c2             	mov    %rax,%rdx
  8004207dd3:	48 89 d0             	mov    %rdx,%rax
  8004207dd6:	48 c1 e0 03          	shl    $0x3,%rax
  8004207dda:	48 01 d0             	add    %rdx,%rax
  8004207ddd:	48 c1 e0 05          	shl    $0x5,%rax
  8004207de1:	48 01 c8             	add    %rcx,%rax
  8004207de4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  8004207de8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207dec:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004207df2:	85 c0                	test   %eax,%eax
  8004207df4:	74 0f                	je     8004207e05 <envid2env+0xa9>
  8004207df6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207dfa:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207e00:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  8004207e03:	74 15                	je     8004207e1a <envid2env+0xbe>
		*env_store = 0;
  8004207e05:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207e09:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207e10:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207e15:	e9 a8 00 00 00       	jmpq   8004207ec2 <envid2env+0x166>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  8004207e1a:	80 7d d8 00          	cmpb   $0x0,-0x28(%rbp)
  8004207e1e:	0f 84 8e 00 00 00    	je     8004207eb2 <envid2env+0x156>
  8004207e24:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004207e2b:	00 00 00 
  8004207e2e:	ff d0                	callq  *%rax
  8004207e30:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004207e37:	00 00 00 
  8004207e3a:	48 98                	cltq   
  8004207e3c:	48 c1 e0 03          	shl    $0x3,%rax
  8004207e40:	48 89 c2             	mov    %rax,%rdx
  8004207e43:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207e47:	48 29 c2             	sub    %rax,%rdx
  8004207e4a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207e4e:	48 83 c0 08          	add    $0x8,%rax
  8004207e52:	48 8b 00             	mov    (%rax),%rax
  8004207e55:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004207e59:	74 57                	je     8004207eb2 <envid2env+0x156>
  8004207e5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207e5f:	8b 98 cc 00 00 00    	mov    0xcc(%rax),%ebx
  8004207e65:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004207e6c:	00 00 00 
  8004207e6f:	ff d0                	callq  *%rax
  8004207e71:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004207e78:	00 00 00 
  8004207e7b:	48 98                	cltq   
  8004207e7d:	48 c1 e0 03          	shl    $0x3,%rax
  8004207e81:	48 89 c2             	mov    %rax,%rdx
  8004207e84:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207e88:	48 29 c2             	sub    %rax,%rdx
  8004207e8b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207e8f:	48 83 c0 08          	add    $0x8,%rax
  8004207e93:	48 8b 00             	mov    (%rax),%rax
  8004207e96:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207e9c:	39 c3                	cmp    %eax,%ebx
  8004207e9e:	74 12                	je     8004207eb2 <envid2env+0x156>
		*env_store = 0;
  8004207ea0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207ea4:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207eab:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207eb0:	eb 10                	jmp    8004207ec2 <envid2env+0x166>
	}

	*env_store = e;
  8004207eb2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207eb6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207eba:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  8004207ebd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207ec2:	48 83 c4 28          	add    $0x28,%rsp
  8004207ec6:	5b                   	pop    %rbx
  8004207ec7:	5d                   	pop    %rbp
  8004207ec8:	c3                   	retq   

0000008004207ec9 <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
void
env_init(void)
{
  8004207ec9:	55                   	push   %rbp
  8004207eca:	48 89 e5             	mov    %rsp,%rbp
  8004207ecd:	48 83 ec 10          	sub    $0x10,%rsp
	// Set up envs array
	env_free_list = NULL;
  8004207ed1:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  8004207ed8:	00 00 00 
  8004207edb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
struct Env* e;
  for( e = envs + NENV - 1; e >= envs; e--){
  8004207ee2:	48 b8 50 d2 49 04 80 	movabs $0x800449d250,%rax
  8004207ee9:	00 00 00 
  8004207eec:	48 8b 00             	mov    (%rax),%rax
  8004207eef:	48 05 e0 7e 04 00    	add    $0x47ee0,%rax
  8004207ef5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207ef9:	eb 3f                	jmp    8004207f3a <env_init+0x71>
		//cprintf("invoked %d times\n", ++num);
		//e->env_status = ENV_FREE;
		e->env_id = 0;
  8004207efb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207eff:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%rax)
  8004207f06:	00 00 00 
		e->env_link = env_free_list;
  8004207f09:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  8004207f10:	00 00 00 
  8004207f13:	48 8b 10             	mov    (%rax),%rdx
  8004207f16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f1a:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
		env_free_list = e;
  8004207f21:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  8004207f28:	00 00 00 
  8004207f2b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207f2f:	48 89 10             	mov    %rdx,(%rax)
env_init(void)
{
	// Set up envs array
	env_free_list = NULL;
struct Env* e;
  for( e = envs + NENV - 1; e >= envs; e--){
  8004207f32:	48 81 6d f8 20 01 00 	subq   $0x120,-0x8(%rbp)
  8004207f39:	00 
  8004207f3a:	48 b8 50 d2 49 04 80 	movabs $0x800449d250,%rax
  8004207f41:	00 00 00 
  8004207f44:	48 8b 00             	mov    (%rax),%rax
  8004207f47:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004207f4b:	73 ae                	jae    8004207efb <env_init+0x32>
		//e->env_status = ENV_FREE;
		e->env_id = 0;
		e->env_link = env_free_list;
		env_free_list = e;
	}
	env_init_percpu();
  8004207f4d:	48 b8 5b 7f 20 04 80 	movabs $0x8004207f5b,%rax
  8004207f54:	00 00 00 
  8004207f57:	ff d0                	callq  *%rax
	//check_pc();
}
  8004207f59:	c9                   	leaveq 
  8004207f5a:	c3                   	retq   

0000008004207f5b <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  8004207f5b:	55                   	push   %rbp
  8004207f5c:	48 89 e5             	mov    %rsp,%rbp
  8004207f5f:	53                   	push   %rbx
  8004207f60:	48 83 ec 10          	sub    $0x10,%rsp
  8004207f64:	48 b8 08 a7 22 04 80 	movabs $0x800422a708,%rax
  8004207f6b:	00 00 00 
  8004207f6e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}

static __inline void
lgdt(void *p)
{
	__asm __volatile("lgdt (%0)" : : "r" (p));
  8004207f72:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207f76:	0f 01 10             	lgdt   (%rax)
	lgdt(&gdt_pd);

	// The kernel never uses GS or FS, so we leave those set to
	// the user data segment.
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  8004207f79:	b8 23 00 00 00       	mov    $0x23,%eax
  8004207f7e:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  8004207f80:	b8 23 00 00 00       	mov    $0x23,%eax
  8004207f85:	8e e0                	mov    %eax,%fs
	// The kernel does use ES, DS, and SS.  We'll change between
	// the kernel and user data segments as needed.
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  8004207f87:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207f8c:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  8004207f8e:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207f93:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  8004207f95:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207f9a:	8e d0                	mov    %eax,%ss
	// Load the kernel text segment into CS.
	asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  8004207f9c:	b8 08 00 00 00       	mov    $0x8,%eax
  8004207fa1:	89 c3                	mov    %eax,%ebx
  8004207fa3:	53                   	push   %rbx
  8004207fa4:	48 b8 b1 7f 20 04 80 	movabs $0x8004207fb1,%rax
  8004207fab:	00 00 00 
  8004207fae:	50                   	push   %rax
  8004207faf:	48 cb                	lretq  
  8004207fb1:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
}

static __inline void
lldt(uint16_t sel)
{
	__asm __volatile("lldt %0" : : "r" (sel));
  8004207fb7:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  8004207fbb:	0f 00 d0             	lldt   %ax
	// For good measure, clear the local descriptor table (LDT),
	// since we don't use it.
	lldt(0);
}
  8004207fbe:	48 83 c4 10          	add    $0x10,%rsp
  8004207fc2:	5b                   	pop    %rbx
  8004207fc3:	5d                   	pop    %rbp
  8004207fc4:	c3                   	retq   

0000008004207fc5 <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
static int
env_setup_vm(struct Env *e)
{
  8004207fc5:	55                   	push   %rbp
  8004207fc6:	48 89 e5             	mov    %rsp,%rbp
  8004207fc9:	48 83 ec 20          	sub    $0x20,%rsp
  8004207fcd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  8004207fd1:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004207fd8:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(ALLOC_ZERO)))
  8004207fd9:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207fde:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  8004207fe5:	00 00 00 
  8004207fe8:	ff d0                	callq  *%rax
  8004207fea:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207fee:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004207ff3:	75 0a                	jne    8004207fff <env_setup_vm+0x3a>
		return -E_NO_MEM;
  8004207ff5:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004207ffa:	e9 e7 00 00 00       	jmpq   80042080e6 <env_setup_vm+0x121>
	//	is an exception -- you need to increment env_pml4e's
	//	pp_ref for env_free to work correctly.
	//    - The functions in kern/pmap.h are handy.

	// LAB 3: Your code here.
	e->env_pml4e = (pml4e_t* )page2kva(p);
  8004207fff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208003:	48 89 c7             	mov    %rax,%rdi
  8004208006:	48 b8 b6 7c 20 04 80 	movabs $0x8004207cb6,%rax
  800420800d:	00 00 00 
  8004208010:	ff d0                	callq  *%rax
  8004208012:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004208016:	48 89 82 e0 00 00 00 	mov    %rax,0xe0(%rdx)
	p->pp_ref++;
  800420801d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208021:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004208025:	8d 50 01             	lea    0x1(%rax),%edx
  8004208028:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420802c:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_cr3 = PADDR(e->env_pml4e);
  8004208030:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208034:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420803b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420803f:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004208046:	00 00 00 
  8004208049:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420804d:	77 32                	ja     8004208081 <env_setup_vm+0xbc>
  800420804f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208053:	48 89 c1             	mov    %rax,%rcx
  8004208056:	48 ba 80 6a 21 04 80 	movabs $0x8004216a80,%rdx
  800420805d:	00 00 00 
  8004208060:	be c9 00 00 00       	mov    $0xc9,%esi
  8004208065:	48 bf a4 6a 21 04 80 	movabs $0x8004216aa4,%rdi
  800420806c:	00 00 00 
  800420806f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208074:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420807b:	00 00 00 
  800420807e:	41 ff d0             	callq  *%r8
  8004208081:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004208088:	ff ff ff 
  800420808b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420808f:	48 01 c2             	add    %rax,%rdx
  8004208092:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208096:	48 89 90 e8 00 00 00 	mov    %rdx,0xe8(%rax)
  e->env_pml4e[1] = boot_pml4e[1];
  800420809d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042080a1:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042080a8:	48 8d 50 08          	lea    0x8(%rax),%rdx
  80042080ac:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  80042080b3:	00 00 00 
  80042080b6:	48 8b 00             	mov    (%rax),%rax
  80042080b9:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042080bd:	48 89 02             	mov    %rax,(%rdx)
	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pml4e[PML4(UVPT)] = e->env_cr3 | PTE_P | PTE_U;
  80042080c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042080c4:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042080cb:	48 8d 50 10          	lea    0x10(%rax),%rdx
  80042080cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042080d3:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042080da:	48 83 c8 05          	or     $0x5,%rax
  80042080de:	48 89 02             	mov    %rax,(%rdx)

	return 0;
  80042080e1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042080e6:	c9                   	leaveq 
  80042080e7:	c3                   	retq   

00000080042080e8 <free_num>:
// Returns 0 on success, < 0 on failure.  Errors include:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
int
free_num(){
  80042080e8:	55                   	push   %rbp
  80042080e9:	48 89 e5             	mov    %rsp,%rbp
  80042080ec:	48 83 ec 10          	sub    $0x10,%rsp
	struct Env* e = env_free_list;
  80042080f0:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  80042080f7:	00 00 00 
  80042080fa:	48 8b 00             	mov    (%rax),%rax
  80042080fd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	int n = 0;
  8004208101:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	for(;e;e=e->env_link) n++;
  8004208108:	eb 13                	jmp    800420811d <free_num+0x35>
  800420810a:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800420810e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208112:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
  8004208119:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420811d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004208122:	75 e6                	jne    800420810a <free_num+0x22>
	return n;
  8004208124:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  8004208127:	c9                   	leaveq 
  8004208128:	c3                   	retq   

0000008004208129 <env_alloc>:
int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  8004208129:	55                   	push   %rbp
  800420812a:	48 89 e5             	mov    %rsp,%rbp
  800420812d:	48 83 ec 30          	sub    $0x30,%rsp
  8004208131:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004208135:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;
	if (!(e = env_free_list))
  8004208138:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  800420813f:	00 00 00 
  8004208142:	48 8b 00             	mov    (%rax),%rax
  8004208145:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004208149:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420814e:	75 0a                	jne    800420815a <env_alloc+0x31>
		return -E_NO_FREE_ENV;
  8004208150:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  8004208155:	e9 76 01 00 00       	jmpq   80042082d0 <env_alloc+0x1a7>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  800420815a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420815e:	48 89 c7             	mov    %rax,%rdi
  8004208161:	48 b8 c5 7f 20 04 80 	movabs $0x8004207fc5,%rax
  8004208168:	00 00 00 
  800420816b:	ff d0                	callq  *%rax
  800420816d:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004208170:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004208174:	79 08                	jns    800420817e <env_alloc+0x55>
		return r;
  8004208176:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208179:	e9 52 01 00 00       	jmpq   80042082d0 <env_alloc+0x1a7>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  800420817e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208182:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004208188:	05 00 10 00 00       	add    $0x1000,%eax
  800420818d:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  8004208192:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004208195:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004208199:	7f 07                	jg     80042081a2 <env_alloc+0x79>
		generation = 1 << ENVGENSHIFT;
  800420819b:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%rbp)
	e->env_id = generation | (e - envs);
  80042081a2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042081a6:	48 b8 50 d2 49 04 80 	movabs $0x800449d250,%rax
  80042081ad:	00 00 00 
  80042081b0:	48 8b 00             	mov    (%rax),%rax
  80042081b3:	48 29 c2             	sub    %rax,%rdx
  80042081b6:	48 89 d0             	mov    %rdx,%rax
  80042081b9:	48 c1 f8 05          	sar    $0x5,%rax
  80042081bd:	48 89 c2             	mov    %rax,%rdx
  80042081c0:	48 b8 39 8e e3 38 8e 	movabs $0x8e38e38e38e38e39,%rax
  80042081c7:	e3 38 8e 
  80042081ca:	48 0f af c2          	imul   %rdx,%rax
  80042081ce:	0b 45 fc             	or     -0x4(%rbp),%eax
  80042081d1:	89 c2                	mov    %eax,%edx
  80042081d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042081d7:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  80042081dd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042081e1:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042081e4:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  80042081ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042081ee:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  80042081f5:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  80042081f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042081fc:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004208203:	00 00 00 
	e->env_runs = 0;
  8004208206:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420820a:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  8004208211:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  8004208214:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208218:	ba c0 00 00 00       	mov    $0xc0,%edx
  800420821d:	be 00 00 00 00       	mov    $0x0,%esi
  8004208222:	48 89 c7             	mov    %rax,%rdi
  8004208225:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  800420822c:	00 00 00 
  800420822f:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  8004208231:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208235:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  800420823c:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  800420823e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208242:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  8004208248:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420824c:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  8004208253:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  8004208255:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208259:	b9 00 e0 7f ef       	mov    $0xef7fe000,%ecx
  800420825e:	48 89 88 b0 00 00 00 	mov    %rcx,0xb0(%rax)
	e->env_tf.tf_cs = GD_UT | 3;
  8004208265:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208269:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  8004208270:	1b 00 
	// You will set e->env_tf.tf_rip later.

	// Enable interrupts while in user mode.
	// LAB 4: Your code here.
	e->env_tf.tf_eflags |= FL_IF;
  8004208272:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208276:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420827d:	80 cc 02             	or     $0x2,%ah
  8004208280:	48 89 c2             	mov    %rax,%rdx
  8004208283:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208287:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
	// Clear the page fault handler until user installs one.
	e->env_pgfault_upcall = 0;
  800420828e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208292:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  8004208299:	00 00 00 00 

	// Also clear the IPC receiving flag.
	e->env_ipc_recving = 0;
  800420829d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042082a1:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  80042082a8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042082ac:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  80042082b3:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  80042082ba:	00 00 00 
  80042082bd:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  80042082c0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042082c4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042082c8:	48 89 10             	mov    %rdx,(%rax)

	//cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
	return 0;
  80042082cb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042082d0:	c9                   	leaveq 
  80042082d1:	c3                   	retq   

00000080042082d2 <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  80042082d2:	55                   	push   %rbp
  80042082d3:	48 89 e5             	mov    %rsp,%rbp
  80042082d6:	48 83 ec 50          	sub    $0x50,%rsp
  80042082da:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042082de:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042082e2:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	int err;
	//int c = 0;
	
	//cprintf("start = %d, end = %d, iter = %d\n", ROUNDDOWN(va, PGSIZE), ROUNDUP(va + len, PGSIZE), c);
void *addr;
	for(addr = ROUNDDOWN(va, PGSIZE); addr < ROUNDUP(va + len, PGSIZE); addr += PGSIZE){
  80042082e6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042082ea:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042082ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042082f2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042082f8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042082fc:	e9 b4 00 00 00       	jmpq   80042083b5 <region_alloc+0xe3>
		page = page_alloc(0);
  8004208301:	bf 00 00 00 00       	mov    $0x0,%edi
  8004208306:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  800420830d:	00 00 00 
  8004208310:	ff d0                	callq  *%rax
  8004208312:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		//check_pc();
		if(!page)
  8004208316:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420831b:	75 30                	jne    800420834d <region_alloc+0x7b>
			panic("region_alloc failed:%e\n", -E_NO_MEM);
  800420831d:	b9 fc ff ff ff       	mov    $0xfffffffc,%ecx
  8004208322:	48 ba af 6a 21 04 80 	movabs $0x8004216aaf,%rdx
  8004208329:	00 00 00 
  800420832c:	be 3c 01 00 00       	mov    $0x13c,%esi
  8004208331:	48 bf a4 6a 21 04 80 	movabs $0x8004216aa4,%rdi
  8004208338:	00 00 00 
  800420833b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208340:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004208347:	00 00 00 
  800420834a:	41 ff d0             	callq  *%r8
		if((err = page_insert(e->env_pml4e, page, addr, PTE_U | PTE_W)))
  800420834d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208351:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208358:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420835c:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  8004208360:	b9 06 00 00 00       	mov    $0x6,%ecx
  8004208365:	48 89 c7             	mov    %rax,%rdi
  8004208368:	48 b8 b4 3b 20 04 80 	movabs $0x8004203bb4,%rax
  800420836f:	00 00 00 
  8004208372:	ff d0                	callq  *%rax
  8004208374:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  8004208377:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  800420837b:	74 30                	je     80042083ad <region_alloc+0xdb>
			panic("page_insert_failed:%e\n", err);
  800420837d:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004208380:	89 c1                	mov    %eax,%ecx
  8004208382:	48 ba c7 6a 21 04 80 	movabs $0x8004216ac7,%rdx
  8004208389:	00 00 00 
  800420838c:	be 3e 01 00 00       	mov    $0x13e,%esi
  8004208391:	48 bf a4 6a 21 04 80 	movabs $0x8004216aa4,%rdi
  8004208398:	00 00 00 
  800420839b:	b8 00 00 00 00       	mov    $0x0,%eax
  80042083a0:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042083a7:	00 00 00 
  80042083aa:	41 ff d0             	callq  *%r8
	int err;
	//int c = 0;
	
	//cprintf("start = %d, end = %d, iter = %d\n", ROUNDDOWN(va, PGSIZE), ROUNDUP(va + len, PGSIZE), c);
void *addr;
	for(addr = ROUNDDOWN(va, PGSIZE); addr < ROUNDUP(va + len, PGSIZE); addr += PGSIZE){
  80042083ad:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042083b4:	00 
  80042083b5:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  80042083bc:	00 
  80042083bd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042083c1:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042083c5:	48 01 d0             	add    %rdx,%rax
  80042083c8:	48 89 c2             	mov    %rax,%rdx
  80042083cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042083cf:	48 01 d0             	add    %rdx,%rax
  80042083d2:	48 83 e8 01          	sub    $0x1,%rax
  80042083d6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042083da:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042083de:	ba 00 00 00 00       	mov    $0x0,%edx
  80042083e3:	48 f7 75 e8          	divq   -0x18(%rbp)
  80042083e7:	48 89 d0             	mov    %rdx,%rax
  80042083ea:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042083ee:	48 29 c2             	sub    %rax,%rdx
  80042083f1:	48 89 d0             	mov    %rdx,%rax
  80042083f4:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042083f8:	0f 87 03 ff ff ff    	ja     8004208301 <region_alloc+0x2f>
		if((err = page_insert(e->env_pml4e, page, addr, PTE_U | PTE_W)))
			panic("page_insert_failed:%e\n", err);
		//c++;
	}
	//cprintf("count = %d\n", c);
}
  80042083fe:	c9                   	leaveq 
  80042083ff:	c3                   	retq   

0000008004208400 <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  8004208400:	55                   	push   %rbp
  8004208401:	48 89 e5             	mov    %rsp,%rbp
  8004208404:	48 83 ec 30          	sub    $0x30,%rsp
  8004208408:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420840c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	//  You must also do something with the program's entry point,
	//  to make sure that the environment starts executing there.
	//  What?  (See env_run() and env_pop_tf() below.)

	// LAB 3: Your code here
  struct Elf* ELFHDR = (struct Elf*) binary;
  8004208410:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208414:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(!(ELFHDR->e_magic == ELF_MAGIC))
  8004208418:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420841c:	8b 00                	mov    (%rax),%eax
  800420841e:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  8004208423:	74 2a                	je     800420844f <load_icode+0x4f>
		panic("not a valid ELF format\n");
  8004208425:	48 ba de 6a 21 04 80 	movabs $0x8004216ade,%rdx
  800420842c:	00 00 00 
  800420842f:	be 7c 01 00 00       	mov    $0x17c,%esi
  8004208434:	48 bf a4 6a 21 04 80 	movabs $0x8004216aa4,%rdi
  800420843b:	00 00 00 
  800420843e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208443:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  800420844a:	00 00 00 
  800420844d:	ff d1                	callq  *%rcx
	//cprintf("phnum = %d\n", ELFHDR->e_phnum);
 	lcr3(e->env_cr3);
  800420844f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208453:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  800420845a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420845e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208462:	0f 22 d8             	mov    %rax,%cr3
  struct Proghdr *ph = (struct Proghdr*) (binary + ELFHDR->e_phoff), *eph = ph + ELFHDR->e_phnum;
  8004208465:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208469:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800420846d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208471:	48 01 d0             	add    %rdx,%rax
  8004208474:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004208478:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420847c:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  8004208480:	0f b7 c0             	movzwl %ax,%eax
  8004208483:	48 c1 e0 03          	shl    $0x3,%rax
  8004208487:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420848e:	00 
  800420848f:	48 29 c2             	sub    %rax,%rdx
  8004208492:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208496:	48 01 d0             	add    %rdx,%rax
  8004208499:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for(;ph < eph;ph++){
  800420849d:	e9 8e 00 00 00       	jmpq   8004208530 <load_icode+0x130>
		if(ph->p_type == ELF_PROG_LOAD){
  80042084a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042084a6:	8b 00                	mov    (%rax),%eax
  80042084a8:	83 f8 01             	cmp    $0x1,%eax
  80042084ab:	75 7e                	jne    800420852b <load_icode+0x12b>
			region_alloc(e, (void *)(ph->p_va), ph->p_memsz);
  80042084ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042084b1:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042084b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042084b9:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042084bd:	48 89 c1             	mov    %rax,%rcx
  80042084c0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042084c4:	48 89 ce             	mov    %rcx,%rsi
  80042084c7:	48 89 c7             	mov    %rax,%rdi
  80042084ca:	48 b8 d2 82 20 04 80 	movabs $0x80042082d2,%rax
  80042084d1:	00 00 00 
  80042084d4:	ff d0                	callq  *%rax
			//cprintf("reaches here\n");
			memset((void*)(ph->p_va), 0, ph->p_memsz);
  80042084d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042084da:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042084de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042084e2:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042084e6:	be 00 00 00 00       	mov    $0x0,%esi
  80042084eb:	48 89 c7             	mov    %rax,%rdi
  80042084ee:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  80042084f5:	00 00 00 
  80042084f8:	ff d0                	callq  *%rax
			memcpy((void*)(ph->p_va), binary + ph->p_offset, ph->p_filesz);
  80042084fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042084fe:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004208502:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208506:	48 8b 48 08          	mov    0x8(%rax),%rcx
  800420850a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420850e:	48 01 c1             	add    %rax,%rcx
  8004208511:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208515:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004208519:	48 89 ce             	mov    %rcx,%rsi
  800420851c:	48 89 c7             	mov    %rax,%rdi
  800420851f:	48 b8 98 dc 20 04 80 	movabs $0x800420dc98,%rax
  8004208526:	00 00 00 
  8004208529:	ff d0                	callq  *%rax
	if(!(ELFHDR->e_magic == ELF_MAGIC))
		panic("not a valid ELF format\n");
	//cprintf("phnum = %d\n", ELFHDR->e_phnum);
 	lcr3(e->env_cr3);
  struct Proghdr *ph = (struct Proghdr*) (binary + ELFHDR->e_phoff), *eph = ph + ELFHDR->e_phnum;
	for(;ph < eph;ph++){
  800420852b:	48 83 45 f8 38       	addq   $0x38,-0x8(%rbp)
  8004208530:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208534:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004208538:	0f 82 64 ff ff ff    	jb     80042084a2 <load_icode+0xa2>
			//cprintf("reaches here\n");
			memset((void*)(ph->p_va), 0, ph->p_memsz);
			memcpy((void*)(ph->p_va), binary + ph->p_offset, ph->p_filesz);
		}
	}
	e->env_tf.tf_rip = ELFHDR->e_entry;
  800420853e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208542:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004208546:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420854a:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	// Now map one page for the program's initial stack
	// at virtual address USTACKTOP - PGSIZE.
	// LAB 3: Your code here.
	e->elf = binary;
  8004208551:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208555:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004208559:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)
	region_alloc(e, (void*)(USTACKTOP - PGSIZE), PGSIZE);
  8004208560:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208564:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004208569:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  800420856e:	48 89 c7             	mov    %rax,%rdi
  8004208571:	48 b8 d2 82 20 04 80 	movabs $0x80042082d2,%rax
  8004208578:	00 00 00 
  800420857b:	ff d0                	callq  *%rax
 
}
  800420857d:	c9                   	leaveq 
  800420857e:	c3                   	retq   

000000800420857f <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  800420857f:	55                   	push   %rbp
  8004208580:	48 89 e5             	mov    %rsp,%rbp
  8004208583:	48 83 ec 20          	sub    $0x20,%rsp
  8004208587:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420858b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// LAB 3: Your code here.

	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
	// LAB 5: Your code here.
	//cprintf("%016x\n", env_free_list);
	assert(env_free_list);
  800420858e:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  8004208595:	00 00 00 
  8004208598:	48 8b 00             	mov    (%rax),%rax
  800420859b:	48 85 c0             	test   %rax,%rax
  800420859e:	75 35                	jne    80042085d5 <env_create+0x56>
  80042085a0:	48 b9 f6 6a 21 04 80 	movabs $0x8004216af6,%rcx
  80042085a7:	00 00 00 
  80042085aa:	48 ba 04 6b 21 04 80 	movabs $0x8004216b04,%rdx
  80042085b1:	00 00 00 
  80042085b4:	be a0 01 00 00       	mov    $0x1a0,%esi
  80042085b9:	48 bf a4 6a 21 04 80 	movabs $0x8004216aa4,%rdi
  80042085c0:	00 00 00 
  80042085c3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042085c8:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042085cf:	00 00 00 
  80042085d2:	41 ff d0             	callq  *%r8
	struct Env* new_env;
	int err = env_alloc(&new_env, 0);
  80042085d5:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  80042085d9:	be 00 00 00 00       	mov    $0x0,%esi
  80042085de:	48 89 c7             	mov    %rax,%rdi
  80042085e1:	48 b8 29 81 20 04 80 	movabs $0x8004208129,%rax
  80042085e8:	00 00 00 
  80042085eb:	ff d0                	callq  *%rax
  80042085ed:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(err)
  80042085f0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042085f4:	74 30                	je     8004208626 <env_create+0xa7>
		panic("env_create failed:%e\n", err);
  80042085f6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042085f9:	89 c1                	mov    %eax,%ecx
  80042085fb:	48 ba 19 6b 21 04 80 	movabs $0x8004216b19,%rdx
  8004208602:	00 00 00 
  8004208605:	be a4 01 00 00       	mov    $0x1a4,%esi
  800420860a:	48 bf a4 6a 21 04 80 	movabs $0x8004216aa4,%rdi
  8004208611:	00 00 00 
  8004208614:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208619:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004208620:	00 00 00 
  8004208623:	41 ff d0             	callq  *%r8
	new_env->env_type = type;
  8004208626:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420862a:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800420862d:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
	load_icode(new_env, binary);
  8004208633:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208637:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420863b:	48 89 d6             	mov    %rdx,%rsi
  800420863e:	48 89 c7             	mov    %rax,%rdi
  8004208641:	48 b8 00 84 20 04 80 	movabs $0x8004208400,%rax
  8004208648:	00 00 00 
  800420864b:	ff d0                	callq  *%rax
	if(type == ENV_TYPE_FS)
  800420864d:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  8004208651:	75 19                	jne    800420866c <env_create+0xed>
		new_env->env_tf.tf_eflags |= FL_IOPL_3;
  8004208653:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208657:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420865b:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  8004208662:	80 ce 30             	or     $0x30,%dh
  8004208665:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)

}
  800420866c:	c9                   	leaveq 
  800420866d:	c3                   	retq   

000000800420866e <env_free>:
//
// Frees env e and all memory it uses.
//
void
env_free(struct Env *e)
{
  800420866e:	55                   	push   %rbp
  800420866f:	48 89 e5             	mov    %rsp,%rbp
  8004208672:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  8004208679:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)


	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  8004208680:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004208687:	00 00 00 
  800420868a:	ff d0                	callq  *%rax
  800420868c:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004208693:	00 00 00 
  8004208696:	48 98                	cltq   
  8004208698:	48 c1 e0 03          	shl    $0x3,%rax
  800420869c:	48 89 c2             	mov    %rax,%rdx
  800420869f:	48 c1 e2 04          	shl    $0x4,%rdx
  80042086a3:	48 29 c2             	sub    %rax,%rdx
  80042086a6:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042086aa:	48 83 c0 08          	add    $0x8,%rax
  80042086ae:	48 8b 00             	mov    (%rax),%rax
  80042086b1:	48 3b 85 78 ff ff ff 	cmp    -0x88(%rbp),%rax
  80042086b8:	75 18                	jne    80042086d2 <env_free+0x64>
		lcr3(boot_cr3);
  80042086ba:	48 b8 20 e7 49 04 80 	movabs $0x800449e720,%rax
  80042086c1:	00 00 00 
  80042086c4:	48 8b 00             	mov    (%rax),%rax
  80042086c7:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  80042086cb:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042086cf:	0f 22 d8             	mov    %rax,%cr3

	// Note the environment's demise.
	//cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);

	// Flush all mapped pages in the user portion of the address space
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  80042086d2:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042086d9:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042086e0:	48 8b 00             	mov    (%rax),%rax
  80042086e3:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042086e9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042086ed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042086f1:	48 c1 e8 0c          	shr    $0xc,%rax
  80042086f5:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042086f8:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042086fb:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004208702:	00 00 00 
  8004208705:	48 8b 00             	mov    (%rax),%rax
  8004208708:	48 39 c2             	cmp    %rax,%rdx
  800420870b:	72 32                	jb     800420873f <env_free+0xd1>
  800420870d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208711:	48 89 c1             	mov    %rax,%rcx
  8004208714:	48 ba 58 6a 21 04 80 	movabs $0x8004216a58,%rdx
  800420871b:	00 00 00 
  800420871e:	be c1 01 00 00       	mov    $0x1c1,%esi
  8004208723:	48 bf a4 6a 21 04 80 	movabs $0x8004216aa4,%rdi
  800420872a:	00 00 00 
  800420872d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208732:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004208739:	00 00 00 
  800420873c:	41 ff d0             	callq  *%r8
  800420873f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208746:	00 00 00 
  8004208749:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420874d:	48 01 d0             	add    %rdx,%rax
  8004208750:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004208754:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420875b:	00 
  800420875c:	e9 ab 02 00 00       	jmpq   8004208a0c <env_free+0x39e>
		if(!(env_pdpe[pdpe_index] & PTE_P))
  8004208761:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208765:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420876c:	00 
  800420876d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208771:	48 01 d0             	add    %rdx,%rax
  8004208774:	48 8b 00             	mov    (%rax),%rax
  8004208777:	83 e0 01             	and    $0x1,%eax
  800420877a:	48 85 c0             	test   %rax,%rax
  800420877d:	75 05                	jne    8004208784 <env_free+0x116>
			continue;
  800420877f:	e9 83 02 00 00       	jmpq   8004208a07 <env_free+0x399>
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  8004208784:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208788:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420878f:	00 
  8004208790:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208794:	48 01 d0             	add    %rdx,%rax
  8004208797:	48 8b 00             	mov    (%rax),%rax
  800420879a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042087a0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042087a4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042087a8:	48 c1 e8 0c          	shr    $0xc,%rax
  80042087ac:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  80042087af:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042087b2:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  80042087b9:	00 00 00 
  80042087bc:	48 8b 00             	mov    (%rax),%rax
  80042087bf:	48 39 c2             	cmp    %rax,%rdx
  80042087c2:	72 32                	jb     80042087f6 <env_free+0x188>
  80042087c4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042087c8:	48 89 c1             	mov    %rax,%rcx
  80042087cb:	48 ba 58 6a 21 04 80 	movabs $0x8004216a58,%rdx
  80042087d2:	00 00 00 
  80042087d5:	be c9 01 00 00       	mov    $0x1c9,%esi
  80042087da:	48 bf a4 6a 21 04 80 	movabs $0x8004216aa4,%rdi
  80042087e1:	00 00 00 
  80042087e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042087e9:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042087f0:	00 00 00 
  80042087f3:	41 ff d0             	callq  *%r8
  80042087f6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042087fd:	00 00 00 
  8004208800:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208804:	48 01 d0             	add    %rdx,%rax
  8004208807:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  800420880b:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004208810:	75 07                	jne    8004208819 <env_free+0x1ab>
  8004208812:	b8 04 00 00 00       	mov    $0x4,%eax
  8004208817:	eb 05                	jmp    800420881e <env_free+0x1b0>
  8004208819:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  800420881e:	89 45 b4             	mov    %eax,-0x4c(%rbp)
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208821:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004208828:	00 
  8004208829:	e9 6e 01 00 00       	jmpq   800420899c <env_free+0x32e>

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
  800420882e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208832:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208839:	00 
  800420883a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420883e:	48 01 d0             	add    %rdx,%rax
  8004208841:	48 8b 00             	mov    (%rax),%rax
  8004208844:	83 e0 01             	and    $0x1,%eax
  8004208847:	48 85 c0             	test   %rax,%rax
  800420884a:	75 05                	jne    8004208851 <env_free+0x1e3>
				continue;
  800420884c:	e9 46 01 00 00       	jmpq   8004208997 <env_free+0x329>
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
  8004208851:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208855:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420885c:	00 
  800420885d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208861:	48 01 d0             	add    %rdx,%rax
  8004208864:	48 8b 00             	mov    (%rax),%rax
  8004208867:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420886d:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			pt = (pte_t*) KADDR(pa);
  8004208871:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208875:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004208879:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420887d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208881:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004208884:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004208887:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  800420888e:	00 00 00 
  8004208891:	48 8b 00             	mov    (%rax),%rax
  8004208894:	48 39 c2             	cmp    %rax,%rdx
  8004208897:	72 32                	jb     80042088cb <env_free+0x25d>
  8004208899:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420889d:	48 89 c1             	mov    %rax,%rcx
  80042088a0:	48 ba 58 6a 21 04 80 	movabs $0x8004216a58,%rdx
  80042088a7:	00 00 00 
  80042088aa:	be d3 01 00 00       	mov    $0x1d3,%esi
  80042088af:	48 bf a4 6a 21 04 80 	movabs $0x8004216aa4,%rdi
  80042088b6:	00 00 00 
  80042088b9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042088be:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042088c5:	00 00 00 
  80042088c8:	41 ff d0             	callq  *%r8
  80042088cb:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042088d2:	00 00 00 
  80042088d5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042088d9:	48 01 d0             	add    %rdx,%rax
  80042088dc:	48 89 45 90          	mov    %rax,-0x70(%rbp)

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  80042088e0:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042088e7:	00 
  80042088e8:	eb 67                	jmp    8004208951 <env_free+0x2e3>
				if (pt[pteno] & PTE_P){
  80042088ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042088ee:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042088f5:	00 
  80042088f6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042088fa:	48 01 d0             	add    %rdx,%rax
  80042088fd:	48 8b 00             	mov    (%rax),%rax
  8004208900:	83 e0 01             	and    $0x1,%eax
  8004208903:	48 85 c0             	test   %rax,%rax
  8004208906:	74 44                	je     800420894c <env_free+0x2de>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  8004208908:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420890c:	48 c1 e0 1e          	shl    $0x1e,%rax
  8004208910:	48 89 c2             	mov    %rax,%rdx
  8004208913:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208917:	48 c1 e0 15          	shl    $0x15,%rax
  800420891b:	48 09 c2             	or     %rax,%rdx
  800420891e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208922:	48 c1 e0 0c          	shl    $0xc,%rax
  8004208926:	48 09 d0             	or     %rdx,%rax
  8004208929:	48 89 c2             	mov    %rax,%rdx
  800420892c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208933:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420893a:	48 89 d6             	mov    %rdx,%rsi
  800420893d:	48 89 c7             	mov    %rax,%rdi
  8004208940:	48 b8 64 3d 20 04 80 	movabs $0x8004203d64,%rax
  8004208947:	00 00 00 
  800420894a:	ff d0                	callq  *%rax
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
			pt = (pte_t*) KADDR(pa);

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  800420894c:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004208951:	48 81 7d f0 fe 01 00 	cmpq   $0x1fe,-0x10(%rbp)
  8004208958:	00 
  8004208959:	76 8f                	jbe    80042088ea <env_free+0x27c>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
				}
			}

			// free the page table itself
			env_pgdir[pdeno] = 0;
  800420895b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420895f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208966:	00 
  8004208967:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420896b:	48 01 d0             	add    %rdx,%rax
  800420896e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  8004208975:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208979:	48 89 c7             	mov    %rax,%rdi
  800420897c:	48 b8 45 7c 20 04 80 	movabs $0x8004207c45,%rax
  8004208983:	00 00 00 
  8004208986:	ff d0                	callq  *%rax
  8004208988:	48 89 c7             	mov    %rax,%rdi
  800420898b:	48 b8 2e 36 20 04 80 	movabs $0x800420362e,%rax
  8004208992:	00 00 00 
  8004208995:	ff d0                	callq  *%rax
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208997:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420899c:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420899f:	48 98                	cltq   
  80042089a1:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042089a5:	0f 87 83 fe ff ff    	ja     800420882e <env_free+0x1c0>
			// free the page table itself
			env_pgdir[pdeno] = 0;
			page_decref(pa2page(pa));
		}
		// free the page directory
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
  80042089ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042089af:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042089b6:	00 
  80042089b7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042089bb:	48 01 d0             	add    %rdx,%rax
  80042089be:	48 8b 00             	mov    (%rax),%rax
  80042089c1:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042089c7:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
		env_pdpe[pdpe_index] = 0;
  80042089cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042089cf:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042089d6:	00 
  80042089d7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042089db:	48 01 d0             	add    %rdx,%rax
  80042089de:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		page_decref(pa2page(pa));
  80042089e5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042089e9:	48 89 c7             	mov    %rax,%rdi
  80042089ec:	48 b8 45 7c 20 04 80 	movabs $0x8004207c45,%rax
  80042089f3:	00 00 00 
  80042089f6:	ff d0                	callq  *%rax
  80042089f8:	48 89 c7             	mov    %rax,%rdi
  80042089fb:	48 b8 2e 36 20 04 80 	movabs $0x800420362e,%rax
  8004208a02:	00 00 00 
  8004208a05:	ff d0                	callq  *%rax
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004208a07:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004208a0c:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004208a11:	0f 86 4a fd ff ff    	jbe    8004208761 <env_free+0xf3>
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
		env_pdpe[pdpe_index] = 0;
		page_decref(pa2page(pa));
	}
	// free the page directory pointer
	page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  8004208a17:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208a1e:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208a25:	48 8b 00             	mov    (%rax),%rax
  8004208a28:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208a2e:	48 89 c7             	mov    %rax,%rdi
  8004208a31:	48 b8 45 7c 20 04 80 	movabs $0x8004207c45,%rax
  8004208a38:	00 00 00 
  8004208a3b:	ff d0                	callq  *%rax
  8004208a3d:	48 89 c7             	mov    %rax,%rdi
  8004208a40:	48 b8 2e 36 20 04 80 	movabs $0x800420362e,%rax
  8004208a47:	00 00 00 
  8004208a4a:	ff d0                	callq  *%rax
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  8004208a4c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208a53:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208a5a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  8004208a61:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208a68:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208a6f:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	e->env_pml4e = 0;
  8004208a73:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208a7a:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  8004208a81:	00 00 00 00 
	e->env_cr3 = 0;
  8004208a85:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208a8c:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8004208a93:	00 00 00 00 
	page_decref(pa2page(pa));
  8004208a97:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208a9b:	48 89 c7             	mov    %rax,%rdi
  8004208a9e:	48 b8 45 7c 20 04 80 	movabs $0x8004207c45,%rax
  8004208aa5:	00 00 00 
  8004208aa8:	ff d0                	callq  *%rax
  8004208aaa:	48 89 c7             	mov    %rax,%rdi
  8004208aad:	48 b8 2e 36 20 04 80 	movabs $0x800420362e,%rax
  8004208ab4:	00 00 00 
  8004208ab7:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  8004208ab9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208ac0:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8004208ac7:	00 00 00 
	e->env_link = env_free_list;
  8004208aca:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  8004208ad1:	00 00 00 
  8004208ad4:	48 8b 10             	mov    (%rax),%rdx
  8004208ad7:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208ade:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  8004208ae5:	48 b8 58 d2 49 04 80 	movabs $0x800449d258,%rax
  8004208aec:	00 00 00 
  8004208aef:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004208af6:	48 89 10             	mov    %rdx,(%rax)
}
  8004208af9:	c9                   	leaveq 
  8004208afa:	c3                   	retq   

0000008004208afb <env_destroy>:
// If e was the current env, then runs a new environment (and does not return
// to the caller).
//
void
env_destroy(struct Env *e)
{
  8004208afb:	55                   	push   %rbp
  8004208afc:	48 89 e5             	mov    %rsp,%rbp
  8004208aff:	48 83 ec 10          	sub    $0x10,%rsp
  8004208b03:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// If e is currently running on other CPUs, we change its state to
	// ENV_DYING. A zombie environment will be freed the next time
	// it traps to the kernel.
	if (e->env_status == ENV_RUNNING && curenv != e) {
  8004208b07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208b0b:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004208b11:	83 f8 03             	cmp    $0x3,%eax
  8004208b14:	75 4a                	jne    8004208b60 <env_destroy+0x65>
  8004208b16:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004208b1d:	00 00 00 
  8004208b20:	ff d0                	callq  *%rax
  8004208b22:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004208b29:	00 00 00 
  8004208b2c:	48 98                	cltq   
  8004208b2e:	48 c1 e0 03          	shl    $0x3,%rax
  8004208b32:	48 89 c2             	mov    %rax,%rdx
  8004208b35:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208b39:	48 29 c2             	sub    %rax,%rdx
  8004208b3c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208b40:	48 83 c0 08          	add    $0x8,%rax
  8004208b44:	48 8b 00             	mov    (%rax),%rax
  8004208b47:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208b4b:	74 13                	je     8004208b60 <env_destroy+0x65>
		e->env_status = ENV_DYING;
  8004208b4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208b51:	c7 80 d4 00 00 00 01 	movl   $0x1,0xd4(%rax)
  8004208b58:	00 00 00 
		return;
  8004208b5b:	e9 8b 00 00 00       	jmpq   8004208beb <env_destroy+0xf0>
	}

	env_free(e);
  8004208b60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208b64:	48 89 c7             	mov    %rax,%rdi
  8004208b67:	48 b8 6e 86 20 04 80 	movabs $0x800420866e,%rax
  8004208b6e:	00 00 00 
  8004208b71:	ff d0                	callq  *%rax
	if (curenv == e) {
  8004208b73:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004208b7a:	00 00 00 
  8004208b7d:	ff d0                	callq  *%rax
  8004208b7f:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004208b86:	00 00 00 
  8004208b89:	48 98                	cltq   
  8004208b8b:	48 c1 e0 03          	shl    $0x3,%rax
  8004208b8f:	48 89 c2             	mov    %rax,%rdx
  8004208b92:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208b96:	48 29 c2             	sub    %rax,%rdx
  8004208b99:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208b9d:	48 83 c0 08          	add    $0x8,%rax
  8004208ba1:	48 8b 00             	mov    (%rax),%rax
  8004208ba4:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208ba8:	75 41                	jne    8004208beb <env_destroy+0xf0>
		curenv = NULL;
  8004208baa:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004208bb1:	00 00 00 
  8004208bb4:	ff d0                	callq  *%rax
  8004208bb6:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004208bbd:	00 00 00 
  8004208bc0:	48 98                	cltq   
  8004208bc2:	48 c1 e0 03          	shl    $0x3,%rax
  8004208bc6:	48 89 c2             	mov    %rax,%rdx
  8004208bc9:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208bcd:	48 29 c2             	sub    %rax,%rdx
  8004208bd0:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208bd4:	48 83 c0 08          	add    $0x8,%rax
  8004208bd8:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		sched_yield();
  8004208bdf:	48 b8 c1 b0 20 04 80 	movabs $0x800420b0c1,%rax
  8004208be6:	00 00 00 
  8004208be9:	ff d0                	callq  *%rax
	}
}
  8004208beb:	c9                   	leaveq 
  8004208bec:	c3                   	retq   

0000008004208bed <env_pop_tf>:
//
// This function does not return.
//
void
env_pop_tf(struct Trapframe *tf)
{
  8004208bed:	55                   	push   %rbp
  8004208bee:	48 89 e5             	mov    %rsp,%rbp
  8004208bf1:	53                   	push   %rbx
  8004208bf2:	48 83 ec 18          	sub    $0x18,%rsp
  8004208bf6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Record the CPU we are running on for user-space debugging
	curenv->env_cpunum = cpunum();
  8004208bfa:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004208c01:	00 00 00 
  8004208c04:	ff d0                	callq  *%rax
  8004208c06:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004208c0d:	00 00 00 
  8004208c10:	48 98                	cltq   
  8004208c12:	48 c1 e0 03          	shl    $0x3,%rax
  8004208c16:	48 89 c2             	mov    %rax,%rdx
  8004208c19:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208c1d:	48 29 c2             	sub    %rax,%rdx
  8004208c20:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208c24:	48 83 c0 08          	add    $0x8,%rax
  8004208c28:	48 8b 18             	mov    (%rax),%rbx
  8004208c2b:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004208c32:	00 00 00 
  8004208c35:	ff d0                	callq  *%rax
  8004208c37:	89 83 dc 00 00 00    	mov    %eax,0xdc(%rbx)
	__asm __volatile("movq %0,%%rsp\n"
  8004208c3d:	48 8b 65 e8          	mov    -0x18(%rbp),%rsp
  8004208c41:	4c 8b 3c 24          	mov    (%rsp),%r15
  8004208c45:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  8004208c4a:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  8004208c4f:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  8004208c54:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  8004208c59:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  8004208c5e:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  8004208c63:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  8004208c68:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  8004208c6d:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  8004208c72:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  8004208c77:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  8004208c7c:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  8004208c81:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  8004208c86:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  8004208c8b:	48 83 c4 78          	add    $0x78,%rsp
  8004208c8f:	8e 04 24             	mov    (%rsp),%es
  8004208c92:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  8004208c96:	48 83 c4 10          	add    $0x10,%rsp
  8004208c9a:	48 83 c4 10          	add    $0x10,%rsp
  8004208c9e:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  8004208ca0:	48 ba 2f 6b 21 04 80 	movabs $0x8004216b2f,%rdx
  8004208ca7:	00 00 00 
  8004208caa:	be 1f 02 00 00       	mov    $0x21f,%esi
  8004208caf:	48 bf a4 6a 21 04 80 	movabs $0x8004216aa4,%rdi
  8004208cb6:	00 00 00 
  8004208cb9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208cbe:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  8004208cc5:	00 00 00 
  8004208cc8:	ff d1                	callq  *%rcx

0000008004208cca <env_run>:
//
// This function does not return.
//
void
env_run(struct Env *e)
{
  8004208cca:	55                   	push   %rbp
  8004208ccb:	48 89 e5             	mov    %rsp,%rbp
  8004208cce:	48 83 ec 20          	sub    $0x20,%rsp
  8004208cd2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//	e->env_tf.  Go back through the code you wrote above
	//	and make sure you have set the relevant parts of
	//	e->env_tf to sensible values.

	// LAB 3: Your code here.
	if(curenv){
  8004208cd6:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004208cdd:	00 00 00 
  8004208ce0:	ff d0                	callq  *%rax
  8004208ce2:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004208ce9:	00 00 00 
  8004208cec:	48 98                	cltq   
  8004208cee:	48 c1 e0 03          	shl    $0x3,%rax
  8004208cf2:	48 89 c2             	mov    %rax,%rdx
  8004208cf5:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208cf9:	48 29 c2             	sub    %rax,%rdx
  8004208cfc:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208d00:	48 83 c0 08          	add    $0x8,%rax
  8004208d04:	48 8b 00             	mov    (%rax),%rax
  8004208d07:	48 85 c0             	test   %rax,%rax
  8004208d0a:	74 77                	je     8004208d83 <env_run+0xb9>
			if(curenv->env_status == ENV_RUNNING){
  8004208d0c:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004208d13:	00 00 00 
  8004208d16:	ff d0                	callq  *%rax
  8004208d18:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004208d1f:	00 00 00 
  8004208d22:	48 98                	cltq   
  8004208d24:	48 c1 e0 03          	shl    $0x3,%rax
  8004208d28:	48 89 c2             	mov    %rax,%rdx
  8004208d2b:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208d2f:	48 29 c2             	sub    %rax,%rdx
  8004208d32:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208d36:	48 83 c0 08          	add    $0x8,%rax
  8004208d3a:	48 8b 00             	mov    (%rax),%rax
  8004208d3d:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004208d43:	83 f8 03             	cmp    $0x3,%eax
  8004208d46:	75 3b                	jne    8004208d83 <env_run+0xb9>
				curenv->env_status = ENV_RUNNABLE;
  8004208d48:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004208d4f:	00 00 00 
  8004208d52:	ff d0                	callq  *%rax
  8004208d54:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004208d5b:	00 00 00 
  8004208d5e:	48 98                	cltq   
  8004208d60:	48 c1 e0 03          	shl    $0x3,%rax
  8004208d64:	48 89 c2             	mov    %rax,%rdx
  8004208d67:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208d6b:	48 29 c2             	sub    %rax,%rdx
  8004208d6e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208d72:	48 83 c0 08          	add    $0x8,%rax
  8004208d76:	48 8b 00             	mov    (%rax),%rax
  8004208d79:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004208d80:	00 00 00 
			}
	}
	curenv = e;
  8004208d83:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004208d8a:	00 00 00 
  8004208d8d:	ff d0                	callq  *%rax
  8004208d8f:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004208d96:	00 00 00 
  8004208d99:	48 98                	cltq   
  8004208d9b:	48 c1 e0 03          	shl    $0x3,%rax
  8004208d9f:	48 89 c2             	mov    %rax,%rdx
  8004208da2:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208da6:	48 29 c2             	sub    %rax,%rdx
  8004208da9:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208dad:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004208db1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208db5:	48 89 02             	mov    %rax,(%rdx)
	curenv->env_status = ENV_RUNNING;
  8004208db8:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004208dbf:	00 00 00 
  8004208dc2:	ff d0                	callq  *%rax
  8004208dc4:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004208dcb:	00 00 00 
  8004208dce:	48 98                	cltq   
  8004208dd0:	48 c1 e0 03          	shl    $0x3,%rax
  8004208dd4:	48 89 c2             	mov    %rax,%rdx
  8004208dd7:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208ddb:	48 29 c2             	sub    %rax,%rdx
  8004208dde:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208de2:	48 83 c0 08          	add    $0x8,%rax
  8004208de6:	48 8b 00             	mov    (%rax),%rax
  8004208de9:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  8004208df0:	00 00 00 
	curenv->env_runs++;
  8004208df3:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004208dfa:	00 00 00 
  8004208dfd:	ff d0                	callq  *%rax
  8004208dff:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004208e06:	00 00 00 
  8004208e09:	48 98                	cltq   
  8004208e0b:	48 c1 e0 03          	shl    $0x3,%rax
  8004208e0f:	48 89 c2             	mov    %rax,%rdx
  8004208e12:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208e16:	48 29 c2             	sub    %rax,%rdx
  8004208e19:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208e1d:	48 83 c0 08          	add    $0x8,%rax
  8004208e21:	48 8b 00             	mov    (%rax),%rax
  8004208e24:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  8004208e2a:	83 c2 01             	add    $0x1,%edx
  8004208e2d:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
	unlock_kernel();
  8004208e33:	48 b8 3e 7d 20 04 80 	movabs $0x8004207d3e,%rax
  8004208e3a:	00 00 00 
  8004208e3d:	ff d0                	callq  *%rax
	lcr3(curenv->env_cr3);
  8004208e3f:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004208e46:	00 00 00 
  8004208e49:	ff d0                	callq  *%rax
  8004208e4b:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004208e52:	00 00 00 
  8004208e55:	48 98                	cltq   
  8004208e57:	48 c1 e0 03          	shl    $0x3,%rax
  8004208e5b:	48 89 c2             	mov    %rax,%rdx
  8004208e5e:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208e62:	48 29 c2             	sub    %rax,%rdx
  8004208e65:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208e69:	48 83 c0 08          	add    $0x8,%rax
  8004208e6d:	48 8b 00             	mov    (%rax),%rax
  8004208e70:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208e77:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004208e7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208e7f:	0f 22 d8             	mov    %rax,%cr3
	//unlock_kernel();
	env_pop_tf(&(curenv->env_tf));
  8004208e82:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004208e89:	00 00 00 
  8004208e8c:	ff d0                	callq  *%rax
  8004208e8e:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  8004208e95:	00 00 00 
  8004208e98:	48 98                	cltq   
  8004208e9a:	48 c1 e0 03          	shl    $0x3,%rax
  8004208e9e:	48 89 c2             	mov    %rax,%rdx
  8004208ea1:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208ea5:	48 29 c2             	sub    %rax,%rdx
  8004208ea8:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208eac:	48 83 c0 08          	add    $0x8,%rax
  8004208eb0:	48 8b 00             	mov    (%rax),%rax
  8004208eb3:	48 89 c7             	mov    %rax,%rdi
  8004208eb6:	48 b8 ed 8b 20 04 80 	movabs $0x8004208bed,%rax
  8004208ebd:	00 00 00 
  8004208ec0:	ff d0                	callq  *%rax

0000008004208ec2 <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  8004208ec2:	55                   	push   %rbp
  8004208ec3:	48 89 e5             	mov    %rsp,%rbp
  8004208ec6:	48 83 ec 14          	sub    $0x14,%rsp
  8004208eca:	89 7d ec             	mov    %edi,-0x14(%rbp)
	outb(IO_RTC, reg);
  8004208ecd:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208ed0:	0f b6 c0             	movzbl %al,%eax
  8004208ed3:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004208eda:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004208edd:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208ee1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208ee4:	ee                   	out    %al,(%dx)
  8004208ee5:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004208eec:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004208eef:	89 c2                	mov    %eax,%edx
  8004208ef1:	ec                   	in     (%dx),%al
  8004208ef2:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004208ef5:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(IO_RTC+1);
  8004208ef9:	0f b6 c0             	movzbl %al,%eax
}
  8004208efc:	c9                   	leaveq 
  8004208efd:	c3                   	retq   

0000008004208efe <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  8004208efe:	55                   	push   %rbp
  8004208eff:	48 89 e5             	mov    %rsp,%rbp
  8004208f02:	48 83 ec 18          	sub    $0x18,%rsp
  8004208f06:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004208f09:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  8004208f0c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208f0f:	0f b6 c0             	movzbl %al,%eax
  8004208f12:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004208f19:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004208f1c:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208f20:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208f23:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  8004208f24:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004208f27:	0f b6 c0             	movzbl %al,%eax
  8004208f2a:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)
  8004208f31:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004208f34:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208f38:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208f3b:	ee                   	out    %al,(%dx)
}
  8004208f3c:	c9                   	leaveq 
  8004208f3d:	c3                   	retq   

0000008004208f3e <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
  8004208f3e:	55                   	push   %rbp
  8004208f3f:	48 89 e5             	mov    %rsp,%rbp
  8004208f42:	48 83 ec 70          	sub    $0x70,%rsp
	didinit = 1;
  8004208f46:	48 b8 60 d2 49 04 80 	movabs $0x800449d260,%rax
  8004208f4d:	00 00 00 
  8004208f50:	c6 00 01             	movb   $0x1,(%rax)
  8004208f53:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%rbp)
  8004208f5a:	c6 45 fb ff          	movb   $0xff,-0x5(%rbp)
  8004208f5e:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208f62:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208f65:	ee                   	out    %al,(%dx)
  8004208f66:	c7 45 f4 a1 00 00 00 	movl   $0xa1,-0xc(%rbp)
  8004208f6d:	c6 45 f3 ff          	movb   $0xff,-0xd(%rbp)
  8004208f71:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208f75:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208f78:	ee                   	out    %al,(%dx)
  8004208f79:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%rbp)
  8004208f80:	c6 45 eb 11          	movb   $0x11,-0x15(%rbp)
  8004208f84:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004208f88:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004208f8b:	ee                   	out    %al,(%dx)
  8004208f8c:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%rbp)
  8004208f93:	c6 45 e3 20          	movb   $0x20,-0x1d(%rbp)
  8004208f97:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004208f9b:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004208f9e:	ee                   	out    %al,(%dx)
  8004208f9f:	c7 45 dc 21 00 00 00 	movl   $0x21,-0x24(%rbp)
  8004208fa6:	c6 45 db 04          	movb   $0x4,-0x25(%rbp)
  8004208faa:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004208fae:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004208fb1:	ee                   	out    %al,(%dx)
  8004208fb2:	c7 45 d4 21 00 00 00 	movl   $0x21,-0x2c(%rbp)
  8004208fb9:	c6 45 d3 03          	movb   $0x3,-0x2d(%rbp)
  8004208fbd:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004208fc1:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004208fc4:	ee                   	out    %al,(%dx)
  8004208fc5:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%rbp)
  8004208fcc:	c6 45 cb 11          	movb   $0x11,-0x35(%rbp)
  8004208fd0:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004208fd4:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004208fd7:	ee                   	out    %al,(%dx)
  8004208fd8:	c7 45 c4 a1 00 00 00 	movl   $0xa1,-0x3c(%rbp)
  8004208fdf:	c6 45 c3 28          	movb   $0x28,-0x3d(%rbp)
  8004208fe3:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  8004208fe7:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004208fea:	ee                   	out    %al,(%dx)
  8004208feb:	c7 45 bc a1 00 00 00 	movl   $0xa1,-0x44(%rbp)
  8004208ff2:	c6 45 bb 02          	movb   $0x2,-0x45(%rbp)
  8004208ff6:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004208ffa:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004208ffd:	ee                   	out    %al,(%dx)
  8004208ffe:	c7 45 b4 a1 00 00 00 	movl   $0xa1,-0x4c(%rbp)
  8004209005:	c6 45 b3 01          	movb   $0x1,-0x4d(%rbp)
  8004209009:	0f b6 45 b3          	movzbl -0x4d(%rbp),%eax
  800420900d:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004209010:	ee                   	out    %al,(%dx)
  8004209011:	c7 45 ac 20 00 00 00 	movl   $0x20,-0x54(%rbp)
  8004209018:	c6 45 ab 68          	movb   $0x68,-0x55(%rbp)
  800420901c:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  8004209020:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004209023:	ee                   	out    %al,(%dx)
  8004209024:	c7 45 a4 20 00 00 00 	movl   $0x20,-0x5c(%rbp)
  800420902b:	c6 45 a3 0a          	movb   $0xa,-0x5d(%rbp)
  800420902f:	0f b6 45 a3          	movzbl -0x5d(%rbp),%eax
  8004209033:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004209036:	ee                   	out    %al,(%dx)
  8004209037:	c7 45 9c a0 00 00 00 	movl   $0xa0,-0x64(%rbp)
  800420903e:	c6 45 9b 68          	movb   $0x68,-0x65(%rbp)
  8004209042:	0f b6 45 9b          	movzbl -0x65(%rbp),%eax
  8004209046:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004209049:	ee                   	out    %al,(%dx)
  800420904a:	c7 45 94 a0 00 00 00 	movl   $0xa0,-0x6c(%rbp)
  8004209051:	c6 45 93 0a          	movb   $0xa,-0x6d(%rbp)
  8004209055:	0f b6 45 93          	movzbl -0x6d(%rbp),%eax
  8004209059:	8b 55 94             	mov    -0x6c(%rbp),%edx
  800420905c:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
  800420905d:	48 b8 12 a7 22 04 80 	movabs $0x800422a712,%rax
  8004209064:	00 00 00 
  8004209067:	0f b7 00             	movzwl (%rax),%eax
  800420906a:	66 83 f8 ff          	cmp    $0xffff,%ax
  800420906e:	74 1e                	je     800420908e <pic_init+0x150>
		irq_setmask_8259A(irq_mask_8259A);
  8004209070:	48 b8 12 a7 22 04 80 	movabs $0x800422a712,%rax
  8004209077:	00 00 00 
  800420907a:	0f b7 00             	movzwl (%rax),%eax
  800420907d:	0f b7 c0             	movzwl %ax,%eax
  8004209080:	89 c7                	mov    %eax,%edi
  8004209082:	48 b8 90 90 20 04 80 	movabs $0x8004209090,%rax
  8004209089:	00 00 00 
  800420908c:	ff d0                	callq  *%rax
}
  800420908e:	c9                   	leaveq 
  800420908f:	c3                   	retq   

0000008004209090 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16_t mask)
{
  8004209090:	55                   	push   %rbp
  8004209091:	48 89 e5             	mov    %rsp,%rbp
  8004209094:	48 83 ec 30          	sub    $0x30,%rsp
  8004209098:	89 f8                	mov    %edi,%eax
  800420909a:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
	int i;
	irq_mask_8259A = mask;
  800420909e:	48 b8 12 a7 22 04 80 	movabs $0x800422a712,%rax
  80042090a5:	00 00 00 
  80042090a8:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80042090ac:	66 89 10             	mov    %dx,(%rax)
	if (!didinit)
  80042090af:	48 b8 60 d2 49 04 80 	movabs $0x800449d260,%rax
  80042090b6:	00 00 00 
  80042090b9:	0f b6 00             	movzbl (%rax),%eax
  80042090bc:	83 f0 01             	xor    $0x1,%eax
  80042090bf:	84 c0                	test   %al,%al
  80042090c1:	74 05                	je     80042090c8 <irq_setmask_8259A+0x38>
		return;
  80042090c3:	e9 b7 00 00 00       	jmpq   800420917f <irq_setmask_8259A+0xef>
	outb(IO_PIC1+1, (char)mask);
  80042090c8:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80042090cc:	0f b6 c0             	movzbl %al,%eax
  80042090cf:	c7 45 f8 21 00 00 00 	movl   $0x21,-0x8(%rbp)
  80042090d6:	88 45 f7             	mov    %al,-0x9(%rbp)
  80042090d9:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  80042090dd:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80042090e0:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
  80042090e1:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80042090e5:	66 c1 e8 08          	shr    $0x8,%ax
  80042090e9:	0f b6 c0             	movzbl %al,%eax
  80042090ec:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%rbp)
  80042090f3:	88 45 ef             	mov    %al,-0x11(%rbp)
  80042090f6:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042090fa:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042090fd:	ee                   	out    %al,(%dx)
	cprintf("enabled interrupts:");
  80042090fe:	48 bf 3b 6b 21 04 80 	movabs $0x8004216b3b,%rdi
  8004209105:	00 00 00 
  8004209108:	b8 00 00 00 00       	mov    $0x0,%eax
  800420910d:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004209114:	00 00 00 
  8004209117:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  8004209119:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004209120:	eb 3c                	jmp    800420915e <irq_setmask_8259A+0xce>
		if (~mask & (1<<i))
  8004209122:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004209126:	f7 d0                	not    %eax
  8004209128:	89 c2                	mov    %eax,%edx
  800420912a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420912d:	89 c1                	mov    %eax,%ecx
  800420912f:	d3 fa                	sar    %cl,%edx
  8004209131:	89 d0                	mov    %edx,%eax
  8004209133:	83 e0 01             	and    $0x1,%eax
  8004209136:	85 c0                	test   %eax,%eax
  8004209138:	74 20                	je     800420915a <irq_setmask_8259A+0xca>
			cprintf(" %d", i);
  800420913a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420913d:	89 c6                	mov    %eax,%esi
  800420913f:	48 bf 4f 6b 21 04 80 	movabs $0x8004216b4f,%rdi
  8004209146:	00 00 00 
  8004209149:	b8 00 00 00 00       	mov    $0x0,%eax
  800420914e:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004209155:	00 00 00 
  8004209158:	ff d2                	callq  *%rdx
	if (!didinit)
		return;
	outb(IO_PIC1+1, (char)mask);
	outb(IO_PIC2+1, (char)(mask >> 8));
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
  800420915a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420915e:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  8004209162:	7e be                	jle    8004209122 <irq_setmask_8259A+0x92>
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
  8004209164:	48 bf 53 6b 21 04 80 	movabs $0x8004216b53,%rdi
  800420916b:	00 00 00 
  800420916e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209173:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420917a:	00 00 00 
  800420917d:	ff d2                	callq  *%rdx
}
  800420917f:	c9                   	leaveq 
  8004209180:	c3                   	retq   

0000008004209181 <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  8004209181:	55                   	push   %rbp
  8004209182:	48 89 e5             	mov    %rsp,%rbp
  8004209185:	48 83 ec 10          	sub    $0x10,%rsp
  8004209189:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420918c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  8004209190:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209193:	89 c7                	mov    %eax,%edi
  8004209195:	48 b8 d8 11 20 04 80 	movabs $0x80042011d8,%rax
  800420919c:	00 00 00 
  800420919f:	ff d0                	callq  *%rax
	*cnt++;
  80042091a1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042091a5:	48 83 c0 04          	add    $0x4,%rax
  80042091a9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  80042091ad:	c9                   	leaveq 
  80042091ae:	c3                   	retq   

00000080042091af <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80042091af:	55                   	push   %rbp
  80042091b0:	48 89 e5             	mov    %rsp,%rbp
  80042091b3:	48 83 ec 30          	sub    $0x30,%rsp
  80042091b7:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042091bb:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  80042091bf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	va_list aq;
	va_copy(aq,ap);
  80042091c6:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80042091ca:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042091ce:	48 8b 0a             	mov    (%rdx),%rcx
  80042091d1:	48 89 08             	mov    %rcx,(%rax)
  80042091d4:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042091d8:	48 89 48 08          	mov    %rcx,0x8(%rax)
  80042091dc:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80042091e0:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  80042091e4:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  80042091e8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042091ec:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  80042091f0:	48 89 c6             	mov    %rax,%rsi
  80042091f3:	48 bf 81 91 20 04 80 	movabs $0x8004209181,%rdi
  80042091fa:	00 00 00 
  80042091fd:	48 b8 06 cf 20 04 80 	movabs $0x800420cf06,%rax
  8004209204:	00 00 00 
  8004209207:	ff d0                	callq  *%rax
	va_end(aq);
	return cnt;
  8004209209:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  800420920c:	c9                   	leaveq 
  800420920d:	c3                   	retq   

000000800420920e <cprintf>:

int
cprintf(const char *fmt, ...)
{
  800420920e:	55                   	push   %rbp
  800420920f:	48 89 e5             	mov    %rsp,%rbp
  8004209212:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  8004209219:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  8004209220:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  8004209227:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420922e:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004209235:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420923c:	84 c0                	test   %al,%al
  800420923e:	74 20                	je     8004209260 <cprintf+0x52>
  8004209240:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004209244:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004209248:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420924c:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004209250:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004209254:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004209258:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420925c:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004209260:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  8004209267:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  800420926e:	00 00 00 
  8004209271:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  8004209278:	00 00 00 
  800420927b:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420927f:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004209286:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420928d:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004209294:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420929b:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  80042092a2:	48 8b 0a             	mov    (%rdx),%rcx
  80042092a5:	48 89 08             	mov    %rcx,(%rax)
  80042092a8:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042092ac:	48 89 48 08          	mov    %rcx,0x8(%rax)
  80042092b0:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80042092b4:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  80042092b8:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  80042092bf:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80042092c6:	48 89 d6             	mov    %rdx,%rsi
  80042092c9:	48 89 c7             	mov    %rax,%rdi
  80042092cc:	48 b8 af 91 20 04 80 	movabs $0x80042091af,%rax
  80042092d3:	00 00 00 
  80042092d6:	ff d0                	callq  *%rax
  80042092d8:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  80042092de:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  80042092e4:	c9                   	leaveq 
  80042092e5:	c3                   	retq   

00000080042092e6 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  80042092e6:	55                   	push   %rbp
  80042092e7:	48 89 e5             	mov    %rsp,%rbp
  80042092ea:	48 83 ec 1c          	sub    $0x1c,%rsp
  80042092ee:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042092f2:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  80042092f5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042092f9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042092fc:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004209300:	f0 87 02             	lock xchg %eax,(%rdx)
  8004209303:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004209306:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004209309:	c9                   	leaveq 
  800420930a:	c3                   	retq   

000000800420930b <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800420930b:	55                   	push   %rbp
  800420930c:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  800420930f:	48 bf 20 a9 22 04 80 	movabs $0x800422a920,%rdi
  8004209316:	00 00 00 
  8004209319:	48 b8 1c 4e 21 04 80 	movabs $0x8004214e1c,%rax
  8004209320:	00 00 00 
  8004209323:	ff d0                	callq  *%rax
}
  8004209325:	5d                   	pop    %rbp
  8004209326:	c3                   	retq   

0000008004209327 <trapname>:
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {0,0};


static const char *trapname(int trapno)
{
  8004209327:	55                   	push   %rbp
  8004209328:	48 89 e5             	mov    %rsp,%rbp
  800420932b:	48 83 ec 04          	sub    $0x4,%rsp
  800420932f:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  8004209332:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209335:	83 f8 13             	cmp    $0x13,%eax
  8004209338:	77 16                	ja     8004209350 <trapname+0x29>
		return excnames[trapno];
  800420933a:	48 b8 00 71 21 04 80 	movabs $0x8004217100,%rax
  8004209341:	00 00 00 
  8004209344:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209347:	48 63 d2             	movslq %edx,%rdx
  800420934a:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  800420934e:	eb 34                	jmp    8004209384 <trapname+0x5d>
	if (trapno == T_SYSCALL)
  8004209350:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  8004209354:	75 0c                	jne    8004209362 <trapname+0x3b>
		return "System call";
  8004209356:	48 b8 60 6b 21 04 80 	movabs $0x8004216b60,%rax
  800420935d:	00 00 00 
  8004209360:	eb 22                	jmp    8004209384 <trapname+0x5d>
	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
  8004209362:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8004209366:	7e 12                	jle    800420937a <trapname+0x53>
  8004209368:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  800420936c:	7f 0c                	jg     800420937a <trapname+0x53>
		return "Hardware Interrupt";
  800420936e:	48 b8 6c 6b 21 04 80 	movabs $0x8004216b6c,%rax
  8004209375:	00 00 00 
  8004209378:	eb 0a                	jmp    8004209384 <trapname+0x5d>
	return "(unknown trap)";
  800420937a:	48 b8 7f 6b 21 04 80 	movabs $0x8004216b7f,%rax
  8004209381:	00 00 00 
}
  8004209384:	c9                   	leaveq 
  8004209385:	c3                   	retq   

0000008004209386 <trap_init>:
void TH_syscall();
void TH_default();
*/
void
trap_init(void)
{
  8004209386:	55                   	push   %rbp
  8004209387:	48 89 e5             	mov    %rsp,%rbp
  800420938a:	48 83 ec 70          	sub    $0x70,%rsp
  extern struct Segdesc gdt[];
	extern uint64_t handlers[];
	extern void* sysenter_handler(void);
	int i;
	char dpl[] = {0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  800420938e:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8004209395:	00 
  8004209396:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  800420939d:	00 
  800420939e:	66 c7 45 a0 00 00    	movw   $0x0,-0x60(%rbp)
  80042093a4:	c6 45 91 03          	movb   $0x3,-0x6f(%rbp)
  80042093a8:	c6 45 93 03          	movb   $0x3,-0x6d(%rbp)
	for(i = 0; i < 20; i++){
  80042093ac:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042093b3:	e9 b6 01 00 00       	jmpq   800420956e <trap_init+0x1e8>
		SETGATE(idt[i], 0, GD_KT, handlers[i], dpl[i]);
  80042093b8:	48 b8 14 a7 22 04 80 	movabs $0x800422a714,%rax
  80042093bf:	00 00 00 
  80042093c2:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042093c5:	48 63 d2             	movslq %edx,%rdx
  80042093c8:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80042093cc:	48 ba 80 d2 49 04 80 	movabs $0x800449d280,%rdx
  80042093d3:	00 00 00 
  80042093d6:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042093d9:	48 63 c9             	movslq %ecx,%rcx
  80042093dc:	48 c1 e1 04          	shl    $0x4,%rcx
  80042093e0:	48 01 ca             	add    %rcx,%rdx
  80042093e3:	66 89 02             	mov    %ax,(%rdx)
  80042093e6:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042093ed:	00 00 00 
  80042093f0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042093f3:	48 63 d2             	movslq %edx,%rdx
  80042093f6:	48 c1 e2 04          	shl    $0x4,%rdx
  80042093fa:	48 01 d0             	add    %rdx,%rax
  80042093fd:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  8004209403:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420940a:	00 00 00 
  800420940d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209410:	48 63 d2             	movslq %edx,%rdx
  8004209413:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209417:	48 01 d0             	add    %rdx,%rax
  800420941a:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  800420941e:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209421:	88 50 04             	mov    %dl,0x4(%rax)
  8004209424:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420942b:	00 00 00 
  800420942e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209431:	48 63 d2             	movslq %edx,%rdx
  8004209434:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209438:	48 01 d0             	add    %rdx,%rax
  800420943b:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  800420943f:	83 e2 07             	and    $0x7,%edx
  8004209442:	88 50 04             	mov    %dl,0x4(%rax)
  8004209445:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420944c:	00 00 00 
  800420944f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209452:	48 63 d2             	movslq %edx,%rdx
  8004209455:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209459:	48 01 d0             	add    %rdx,%rax
  800420945c:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209460:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209463:	83 ca 0e             	or     $0xe,%edx
  8004209466:	88 50 05             	mov    %dl,0x5(%rax)
  8004209469:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209470:	00 00 00 
  8004209473:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209476:	48 63 d2             	movslq %edx,%rdx
  8004209479:	48 c1 e2 04          	shl    $0x4,%rdx
  800420947d:	48 01 d0             	add    %rdx,%rax
  8004209480:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209484:	83 e2 ef             	and    $0xffffffef,%edx
  8004209487:	88 50 05             	mov    %dl,0x5(%rax)
  800420948a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420948d:	48 98                	cltq   
  800420948f:	0f b6 44 05 90       	movzbl -0x70(%rbp,%rax,1),%eax
  8004209494:	83 e0 03             	and    $0x3,%eax
  8004209497:	89 c1                	mov    %eax,%ecx
  8004209499:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042094a0:	00 00 00 
  80042094a3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042094a6:	48 63 d2             	movslq %edx,%rdx
  80042094a9:	48 c1 e2 04          	shl    $0x4,%rdx
  80042094ad:	48 01 d0             	add    %rdx,%rax
  80042094b0:	83 e1 03             	and    $0x3,%ecx
  80042094b3:	89 ca                	mov    %ecx,%edx
  80042094b5:	89 d1                	mov    %edx,%ecx
  80042094b7:	c1 e1 05             	shl    $0x5,%ecx
  80042094ba:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042094be:	83 e2 9f             	and    $0xffffff9f,%edx
  80042094c1:	09 ca                	or     %ecx,%edx
  80042094c3:	88 50 05             	mov    %dl,0x5(%rax)
  80042094c6:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042094cd:	00 00 00 
  80042094d0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042094d3:	48 63 d2             	movslq %edx,%rdx
  80042094d6:	48 c1 e2 04          	shl    $0x4,%rdx
  80042094da:	48 01 d0             	add    %rdx,%rax
  80042094dd:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042094e1:	83 ca 80             	or     $0xffffff80,%edx
  80042094e4:	88 50 05             	mov    %dl,0x5(%rax)
  80042094e7:	48 b8 14 a7 22 04 80 	movabs $0x800422a714,%rax
  80042094ee:	00 00 00 
  80042094f1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042094f4:	48 63 d2             	movslq %edx,%rdx
  80042094f7:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80042094fb:	48 c1 e8 10          	shr    $0x10,%rax
  80042094ff:	48 ba 80 d2 49 04 80 	movabs $0x800449d280,%rdx
  8004209506:	00 00 00 
  8004209509:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800420950c:	48 63 c9             	movslq %ecx,%rcx
  800420950f:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209513:	48 01 ca             	add    %rcx,%rdx
  8004209516:	66 89 42 06          	mov    %ax,0x6(%rdx)
  800420951a:	48 b8 14 a7 22 04 80 	movabs $0x800422a714,%rax
  8004209521:	00 00 00 
  8004209524:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209527:	48 63 d2             	movslq %edx,%rdx
  800420952a:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  800420952e:	48 c1 e8 20          	shr    $0x20,%rax
  8004209532:	48 ba 80 d2 49 04 80 	movabs $0x800449d280,%rdx
  8004209539:	00 00 00 
  800420953c:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800420953f:	48 63 c9             	movslq %ecx,%rcx
  8004209542:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209546:	48 01 ca             	add    %rcx,%rdx
  8004209549:	89 42 08             	mov    %eax,0x8(%rdx)
  800420954c:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209553:	00 00 00 
  8004209556:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209559:	48 63 d2             	movslq %edx,%rdx
  800420955c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209560:	48 01 d0             	add    %rdx,%rax
  8004209563:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
  extern struct Segdesc gdt[];
	extern uint64_t handlers[];
	extern void* sysenter_handler(void);
	int i;
	char dpl[] = {0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	for(i = 0; i < 20; i++){
  800420956a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420956e:	83 7d fc 13          	cmpl   $0x13,-0x4(%rbp)
  8004209572:	0f 8e 40 fe ff ff    	jle    80042093b8 <trap_init+0x32>
		SETGATE(idt[i], 0, GD_KT, handlers[i], dpl[i]);
	}
	for(; i < 256; i++){
  8004209578:	e9 92 01 00 00       	jmpq   800420970f <trap_init+0x389>
		SETGATE(idt[i], 0, GD_KT, handlers[21], 0);
  800420957d:	48 b8 14 a7 22 04 80 	movabs $0x800422a714,%rax
  8004209584:	00 00 00 
  8004209587:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420958e:	48 ba 80 d2 49 04 80 	movabs $0x800449d280,%rdx
  8004209595:	00 00 00 
  8004209598:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800420959b:	48 63 c9             	movslq %ecx,%rcx
  800420959e:	48 c1 e1 04          	shl    $0x4,%rcx
  80042095a2:	48 01 ca             	add    %rcx,%rdx
  80042095a5:	66 89 02             	mov    %ax,(%rdx)
  80042095a8:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042095af:	00 00 00 
  80042095b2:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042095b5:	48 63 d2             	movslq %edx,%rdx
  80042095b8:	48 c1 e2 04          	shl    $0x4,%rdx
  80042095bc:	48 01 d0             	add    %rdx,%rax
  80042095bf:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  80042095c5:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042095cc:	00 00 00 
  80042095cf:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042095d2:	48 63 d2             	movslq %edx,%rdx
  80042095d5:	48 c1 e2 04          	shl    $0x4,%rdx
  80042095d9:	48 01 d0             	add    %rdx,%rax
  80042095dc:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  80042095e0:	83 e2 f8             	and    $0xfffffff8,%edx
  80042095e3:	88 50 04             	mov    %dl,0x4(%rax)
  80042095e6:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042095ed:	00 00 00 
  80042095f0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042095f3:	48 63 d2             	movslq %edx,%rdx
  80042095f6:	48 c1 e2 04          	shl    $0x4,%rdx
  80042095fa:	48 01 d0             	add    %rdx,%rax
  80042095fd:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004209601:	83 e2 07             	and    $0x7,%edx
  8004209604:	88 50 04             	mov    %dl,0x4(%rax)
  8004209607:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420960e:	00 00 00 
  8004209611:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209614:	48 63 d2             	movslq %edx,%rdx
  8004209617:	48 c1 e2 04          	shl    $0x4,%rdx
  800420961b:	48 01 d0             	add    %rdx,%rax
  800420961e:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209622:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209625:	83 ca 0e             	or     $0xe,%edx
  8004209628:	88 50 05             	mov    %dl,0x5(%rax)
  800420962b:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209632:	00 00 00 
  8004209635:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209638:	48 63 d2             	movslq %edx,%rdx
  800420963b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420963f:	48 01 d0             	add    %rdx,%rax
  8004209642:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209646:	83 e2 ef             	and    $0xffffffef,%edx
  8004209649:	88 50 05             	mov    %dl,0x5(%rax)
  800420964c:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209653:	00 00 00 
  8004209656:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209659:	48 63 d2             	movslq %edx,%rdx
  800420965c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209660:	48 01 d0             	add    %rdx,%rax
  8004209663:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209667:	83 e2 9f             	and    $0xffffff9f,%edx
  800420966a:	88 50 05             	mov    %dl,0x5(%rax)
  800420966d:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209674:	00 00 00 
  8004209677:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420967a:	48 63 d2             	movslq %edx,%rdx
  800420967d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209681:	48 01 d0             	add    %rdx,%rax
  8004209684:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209688:	83 ca 80             	or     $0xffffff80,%edx
  800420968b:	88 50 05             	mov    %dl,0x5(%rax)
  800420968e:	48 b8 14 a7 22 04 80 	movabs $0x800422a714,%rax
  8004209695:	00 00 00 
  8004209698:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420969f:	48 c1 e8 10          	shr    $0x10,%rax
  80042096a3:	48 ba 80 d2 49 04 80 	movabs $0x800449d280,%rdx
  80042096aa:	00 00 00 
  80042096ad:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042096b0:	48 63 c9             	movslq %ecx,%rcx
  80042096b3:	48 c1 e1 04          	shl    $0x4,%rcx
  80042096b7:	48 01 ca             	add    %rcx,%rdx
  80042096ba:	66 89 42 06          	mov    %ax,0x6(%rdx)
  80042096be:	48 b8 14 a7 22 04 80 	movabs $0x800422a714,%rax
  80042096c5:	00 00 00 
  80042096c8:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  80042096cf:	48 c1 e8 20          	shr    $0x20,%rax
  80042096d3:	48 ba 80 d2 49 04 80 	movabs $0x800449d280,%rdx
  80042096da:	00 00 00 
  80042096dd:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042096e0:	48 63 c9             	movslq %ecx,%rcx
  80042096e3:	48 c1 e1 04          	shl    $0x4,%rcx
  80042096e7:	48 01 ca             	add    %rcx,%rdx
  80042096ea:	89 42 08             	mov    %eax,0x8(%rdx)
  80042096ed:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042096f4:	00 00 00 
  80042096f7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042096fa:	48 63 d2             	movslq %edx,%rdx
  80042096fd:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209701:	48 01 d0             	add    %rdx,%rax
  8004209704:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
	int i;
	char dpl[] = {0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	for(i = 0; i < 20; i++){
		SETGATE(idt[i], 0, GD_KT, handlers[i], dpl[i]);
	}
	for(; i < 256; i++){
  800420970b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420970f:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%rbp)
  8004209716:	0f 8e 61 fe ff ff    	jle    800420957d <trap_init+0x1f7>
		SETGATE(idt[i], 0, GD_KT, handlers[21], 0);
	}

	//SETGATE(idt[14], 0, GD_KT, handlers[14], 0);
	SETGATE(idt[T_NMI], 0, GD_KT, handlers[2], 0);
  800420971c:	48 b8 14 a7 22 04 80 	movabs $0x800422a714,%rax
  8004209723:	00 00 00 
  8004209726:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420972a:	89 c2                	mov    %eax,%edx
  800420972c:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209733:	00 00 00 
  8004209736:	66 89 50 20          	mov    %dx,0x20(%rax)
  800420973a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209741:	00 00 00 
  8004209744:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  800420974a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209751:	00 00 00 
  8004209754:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004209758:	83 e2 f8             	and    $0xfffffff8,%edx
  800420975b:	88 50 24             	mov    %dl,0x24(%rax)
  800420975e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209765:	00 00 00 
  8004209768:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  800420976c:	83 e2 07             	and    $0x7,%edx
  800420976f:	88 50 24             	mov    %dl,0x24(%rax)
  8004209772:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209779:	00 00 00 
  800420977c:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004209780:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209783:	83 ca 0e             	or     $0xe,%edx
  8004209786:	88 50 25             	mov    %dl,0x25(%rax)
  8004209789:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209790:	00 00 00 
  8004209793:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004209797:	83 e2 ef             	and    $0xffffffef,%edx
  800420979a:	88 50 25             	mov    %dl,0x25(%rax)
  800420979d:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042097a4:	00 00 00 
  80042097a7:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  80042097ab:	83 e2 9f             	and    $0xffffff9f,%edx
  80042097ae:	88 50 25             	mov    %dl,0x25(%rax)
  80042097b1:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042097b8:	00 00 00 
  80042097bb:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  80042097bf:	83 ca 80             	or     $0xffffff80,%edx
  80042097c2:	88 50 25             	mov    %dl,0x25(%rax)
  80042097c5:	48 b8 14 a7 22 04 80 	movabs $0x800422a714,%rax
  80042097cc:	00 00 00 
  80042097cf:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042097d3:	48 c1 e8 10          	shr    $0x10,%rax
  80042097d7:	89 c2                	mov    %eax,%edx
  80042097d9:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042097e0:	00 00 00 
  80042097e3:	66 89 50 26          	mov    %dx,0x26(%rax)
  80042097e7:	48 b8 14 a7 22 04 80 	movabs $0x800422a714,%rax
  80042097ee:	00 00 00 
  80042097f1:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042097f5:	48 c1 e8 20          	shr    $0x20,%rax
  80042097f9:	89 c2                	mov    %eax,%edx
  80042097fb:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209802:	00 00 00 
  8004209805:	89 50 28             	mov    %edx,0x28(%rax)
  8004209808:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420980f:	00 00 00 
  8004209812:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
	SETGATE(idt[T_PGFLT], 1, GD_KT,vectors[14], 0);
	SETGATE(idt[T_FPERR], 1, GD_KT, TH_fperr, 0);
	SETGATE(idt[T_ALIGN], 1, GD_KT, TH_align, 0);
	SETGATE(idt[T_MCHK], 1, GD_KT, TH_mchk, 0);
	SETGATE(idt[T_SIMDERR], 1, GD_KT, TH_simderr, 0);*/
	SETGATE(idt[T_SYSCALL], 0, GD_KT, handlers[20], 3);
  8004209819:	48 b8 14 a7 22 04 80 	movabs $0x800422a714,%rax
  8004209820:	00 00 00 
  8004209823:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  800420982a:	89 c2                	mov    %eax,%edx
  800420982c:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209833:	00 00 00 
  8004209836:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  800420983d:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209844:	00 00 00 
  8004209847:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  800420984e:	08 00 
  8004209850:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209857:	00 00 00 
  800420985a:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  8004209861:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209864:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420986a:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209871:	00 00 00 
  8004209874:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420987b:	83 e2 07             	and    $0x7,%edx
  800420987e:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  8004209884:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420988b:	00 00 00 
  800420988e:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209895:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209898:	83 ca 0e             	or     $0xe,%edx
  800420989b:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  80042098a1:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042098a8:	00 00 00 
  80042098ab:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  80042098b2:	83 e2 ef             	and    $0xffffffef,%edx
  80042098b5:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  80042098bb:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042098c2:	00 00 00 
  80042098c5:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  80042098cc:	83 ca 60             	or     $0x60,%edx
  80042098cf:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  80042098d5:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042098dc:	00 00 00 
  80042098df:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  80042098e6:	83 ca 80             	or     $0xffffff80,%edx
  80042098e9:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  80042098ef:	48 b8 14 a7 22 04 80 	movabs $0x800422a714,%rax
  80042098f6:	00 00 00 
  80042098f9:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  8004209900:	48 c1 e8 10          	shr    $0x10,%rax
  8004209904:	89 c2                	mov    %eax,%edx
  8004209906:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420990d:	00 00 00 
  8004209910:	66 89 90 06 03 00 00 	mov    %dx,0x306(%rax)
  8004209917:	48 b8 14 a7 22 04 80 	movabs $0x800422a714,%rax
  800420991e:	00 00 00 
  8004209921:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  8004209928:	48 c1 e8 20          	shr    $0x20,%rax
  800420992c:	89 c2                	mov    %eax,%edx
  800420992e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209935:	00 00 00 
  8004209938:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  800420993e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209945:	00 00 00 
  8004209948:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  800420994f:	00 00 00 
	SETGATE(idt[T_DEFAULT], 0, GD_KT, handlers[21], 0);
  8004209952:	48 b8 14 a7 22 04 80 	movabs $0x800422a714,%rax
  8004209959:	00 00 00 
  800420995c:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8004209963:	89 c2                	mov    %eax,%edx
  8004209965:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420996c:	00 00 00 
  800420996f:	66 89 90 40 1f 00 00 	mov    %dx,0x1f40(%rax)
  8004209976:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  800420997d:	00 00 00 
  8004209980:	66 c7 80 42 1f 00 00 	movw   $0x8,0x1f42(%rax)
  8004209987:	08 00 
  8004209989:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209990:	00 00 00 
  8004209993:	0f b6 90 44 1f 00 00 	movzbl 0x1f44(%rax),%edx
  800420999a:	83 e2 f8             	and    $0xfffffff8,%edx
  800420999d:	88 90 44 1f 00 00    	mov    %dl,0x1f44(%rax)
  80042099a3:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042099aa:	00 00 00 
  80042099ad:	0f b6 90 44 1f 00 00 	movzbl 0x1f44(%rax),%edx
  80042099b4:	83 e2 07             	and    $0x7,%edx
  80042099b7:	88 90 44 1f 00 00    	mov    %dl,0x1f44(%rax)
  80042099bd:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042099c4:	00 00 00 
  80042099c7:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  80042099ce:	83 e2 f0             	and    $0xfffffff0,%edx
  80042099d1:	83 ca 0e             	or     $0xe,%edx
  80042099d4:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  80042099da:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042099e1:	00 00 00 
  80042099e4:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  80042099eb:	83 e2 ef             	and    $0xffffffef,%edx
  80042099ee:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  80042099f4:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  80042099fb:	00 00 00 
  80042099fe:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  8004209a05:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209a08:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  8004209a0e:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209a15:	00 00 00 
  8004209a18:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  8004209a1f:	83 ca 80             	or     $0xffffff80,%edx
  8004209a22:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  8004209a28:	48 b8 14 a7 22 04 80 	movabs $0x800422a714,%rax
  8004209a2f:	00 00 00 
  8004209a32:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8004209a39:	48 c1 e8 10          	shr    $0x10,%rax
  8004209a3d:	89 c2                	mov    %eax,%edx
  8004209a3f:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209a46:	00 00 00 
  8004209a49:	66 89 90 46 1f 00 00 	mov    %dx,0x1f46(%rax)
  8004209a50:	48 b8 14 a7 22 04 80 	movabs $0x800422a714,%rax
  8004209a57:	00 00 00 
  8004209a5a:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8004209a61:	48 c1 e8 20          	shr    $0x20,%rax
  8004209a65:	89 c2                	mov    %eax,%edx
  8004209a67:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209a6e:	00 00 00 
  8004209a71:	89 90 48 1f 00 00    	mov    %edx,0x1f48(%rax)
  8004209a77:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209a7e:	00 00 00 
  8004209a81:	c7 80 4c 1f 00 00 00 	movl   $0x0,0x1f4c(%rax)
  8004209a88:	00 00 00 
	//SETGATE(idt[IRQ_OFFSET], 0, GD_KT, handlers[22], 0);
	int ii;
	for(ii = 0; ii < 16; ii++){
  8004209a8b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004209a92:	e9 c5 01 00 00       	jmpq   8004209c5c <trap_init+0x8d6>
		SETGATE(idt[IRQ_OFFSET + ii], 0, GD_KT, handlers[22 + ii], 0);
  8004209a97:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209a9a:	8d 48 20             	lea    0x20(%rax),%ecx
  8004209a9d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209aa0:	8d 50 16             	lea    0x16(%rax),%edx
  8004209aa3:	48 b8 14 a7 22 04 80 	movabs $0x800422a714,%rax
  8004209aaa:	00 00 00 
  8004209aad:	48 63 d2             	movslq %edx,%rdx
  8004209ab0:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004209ab4:	48 ba 80 d2 49 04 80 	movabs $0x800449d280,%rdx
  8004209abb:	00 00 00 
  8004209abe:	48 63 c9             	movslq %ecx,%rcx
  8004209ac1:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209ac5:	48 01 ca             	add    %rcx,%rdx
  8004209ac8:	66 89 02             	mov    %ax,(%rdx)
  8004209acb:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209ace:	8d 50 20             	lea    0x20(%rax),%edx
  8004209ad1:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209ad8:	00 00 00 
  8004209adb:	48 63 d2             	movslq %edx,%rdx
  8004209ade:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209ae2:	48 01 d0             	add    %rdx,%rax
  8004209ae5:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  8004209aeb:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209aee:	8d 50 20             	lea    0x20(%rax),%edx
  8004209af1:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209af8:	00 00 00 
  8004209afb:	48 63 d2             	movslq %edx,%rdx
  8004209afe:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209b02:	48 01 d0             	add    %rdx,%rax
  8004209b05:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004209b09:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209b0c:	88 50 04             	mov    %dl,0x4(%rax)
  8004209b0f:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209b12:	8d 50 20             	lea    0x20(%rax),%edx
  8004209b15:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209b1c:	00 00 00 
  8004209b1f:	48 63 d2             	movslq %edx,%rdx
  8004209b22:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209b26:	48 01 d0             	add    %rdx,%rax
  8004209b29:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004209b2d:	83 e2 07             	and    $0x7,%edx
  8004209b30:	88 50 04             	mov    %dl,0x4(%rax)
  8004209b33:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209b36:	8d 50 20             	lea    0x20(%rax),%edx
  8004209b39:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209b40:	00 00 00 
  8004209b43:	48 63 d2             	movslq %edx,%rdx
  8004209b46:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209b4a:	48 01 d0             	add    %rdx,%rax
  8004209b4d:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209b51:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209b54:	83 ca 0e             	or     $0xe,%edx
  8004209b57:	88 50 05             	mov    %dl,0x5(%rax)
  8004209b5a:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209b5d:	8d 50 20             	lea    0x20(%rax),%edx
  8004209b60:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209b67:	00 00 00 
  8004209b6a:	48 63 d2             	movslq %edx,%rdx
  8004209b6d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209b71:	48 01 d0             	add    %rdx,%rax
  8004209b74:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209b78:	83 e2 ef             	and    $0xffffffef,%edx
  8004209b7b:	88 50 05             	mov    %dl,0x5(%rax)
  8004209b7e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209b81:	8d 50 20             	lea    0x20(%rax),%edx
  8004209b84:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209b8b:	00 00 00 
  8004209b8e:	48 63 d2             	movslq %edx,%rdx
  8004209b91:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209b95:	48 01 d0             	add    %rdx,%rax
  8004209b98:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209b9c:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209b9f:	88 50 05             	mov    %dl,0x5(%rax)
  8004209ba2:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209ba5:	8d 50 20             	lea    0x20(%rax),%edx
  8004209ba8:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209baf:	00 00 00 
  8004209bb2:	48 63 d2             	movslq %edx,%rdx
  8004209bb5:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209bb9:	48 01 d0             	add    %rdx,%rax
  8004209bbc:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209bc0:	83 ca 80             	or     $0xffffff80,%edx
  8004209bc3:	88 50 05             	mov    %dl,0x5(%rax)
  8004209bc6:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209bc9:	8d 48 20             	lea    0x20(%rax),%ecx
  8004209bcc:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209bcf:	8d 50 16             	lea    0x16(%rax),%edx
  8004209bd2:	48 b8 14 a7 22 04 80 	movabs $0x800422a714,%rax
  8004209bd9:	00 00 00 
  8004209bdc:	48 63 d2             	movslq %edx,%rdx
  8004209bdf:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004209be3:	48 c1 e8 10          	shr    $0x10,%rax
  8004209be7:	48 ba 80 d2 49 04 80 	movabs $0x800449d280,%rdx
  8004209bee:	00 00 00 
  8004209bf1:	48 63 c9             	movslq %ecx,%rcx
  8004209bf4:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209bf8:	48 01 ca             	add    %rcx,%rdx
  8004209bfb:	66 89 42 06          	mov    %ax,0x6(%rdx)
  8004209bff:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209c02:	8d 48 20             	lea    0x20(%rax),%ecx
  8004209c05:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209c08:	8d 50 16             	lea    0x16(%rax),%edx
  8004209c0b:	48 b8 14 a7 22 04 80 	movabs $0x800422a714,%rax
  8004209c12:	00 00 00 
  8004209c15:	48 63 d2             	movslq %edx,%rdx
  8004209c18:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004209c1c:	48 c1 e8 20          	shr    $0x20,%rax
  8004209c20:	48 ba 80 d2 49 04 80 	movabs $0x800449d280,%rdx
  8004209c27:	00 00 00 
  8004209c2a:	48 63 c9             	movslq %ecx,%rcx
  8004209c2d:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209c31:	48 01 ca             	add    %rcx,%rdx
  8004209c34:	89 42 08             	mov    %eax,0x8(%rdx)
  8004209c37:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209c3a:	8d 50 20             	lea    0x20(%rax),%edx
  8004209c3d:	48 b8 80 d2 49 04 80 	movabs $0x800449d280,%rax
  8004209c44:	00 00 00 
  8004209c47:	48 63 d2             	movslq %edx,%rdx
  8004209c4a:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209c4e:	48 01 d0             	add    %rdx,%rax
  8004209c51:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
	SETGATE(idt[T_SIMDERR], 1, GD_KT, TH_simderr, 0);*/
	SETGATE(idt[T_SYSCALL], 0, GD_KT, handlers[20], 3);
	SETGATE(idt[T_DEFAULT], 0, GD_KT, handlers[21], 0);
	//SETGATE(idt[IRQ_OFFSET], 0, GD_KT, handlers[22], 0);
	int ii;
	for(ii = 0; ii < 16; ii++){
  8004209c58:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004209c5c:	83 7d f8 0f          	cmpl   $0xf,-0x8(%rbp)
  8004209c60:	0f 8e 31 fe ff ff    	jle    8004209a97 <trap_init+0x711>
	SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL], 0, GD_KT, handlers[24], 0);
	SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS], 0, GD_KT, handlers[25], 0);
	SETGATE(idt[IRQ_OFFSET + IRQ_IDE], 0, GD_KT, handlers[26], 0);
	SETGATE(idt[IRQ_OFFSET + IRQ_ERROR], 0, GD_KT, handlers[27], 0);*/
	// LAB 3: Your code here.
	idt_pd.pd_lim = sizeof(idt)-1;
  8004209c66:	48 b8 80 e2 49 04 80 	movabs $0x800449e280,%rax
  8004209c6d:	00 00 00 
  8004209c70:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)
	idt_pd.pd_base = (uint64_t)idt;
  8004209c75:	48 ba 80 d2 49 04 80 	movabs $0x800449d280,%rdx
  8004209c7c:	00 00 00 
  8004209c7f:	48 b8 80 e2 49 04 80 	movabs $0x800449e280,%rax
  8004209c86:	00 00 00 
  8004209c89:	48 89 50 02          	mov    %rdx,0x2(%rax)
	// Per-CPU setup
	trap_init_percpu();
  8004209c8d:	48 b8 2f 9d 20 04 80 	movabs $0x8004209d2f,%rax
  8004209c94:	00 00 00 
  8004209c97:	ff d0                	callq  *%rax
  8004209c99:	c7 45 f4 74 01 00 00 	movl   $0x174,-0xc(%rbp)
  8004209ca0:	48 c7 45 e8 08 00 00 	movq   $0x8,-0x18(%rbp)
  8004209ca7:	00 
}

static __inline void
write_msr( uint32_t ecx, uint64_t val ) {
	uint32_t edx, eax;
	eax = (uint32_t) val;
  8004209ca8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209cac:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	edx = (uint32_t) ( val >> 32 );
  8004209caf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209cb3:	48 c1 e8 20          	shr    $0x20,%rax
  8004209cb7:	89 45 e0             	mov    %eax,-0x20(%rbp)
	__asm __volatile("wrmsr"
  8004209cba:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004209cbd:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004209cc0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004209cc3:	0f 30                	wrmsr  
	write_msr(0x174, GD_KT);
	write_msr(0x175, ts.ts_esp0);
  8004209cc5:	48 b8 40 e7 49 04 80 	movabs $0x800449e740,%rax
  8004209ccc:	00 00 00 
  8004209ccf:	48 8b 40 04          	mov    0x4(%rax),%rax
  8004209cd3:	c7 45 dc 75 01 00 00 	movl   $0x175,-0x24(%rbp)
  8004209cda:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
}

static __inline void
write_msr( uint32_t ecx, uint64_t val ) {
	uint32_t edx, eax;
	eax = (uint32_t) val;
  8004209cde:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004209ce2:	89 45 cc             	mov    %eax,-0x34(%rbp)
	edx = (uint32_t) ( val >> 32 );
  8004209ce5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004209ce9:	48 c1 e8 20          	shr    $0x20,%rax
  8004209ced:	89 45 c8             	mov    %eax,-0x38(%rbp)
	__asm __volatile("wrmsr"
  8004209cf0:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  8004209cf3:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004209cf6:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004209cf9:	0f 30                	wrmsr  
	write_msr(0x176, (uint64_t) sysenter_handler);
  8004209cfb:	48 b8 f6 af 20 04 80 	movabs $0x800420aff6,%rax
  8004209d02:	00 00 00 
  8004209d05:	c7 45 c4 76 01 00 00 	movl   $0x176,-0x3c(%rbp)
  8004209d0c:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
}

static __inline void
write_msr( uint32_t ecx, uint64_t val ) {
	uint32_t edx, eax;
	eax = (uint32_t) val;
  8004209d10:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004209d14:	89 45 b4             	mov    %eax,-0x4c(%rbp)
	edx = (uint32_t) ( val >> 32 );
  8004209d17:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004209d1b:	48 c1 e8 20          	shr    $0x20,%rax
  8004209d1f:	89 45 b0             	mov    %eax,-0x50(%rbp)
	__asm __volatile("wrmsr"
  8004209d22:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
  8004209d25:	8b 55 b0             	mov    -0x50(%rbp),%edx
  8004209d28:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004209d2b:	0f 30                	wrmsr  
	//cprintf("%016x, %016x, %016x\n", read_msr(0x174), read_msr(0x175), read_msr(0x176));
}
  8004209d2d:	c9                   	leaveq 
  8004209d2e:	c3                   	retq   

0000008004209d2f <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  8004209d2f:	55                   	push   %rbp
  8004209d30:	48 89 e5             	mov    %rsp,%rbp
  8004209d33:	53                   	push   %rbx
  8004209d34:	48 83 ec 18          	sub    $0x18,%rsp
	// LAB 4: Your code here:


	// Setup a TSS so that we get the right stack
	// when we trap to the kernel.
	int i = cpunum();
  8004209d38:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004209d3f:	00 00 00 
  8004209d42:	ff d0                	callq  *%rax
  8004209d44:	89 45 ec             	mov    %eax,-0x14(%rbp)
	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);
  8004209d47:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004209d4e:	00 00 00 
  8004209d51:	ff d0                	callq  *%rax
  8004209d53:	89 c6                	mov    %eax,%esi
  8004209d55:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004209d58:	89 d0                	mov    %edx,%eax
  8004209d5a:	01 c0                	add    %eax,%eax
  8004209d5c:	01 d0                	add    %edx,%eax
  8004209d5e:	c1 e0 0f             	shl    $0xf,%eax
  8004209d61:	48 98                	cltq   
  8004209d63:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004209d6a:	00 00 00 
  8004209d6d:	48 29 c2             	sub    %rax,%rdx
  8004209d70:	48 89 d0             	mov    %rdx,%rax
  8004209d73:	48 89 c1             	mov    %rax,%rcx
  8004209d76:	48 bf 20 00 4a 04 80 	movabs $0x80044a0020,%rdi
  8004209d7d:	00 00 00 
  8004209d80:	48 63 c6             	movslq %esi,%rax
  8004209d83:	48 c1 e0 03          	shl    $0x3,%rax
  8004209d87:	48 89 c2             	mov    %rax,%rdx
  8004209d8a:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209d8e:	48 29 c2             	sub    %rax,%rdx
  8004209d91:	48 8d 04 17          	lea    (%rdi,%rdx,1),%rax
  8004209d95:	48 83 c0 10          	add    $0x10,%rax
  8004209d99:	48 89 48 04          	mov    %rcx,0x4(%rax)
	// Initialize the TSS slot of the gdt.
	SETTSS((struct SystemSegdesc64 *)(&gdt[(GD_TSS0 >> 3) + 2 * i]),STS_T64A, (uint64_t) (&thiscpu->cpu_ts),sizeof(struct Taskstate), 0);
  8004209d9d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209da0:	01 c0                	add    %eax,%eax
  8004209da2:	83 c0 05             	add    $0x5,%eax
  8004209da5:	48 98                	cltq   
  8004209da7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209dae:	00 
  8004209daf:	48 b8 60 a6 22 04 80 	movabs $0x800422a660,%rax
  8004209db6:	00 00 00 
  8004209db9:	48 01 d0             	add    %rdx,%rax
  8004209dbc:	66 c7 00 68 00       	movw   $0x68,(%rax)
  8004209dc1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209dc4:	01 c0                	add    %eax,%eax
  8004209dc6:	83 c0 05             	add    $0x5,%eax
  8004209dc9:	48 98                	cltq   
  8004209dcb:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209dd2:	00 
  8004209dd3:	48 b8 60 a6 22 04 80 	movabs $0x800422a660,%rax
  8004209dda:	00 00 00 
  8004209ddd:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004209de1:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004209de8:	00 00 00 
  8004209deb:	ff d0                	callq  *%rax
  8004209ded:	48 98                	cltq   
  8004209def:	48 c1 e0 03          	shl    $0x3,%rax
  8004209df3:	48 89 c2             	mov    %rax,%rdx
  8004209df6:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209dfa:	48 29 c2             	sub    %rax,%rdx
  8004209dfd:	48 83 c2 10          	add    $0x10,%rdx
  8004209e01:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  8004209e08:	00 00 00 
  8004209e0b:	48 01 d0             	add    %rdx,%rax
  8004209e0e:	66 89 43 02          	mov    %ax,0x2(%rbx)
  8004209e12:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209e15:	01 c0                	add    %eax,%eax
  8004209e17:	83 c0 05             	add    $0x5,%eax
  8004209e1a:	48 98                	cltq   
  8004209e1c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209e23:	00 
  8004209e24:	48 b8 60 a6 22 04 80 	movabs $0x800422a660,%rax
  8004209e2b:	00 00 00 
  8004209e2e:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004209e32:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004209e39:	00 00 00 
  8004209e3c:	ff d0                	callq  *%rax
  8004209e3e:	48 98                	cltq   
  8004209e40:	48 c1 e0 03          	shl    $0x3,%rax
  8004209e44:	48 89 c2             	mov    %rax,%rdx
  8004209e47:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209e4b:	48 29 c2             	sub    %rax,%rdx
  8004209e4e:	48 83 c2 10          	add    $0x10,%rdx
  8004209e52:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  8004209e59:	00 00 00 
  8004209e5c:	48 01 d0             	add    %rdx,%rax
  8004209e5f:	48 c1 e8 10          	shr    $0x10,%rax
  8004209e63:	88 43 04             	mov    %al,0x4(%rbx)
  8004209e66:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209e69:	01 c0                	add    %eax,%eax
  8004209e6b:	83 c0 05             	add    $0x5,%eax
  8004209e6e:	48 98                	cltq   
  8004209e70:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209e77:	00 
  8004209e78:	48 b8 60 a6 22 04 80 	movabs $0x800422a660,%rax
  8004209e7f:	00 00 00 
  8004209e82:	48 01 d0             	add    %rdx,%rax
  8004209e85:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209e89:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209e8c:	83 ca 09             	or     $0x9,%edx
  8004209e8f:	88 50 05             	mov    %dl,0x5(%rax)
  8004209e92:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209e95:	01 c0                	add    %eax,%eax
  8004209e97:	83 c0 05             	add    $0x5,%eax
  8004209e9a:	48 98                	cltq   
  8004209e9c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209ea3:	00 
  8004209ea4:	48 b8 60 a6 22 04 80 	movabs $0x800422a660,%rax
  8004209eab:	00 00 00 
  8004209eae:	48 01 d0             	add    %rdx,%rax
  8004209eb1:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209eb5:	83 e2 ef             	and    $0xffffffef,%edx
  8004209eb8:	88 50 05             	mov    %dl,0x5(%rax)
  8004209ebb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209ebe:	01 c0                	add    %eax,%eax
  8004209ec0:	83 c0 05             	add    $0x5,%eax
  8004209ec3:	48 98                	cltq   
  8004209ec5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209ecc:	00 
  8004209ecd:	48 b8 60 a6 22 04 80 	movabs $0x800422a660,%rax
  8004209ed4:	00 00 00 
  8004209ed7:	48 01 d0             	add    %rdx,%rax
  8004209eda:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209ede:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209ee1:	88 50 05             	mov    %dl,0x5(%rax)
  8004209ee4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209ee7:	01 c0                	add    %eax,%eax
  8004209ee9:	83 c0 05             	add    $0x5,%eax
  8004209eec:	48 98                	cltq   
  8004209eee:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209ef5:	00 
  8004209ef6:	48 b8 60 a6 22 04 80 	movabs $0x800422a660,%rax
  8004209efd:	00 00 00 
  8004209f00:	48 01 d0             	add    %rdx,%rax
  8004209f03:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209f07:	83 ca 80             	or     $0xffffff80,%edx
  8004209f0a:	88 50 05             	mov    %dl,0x5(%rax)
  8004209f0d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209f10:	01 c0                	add    %eax,%eax
  8004209f12:	83 c0 05             	add    $0x5,%eax
  8004209f15:	48 98                	cltq   
  8004209f17:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209f1e:	00 
  8004209f1f:	48 b8 60 a6 22 04 80 	movabs $0x800422a660,%rax
  8004209f26:	00 00 00 
  8004209f29:	48 01 d0             	add    %rdx,%rax
  8004209f2c:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  8004209f30:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209f33:	88 50 06             	mov    %dl,0x6(%rax)
  8004209f36:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209f39:	01 c0                	add    %eax,%eax
  8004209f3b:	83 c0 05             	add    $0x5,%eax
  8004209f3e:	48 98                	cltq   
  8004209f40:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209f47:	00 
  8004209f48:	48 b8 60 a6 22 04 80 	movabs $0x800422a660,%rax
  8004209f4f:	00 00 00 
  8004209f52:	48 01 d0             	add    %rdx,%rax
  8004209f55:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  8004209f59:	83 e2 ef             	and    $0xffffffef,%edx
  8004209f5c:	88 50 06             	mov    %dl,0x6(%rax)
  8004209f5f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209f62:	01 c0                	add    %eax,%eax
  8004209f64:	83 c0 05             	add    $0x5,%eax
  8004209f67:	48 98                	cltq   
  8004209f69:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209f70:	00 
  8004209f71:	48 b8 60 a6 22 04 80 	movabs $0x800422a660,%rax
  8004209f78:	00 00 00 
  8004209f7b:	48 01 d0             	add    %rdx,%rax
  8004209f7e:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  8004209f82:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209f85:	88 50 06             	mov    %dl,0x6(%rax)
  8004209f88:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209f8b:	01 c0                	add    %eax,%eax
  8004209f8d:	83 c0 05             	add    $0x5,%eax
  8004209f90:	48 98                	cltq   
  8004209f92:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209f99:	00 
  8004209f9a:	48 b8 60 a6 22 04 80 	movabs $0x800422a660,%rax
  8004209fa1:	00 00 00 
  8004209fa4:	48 01 d0             	add    %rdx,%rax
  8004209fa7:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  8004209fab:	83 e2 7f             	and    $0x7f,%edx
  8004209fae:	88 50 06             	mov    %dl,0x6(%rax)
  8004209fb1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209fb4:	01 c0                	add    %eax,%eax
  8004209fb6:	83 c0 05             	add    $0x5,%eax
  8004209fb9:	48 98                	cltq   
  8004209fbb:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209fc2:	00 
  8004209fc3:	48 b8 60 a6 22 04 80 	movabs $0x800422a660,%rax
  8004209fca:	00 00 00 
  8004209fcd:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004209fd1:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004209fd8:	00 00 00 
  8004209fdb:	ff d0                	callq  *%rax
  8004209fdd:	48 98                	cltq   
  8004209fdf:	48 c1 e0 03          	shl    $0x3,%rax
  8004209fe3:	48 89 c2             	mov    %rax,%rdx
  8004209fe6:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209fea:	48 29 c2             	sub    %rax,%rdx
  8004209fed:	48 83 c2 10          	add    $0x10,%rdx
  8004209ff1:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  8004209ff8:	00 00 00 
  8004209ffb:	48 01 d0             	add    %rdx,%rax
  8004209ffe:	48 c1 e8 18          	shr    $0x18,%rax
  800420a002:	88 43 07             	mov    %al,0x7(%rbx)
  800420a005:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420a008:	01 c0                	add    %eax,%eax
  800420a00a:	83 c0 05             	add    $0x5,%eax
  800420a00d:	48 98                	cltq   
  800420a00f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420a016:	00 
  800420a017:	48 b8 60 a6 22 04 80 	movabs $0x800422a660,%rax
  800420a01e:	00 00 00 
  800420a021:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420a025:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420a02c:	00 00 00 
  800420a02f:	ff d0                	callq  *%rax
  800420a031:	48 98                	cltq   
  800420a033:	48 c1 e0 03          	shl    $0x3,%rax
  800420a037:	48 89 c2             	mov    %rax,%rdx
  800420a03a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a03e:	48 29 c2             	sub    %rax,%rdx
  800420a041:	48 83 c2 10          	add    $0x10,%rdx
  800420a045:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  800420a04c:	00 00 00 
  800420a04f:	48 01 d0             	add    %rdx,%rax
  800420a052:	48 c1 e8 20          	shr    $0x20,%rax
  800420a056:	89 43 08             	mov    %eax,0x8(%rbx)
  800420a059:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420a05c:	01 c0                	add    %eax,%eax
  800420a05e:	83 c0 05             	add    $0x5,%eax
  800420a061:	48 98                	cltq   
  800420a063:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420a06a:	00 
  800420a06b:	48 b8 60 a6 22 04 80 	movabs $0x800422a660,%rax
  800420a072:	00 00 00 
  800420a075:	48 01 d0             	add    %rdx,%rax
  800420a078:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  800420a07c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420a07f:	01 c0                	add    %eax,%eax
  800420a081:	83 c0 05             	add    $0x5,%eax
  800420a084:	48 98                	cltq   
  800420a086:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420a08d:	00 
  800420a08e:	48 b8 60 a6 22 04 80 	movabs $0x800422a660,%rax
  800420a095:	00 00 00 
  800420a098:	48 01 d0             	add    %rdx,%rax
  800420a09b:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  800420a09f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420a0a2:	01 c0                	add    %eax,%eax
  800420a0a4:	83 c0 05             	add    $0x5,%eax
  800420a0a7:	48 98                	cltq   
  800420a0a9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420a0b0:	00 
  800420a0b1:	48 b8 60 a6 22 04 80 	movabs $0x800422a660,%rax
  800420a0b8:	00 00 00 
  800420a0bb:	48 01 d0             	add    %rdx,%rax
  800420a0be:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)
	// Load the TSS selector (like other segment selectors, the
	// bottom three bits are special; we leave them 0)
	ltr(GD_TSS0 + ((i * 2) << 3));
  800420a0c4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420a0c7:	01 c0                	add    %eax,%eax
  800420a0c9:	c1 e0 03             	shl    $0x3,%eax
  800420a0cc:	83 c0 28             	add    $0x28,%eax
  800420a0cf:	0f b7 c0             	movzwl %ax,%eax
  800420a0d2:	66 89 45 ea          	mov    %ax,-0x16(%rbp)
	__asm __volatile("lgdt (%0)" : : "r" (p));
}
static __inline void
ltr(uint16_t sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
  800420a0d6:	0f b7 45 ea          	movzwl -0x16(%rbp),%eax
  800420a0da:	0f 00 d8             	ltr    %ax
  800420a0dd:	48 b8 80 e2 49 04 80 	movabs $0x800449e280,%rax
  800420a0e4:	00 00 00 
  800420a0e7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}  

static __inline void
lidt(void *p)
{
	__asm __volatile("lidt (%0)" : : "r" (p));
  800420a0eb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420a0ef:	0f 01 18             	lidt   (%rax)

	// Load the IDT
	lidt(&idt_pd);
}
  800420a0f2:	48 83 c4 18          	add    $0x18,%rsp
  800420a0f6:	5b                   	pop    %rbx
  800420a0f7:	5d                   	pop    %rbp
  800420a0f8:	c3                   	retq   

000000800420a0f9 <print_trapframe>:

void
print_trapframe(struct Trapframe *tf)
{
  800420a0f9:	55                   	push   %rbp
  800420a0fa:	48 89 e5             	mov    %rsp,%rbp
  800420a0fd:	48 83 ec 20          	sub    $0x20,%rsp
  800420a101:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//return;
	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
  800420a105:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420a10c:	00 00 00 
  800420a10f:	ff d0                	callq  *%rax
  800420a111:	89 c2                	mov    %eax,%edx
  800420a113:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a117:	48 89 c6             	mov    %rax,%rsi
  800420a11a:	48 bf 8e 6b 21 04 80 	movabs $0x8004216b8e,%rdi
  800420a121:	00 00 00 
  800420a124:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a129:	48 b9 0e 92 20 04 80 	movabs $0x800420920e,%rcx
  800420a130:	00 00 00 
  800420a133:	ff d1                	callq  *%rcx
	print_regs(&tf->tf_regs);
  800420a135:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a139:	48 89 c7             	mov    %rax,%rdi
  800420a13c:	48 b8 0a a4 20 04 80 	movabs $0x800420a40a,%rax
  800420a143:	00 00 00 
  800420a146:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  800420a148:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a14c:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800420a150:	0f b7 c0             	movzwl %ax,%eax
  800420a153:	89 c6                	mov    %eax,%esi
  800420a155:	48 bf ac 6b 21 04 80 	movabs $0x8004216bac,%rdi
  800420a15c:	00 00 00 
  800420a15f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a164:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a16b:	00 00 00 
  800420a16e:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  800420a170:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a174:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  800420a17b:	0f b7 c0             	movzwl %ax,%eax
  800420a17e:	89 c6                	mov    %eax,%esi
  800420a180:	48 bf bf 6b 21 04 80 	movabs $0x8004216bbf,%rdi
  800420a187:	00 00 00 
  800420a18a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a18f:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a196:	00 00 00 
  800420a199:	ff d2                	callq  *%rdx
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  800420a19b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a19f:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420a1a6:	89 c7                	mov    %eax,%edi
  800420a1a8:	48 b8 27 93 20 04 80 	movabs $0x8004209327,%rax
  800420a1af:	00 00 00 
  800420a1b2:	ff d0                	callq  *%rax
  800420a1b4:	48 89 c2             	mov    %rax,%rdx
  800420a1b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a1bb:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420a1c2:	48 89 c6             	mov    %rax,%rsi
  800420a1c5:	48 bf d2 6b 21 04 80 	movabs $0x8004216bd2,%rdi
  800420a1cc:	00 00 00 
  800420a1cf:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a1d4:	48 b9 0e 92 20 04 80 	movabs $0x800420920e,%rcx
  800420a1db:	00 00 00 
  800420a1de:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  800420a1e0:	48 b8 90 e2 49 04 80 	movabs $0x800449e290,%rax
  800420a1e7:	00 00 00 
  800420a1ea:	48 8b 00             	mov    (%rax),%rax
  800420a1ed:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420a1f1:	75 3a                	jne    800420a22d <print_trapframe+0x134>
  800420a1f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a1f7:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420a1fe:	48 83 f8 0e          	cmp    $0xe,%rax
  800420a202:	75 29                	jne    800420a22d <print_trapframe+0x134>

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420a204:	0f 20 d0             	mov    %cr2,%rax
  800420a207:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return val;
  800420a20b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  800420a20f:	48 89 c6             	mov    %rax,%rsi
  800420a212:	48 bf e4 6b 21 04 80 	movabs $0x8004216be4,%rdi
  800420a219:	00 00 00 
  800420a21c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a221:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a228:	00 00 00 
  800420a22b:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  800420a22d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a231:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420a238:	48 89 c6             	mov    %rax,%rsi
  800420a23b:	48 bf f3 6b 21 04 80 	movabs $0x8004216bf3,%rdi
  800420a242:	00 00 00 
  800420a245:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a24a:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a251:	00 00 00 
  800420a254:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  800420a256:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a25a:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420a261:	48 83 f8 0e          	cmp    $0xe,%rax
  800420a265:	0f 85 9c 00 00 00    	jne    800420a307 <print_trapframe+0x20e>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  800420a26b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a26f:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420a276:	83 e0 01             	and    $0x1,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420a279:	48 85 c0             	test   %rax,%rax
  800420a27c:	74 0c                	je     800420a28a <print_trapframe+0x191>
  800420a27e:	48 b9 01 6c 21 04 80 	movabs $0x8004216c01,%rcx
  800420a285:	00 00 00 
  800420a288:	eb 0a                	jmp    800420a294 <print_trapframe+0x19b>
  800420a28a:	48 b9 0c 6c 21 04 80 	movabs $0x8004216c0c,%rcx
  800420a291:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
  800420a294:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a298:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420a29f:	83 e0 02             	and    $0x2,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420a2a2:	48 85 c0             	test   %rax,%rax
  800420a2a5:	74 0c                	je     800420a2b3 <print_trapframe+0x1ba>
  800420a2a7:	48 ba 18 6c 21 04 80 	movabs $0x8004216c18,%rdx
  800420a2ae:	00 00 00 
  800420a2b1:	eb 0a                	jmp    800420a2bd <print_trapframe+0x1c4>
  800420a2b3:	48 ba 1e 6c 21 04 80 	movabs $0x8004216c1e,%rdx
  800420a2ba:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  800420a2bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a2c1:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420a2c8:	83 e0 04             	and    $0x4,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420a2cb:	48 85 c0             	test   %rax,%rax
  800420a2ce:	74 0c                	je     800420a2dc <print_trapframe+0x1e3>
  800420a2d0:	48 b8 23 6c 21 04 80 	movabs $0x8004216c23,%rax
  800420a2d7:	00 00 00 
  800420a2da:	eb 0a                	jmp    800420a2e6 <print_trapframe+0x1ed>
  800420a2dc:	48 b8 28 6c 21 04 80 	movabs $0x8004216c28,%rax
  800420a2e3:	00 00 00 
  800420a2e6:	48 89 c6             	mov    %rax,%rsi
  800420a2e9:	48 bf 2f 6c 21 04 80 	movabs $0x8004216c2f,%rdi
  800420a2f0:	00 00 00 
  800420a2f3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a2f8:	49 b8 0e 92 20 04 80 	movabs $0x800420920e,%r8
  800420a2ff:	00 00 00 
  800420a302:	41 ff d0             	callq  *%r8
  800420a305:	eb 1b                	jmp    800420a322 <print_trapframe+0x229>
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
	else
		cprintf("\n");
  800420a307:	48 bf 3e 6c 21 04 80 	movabs $0x8004216c3e,%rdi
  800420a30e:	00 00 00 
  800420a311:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a316:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a31d:	00 00 00 
  800420a320:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  800420a322:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a326:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800420a32d:	48 89 c6             	mov    %rax,%rsi
  800420a330:	48 bf 40 6c 21 04 80 	movabs $0x8004216c40,%rdi
  800420a337:	00 00 00 
  800420a33a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a33f:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a346:	00 00 00 
  800420a349:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  800420a34b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a34f:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420a356:	0f b7 c0             	movzwl %ax,%eax
  800420a359:	89 c6                	mov    %eax,%esi
  800420a35b:	48 bf 4f 6c 21 04 80 	movabs $0x8004216c4f,%rdi
  800420a362:	00 00 00 
  800420a365:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a36a:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a371:	00 00 00 
  800420a374:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  800420a376:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a37a:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420a381:	48 89 c6             	mov    %rax,%rsi
  800420a384:	48 bf 62 6c 21 04 80 	movabs $0x8004216c62,%rdi
  800420a38b:	00 00 00 
  800420a38e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a393:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a39a:	00 00 00 
  800420a39d:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  800420a39f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a3a3:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420a3aa:	0f b7 c0             	movzwl %ax,%eax
  800420a3ad:	83 e0 03             	and    $0x3,%eax
  800420a3b0:	85 c0                	test   %eax,%eax
  800420a3b2:	74 54                	je     800420a408 <print_trapframe+0x30f>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  800420a3b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a3b8:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420a3bf:	48 89 c6             	mov    %rax,%rsi
  800420a3c2:	48 bf 71 6c 21 04 80 	movabs $0x8004216c71,%rdi
  800420a3c9:	00 00 00 
  800420a3cc:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a3d1:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a3d8:	00 00 00 
  800420a3db:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  800420a3dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a3e1:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  800420a3e8:	0f b7 c0             	movzwl %ax,%eax
  800420a3eb:	89 c6                	mov    %eax,%esi
  800420a3ed:	48 bf 80 6c 21 04 80 	movabs $0x8004216c80,%rdi
  800420a3f4:	00 00 00 
  800420a3f7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a3fc:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a403:	00 00 00 
  800420a406:	ff d2                	callq  *%rdx
	}
}
  800420a408:	c9                   	leaveq 
  800420a409:	c3                   	retq   

000000800420a40a <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  800420a40a:	55                   	push   %rbp
  800420a40b:	48 89 e5             	mov    %rsp,%rbp
  800420a40e:	48 83 ec 10          	sub    $0x10,%rsp
  800420a412:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  800420a416:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a41a:	48 8b 00             	mov    (%rax),%rax
  800420a41d:	48 89 c6             	mov    %rax,%rsi
  800420a420:	48 bf 93 6c 21 04 80 	movabs $0x8004216c93,%rdi
  800420a427:	00 00 00 
  800420a42a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a42f:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a436:	00 00 00 
  800420a439:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  800420a43b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a43f:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420a443:	48 89 c6             	mov    %rax,%rsi
  800420a446:	48 bf a2 6c 21 04 80 	movabs $0x8004216ca2,%rdi
  800420a44d:	00 00 00 
  800420a450:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a455:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a45c:	00 00 00 
  800420a45f:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  800420a461:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a465:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420a469:	48 89 c6             	mov    %rax,%rsi
  800420a46c:	48 bf b1 6c 21 04 80 	movabs $0x8004216cb1,%rdi
  800420a473:	00 00 00 
  800420a476:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a47b:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a482:	00 00 00 
  800420a485:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  800420a487:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a48b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420a48f:	48 89 c6             	mov    %rax,%rsi
  800420a492:	48 bf c0 6c 21 04 80 	movabs $0x8004216cc0,%rdi
  800420a499:	00 00 00 
  800420a49c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a4a1:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a4a8:	00 00 00 
  800420a4ab:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  800420a4ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a4b1:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420a4b5:	48 89 c6             	mov    %rax,%rsi
  800420a4b8:	48 bf cf 6c 21 04 80 	movabs $0x8004216ccf,%rdi
  800420a4bf:	00 00 00 
  800420a4c2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a4c7:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a4ce:	00 00 00 
  800420a4d1:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  800420a4d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a4d7:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420a4db:	48 89 c6             	mov    %rax,%rsi
  800420a4de:	48 bf de 6c 21 04 80 	movabs $0x8004216cde,%rdi
  800420a4e5:	00 00 00 
  800420a4e8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a4ed:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a4f4:	00 00 00 
  800420a4f7:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  800420a4f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a4fd:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420a501:	48 89 c6             	mov    %rax,%rsi
  800420a504:	48 bf ed 6c 21 04 80 	movabs $0x8004216ced,%rdi
  800420a50b:	00 00 00 
  800420a50e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a513:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a51a:	00 00 00 
  800420a51d:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  800420a51f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a523:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420a527:	48 89 c6             	mov    %rax,%rsi
  800420a52a:	48 bf fb 6c 21 04 80 	movabs $0x8004216cfb,%rdi
  800420a531:	00 00 00 
  800420a534:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a539:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a540:	00 00 00 
  800420a543:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  800420a545:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a549:	48 8b 40 48          	mov    0x48(%rax),%rax
  800420a54d:	48 89 c6             	mov    %rax,%rsi
  800420a550:	48 bf 09 6d 21 04 80 	movabs $0x8004216d09,%rdi
  800420a557:	00 00 00 
  800420a55a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a55f:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a566:	00 00 00 
  800420a569:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  800420a56b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a56f:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420a573:	48 89 c6             	mov    %rax,%rsi
  800420a576:	48 bf 18 6d 21 04 80 	movabs $0x8004216d18,%rdi
  800420a57d:	00 00 00 
  800420a580:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a585:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a58c:	00 00 00 
  800420a58f:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  800420a591:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a595:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420a599:	48 89 c6             	mov    %rax,%rsi
  800420a59c:	48 bf 27 6d 21 04 80 	movabs $0x8004216d27,%rdi
  800420a5a3:	00 00 00 
  800420a5a6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a5ab:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a5b2:	00 00 00 
  800420a5b5:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  800420a5b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a5bb:	48 8b 40 68          	mov    0x68(%rax),%rax
  800420a5bf:	48 89 c6             	mov    %rax,%rsi
  800420a5c2:	48 bf 36 6d 21 04 80 	movabs $0x8004216d36,%rdi
  800420a5c9:	00 00 00 
  800420a5cc:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a5d1:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a5d8:	00 00 00 
  800420a5db:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  800420a5dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a5e1:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420a5e5:	48 89 c6             	mov    %rax,%rsi
  800420a5e8:	48 bf 45 6d 21 04 80 	movabs $0x8004216d45,%rdi
  800420a5ef:	00 00 00 
  800420a5f2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a5f7:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a5fe:	00 00 00 
  800420a601:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  800420a603:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a607:	48 8b 40 60          	mov    0x60(%rax),%rax
  800420a60b:	48 89 c6             	mov    %rax,%rsi
  800420a60e:	48 bf 54 6d 21 04 80 	movabs $0x8004216d54,%rdi
  800420a615:	00 00 00 
  800420a618:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a61d:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a624:	00 00 00 
  800420a627:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  800420a629:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a62d:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420a631:	48 89 c6             	mov    %rax,%rsi
  800420a634:	48 bf 63 6d 21 04 80 	movabs $0x8004216d63,%rdi
  800420a63b:	00 00 00 
  800420a63e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a643:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a64a:	00 00 00 
  800420a64d:	ff d2                	callq  *%rdx
}
  800420a64f:	c9                   	leaveq 
  800420a650:	c3                   	retq   

000000800420a651 <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  800420a651:	55                   	push   %rbp
  800420a652:	48 89 e5             	mov    %rsp,%rbp
  800420a655:	48 83 ec 10          	sub    $0x10,%rsp
  800420a659:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// LAB 4: Your code here.

	// Handle keyboard and serial interrupts.
	// LAB 5: Your code here.

	switch(tf->tf_trapno){
  800420a65d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a661:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420a668:	48 83 f8 30          	cmp    $0x30,%rax
  800420a66c:	0f 87 09 01 00 00    	ja     800420a77b <trap_dispatch+0x12a>
  800420a672:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420a679:	00 
  800420a67a:	48 b8 b8 6d 21 04 80 	movabs $0x8004216db8,%rax
  800420a681:	00 00 00 
  800420a684:	48 01 d0             	add    %rdx,%rax
  800420a687:	48 8b 00             	mov    (%rax),%rax
  800420a68a:	ff e0                	jmpq   *%rax
		case IRQ_OFFSET + IRQ_SPURIOUS:
			cprintf("Spurious interrupt on irq 7\n");
  800420a68c:	48 bf 72 6d 21 04 80 	movabs $0x8004216d72,%rdi
  800420a693:	00 00 00 
  800420a696:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a69b:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420a6a2:	00 00 00 
  800420a6a5:	ff d2                	callq  *%rdx
			print_trapframe(tf);
  800420a6a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a6ab:	48 89 c7             	mov    %rax,%rdi
  800420a6ae:	48 b8 f9 a0 20 04 80 	movabs $0x800420a0f9,%rax
  800420a6b5:	00 00 00 
  800420a6b8:	ff d0                	callq  *%rax
			return;
  800420a6ba:	e9 38 01 00 00       	jmpq   800420a7f7 <trap_dispatch+0x1a6>
		case IRQ_OFFSET + IRQ_TIMER:
			lapic_eoi();
  800420a6bf:	48 b8 c6 4a 21 04 80 	movabs $0x8004214ac6,%rax
  800420a6c6:	00 00 00 
  800420a6c9:	ff d0                	callq  *%rax
			sched_yield();
  800420a6cb:	48 b8 c1 b0 20 04 80 	movabs $0x800420b0c1,%rax
  800420a6d2:	00 00 00 
  800420a6d5:	ff d0                	callq  *%rax
			return;
		case IRQ_OFFSET + IRQ_KBD:
			kbd_intr();
  800420a6d7:	48 b8 b1 0f 20 04 80 	movabs $0x8004200fb1,%rax
  800420a6de:	00 00 00 
  800420a6e1:	ff d0                	callq  *%rax
			return;
  800420a6e3:	e9 0f 01 00 00       	jmpq   800420a7f7 <trap_dispatch+0x1a6>
		case IRQ_OFFSET + IRQ_SERIAL:
			serial_intr();
  800420a6e8:	48 b8 62 07 20 04 80 	movabs $0x8004200762,%rax
  800420a6ef:	00 00 00 
  800420a6f2:	ff d0                	callq  *%rax
			return;
  800420a6f4:	e9 fe 00 00 00       	jmpq   800420a7f7 <trap_dispatch+0x1a6>
		case	T_PGFLT:
	    //print_trapframe(tf);
			page_fault_handler(tf);
  800420a6f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a6fd:	48 89 c7             	mov    %rax,%rdi
  800420a700:	48 b8 63 ab 20 04 80 	movabs $0x800420ab63,%rax
  800420a707:	00 00 00 
  800420a70a:	ff d0                	callq  *%rax
			return; 
  800420a70c:	e9 e6 00 00 00       	jmpq   800420a7f7 <trap_dispatch+0x1a6>
		case T_BRKPT:
		case T_DEBUG:
			monitor(tf);
  800420a711:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a715:	48 89 c7             	mov    %rax,%rdi
  800420a718:	48 b8 bc 21 20 04 80 	movabs $0x80042021bc,%rax
  800420a71f:	00 00 00 
  800420a722:	ff d0                	callq  *%rax
			return;
  800420a724:	e9 ce 00 00 00       	jmpq   800420a7f7 <trap_dispatch+0x1a6>
		case T_SYSCALL:
			tf->tf_regs.reg_rax = syscall(tf->tf_regs.reg_rax, tf->tf_regs.reg_rdx, tf->tf_regs.reg_rcx, tf->tf_regs.reg_rbx, tf->tf_regs.reg_rdi, tf->tf_regs.reg_rsi);
  800420a729:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a72d:	4c 8b 40 40          	mov    0x40(%rax),%r8
  800420a731:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a735:	48 8b 78 48          	mov    0x48(%rax),%rdi
  800420a739:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a73d:	48 8b 48 68          	mov    0x68(%rax),%rcx
  800420a741:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a745:	48 8b 50 60          	mov    0x60(%rax),%rdx
  800420a749:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a74d:	48 8b 70 58          	mov    0x58(%rax),%rsi
  800420a751:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a755:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420a759:	4d 89 c1             	mov    %r8,%r9
  800420a75c:	49 89 f8             	mov    %rdi,%r8
  800420a75f:	48 89 c7             	mov    %rax,%rdi
  800420a762:	48 b8 d6 bd 20 04 80 	movabs $0x800420bdd6,%rax
  800420a769:	00 00 00 
  800420a76c:	ff d0                	callq  *%rax
  800420a76e:	48 89 c2             	mov    %rax,%rdx
  800420a771:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a775:	48 89 50 70          	mov    %rdx,0x70(%rax)
			return;
  800420a779:	eb 7c                	jmp    800420a7f7 <trap_dispatch+0x1a6>
	}

	// Unexpected trap: The user process or the kernel has a bug.
	if (tf->tf_cs == GD_KT){
  800420a77b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420a77f:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420a786:	66 83 f8 08          	cmp    $0x8,%ax
  800420a78a:	75 2a                	jne    800420a7b6 <trap_dispatch+0x165>
	//	print_trapframe(tf);
		panic("unhandled trap in kernel");
  800420a78c:	48 ba 8f 6d 21 04 80 	movabs $0x8004216d8f,%rdx
  800420a793:	00 00 00 
  800420a796:	be 26 01 00 00       	mov    $0x126,%esi
  800420a79b:	48 bf a8 6d 21 04 80 	movabs $0x8004216da8,%rdi
  800420a7a2:	00 00 00 
  800420a7a5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a7aa:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  800420a7b1:	00 00 00 
  800420a7b4:	ff d1                	callq  *%rcx
	}
	else {
		env_destroy(curenv);
  800420a7b6:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420a7bd:	00 00 00 
  800420a7c0:	ff d0                	callq  *%rax
  800420a7c2:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420a7c9:	00 00 00 
  800420a7cc:	48 98                	cltq   
  800420a7ce:	48 c1 e0 03          	shl    $0x3,%rax
  800420a7d2:	48 89 c2             	mov    %rax,%rdx
  800420a7d5:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a7d9:	48 29 c2             	sub    %rax,%rdx
  800420a7dc:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420a7e0:	48 83 c0 08          	add    $0x8,%rax
  800420a7e4:	48 8b 00             	mov    (%rax),%rax
  800420a7e7:	48 89 c7             	mov    %rax,%rdi
  800420a7ea:	48 b8 fb 8a 20 04 80 	movabs $0x8004208afb,%rax
  800420a7f1:	00 00 00 
  800420a7f4:	ff d0                	callq  *%rax
		return;
  800420a7f6:	90                   	nop
	}
}
  800420a7f7:	c9                   	leaveq 
  800420a7f8:	c3                   	retq   

000000800420a7f9 <trap>:
void
trap(struct Trapframe *tf)
{
  800420a7f9:	55                   	push   %rbp
  800420a7fa:	48 89 e5             	mov    %rsp,%rbp
  800420a7fd:	48 83 ec 20          	sub    $0x20,%rsp
  800420a801:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//struct Trapframe *tf = &tf_;
	// The environment may have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  800420a805:	fc                   	cld    

	// Halt the CPU if some other CPU has called panic()
	extern char *panicstr;
	if (panicstr)
  800420a806:	48 b8 10 e7 49 04 80 	movabs $0x800449e710,%rax
  800420a80d:	00 00 00 
  800420a810:	48 8b 00             	mov    (%rax),%rax
  800420a813:	48 85 c0             	test   %rax,%rax
  800420a816:	74 01                	je     800420a819 <trap+0x20>
		asm volatile("hlt");
  800420a818:	f4                   	hlt    

	// Re-acqurie the big kernel lock if we were halted in
	// sched_yield()
	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
  800420a819:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420a820:	00 00 00 
  800420a823:	ff d0                	callq  *%rax
  800420a825:	48 98                	cltq   
  800420a827:	48 c1 e0 03          	shl    $0x3,%rax
  800420a82b:	48 89 c2             	mov    %rax,%rdx
  800420a82e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a832:	48 29 c2             	sub    %rax,%rdx
  800420a835:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  800420a83c:	00 00 00 
  800420a83f:	48 01 d0             	add    %rdx,%rax
  800420a842:	48 83 c0 04          	add    $0x4,%rax
  800420a846:	be 01 00 00 00       	mov    $0x1,%esi
  800420a84b:	48 89 c7             	mov    %rax,%rdi
  800420a84e:	48 b8 e6 92 20 04 80 	movabs $0x80042092e6,%rax
  800420a855:	00 00 00 
  800420a858:	ff d0                	callq  *%rax
  800420a85a:	83 f8 02             	cmp    $0x2,%eax
  800420a85d:	75 0c                	jne    800420a86b <trap+0x72>
		lock_kernel();
  800420a85f:	48 b8 0b 93 20 04 80 	movabs $0x800420930b,%rax
  800420a866:	00 00 00 
  800420a869:	ff d0                	callq  *%rax

static __inline uint64_t
read_eflags(void)
{
	uint64_t rflags;
	__asm __volatile("pushfq; popq %0" : "=r" (rflags));
  800420a86b:	9c                   	pushfq 
  800420a86c:	58                   	pop    %rax
  800420a86d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return rflags;
  800420a871:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  800420a875:	25 00 02 00 00       	and    $0x200,%eax
  800420a87a:	48 85 c0             	test   %rax,%rax
  800420a87d:	74 35                	je     800420a8b4 <trap+0xbb>
  800420a87f:	48 b9 40 6f 21 04 80 	movabs $0x8004216f40,%rcx
  800420a886:	00 00 00 
  800420a889:	48 ba 59 6f 21 04 80 	movabs $0x8004216f59,%rdx
  800420a890:	00 00 00 
  800420a893:	be 41 01 00 00       	mov    $0x141,%esi
  800420a898:	48 bf a8 6d 21 04 80 	movabs $0x8004216da8,%rdi
  800420a89f:	00 00 00 
  800420a8a2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a8a7:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420a8ae:	00 00 00 
  800420a8b1:	41 ff d0             	callq  *%r8
	if ((tf->tf_cs & 3) == 3) {
  800420a8b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420a8b8:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420a8bf:	0f b7 c0             	movzwl %ax,%eax
  800420a8c2:	83 e0 03             	and    $0x3,%eax
  800420a8c5:	83 f8 03             	cmp    $0x3,%eax
  800420a8c8:	0f 85 b3 01 00 00    	jne    800420aa81 <trap+0x288>
		// Trapped from user mode.
		// Acquire the big kernel lock before doing any
		// serious kernel work.
		// LAB 4: Your code here.
		lock_kernel();
  800420a8ce:	48 b8 0b 93 20 04 80 	movabs $0x800420930b,%rax
  800420a8d5:	00 00 00 
  800420a8d8:	ff d0                	callq  *%rax
		assert(curenv);
  800420a8da:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420a8e1:	00 00 00 
  800420a8e4:	ff d0                	callq  *%rax
  800420a8e6:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420a8ed:	00 00 00 
  800420a8f0:	48 98                	cltq   
  800420a8f2:	48 c1 e0 03          	shl    $0x3,%rax
  800420a8f6:	48 89 c2             	mov    %rax,%rdx
  800420a8f9:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a8fd:	48 29 c2             	sub    %rax,%rdx
  800420a900:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420a904:	48 83 c0 08          	add    $0x8,%rax
  800420a908:	48 8b 00             	mov    (%rax),%rax
  800420a90b:	48 85 c0             	test   %rax,%rax
  800420a90e:	75 35                	jne    800420a945 <trap+0x14c>
  800420a910:	48 b9 6e 6f 21 04 80 	movabs $0x8004216f6e,%rcx
  800420a917:	00 00 00 
  800420a91a:	48 ba 59 6f 21 04 80 	movabs $0x8004216f59,%rdx
  800420a921:	00 00 00 
  800420a924:	be 48 01 00 00       	mov    $0x148,%esi
  800420a929:	48 bf a8 6d 21 04 80 	movabs $0x8004216da8,%rdi
  800420a930:	00 00 00 
  800420a933:	b8 00 00 00 00       	mov    $0x0,%eax
  800420a938:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420a93f:	00 00 00 
  800420a942:	41 ff d0             	callq  *%r8

		// Garbage collect if current enviroment is a zombie
		if (curenv->env_status == ENV_DYING) {
  800420a945:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420a94c:	00 00 00 
  800420a94f:	ff d0                	callq  *%rax
  800420a951:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420a958:	00 00 00 
  800420a95b:	48 98                	cltq   
  800420a95d:	48 c1 e0 03          	shl    $0x3,%rax
  800420a961:	48 89 c2             	mov    %rax,%rdx
  800420a964:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a968:	48 29 c2             	sub    %rax,%rdx
  800420a96b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420a96f:	48 83 c0 08          	add    $0x8,%rax
  800420a973:	48 8b 00             	mov    (%rax),%rax
  800420a976:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420a97c:	83 f8 01             	cmp    $0x1,%eax
  800420a97f:	0f 85 81 00 00 00    	jne    800420aa06 <trap+0x20d>
			env_free(curenv);
  800420a985:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420a98c:	00 00 00 
  800420a98f:	ff d0                	callq  *%rax
  800420a991:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420a998:	00 00 00 
  800420a99b:	48 98                	cltq   
  800420a99d:	48 c1 e0 03          	shl    $0x3,%rax
  800420a9a1:	48 89 c2             	mov    %rax,%rdx
  800420a9a4:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a9a8:	48 29 c2             	sub    %rax,%rdx
  800420a9ab:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420a9af:	48 83 c0 08          	add    $0x8,%rax
  800420a9b3:	48 8b 00             	mov    (%rax),%rax
  800420a9b6:	48 89 c7             	mov    %rax,%rdi
  800420a9b9:	48 b8 6e 86 20 04 80 	movabs $0x800420866e,%rax
  800420a9c0:	00 00 00 
  800420a9c3:	ff d0                	callq  *%rax
			curenv = NULL;
  800420a9c5:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420a9cc:	00 00 00 
  800420a9cf:	ff d0                	callq  *%rax
  800420a9d1:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420a9d8:	00 00 00 
  800420a9db:	48 98                	cltq   
  800420a9dd:	48 c1 e0 03          	shl    $0x3,%rax
  800420a9e1:	48 89 c2             	mov    %rax,%rdx
  800420a9e4:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a9e8:	48 29 c2             	sub    %rax,%rdx
  800420a9eb:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420a9ef:	48 83 c0 08          	add    $0x8,%rax
  800420a9f3:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			sched_yield();
  800420a9fa:	48 b8 c1 b0 20 04 80 	movabs $0x800420b0c1,%rax
  800420aa01:	00 00 00 
  800420aa04:	ff d0                	callq  *%rax
		}

		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  800420aa06:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420aa0d:	00 00 00 
  800420aa10:	ff d0                	callq  *%rax
  800420aa12:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420aa19:	00 00 00 
  800420aa1c:	48 98                	cltq   
  800420aa1e:	48 c1 e0 03          	shl    $0x3,%rax
  800420aa22:	48 89 c2             	mov    %rax,%rdx
  800420aa25:	48 c1 e2 04          	shl    $0x4,%rdx
  800420aa29:	48 29 c2             	sub    %rax,%rdx
  800420aa2c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420aa30:	48 83 c0 08          	add    $0x8,%rax
  800420aa34:	48 8b 10             	mov    (%rax),%rdx
  800420aa37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420aa3b:	48 89 c6             	mov    %rax,%rsi
  800420aa3e:	b8 18 00 00 00       	mov    $0x18,%eax
  800420aa43:	48 89 d7             	mov    %rdx,%rdi
  800420aa46:	48 89 c1             	mov    %rax,%rcx
  800420aa49:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  800420aa4c:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420aa53:	00 00 00 
  800420aa56:	ff d0                	callq  *%rax
  800420aa58:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420aa5f:	00 00 00 
  800420aa62:	48 98                	cltq   
  800420aa64:	48 c1 e0 03          	shl    $0x3,%rax
  800420aa68:	48 89 c2             	mov    %rax,%rdx
  800420aa6b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420aa6f:	48 29 c2             	sub    %rax,%rdx
  800420aa72:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420aa76:	48 83 c0 08          	add    $0x8,%rax
  800420aa7a:	48 8b 00             	mov    (%rax),%rax
  800420aa7d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}

	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  800420aa81:	48 b8 90 e2 49 04 80 	movabs $0x800449e290,%rax
  800420aa88:	00 00 00 
  800420aa8b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420aa8f:	48 89 10             	mov    %rdx,(%rax)

	//cprintf("Incoming TRAP frame at %p\n", tf);
	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  800420aa92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420aa96:	48 89 c7             	mov    %rax,%rdi
  800420aa99:	48 b8 51 a6 20 04 80 	movabs $0x800420a651,%rax
  800420aaa0:	00 00 00 
  800420aaa3:	ff d0                	callq  *%rax

	// If we made it to this point, then no other environment was
	// scheduled, so we should return to the current environment
	// if doing so makes sense.
	if (curenv && curenv->env_status == ENV_RUNNING)
  800420aaa5:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420aaac:	00 00 00 
  800420aaaf:	ff d0                	callq  *%rax
  800420aab1:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420aab8:	00 00 00 
  800420aabb:	48 98                	cltq   
  800420aabd:	48 c1 e0 03          	shl    $0x3,%rax
  800420aac1:	48 89 c2             	mov    %rax,%rdx
  800420aac4:	48 c1 e2 04          	shl    $0x4,%rdx
  800420aac8:	48 29 c2             	sub    %rax,%rdx
  800420aacb:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420aacf:	48 83 c0 08          	add    $0x8,%rax
  800420aad3:	48 8b 00             	mov    (%rax),%rax
  800420aad6:	48 85 c0             	test   %rax,%rax
  800420aad9:	74 7c                	je     800420ab57 <trap+0x35e>
  800420aadb:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420aae2:	00 00 00 
  800420aae5:	ff d0                	callq  *%rax
  800420aae7:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420aaee:	00 00 00 
  800420aaf1:	48 98                	cltq   
  800420aaf3:	48 c1 e0 03          	shl    $0x3,%rax
  800420aaf7:	48 89 c2             	mov    %rax,%rdx
  800420aafa:	48 c1 e2 04          	shl    $0x4,%rdx
  800420aafe:	48 29 c2             	sub    %rax,%rdx
  800420ab01:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ab05:	48 83 c0 08          	add    $0x8,%rax
  800420ab09:	48 8b 00             	mov    (%rax),%rax
  800420ab0c:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420ab12:	83 f8 03             	cmp    $0x3,%eax
  800420ab15:	75 40                	jne    800420ab57 <trap+0x35e>
		env_run(curenv);
  800420ab17:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420ab1e:	00 00 00 
  800420ab21:	ff d0                	callq  *%rax
  800420ab23:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420ab2a:	00 00 00 
  800420ab2d:	48 98                	cltq   
  800420ab2f:	48 c1 e0 03          	shl    $0x3,%rax
  800420ab33:	48 89 c2             	mov    %rax,%rdx
  800420ab36:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ab3a:	48 29 c2             	sub    %rax,%rdx
  800420ab3d:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ab41:	48 83 c0 08          	add    $0x8,%rax
  800420ab45:	48 8b 00             	mov    (%rax),%rax
  800420ab48:	48 89 c7             	mov    %rax,%rdi
  800420ab4b:	48 b8 ca 8c 20 04 80 	movabs $0x8004208cca,%rax
  800420ab52:	00 00 00 
  800420ab55:	ff d0                	callq  *%rax
	else
		sched_yield();
  800420ab57:	48 b8 c1 b0 20 04 80 	movabs $0x800420b0c1,%rax
  800420ab5e:	00 00 00 
  800420ab61:	ff d0                	callq  *%rax

000000800420ab63 <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  800420ab63:	55                   	push   %rbp
  800420ab64:	48 89 e5             	mov    %rsp,%rbp
  800420ab67:	53                   	push   %rbx
  800420ab68:	48 83 ec 38          	sub    $0x38,%rsp
  800420ab6c:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420ab70:	0f 20 d0             	mov    %cr2,%rax
  800420ab73:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	return val;
  800420ab77:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
	uint64_t fault_va;

	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  800420ab7b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// Handle kernel-mode page faults.

	// LAB 3: Your code here.
	if(!(tf->tf_cs & 3)) panic("page fault in kernel!\n");
  800420ab7f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ab83:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420ab8a:	0f b7 c0             	movzwl %ax,%eax
  800420ab8d:	83 e0 03             	and    $0x3,%eax
  800420ab90:	85 c0                	test   %eax,%eax
  800420ab92:	75 2a                	jne    800420abbe <page_fault_handler+0x5b>
  800420ab94:	48 ba 75 6f 21 04 80 	movabs $0x8004216f75,%rdx
  800420ab9b:	00 00 00 
  800420ab9e:	be 76 01 00 00       	mov    $0x176,%esi
  800420aba3:	48 bf a8 6d 21 04 80 	movabs $0x8004216da8,%rdi
  800420abaa:	00 00 00 
  800420abad:	b8 00 00 00 00       	mov    $0x0,%eax
  800420abb2:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  800420abb9:	00 00 00 
  800420abbc:	ff d1                	callq  *%rcx

	// LAB 4: Your code here.

	// Destroy the environment that caused the fault.
//user_mem_assert(curenv, fault_va)
	if(curenv->env_pgfault_upcall) {
  800420abbe:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420abc5:	00 00 00 
  800420abc8:	ff d0                	callq  *%rax
  800420abca:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420abd1:	00 00 00 
  800420abd4:	48 98                	cltq   
  800420abd6:	48 c1 e0 03          	shl    $0x3,%rax
  800420abda:	48 89 c2             	mov    %rax,%rdx
  800420abdd:	48 c1 e2 04          	shl    $0x4,%rdx
  800420abe1:	48 29 c2             	sub    %rax,%rdx
  800420abe4:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420abe8:	48 83 c0 08          	add    $0x8,%rax
  800420abec:	48 8b 00             	mov    (%rax),%rax
  800420abef:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420abf6:	48 85 c0             	test   %rax,%rax
  800420abf9:	0f 84 0b 02 00 00    	je     800420ae0a <page_fault_handler+0x2a7>
		struct UTrapframe* utf = (struct UTrapframe*)((tf->tf_rsp < UXSTACKTOP && tf->tf_rsp >= (UXSTACKTOP - PGSIZE)) ?  
  800420abff:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ac03:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420ac0a:	b8 ff ff 7f ef       	mov    $0xef7fffff,%eax
  800420ac0f:	48 39 c2             	cmp    %rax,%rdx
  800420ac12:	77 28                	ja     800420ac3c <page_fault_handler+0xd9>
  800420ac14:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ac18:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420ac1f:	b8 ff ef 7f ef       	mov    $0xef7fefff,%eax
  800420ac24:	48 39 c2             	cmp    %rax,%rdx
  800420ac27:	76 13                	jbe    800420ac3c <page_fault_handler+0xd9>
															  								   tf->tf_rsp - (8 + UTFSIZE) : UXSTACKTOP - UTFSIZE);
  800420ac29:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ac2d:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420ac34:	48 2d a8 00 00 00    	sub    $0xa8,%rax
	// LAB 4: Your code here.

	// Destroy the environment that caused the fault.
//user_mem_assert(curenv, fault_va)
	if(curenv->env_pgfault_upcall) {
		struct UTrapframe* utf = (struct UTrapframe*)((tf->tf_rsp < UXSTACKTOP && tf->tf_rsp >= (UXSTACKTOP - PGSIZE)) ?  
  800420ac3a:	eb 05                	jmp    800420ac41 <page_fault_handler+0xde>
  800420ac3c:	b8 60 ff 7f ef       	mov    $0xef7fff60,%eax
  800420ac41:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
															  								   tf->tf_rsp - (8 + UTFSIZE) : UXSTACKTOP - UTFSIZE);
		user_mem_assert(curenv, (void*)utf, UTFSIZE, PTE_W);
  800420ac45:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420ac4c:	00 00 00 
  800420ac4f:	ff d0                	callq  *%rax
  800420ac51:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420ac58:	00 00 00 
  800420ac5b:	48 98                	cltq   
  800420ac5d:	48 c1 e0 03          	shl    $0x3,%rax
  800420ac61:	48 89 c2             	mov    %rax,%rdx
  800420ac64:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ac68:	48 29 c2             	sub    %rax,%rdx
  800420ac6b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ac6f:	48 83 c0 08          	add    $0x8,%rax
  800420ac73:	48 8b 00             	mov    (%rax),%rax
  800420ac76:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420ac7a:	b9 02 00 00 00       	mov    $0x2,%ecx
  800420ac7f:	ba a0 00 00 00       	mov    $0xa0,%edx
  800420ac84:	48 89 c7             	mov    %rax,%rdi
  800420ac87:	48 b8 ba 40 20 04 80 	movabs $0x80042040ba,%rax
  800420ac8e:	00 00 00 
  800420ac91:	ff d0                	callq  *%rax
		utf->utf_fault_va = fault_va;
  800420ac93:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ac97:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ac9b:	48 89 10             	mov    %rdx,(%rax)
		utf->utf_err = tf->tf_err;
  800420ac9e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420aca2:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
  800420aca9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420acad:	48 89 50 08          	mov    %rdx,0x8(%rax)
		utf->utf_regs = tf->tf_regs;
  800420acb1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420acb5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420acb9:	48 8b 0a             	mov    (%rdx),%rcx
  800420acbc:	48 89 48 10          	mov    %rcx,0x10(%rax)
  800420acc0:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420acc4:	48 89 48 18          	mov    %rcx,0x18(%rax)
  800420acc8:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  800420accc:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420acd0:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  800420acd4:	48 89 48 28          	mov    %rcx,0x28(%rax)
  800420acd8:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  800420acdc:	48 89 48 30          	mov    %rcx,0x30(%rax)
  800420ace0:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
  800420ace4:	48 89 48 38          	mov    %rcx,0x38(%rax)
  800420ace8:	48 8b 4a 30          	mov    0x30(%rdx),%rcx
  800420acec:	48 89 48 40          	mov    %rcx,0x40(%rax)
  800420acf0:	48 8b 4a 38          	mov    0x38(%rdx),%rcx
  800420acf4:	48 89 48 48          	mov    %rcx,0x48(%rax)
  800420acf8:	48 8b 4a 40          	mov    0x40(%rdx),%rcx
  800420acfc:	48 89 48 50          	mov    %rcx,0x50(%rax)
  800420ad00:	48 8b 4a 48          	mov    0x48(%rdx),%rcx
  800420ad04:	48 89 48 58          	mov    %rcx,0x58(%rax)
  800420ad08:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
  800420ad0c:	48 89 48 60          	mov    %rcx,0x60(%rax)
  800420ad10:	48 8b 4a 58          	mov    0x58(%rdx),%rcx
  800420ad14:	48 89 48 68          	mov    %rcx,0x68(%rax)
  800420ad18:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
  800420ad1c:	48 89 48 70          	mov    %rcx,0x70(%rax)
  800420ad20:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
  800420ad24:	48 89 48 78          	mov    %rcx,0x78(%rax)
  800420ad28:	48 8b 52 70          	mov    0x70(%rdx),%rdx
  800420ad2c:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
		utf->utf_rip = tf->tf_rip;
  800420ad33:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ad37:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800420ad3e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ad42:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
		tf->tf_rip = (uintptr_t)curenv->env_pgfault_upcall;
  800420ad49:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420ad50:	00 00 00 
  800420ad53:	ff d0                	callq  *%rax
  800420ad55:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420ad5c:	00 00 00 
  800420ad5f:	48 98                	cltq   
  800420ad61:	48 c1 e0 03          	shl    $0x3,%rax
  800420ad65:	48 89 c2             	mov    %rax,%rdx
  800420ad68:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ad6c:	48 29 c2             	sub    %rax,%rdx
  800420ad6f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ad73:	48 83 c0 08          	add    $0x8,%rax
  800420ad77:	48 8b 00             	mov    (%rax),%rax
  800420ad7a:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420ad81:	48 89 c2             	mov    %rax,%rdx
  800420ad84:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ad88:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		utf->utf_eflags = tf->tf_eflags;
  800420ad8f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ad93:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  800420ad9a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ad9e:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
		utf->utf_rsp = tf->tf_rsp;
  800420ada5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ada9:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420adb0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420adb4:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		tf->tf_rsp = (uintptr_t)utf;
  800420adbb:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420adbf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420adc3:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
		env_run(curenv);
  800420adca:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420add1:	00 00 00 
  800420add4:	ff d0                	callq  *%rax
  800420add6:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420addd:	00 00 00 
  800420ade0:	48 98                	cltq   
  800420ade2:	48 c1 e0 03          	shl    $0x3,%rax
  800420ade6:	48 89 c2             	mov    %rax,%rdx
  800420ade9:	48 c1 e2 04          	shl    $0x4,%rdx
  800420aded:	48 29 c2             	sub    %rax,%rdx
  800420adf0:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420adf4:	48 83 c0 08          	add    $0x8,%rax
  800420adf8:	48 8b 00             	mov    (%rax),%rax
  800420adfb:	48 89 c7             	mov    %rax,%rdi
  800420adfe:	48 b8 ca 8c 20 04 80 	movabs $0x8004208cca,%rax
  800420ae05:	00 00 00 
  800420ae08:	ff d0                	callq  *%rax
	}
	cprintf("[%08x] user fault va %08x ip %08x\n",
  800420ae0a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ae0e:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
	   curenv->env_id, fault_va, tf->tf_rip);
  800420ae15:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420ae1c:	00 00 00 
  800420ae1f:	ff d0                	callq  *%rax
  800420ae21:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420ae28:	00 00 00 
  800420ae2b:	48 98                	cltq   
  800420ae2d:	48 c1 e0 03          	shl    $0x3,%rax
  800420ae31:	48 89 c2             	mov    %rax,%rdx
  800420ae34:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ae38:	48 29 c2             	sub    %rax,%rdx
  800420ae3b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ae3f:	48 83 c0 08          	add    $0x8,%rax
  800420ae43:	48 8b 00             	mov    (%rax),%rax
		utf->utf_eflags = tf->tf_eflags;
		utf->utf_rsp = tf->tf_rsp;
		tf->tf_rsp = (uintptr_t)utf;
		env_run(curenv);
	}
	cprintf("[%08x] user fault va %08x ip %08x\n",
  800420ae46:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420ae4c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ae50:	48 89 d9             	mov    %rbx,%rcx
  800420ae53:	89 c6                	mov    %eax,%esi
  800420ae55:	48 bf 90 6f 21 04 80 	movabs $0x8004216f90,%rdi
  800420ae5c:	00 00 00 
  800420ae5f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ae64:	49 b8 0e 92 20 04 80 	movabs $0x800420920e,%r8
  800420ae6b:	00 00 00 
  800420ae6e:	41 ff d0             	callq  *%r8
	   curenv->env_id, fault_va, tf->tf_rip);
	print_trapframe(tf);
  800420ae71:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ae75:	48 89 c7             	mov    %rax,%rdi
  800420ae78:	48 b8 f9 a0 20 04 80 	movabs $0x800420a0f9,%rax
  800420ae7f:	00 00 00 
  800420ae82:	ff d0                	callq  *%rax
	

	env_destroy(curenv);
  800420ae84:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420ae8b:	00 00 00 
  800420ae8e:	ff d0                	callq  *%rax
  800420ae90:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420ae97:	00 00 00 
  800420ae9a:	48 98                	cltq   
  800420ae9c:	48 c1 e0 03          	shl    $0x3,%rax
  800420aea0:	48 89 c2             	mov    %rax,%rdx
  800420aea3:	48 c1 e2 04          	shl    $0x4,%rdx
  800420aea7:	48 29 c2             	sub    %rax,%rdx
  800420aeaa:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420aeae:	48 83 c0 08          	add    $0x8,%rax
  800420aeb2:	48 8b 00             	mov    (%rax),%rax
  800420aeb5:	48 89 c7             	mov    %rax,%rdi
  800420aeb8:	48 b8 fb 8a 20 04 80 	movabs $0x8004208afb,%rax
  800420aebf:	00 00 00 
  800420aec2:	ff d0                	callq  *%rax
}
  800420aec4:	48 83 c4 38          	add    $0x38,%rsp
  800420aec8:	5b                   	pop    %rbx
  800420aec9:	5d                   	pop    %rbp
  800420aeca:	c3                   	retq   
  800420aecb:	90                   	nop

000000800420aecc <TH_divide>:
/*
 * Lab 3: Your code here for generating entry points for the different traps.
  Find the PUSHA,POPA macros in kern/macro.h. Since amd64 doesn't support
   pusha,popa so you will find these macros handy.
 */
	TRAPHANDLER_NOEC(TH_divide, T_DIVIDE)
  800420aecc:	6a 00                	pushq  $0x0
  800420aece:	6a 00                	pushq  $0x0
  800420aed0:	e9 34 01 00 00       	jmpq   800420b009 <_alltraps>
  800420aed5:	90                   	nop

000000800420aed6 <TH_debug>:
	TRAPHANDLER_NOEC(TH_debug, T_DEBUG)
  800420aed6:	6a 00                	pushq  $0x0
  800420aed8:	6a 01                	pushq  $0x1
  800420aeda:	e9 2a 01 00 00       	jmpq   800420b009 <_alltraps>
  800420aedf:	90                   	nop

000000800420aee0 <TH_nmi>:
	TRAPHANDLER_NOEC(TH_nmi, T_NMI)
  800420aee0:	6a 00                	pushq  $0x0
  800420aee2:	6a 02                	pushq  $0x2
  800420aee4:	e9 20 01 00 00       	jmpq   800420b009 <_alltraps>
  800420aee9:	90                   	nop

000000800420aeea <TH_brkpt>:
	TRAPHANDLER_NOEC(TH_brkpt, T_BRKPT)
  800420aeea:	6a 00                	pushq  $0x0
  800420aeec:	6a 03                	pushq  $0x3
  800420aeee:	e9 16 01 00 00       	jmpq   800420b009 <_alltraps>
  800420aef3:	90                   	nop

000000800420aef4 <TH_oflow>:
	TRAPHANDLER_NOEC(TH_oflow, T_OFLOW)
  800420aef4:	6a 00                	pushq  $0x0
  800420aef6:	6a 04                	pushq  $0x4
  800420aef8:	e9 0c 01 00 00       	jmpq   800420b009 <_alltraps>
  800420aefd:	90                   	nop

000000800420aefe <TH_bound>:
	TRAPHANDLER_NOEC(TH_bound, T_BOUND)
  800420aefe:	6a 00                	pushq  $0x0
  800420af00:	6a 05                	pushq  $0x5
  800420af02:	e9 02 01 00 00       	jmpq   800420b009 <_alltraps>
  800420af07:	90                   	nop

000000800420af08 <TH_illop>:
	TRAPHANDLER_NOEC(TH_illop, T_ILLOP)
  800420af08:	6a 00                	pushq  $0x0
  800420af0a:	6a 06                	pushq  $0x6
  800420af0c:	e9 f8 00 00 00       	jmpq   800420b009 <_alltraps>
  800420af11:	90                   	nop

000000800420af12 <TH_device>:
	TRAPHANDLER_NOEC(TH_device, T_DEVICE)
  800420af12:	6a 00                	pushq  $0x0
  800420af14:	6a 07                	pushq  $0x7
  800420af16:	e9 ee 00 00 00       	jmpq   800420b009 <_alltraps>
  800420af1b:	90                   	nop

000000800420af1c <TH_dblflt>:
	TRAPHANDLER(TH_dblflt, T_DBLFLT)
  800420af1c:	6a 08                	pushq  $0x8
  800420af1e:	e9 e6 00 00 00       	jmpq   800420b009 <_alltraps>
  800420af23:	90                   	nop

000000800420af24 <TH_coproc>:
	TRAPHANDLER_NOEC(TH_coproc, 9)
  800420af24:	6a 00                	pushq  $0x0
  800420af26:	6a 09                	pushq  $0x9
  800420af28:	e9 dc 00 00 00       	jmpq   800420b009 <_alltraps>
  800420af2d:	90                   	nop

000000800420af2e <TH_tss>:
	TRAPHANDLER(TH_tss, T_TSS)
  800420af2e:	6a 0a                	pushq  $0xa
  800420af30:	e9 d4 00 00 00       	jmpq   800420b009 <_alltraps>
  800420af35:	90                   	nop

000000800420af36 <TH_segnp>:
	TRAPHANDLER(TH_segnp, T_SEGNP)
  800420af36:	6a 0b                	pushq  $0xb
  800420af38:	e9 cc 00 00 00       	jmpq   800420b009 <_alltraps>
  800420af3d:	90                   	nop

000000800420af3e <TH_stack>:
	TRAPHANDLER(TH_stack, T_STACK)
  800420af3e:	6a 0c                	pushq  $0xc
  800420af40:	e9 c4 00 00 00       	jmpq   800420b009 <_alltraps>
  800420af45:	90                   	nop

000000800420af46 <TH_gpflt>:
	TRAPHANDLER(TH_gpflt, T_GPFLT)
  800420af46:	6a 0d                	pushq  $0xd
  800420af48:	e9 bc 00 00 00       	jmpq   800420b009 <_alltraps>
  800420af4d:	90                   	nop

000000800420af4e <TH_pgflt>:
	TRAPHANDLER(TH_pgflt, T_PGFLT)
  800420af4e:	6a 0e                	pushq  $0xe
  800420af50:	e9 b4 00 00 00       	jmpq   800420b009 <_alltraps>
  800420af55:	90                   	nop

000000800420af56 <TH_res>:
	TRAPHANDLER_NOEC(TH_res, 15)
  800420af56:	6a 00                	pushq  $0x0
  800420af58:	6a 0f                	pushq  $0xf
  800420af5a:	e9 aa 00 00 00       	jmpq   800420b009 <_alltraps>
  800420af5f:	90                   	nop

000000800420af60 <TH_fperr>:
	TRAPHANDLER_NOEC(TH_fperr, T_FPERR)
  800420af60:	6a 00                	pushq  $0x0
  800420af62:	6a 10                	pushq  $0x10
  800420af64:	e9 a0 00 00 00       	jmpq   800420b009 <_alltraps>
  800420af69:	90                   	nop

000000800420af6a <TH_align>:
	TRAPHANDLER(TH_align, T_ALIGN)
  800420af6a:	6a 11                	pushq  $0x11
  800420af6c:	e9 98 00 00 00       	jmpq   800420b009 <_alltraps>
  800420af71:	90                   	nop

000000800420af72 <TH_mchk>:
	TRAPHANDLER_NOEC(TH_mchk, T_MCHK)
  800420af72:	6a 00                	pushq  $0x0
  800420af74:	6a 12                	pushq  $0x12
  800420af76:	e9 8e 00 00 00       	jmpq   800420b009 <_alltraps>
  800420af7b:	90                   	nop

000000800420af7c <TH_simderr>:
	TRAPHANDLER_NOEC(TH_simderr, T_SIMDERR)
  800420af7c:	6a 00                	pushq  $0x0
  800420af7e:	6a 13                	pushq  $0x13
  800420af80:	e9 84 00 00 00       	jmpq   800420b009 <_alltraps>
  800420af85:	90                   	nop

000000800420af86 <TH_syscall>:
	TRAPHANDLER_NOEC(TH_syscall, T_SYSCALL)
  800420af86:	6a 00                	pushq  $0x0
  800420af88:	6a 30                	pushq  $0x30
  800420af8a:	eb 7d                	jmp    800420b009 <_alltraps>

000000800420af8c <TH_default>:
	TRAPHANDLER_NOEC(TH_default, T_DEFAULT)
  800420af8c:	6a 00                	pushq  $0x0
  800420af8e:	68 f4 01 00 00       	pushq  $0x1f4
  800420af93:	eb 74                	jmp    800420b009 <_alltraps>
  800420af95:	90                   	nop

000000800420af96 <TH_irq_timer>:

	//TRAPHANDLER_NOEC(TH_irq_offset,  IRQ_OFFSET)
	TRAPHANDLER_NOEC(TH_irq_timer, IRQ_OFFSET + IRQ_TIMER)
  800420af96:	6a 00                	pushq  $0x0
  800420af98:	6a 20                	pushq  $0x20
  800420af9a:	eb 6d                	jmp    800420b009 <_alltraps>

000000800420af9c <TH_irq_kbd>:
	TRAPHANDLER_NOEC(TH_irq_kbd,  IRQ_OFFSET + IRQ_KBD)
  800420af9c:	6a 00                	pushq  $0x0
  800420af9e:	6a 21                	pushq  $0x21
  800420afa0:	eb 67                	jmp    800420b009 <_alltraps>

000000800420afa2 <TH_irq_2>:
	TRAPHANDLER_NOEC(TH_irq_2, IRQ_OFFSET + 2)
  800420afa2:	6a 00                	pushq  $0x0
  800420afa4:	6a 22                	pushq  $0x22
  800420afa6:	eb 61                	jmp    800420b009 <_alltraps>

000000800420afa8 <TH_irq_3>:
	TRAPHANDLER_NOEC(TH_irq_3, IRQ_OFFSET + 3)
  800420afa8:	6a 00                	pushq  $0x0
  800420afaa:	6a 23                	pushq  $0x23
  800420afac:	eb 5b                	jmp    800420b009 <_alltraps>

000000800420afae <TH_irq_serial>:
	TRAPHANDLER_NOEC(TH_irq_serial,  IRQ_OFFSET + IRQ_SERIAL)
  800420afae:	6a 00                	pushq  $0x0
  800420afb0:	6a 24                	pushq  $0x24
  800420afb2:	eb 55                	jmp    800420b009 <_alltraps>

000000800420afb4 <TH_irq_5>:
	TRAPHANDLER_NOEC(TH_irq_5, IRQ_OFFSET + 5)
  800420afb4:	6a 00                	pushq  $0x0
  800420afb6:	6a 25                	pushq  $0x25
  800420afb8:	eb 4f                	jmp    800420b009 <_alltraps>

000000800420afba <TH_irq_6>:
	TRAPHANDLER_NOEC(TH_irq_6, IRQ_OFFSET + 6)
  800420afba:	6a 00                	pushq  $0x0
  800420afbc:	6a 26                	pushq  $0x26
  800420afbe:	eb 49                	jmp    800420b009 <_alltraps>

000000800420afc0 <TH_irq_spurious>:
	TRAPHANDLER_NOEC(TH_irq_spurious,  IRQ_OFFSET + IRQ_SPURIOUS)
  800420afc0:	6a 00                	pushq  $0x0
  800420afc2:	6a 27                	pushq  $0x27
  800420afc4:	eb 43                	jmp    800420b009 <_alltraps>

000000800420afc6 <TH_irq_8>:
	TRAPHANDLER_NOEC(TH_irq_8, IRQ_OFFSET + 8)
  800420afc6:	6a 00                	pushq  $0x0
  800420afc8:	6a 28                	pushq  $0x28
  800420afca:	eb 3d                	jmp    800420b009 <_alltraps>

000000800420afcc <TH_irq_9>:
	TRAPHANDLER_NOEC(TH_irq_9, IRQ_OFFSET + 9)
  800420afcc:	6a 00                	pushq  $0x0
  800420afce:	6a 29                	pushq  $0x29
  800420afd0:	eb 37                	jmp    800420b009 <_alltraps>

000000800420afd2 <TH_irq_10>:
	TRAPHANDLER_NOEC(TH_irq_10, IRQ_OFFSET + 10)
  800420afd2:	6a 00                	pushq  $0x0
  800420afd4:	6a 2a                	pushq  $0x2a
  800420afd6:	eb 31                	jmp    800420b009 <_alltraps>

000000800420afd8 <TH_irq_11>:
	TRAPHANDLER_NOEC(TH_irq_11, IRQ_OFFSET + 11)
  800420afd8:	6a 00                	pushq  $0x0
  800420afda:	6a 2b                	pushq  $0x2b
  800420afdc:	eb 2b                	jmp    800420b009 <_alltraps>

000000800420afde <TH_irq_12>:
	TRAPHANDLER_NOEC(TH_irq_12, IRQ_OFFSET + 12)
  800420afde:	6a 00                	pushq  $0x0
  800420afe0:	6a 2c                	pushq  $0x2c
  800420afe2:	eb 25                	jmp    800420b009 <_alltraps>

000000800420afe4 <TH_irq_13>:
	TRAPHANDLER_NOEC(TH_irq_13, IRQ_OFFSET + 13)
  800420afe4:	6a 00                	pushq  $0x0
  800420afe6:	6a 2d                	pushq  $0x2d
  800420afe8:	eb 1f                	jmp    800420b009 <_alltraps>

000000800420afea <TH_irq_ide>:
	TRAPHANDLER_NOEC(TH_irq_ide,  IRQ_OFFSET + IRQ_IDE)
  800420afea:	6a 00                	pushq  $0x0
  800420afec:	6a 2e                	pushq  $0x2e
  800420afee:	eb 19                	jmp    800420b009 <_alltraps>

000000800420aff0 <TH_irq_15>:
	TRAPHANDLER_NOEC(TH_irq_15, IRQ_OFFSET + 15)
  800420aff0:	6a 00                	pushq  $0x0
  800420aff2:	6a 2f                	pushq  $0x2f
  800420aff4:	eb 13                	jmp    800420b009 <_alltraps>

000000800420aff6 <sysenter_handler>:
	push %rcx
	push %rdx
	push %rax*/
	//int $3
  //PUSHA
	push %r14
  800420aff6:	41 56                	push   %r14
	push %rbp
  800420aff8:	55                   	push   %rbp
	call syscall
  800420aff9:	e8 d8 0d 00 00       	callq  800420bdd6 <syscall>
	pop %rbp
  800420affe:	5d                   	pop    %rbp
	pop %r14
  800420afff:	41 5e                	pop    %r14
	//int $3
	//add $0x18, %rsp
	mov %r14, %rdx
  800420b001:	4c 89 f2             	mov    %r14,%rdx
	mov %rbp, %rcx
  800420b004:	48 89 e9             	mov    %rbp,%rcx
	//int $3
	sysexit
  800420b007:	0f 35                	sysexit 

000000800420b009 <_alltraps>:

_alltraps:
subq $16, %rsp
  800420b009:	48 83 ec 10          	sub    $0x10,%rsp
mov %ds, 8(%rsp)
  800420b00d:	8c 5c 24 08          	mov    %ds,0x8(%rsp)
mov %es, 0(%rsp)
  800420b011:	8c 04 24             	mov    %es,(%rsp)
PUSHA
  800420b014:	48 83 ec 78          	sub    $0x78,%rsp
  800420b018:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  800420b01d:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  800420b022:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  800420b027:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  800420b02c:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  800420b031:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  800420b036:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  800420b03b:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  800420b040:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  800420b045:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  800420b04a:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  800420b04f:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  800420b054:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  800420b059:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  800420b05e:	4c 89 3c 24          	mov    %r15,(%rsp)
mov %rsp, %rdi
  800420b062:	48 89 e7             	mov    %rsp,%rdi
push %r15
  800420b065:	41 57                	push   %r15
xor %r15, %r15
  800420b067:	4d 31 ff             	xor    %r15,%r15
mov $(GD_KD), %r15
  800420b06a:	49 c7 c7 10 00 00 00 	mov    $0x10,%r15
mov %r15, %ds
  800420b071:	49 8e df             	mov    %r15,%ds
mov %r15, %es
  800420b074:	49 8e c7             	mov    %r15,%es
pop %r15
  800420b077:	41 5f                	pop    %r15
call trap
  800420b079:	e8 7b f7 ff ff       	callq  800420a7f9 <trap>

000000800420b07e <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800420b07e:	55                   	push   %rbp
  800420b07f:	48 89 e5             	mov    %rsp,%rbp
  800420b082:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420b086:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420b08a:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420b08d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b091:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420b094:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420b098:	f0 87 02             	lock xchg %eax,(%rdx)
  800420b09b:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800420b09e:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420b0a1:	c9                   	leaveq 
  800420b0a2:	c3                   	retq   

000000800420b0a3 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420b0a3:	55                   	push   %rbp
  800420b0a4:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420b0a7:	48 bf 20 a9 22 04 80 	movabs $0x800422a920,%rdi
  800420b0ae:	00 00 00 
  800420b0b1:	48 b8 f3 4e 21 04 80 	movabs $0x8004214ef3,%rax
  800420b0b8:	00 00 00 
  800420b0bb:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420b0bd:	f3 90                	pause  
}
  800420b0bf:	5d                   	pop    %rbp
  800420b0c0:	c3                   	retq   

000000800420b0c1 <sched_yield>:


// Choose a user environment to run and run it.
void
sched_yield(void)
{
  800420b0c1:	55                   	push   %rbp
  800420b0c2:	48 89 e5             	mov    %rsp,%rbp
  800420b0c5:	48 83 ec 10          	sub    $0x10,%rsp
	// no runnable environments, simply drop through to the code
	// below to halt the cpu.

	// LAB 4: Your code here.
	// sched_halt never returns
	for(idle = curenv ? curenv + 1 : envs; idle < envs + NENV; idle++)
  800420b0c9:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420b0d0:	00 00 00 
  800420b0d3:	ff d0                	callq  *%rax
  800420b0d5:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420b0dc:	00 00 00 
  800420b0df:	48 98                	cltq   
  800420b0e1:	48 c1 e0 03          	shl    $0x3,%rax
  800420b0e5:	48 89 c2             	mov    %rax,%rdx
  800420b0e8:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b0ec:	48 29 c2             	sub    %rax,%rdx
  800420b0ef:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b0f3:	48 83 c0 08          	add    $0x8,%rax
  800420b0f7:	48 8b 00             	mov    (%rax),%rax
  800420b0fa:	48 85 c0             	test   %rax,%rax
  800420b0fd:	74 39                	je     800420b138 <sched_yield+0x77>
  800420b0ff:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420b106:	00 00 00 
  800420b109:	ff d0                	callq  *%rax
  800420b10b:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420b112:	00 00 00 
  800420b115:	48 98                	cltq   
  800420b117:	48 c1 e0 03          	shl    $0x3,%rax
  800420b11b:	48 89 c2             	mov    %rax,%rdx
  800420b11e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b122:	48 29 c2             	sub    %rax,%rdx
  800420b125:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b129:	48 83 c0 08          	add    $0x8,%rax
  800420b12d:	48 8b 00             	mov    (%rax),%rax
  800420b130:	48 05 20 01 00 00    	add    $0x120,%rax
  800420b136:	eb 0d                	jmp    800420b145 <sched_yield+0x84>
  800420b138:	48 b8 50 d2 49 04 80 	movabs $0x800449d250,%rax
  800420b13f:	00 00 00 
  800420b142:	48 8b 00             	mov    (%rax),%rax
  800420b145:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420b149:	eb 2a                	jmp    800420b175 <sched_yield+0xb4>
			if(idle->env_status == ENV_RUNNABLE) env_run(idle);
  800420b14b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b14f:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420b155:	83 f8 02             	cmp    $0x2,%eax
  800420b158:	75 13                	jne    800420b16d <sched_yield+0xac>
  800420b15a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b15e:	48 89 c7             	mov    %rax,%rdi
  800420b161:	48 b8 ca 8c 20 04 80 	movabs $0x8004208cca,%rax
  800420b168:	00 00 00 
  800420b16b:	ff d0                	callq  *%rax
	// no runnable environments, simply drop through to the code
	// below to halt the cpu.

	// LAB 4: Your code here.
	// sched_halt never returns
	for(idle = curenv ? curenv + 1 : envs; idle < envs + NENV; idle++)
  800420b16d:	48 81 45 f8 20 01 00 	addq   $0x120,-0x8(%rbp)
  800420b174:	00 
  800420b175:	48 b8 50 d2 49 04 80 	movabs $0x800449d250,%rax
  800420b17c:	00 00 00 
  800420b17f:	48 8b 00             	mov    (%rax),%rax
  800420b182:	48 05 00 80 04 00    	add    $0x48000,%rax
  800420b188:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420b18c:	77 bd                	ja     800420b14b <sched_yield+0x8a>
			if(idle->env_status == ENV_RUNNABLE) env_run(idle);
	if(curenv){
  800420b18e:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420b195:	00 00 00 
  800420b198:	ff d0                	callq  *%rax
  800420b19a:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420b1a1:	00 00 00 
  800420b1a4:	48 98                	cltq   
  800420b1a6:	48 c1 e0 03          	shl    $0x3,%rax
  800420b1aa:	48 89 c2             	mov    %rax,%rdx
  800420b1ad:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b1b1:	48 29 c2             	sub    %rax,%rdx
  800420b1b4:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b1b8:	48 83 c0 08          	add    $0x8,%rax
  800420b1bc:	48 8b 00             	mov    (%rax),%rax
  800420b1bf:	48 85 c0             	test   %rax,%rax
  800420b1c2:	0f 84 f0 00 00 00    	je     800420b2b8 <sched_yield+0x1f7>
		for(idle = envs; idle < curenv; idle++)
  800420b1c8:	48 b8 50 d2 49 04 80 	movabs $0x800449d250,%rax
  800420b1cf:	00 00 00 
  800420b1d2:	48 8b 00             	mov    (%rax),%rax
  800420b1d5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420b1d9:	eb 2a                	jmp    800420b205 <sched_yield+0x144>
			if(idle->env_status == ENV_RUNNABLE) env_run(idle);
  800420b1db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b1df:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420b1e5:	83 f8 02             	cmp    $0x2,%eax
  800420b1e8:	75 13                	jne    800420b1fd <sched_yield+0x13c>
  800420b1ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b1ee:	48 89 c7             	mov    %rax,%rdi
  800420b1f1:	48 b8 ca 8c 20 04 80 	movabs $0x8004208cca,%rax
  800420b1f8:	00 00 00 
  800420b1fb:	ff d0                	callq  *%rax
	// LAB 4: Your code here.
	// sched_halt never returns
	for(idle = curenv ? curenv + 1 : envs; idle < envs + NENV; idle++)
			if(idle->env_status == ENV_RUNNABLE) env_run(idle);
	if(curenv){
		for(idle = envs; idle < curenv; idle++)
  800420b1fd:	48 81 45 f8 20 01 00 	addq   $0x120,-0x8(%rbp)
  800420b204:	00 
  800420b205:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420b20c:	00 00 00 
  800420b20f:	ff d0                	callq  *%rax
  800420b211:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420b218:	00 00 00 
  800420b21b:	48 98                	cltq   
  800420b21d:	48 c1 e0 03          	shl    $0x3,%rax
  800420b221:	48 89 c2             	mov    %rax,%rdx
  800420b224:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b228:	48 29 c2             	sub    %rax,%rdx
  800420b22b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b22f:	48 83 c0 08          	add    $0x8,%rax
  800420b233:	48 8b 00             	mov    (%rax),%rax
  800420b236:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420b23a:	77 9f                	ja     800420b1db <sched_yield+0x11a>
			if(idle->env_status == ENV_RUNNABLE) env_run(idle);
		if(curenv->env_status == ENV_RUNNING) env_run(curenv);
  800420b23c:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420b243:	00 00 00 
  800420b246:	ff d0                	callq  *%rax
  800420b248:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420b24f:	00 00 00 
  800420b252:	48 98                	cltq   
  800420b254:	48 c1 e0 03          	shl    $0x3,%rax
  800420b258:	48 89 c2             	mov    %rax,%rdx
  800420b25b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b25f:	48 29 c2             	sub    %rax,%rdx
  800420b262:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b266:	48 83 c0 08          	add    $0x8,%rax
  800420b26a:	48 8b 00             	mov    (%rax),%rax
  800420b26d:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420b273:	83 f8 03             	cmp    $0x3,%eax
  800420b276:	75 40                	jne    800420b2b8 <sched_yield+0x1f7>
  800420b278:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420b27f:	00 00 00 
  800420b282:	ff d0                	callq  *%rax
  800420b284:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420b28b:	00 00 00 
  800420b28e:	48 98                	cltq   
  800420b290:	48 c1 e0 03          	shl    $0x3,%rax
  800420b294:	48 89 c2             	mov    %rax,%rdx
  800420b297:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b29b:	48 29 c2             	sub    %rax,%rdx
  800420b29e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b2a2:	48 83 c0 08          	add    $0x8,%rax
  800420b2a6:	48 8b 00             	mov    (%rax),%rax
  800420b2a9:	48 89 c7             	mov    %rax,%rdi
  800420b2ac:	48 b8 ca 8c 20 04 80 	movabs $0x8004208cca,%rax
  800420b2b3:	00 00 00 
  800420b2b6:	ff d0                	callq  *%rax
	}	
	sched_halt();
  800420b2b8:	48 b8 c6 b2 20 04 80 	movabs $0x800420b2c6,%rax
  800420b2bf:	00 00 00 
  800420b2c2:	ff d0                	callq  *%rax
}
  800420b2c4:	c9                   	leaveq 
  800420b2c5:	c3                   	retq   

000000800420b2c6 <sched_halt>:
// Halt this CPU when there is nothing to do. Wait until the
// timer interrupt wakes it up. This function never returns.
//
void
sched_halt(void)
{
  800420b2c6:	55                   	push   %rbp
  800420b2c7:	48 89 e5             	mov    %rsp,%rbp
  800420b2ca:	48 83 ec 20          	sub    $0x20,%rsp
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420b2ce:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420b2d5:	e9 91 00 00 00       	jmpq   800420b36b <sched_halt+0xa5>
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420b2da:	48 b8 50 d2 49 04 80 	movabs $0x800449d250,%rax
  800420b2e1:	00 00 00 
  800420b2e4:	48 8b 08             	mov    (%rax),%rcx
  800420b2e7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420b2ea:	48 63 d0             	movslq %eax,%rdx
  800420b2ed:	48 89 d0             	mov    %rdx,%rax
  800420b2f0:	48 c1 e0 03          	shl    $0x3,%rax
  800420b2f4:	48 01 d0             	add    %rdx,%rax
  800420b2f7:	48 c1 e0 05          	shl    $0x5,%rax
  800420b2fb:	48 01 c8             	add    %rcx,%rax
  800420b2fe:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420b304:	83 f8 02             	cmp    $0x2,%eax
  800420b307:	74 6f                	je     800420b378 <sched_halt+0xb2>
		     envs[i].env_status == ENV_RUNNING ||
  800420b309:	48 b8 50 d2 49 04 80 	movabs $0x800449d250,%rax
  800420b310:	00 00 00 
  800420b313:	48 8b 08             	mov    (%rax),%rcx
  800420b316:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420b319:	48 63 d0             	movslq %eax,%rdx
  800420b31c:	48 89 d0             	mov    %rdx,%rax
  800420b31f:	48 c1 e0 03          	shl    $0x3,%rax
  800420b323:	48 01 d0             	add    %rdx,%rax
  800420b326:	48 c1 e0 05          	shl    $0x5,%rax
  800420b32a:	48 01 c8             	add    %rcx,%rax
  800420b32d:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420b333:	83 f8 03             	cmp    $0x3,%eax
  800420b336:	74 40                	je     800420b378 <sched_halt+0xb2>
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
  800420b338:	48 b8 50 d2 49 04 80 	movabs $0x800449d250,%rax
  800420b33f:	00 00 00 
  800420b342:	48 8b 08             	mov    (%rax),%rcx
  800420b345:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420b348:	48 63 d0             	movslq %eax,%rdx
  800420b34b:	48 89 d0             	mov    %rdx,%rax
  800420b34e:	48 c1 e0 03          	shl    $0x3,%rax
  800420b352:	48 01 d0             	add    %rdx,%rax
  800420b355:	48 c1 e0 05          	shl    $0x5,%rax
  800420b359:	48 01 c8             	add    %rcx,%rax
  800420b35c:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
  800420b362:	83 f8 01             	cmp    $0x1,%eax
  800420b365:	74 11                	je     800420b378 <sched_halt+0xb2>
{
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420b367:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420b36b:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420b372:	0f 8e 62 ff ff ff    	jle    800420b2da <sched_halt+0x14>
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
			break;
	}
	if (i == NENV) {
  800420b378:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420b37f:	75 2e                	jne    800420b3af <sched_halt+0xe9>
		cprintf("No runnable environments in the system!\n");
  800420b381:	48 bf a0 71 21 04 80 	movabs $0x80042171a0,%rdi
  800420b388:	00 00 00 
  800420b38b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b390:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420b397:	00 00 00 
  800420b39a:	ff d2                	callq  *%rdx
		while (1)
			monitor(NULL);
  800420b39c:	bf 00 00 00 00       	mov    $0x0,%edi
  800420b3a1:	48 b8 bc 21 20 04 80 	movabs $0x80042021bc,%rax
  800420b3a8:	00 00 00 
  800420b3ab:	ff d0                	callq  *%rax
  800420b3ad:	eb ed                	jmp    800420b39c <sched_halt+0xd6>
	}

	// Mark that no environment is running on this CPU
	curenv = NULL;
  800420b3af:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420b3b6:	00 00 00 
  800420b3b9:	ff d0                	callq  *%rax
  800420b3bb:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420b3c2:	00 00 00 
  800420b3c5:	48 98                	cltq   
  800420b3c7:	48 c1 e0 03          	shl    $0x3,%rax
  800420b3cb:	48 89 c2             	mov    %rax,%rdx
  800420b3ce:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b3d2:	48 29 c2             	sub    %rax,%rdx
  800420b3d5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b3d9:	48 83 c0 08          	add    $0x8,%rax
  800420b3dd:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	lcr3(PADDR(boot_pml4e));
  800420b3e4:	48 b8 28 e7 49 04 80 	movabs $0x800449e728,%rax
  800420b3eb:	00 00 00 
  800420b3ee:	48 8b 00             	mov    (%rax),%rax
  800420b3f1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420b3f5:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420b3fc:	00 00 00 
  800420b3ff:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420b403:	77 32                	ja     800420b437 <sched_halt+0x171>
  800420b405:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b409:	48 89 c1             	mov    %rax,%rcx
  800420b40c:	48 ba d0 71 21 04 80 	movabs $0x80042171d0,%rdx
  800420b413:	00 00 00 
  800420b416:	be 46 00 00 00       	mov    $0x46,%esi
  800420b41b:	48 bf f4 71 21 04 80 	movabs $0x80042171f4,%rdi
  800420b422:	00 00 00 
  800420b425:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b42a:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420b431:	00 00 00 
  800420b434:	41 ff d0             	callq  *%r8
  800420b437:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420b43e:	ff ff ff 
  800420b441:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b445:	48 01 d0             	add    %rdx,%rax
  800420b448:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420b44c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b450:	0f 22 d8             	mov    %rax,%cr3

	// Mark that this CPU is in the HALT state, so that when
	// timer interupts come in, we know we should re-acquire the
	// big kernel lock
	xchg(&thiscpu->cpu_status, CPU_HALTED);
  800420b453:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420b45a:	00 00 00 
  800420b45d:	ff d0                	callq  *%rax
  800420b45f:	48 98                	cltq   
  800420b461:	48 c1 e0 03          	shl    $0x3,%rax
  800420b465:	48 89 c2             	mov    %rax,%rdx
  800420b468:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b46c:	48 29 c2             	sub    %rax,%rdx
  800420b46f:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  800420b476:	00 00 00 
  800420b479:	48 01 d0             	add    %rdx,%rax
  800420b47c:	48 83 c0 04          	add    $0x4,%rax
  800420b480:	be 02 00 00 00       	mov    $0x2,%esi
  800420b485:	48 89 c7             	mov    %rax,%rdi
  800420b488:	48 b8 7e b0 20 04 80 	movabs $0x800420b07e,%rax
  800420b48f:	00 00 00 
  800420b492:	ff d0                	callq  *%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();
  800420b494:	48 b8 a3 b0 20 04 80 	movabs $0x800420b0a3,%rax
  800420b49b:	00 00 00 
  800420b49e:	ff d0                	callq  *%rax
		"movq %0, %%rsp\n"
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
  800420b4a0:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420b4a7:	00 00 00 
  800420b4aa:	ff d0                	callq  *%rax
  800420b4ac:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420b4b3:	00 00 00 
  800420b4b6:	48 98                	cltq   
  800420b4b8:	48 c1 e0 03          	shl    $0x3,%rax
  800420b4bc:	48 89 c2             	mov    %rax,%rdx
  800420b4bf:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b4c3:	48 29 c2             	sub    %rax,%rdx
  800420b4c6:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b4ca:	48 83 c0 10          	add    $0x10,%rax
  800420b4ce:	48 8b 40 04          	mov    0x4(%rax),%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();

	// Reset stack pointer, enable interrupts and then halt.
	asm volatile (
  800420b4d2:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  800420b4d9:	48 89 c4             	mov    %rax,%rsp
  800420b4dc:	6a 00                	pushq  $0x0
  800420b4de:	6a 00                	pushq  $0x0
  800420b4e0:	fb                   	sti    
  800420b4e1:	f4                   	hlt    
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
}
  800420b4e2:	c9                   	leaveq 
  800420b4e3:	c3                   	retq   

000000800420b4e4 <sys_cputs>:
// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  800420b4e4:	55                   	push   %rbp
  800420b4e5:	48 89 e5             	mov    %rsp,%rbp
  800420b4e8:	48 83 ec 10          	sub    $0x10,%rsp
  800420b4ec:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420b4f0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.
	user_mem_assert(curenv, (const void*)s, len, PTE_P);
  800420b4f4:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420b4fb:	00 00 00 
  800420b4fe:	ff d0                	callq  *%rax
  800420b500:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420b507:	00 00 00 
  800420b50a:	48 98                	cltq   
  800420b50c:	48 c1 e0 03          	shl    $0x3,%rax
  800420b510:	48 89 c2             	mov    %rax,%rdx
  800420b513:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b517:	48 29 c2             	sub    %rax,%rdx
  800420b51a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b51e:	48 83 c0 08          	add    $0x8,%rax
  800420b522:	48 8b 00             	mov    (%rax),%rax
  800420b525:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420b529:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420b52d:	b9 01 00 00 00       	mov    $0x1,%ecx
  800420b532:	48 89 c7             	mov    %rax,%rdi
  800420b535:	48 b8 ba 40 20 04 80 	movabs $0x80042040ba,%rax
  800420b53c:	00 00 00 
  800420b53f:	ff d0                	callq  *%rax
	// Print the string supplied by the user.
	//extern pte_t* uvpt;
	//extern pte_t* uvpd;
	//cprintf("uvpt = %016x, uvpd = %016x\n", uvpt, uvpd);
	cprintf("%.*s", len, s);
  800420b541:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420b545:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b549:	48 89 c6             	mov    %rax,%rsi
  800420b54c:	48 bf 08 72 21 04 80 	movabs $0x8004217208,%rdi
  800420b553:	00 00 00 
  800420b556:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b55b:	48 b9 0e 92 20 04 80 	movabs $0x800420920e,%rcx
  800420b562:	00 00 00 
  800420b565:	ff d1                	callq  *%rcx
}
  800420b567:	c9                   	leaveq 
  800420b568:	c3                   	retq   

000000800420b569 <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  800420b569:	55                   	push   %rbp
  800420b56a:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  800420b56d:	48 b8 8b 10 20 04 80 	movabs $0x800420108b,%rax
  800420b574:	00 00 00 
  800420b577:	ff d0                	callq  *%rax
}
  800420b579:	5d                   	pop    %rbp
  800420b57a:	c3                   	retq   

000000800420b57b <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  800420b57b:	55                   	push   %rbp
  800420b57c:	48 89 e5             	mov    %rsp,%rbp
	return curenv->env_id;
  800420b57f:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420b586:	00 00 00 
  800420b589:	ff d0                	callq  *%rax
  800420b58b:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420b592:	00 00 00 
  800420b595:	48 98                	cltq   
  800420b597:	48 c1 e0 03          	shl    $0x3,%rax
  800420b59b:	48 89 c2             	mov    %rax,%rdx
  800420b59e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b5a2:	48 29 c2             	sub    %rax,%rdx
  800420b5a5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b5a9:	48 83 c0 08          	add    $0x8,%rax
  800420b5ad:	48 8b 00             	mov    (%rax),%rax
  800420b5b0:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420b5b6:	5d                   	pop    %rbp
  800420b5b7:	c3                   	retq   

000000800420b5b8 <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  800420b5b8:	55                   	push   %rbp
  800420b5b9:	48 89 e5             	mov    %rsp,%rbp
  800420b5bc:	48 83 ec 20          	sub    $0x20,%rsp
  800420b5c0:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420b5c3:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420b5c7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420b5ca:	ba 01 00 00 00       	mov    $0x1,%edx
  800420b5cf:	48 89 ce             	mov    %rcx,%rsi
  800420b5d2:	89 c7                	mov    %eax,%edi
  800420b5d4:	48 b8 5c 7d 20 04 80 	movabs $0x8004207d5c,%rax
  800420b5db:	00 00 00 
  800420b5de:	ff d0                	callq  *%rax
  800420b5e0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420b5e3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420b5e7:	79 05                	jns    800420b5ee <sys_env_destroy+0x36>
		return r;
  800420b5e9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420b5ec:	eb 18                	jmp    800420b606 <sys_env_destroy+0x4e>
 // if (e == curenv)
//			cprintf("[%08x] exiting gracefully\n", curenv->env_id);
//	else
//				cprintf("[%08x] destroying %08x\n", curenv->env_id, e->env_id);
	env_destroy(e);
  800420b5ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b5f2:	48 89 c7             	mov    %rax,%rdi
  800420b5f5:	48 b8 fb 8a 20 04 80 	movabs $0x8004208afb,%rax
  800420b5fc:	00 00 00 
  800420b5ff:	ff d0                	callq  *%rax
	return 0;
  800420b601:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420b606:	c9                   	leaveq 
  800420b607:	c3                   	retq   

000000800420b608 <sys_yield>:

// Deschedule current environment and pick a different one to run.
static void
sys_yield(void)
{
  800420b608:	55                   	push   %rbp
  800420b609:	48 89 e5             	mov    %rsp,%rbp
	sched_yield();
  800420b60c:	48 b8 c1 b0 20 04 80 	movabs $0x800420b0c1,%rax
  800420b613:	00 00 00 
  800420b616:	ff d0                	callq  *%rax

000000800420b618 <sys_exofork>:
// Returns envid of new environment, or < 0 on error.  Errors are:
//	-E_NO_FREE_ENV if no free environment is available.
//	-E_NO_MEM on memory exhaustion.
static envid_t
sys_exofork(void)
{
  800420b618:	55                   	push   %rbp
  800420b619:	48 89 e5             	mov    %rsp,%rbp
  800420b61c:	53                   	push   %rbx
  800420b61d:	48 83 ec 18          	sub    $0x18,%rsp

	// LAB 4: Your code here.
	struct Env *child;
	//cprintf("free=%d\n", free_num());
	//cprintf("freelist = %016x\n", env_free_list);
	int result = env_alloc(&child, curenv->env_id);
  800420b621:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420b628:	00 00 00 
  800420b62b:	ff d0                	callq  *%rax
  800420b62d:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420b634:	00 00 00 
  800420b637:	48 98                	cltq   
  800420b639:	48 c1 e0 03          	shl    $0x3,%rax
  800420b63d:	48 89 c2             	mov    %rax,%rdx
  800420b640:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b644:	48 29 c2             	sub    %rax,%rdx
  800420b647:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b64b:	48 83 c0 08          	add    $0x8,%rax
  800420b64f:	48 8b 00             	mov    (%rax),%rax
  800420b652:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420b658:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420b65c:	89 d6                	mov    %edx,%esi
  800420b65e:	48 89 c7             	mov    %rax,%rdi
  800420b661:	48 b8 29 81 20 04 80 	movabs $0x8004208129,%rax
  800420b668:	00 00 00 
  800420b66b:	ff d0                	callq  *%rax
  800420b66d:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if(result < 0) {
  800420b670:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420b674:	79 05                	jns    800420b67b <sys_exofork+0x63>
//		cprintf("result = %d\n", result);
		return result;
  800420b676:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420b679:	eb 6d                	jmp    800420b6e8 <sys_exofork+0xd0>
	}
	child->env_status = ENV_NOT_RUNNABLE;
  800420b67b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420b67f:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420b686:	00 00 00 
	child->env_tf = curenv->env_tf;
  800420b689:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420b68d:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420b694:	00 00 00 
  800420b697:	ff d0                	callq  *%rax
  800420b699:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420b6a0:	00 00 00 
  800420b6a3:	48 98                	cltq   
  800420b6a5:	48 c1 e0 03          	shl    $0x3,%rax
  800420b6a9:	48 89 c2             	mov    %rax,%rdx
  800420b6ac:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b6b0:	48 29 c2             	sub    %rax,%rdx
  800420b6b3:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b6b7:	48 83 c0 08          	add    $0x8,%rax
  800420b6bb:	48 8b 00             	mov    (%rax),%rax
  800420b6be:	48 89 da             	mov    %rbx,%rdx
  800420b6c1:	48 89 c6             	mov    %rax,%rsi
  800420b6c4:	b8 18 00 00 00       	mov    $0x18,%eax
  800420b6c9:	48 89 d7             	mov    %rdx,%rdi
  800420b6cc:	48 89 c1             	mov    %rax,%rcx
  800420b6cf:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	child->env_tf.tf_regs.reg_rax = 0;
  800420b6d2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420b6d6:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420b6dd:	00 
	return child->env_id;
  800420b6de:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420b6e2:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
	//panic("sys_exofork not implemented");
}
  800420b6e8:	48 83 c4 18          	add    $0x18,%rsp
  800420b6ec:	5b                   	pop    %rbx
  800420b6ed:	5d                   	pop    %rbp
  800420b6ee:	c3                   	retq   

000000800420b6ef <sys_env_set_status>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
  800420b6ef:	55                   	push   %rbp
  800420b6f0:	48 89 e5             	mov    %rsp,%rbp
  800420b6f3:	48 83 ec 20          	sub    $0x20,%rsp
  800420b6f7:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420b6fa:	89 75 e8             	mov    %esi,-0x18(%rbp)
	// envid's status.

	// LAB 4: Your code here.
	//panic("sys_env_set_status not implemented");
	struct Env* env;
	int result = envid2env(envid, &env, 1);
  800420b6fd:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420b701:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420b704:	ba 01 00 00 00       	mov    $0x1,%edx
  800420b709:	48 89 ce             	mov    %rcx,%rsi
  800420b70c:	89 c7                	mov    %eax,%edi
  800420b70e:	48 b8 5c 7d 20 04 80 	movabs $0x8004207d5c,%rax
  800420b715:	00 00 00 
  800420b718:	ff d0                	callq  *%rax
  800420b71a:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(result < 0) return result;
  800420b71d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420b721:	79 05                	jns    800420b728 <sys_env_set_status+0x39>
  800420b723:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420b726:	eb 25                	jmp    800420b74d <sys_env_set_status+0x5e>
	if(status != ENV_RUNNABLE && status != ENV_NOT_RUNNABLE) return -E_INVAL;
  800420b728:	83 7d e8 02          	cmpl   $0x2,-0x18(%rbp)
  800420b72c:	74 0d                	je     800420b73b <sys_env_set_status+0x4c>
  800420b72e:	83 7d e8 04          	cmpl   $0x4,-0x18(%rbp)
  800420b732:	74 07                	je     800420b73b <sys_env_set_status+0x4c>
  800420b734:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420b739:	eb 12                	jmp    800420b74d <sys_env_set_status+0x5e>
	env->env_status = status;
  800420b73b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b73f:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420b742:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
	return 0;
  800420b748:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420b74d:	c9                   	leaveq 
  800420b74e:	c3                   	retq   

000000800420b74f <sys_env_set_trapframe>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  800420b74f:	55                   	push   %rbp
  800420b750:	48 89 e5             	mov    %rsp,%rbp
  800420b753:	48 83 ec 20          	sub    $0x20,%rsp
  800420b757:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420b75a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// LAB 5: Your code here.
	// Remember to check whether the user has supplied us with a good
	// address!
	struct Env* env;
	int result = envid2env(envid, &env, 1);
  800420b75e:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420b762:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420b765:	ba 01 00 00 00       	mov    $0x1,%edx
  800420b76a:	48 89 ce             	mov    %rcx,%rsi
  800420b76d:	89 c7                	mov    %eax,%edi
  800420b76f:	48 b8 5c 7d 20 04 80 	movabs $0x8004207d5c,%rax
  800420b776:	00 00 00 
  800420b779:	ff d0                	callq  *%rax
  800420b77b:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(result < 0) return result;
  800420b77e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420b782:	79 05                	jns    800420b789 <sys_env_set_trapframe+0x3a>
  800420b784:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420b787:	eb 1e                	jmp    800420b7a7 <sys_env_set_trapframe+0x58>
	env->env_tf = *tf;
  800420b789:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420b78d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420b791:	48 89 c6             	mov    %rax,%rsi
  800420b794:	b8 18 00 00 00       	mov    $0x18,%eax
  800420b799:	48 89 d7             	mov    %rdx,%rdi
  800420b79c:	48 89 c1             	mov    %rax,%rcx
  800420b79f:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	return 0;
  800420b7a2:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_env_set_trapframe not implemented");
}
  800420b7a7:	c9                   	leaveq 
  800420b7a8:	c3                   	retq   

000000800420b7a9 <sys_env_set_pgfault_upcall>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
  800420b7a9:	55                   	push   %rbp
  800420b7aa:	48 89 e5             	mov    %rsp,%rbp
  800420b7ad:	48 83 ec 20          	sub    $0x20,%rsp
  800420b7b1:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420b7b4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// LAB 4: Your code here.
	//panic("sys_env_set_pgfault_upcall not implemented");
	struct Env* env;
	int result = envid2env(envid, &env, 1);
  800420b7b8:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420b7bc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420b7bf:	ba 01 00 00 00       	mov    $0x1,%edx
  800420b7c4:	48 89 ce             	mov    %rcx,%rsi
  800420b7c7:	89 c7                	mov    %eax,%edi
  800420b7c9:	48 b8 5c 7d 20 04 80 	movabs $0x8004207d5c,%rax
  800420b7d0:	00 00 00 
  800420b7d3:	ff d0                	callq  *%rax
  800420b7d5:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(result < 0) return result;
  800420b7d8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420b7dc:	79 05                	jns    800420b7e3 <sys_env_set_pgfault_upcall+0x3a>
  800420b7de:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420b7e1:	eb 14                	jmp    800420b7f7 <sys_env_set_pgfault_upcall+0x4e>
	env->env_pgfault_upcall = func;
  800420b7e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420b7e7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420b7eb:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)
	return 0;
  800420b7f2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420b7f7:	c9                   	leaveq 
  800420b7f8:	c3                   	retq   

000000800420b7f9 <sys_page_alloc>:
//	-E_INVAL if perm is inappropriate (see above).
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  800420b7f9:	55                   	push   %rbp
  800420b7fa:	48 89 e5             	mov    %rsp,%rbp
  800420b7fd:	48 83 ec 30          	sub    $0x30,%rsp
  800420b801:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420b804:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420b808:	89 55 d8             	mov    %edx,-0x28(%rbp)
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	// LAB 4: Your code here.
	struct Env* env;
	int result = envid2env(envid, &env, 1);
  800420b80b:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420b80f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420b812:	ba 01 00 00 00       	mov    $0x1,%edx
  800420b817:	48 89 ce             	mov    %rcx,%rsi
  800420b81a:	89 c7                	mov    %eax,%edi
  800420b81c:	48 b8 5c 7d 20 04 80 	movabs $0x8004207d5c,%rax
  800420b823:	00 00 00 
  800420b826:	ff d0                	callq  *%rax
  800420b828:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(result < 0) return result;
  800420b82b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420b82f:	79 08                	jns    800420b839 <sys_page_alloc+0x40>
  800420b831:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420b834:	e9 90 00 00 00       	jmpq   800420b8c9 <sys_page_alloc+0xd0>
	if((uintptr_t)va >= UTOP || PGOFF(va) || !(perm & PTE_U) || !(perm & PTE_P) || (perm & ~PTE_SYSCALL)) return -E_INVAL;
  800420b839:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420b83d:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420b844:	00 00 00 
  800420b847:	48 39 c2             	cmp    %rax,%rdx
  800420b84a:	77 2e                	ja     800420b87a <sys_page_alloc+0x81>
  800420b84c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420b850:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420b855:	48 85 c0             	test   %rax,%rax
  800420b858:	75 20                	jne    800420b87a <sys_page_alloc+0x81>
  800420b85a:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420b85d:	83 e0 04             	and    $0x4,%eax
  800420b860:	85 c0                	test   %eax,%eax
  800420b862:	74 16                	je     800420b87a <sys_page_alloc+0x81>
  800420b864:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420b867:	83 e0 01             	and    $0x1,%eax
  800420b86a:	85 c0                	test   %eax,%eax
  800420b86c:	74 0c                	je     800420b87a <sys_page_alloc+0x81>
  800420b86e:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420b871:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420b876:	85 c0                	test   %eax,%eax
  800420b878:	74 07                	je     800420b881 <sys_page_alloc+0x88>
  800420b87a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420b87f:	eb 48                	jmp    800420b8c9 <sys_page_alloc+0xd0>
	struct PageInfo *page = page_alloc(ALLOC_ZERO);
  800420b881:	bf 01 00 00 00       	mov    $0x1,%edi
  800420b886:	48 b8 f4 34 20 04 80 	movabs $0x80042034f4,%rax
  800420b88d:	00 00 00 
  800420b890:	ff d0                	callq  *%rax
  800420b892:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	return page ? page_insert(env->env_pml4e, page, va, perm) : -E_NO_MEM;
  800420b896:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420b89b:	74 27                	je     800420b8c4 <sys_page_alloc+0xcb>
  800420b89d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b8a1:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420b8a8:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  800420b8ab:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420b8af:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420b8b3:	48 89 c7             	mov    %rax,%rdi
  800420b8b6:	48 b8 b4 3b 20 04 80 	movabs $0x8004203bb4,%rax
  800420b8bd:	00 00 00 
  800420b8c0:	ff d0                	callq  *%rax
  800420b8c2:	eb 05                	jmp    800420b8c9 <sys_page_alloc+0xd0>
  800420b8c4:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
	//panic("sys_page_alloc not implemented");
}
  800420b8c9:	c9                   	leaveq 
  800420b8ca:	c3                   	retq   

000000800420b8cb <sys_page_map>:
//		address space.
//	-E_NO_MEM if there's no memory to allocate any necessary page tables.
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
  800420b8cb:	55                   	push   %rbp
  800420b8cc:	48 89 e5             	mov    %rsp,%rbp
  800420b8cf:	53                   	push   %rbx
  800420b8d0:	48 83 ec 58          	sub    $0x58,%rsp
  800420b8d4:	89 7d bc             	mov    %edi,-0x44(%rbp)
  800420b8d7:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800420b8db:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420b8de:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  800420b8e2:	44 89 45 a4          	mov    %r8d,-0x5c(%rbp)
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	//panic("sys_page_map not implemented");
	struct Env *src, *dst;
	int result = envid2env(srcenvid, &src, 1) |	envid2env(dstenvid, &dst, 1);
  800420b8e6:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800420b8ea:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420b8ed:	ba 01 00 00 00       	mov    $0x1,%edx
  800420b8f2:	48 89 ce             	mov    %rcx,%rsi
  800420b8f5:	89 c7                	mov    %eax,%edi
  800420b8f7:	48 b8 5c 7d 20 04 80 	movabs $0x8004207d5c,%rax
  800420b8fe:	00 00 00 
  800420b901:	ff d0                	callq  *%rax
  800420b903:	89 c3                	mov    %eax,%ebx
  800420b905:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
  800420b909:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420b90c:	ba 01 00 00 00       	mov    $0x1,%edx
  800420b911:	48 89 ce             	mov    %rcx,%rsi
  800420b914:	89 c7                	mov    %eax,%edi
  800420b916:	48 b8 5c 7d 20 04 80 	movabs $0x8004207d5c,%rax
  800420b91d:	00 00 00 
  800420b920:	ff d0                	callq  *%rax
  800420b922:	09 d8                	or     %ebx,%eax
  800420b924:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if(result < 0) return result;
  800420b927:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420b92b:	79 08                	jns    800420b935 <sys_page_map+0x6a>
  800420b92d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420b930:	e9 e4 00 00 00       	jmpq   800420ba19 <sys_page_map+0x14e>
	if((uintptr_t)srcva >= UTOP || PGOFF(srcva) ||
  800420b935:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420b939:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420b940:	00 00 00 
  800420b943:	48 39 c2             	cmp    %rax,%rdx
  800420b946:	77 4f                	ja     800420b997 <sys_page_map+0xcc>
  800420b948:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420b94c:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420b951:	48 85 c0             	test   %rax,%rax
  800420b954:	75 41                	jne    800420b997 <sys_page_map+0xcc>
		 (uintptr_t)dstva >= UTOP || PGOFF(dstva) ||
  800420b956:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
	// LAB 4: Your code here.
	//panic("sys_page_map not implemented");
	struct Env *src, *dst;
	int result = envid2env(srcenvid, &src, 1) |	envid2env(dstenvid, &dst, 1);
	if(result < 0) return result;
	if((uintptr_t)srcva >= UTOP || PGOFF(srcva) ||
  800420b95a:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420b961:	00 00 00 
  800420b964:	48 39 c2             	cmp    %rax,%rdx
  800420b967:	77 2e                	ja     800420b997 <sys_page_map+0xcc>
		 (uintptr_t)dstva >= UTOP || PGOFF(dstva) ||
  800420b969:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420b96d:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420b972:	48 85 c0             	test   %rax,%rax
  800420b975:	75 20                	jne    800420b997 <sys_page_map+0xcc>
     !(perm & PTE_U) || !(perm & PTE_P) || (perm & ~PTE_SYSCALL)) return -E_INVAL;
  800420b977:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800420b97a:	83 e0 04             	and    $0x4,%eax
	//panic("sys_page_map not implemented");
	struct Env *src, *dst;
	int result = envid2env(srcenvid, &src, 1) |	envid2env(dstenvid, &dst, 1);
	if(result < 0) return result;
	if((uintptr_t)srcva >= UTOP || PGOFF(srcva) ||
		 (uintptr_t)dstva >= UTOP || PGOFF(dstva) ||
  800420b97d:	85 c0                	test   %eax,%eax
  800420b97f:	74 16                	je     800420b997 <sys_page_map+0xcc>
     !(perm & PTE_U) || !(perm & PTE_P) || (perm & ~PTE_SYSCALL)) return -E_INVAL;
  800420b981:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800420b984:	83 e0 01             	and    $0x1,%eax
  800420b987:	85 c0                	test   %eax,%eax
  800420b989:	74 0c                	je     800420b997 <sys_page_map+0xcc>
  800420b98b:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800420b98e:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420b993:	85 c0                	test   %eax,%eax
  800420b995:	74 07                	je     800420b99e <sys_page_map+0xd3>
  800420b997:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420b99c:	eb 7b                	jmp    800420ba19 <sys_page_map+0x14e>
	pte_t *entry;
	struct PageInfo* page = page_lookup(src->env_pml4e, srcva, &entry);
  800420b99e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420b9a2:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420b9a9:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  800420b9ad:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800420b9b1:	48 89 ce             	mov    %rcx,%rsi
  800420b9b4:	48 89 c7             	mov    %rax,%rdi
  800420b9b7:	48 b8 e0 3c 20 04 80 	movabs $0x8004203ce0,%rax
  800420b9be:	00 00 00 
  800420b9c1:	ff d0                	callq  *%rax
  800420b9c3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if(!page || ((perm & PTE_W) && !(*entry & PTE_W))) return -E_INVAL;
  800420b9c7:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420b9cc:	74 19                	je     800420b9e7 <sys_page_map+0x11c>
  800420b9ce:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800420b9d1:	83 e0 02             	and    $0x2,%eax
  800420b9d4:	85 c0                	test   %eax,%eax
  800420b9d6:	74 16                	je     800420b9ee <sys_page_map+0x123>
  800420b9d8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420b9dc:	48 8b 00             	mov    (%rax),%rax
  800420b9df:	83 e0 02             	and    $0x2,%eax
  800420b9e2:	48 85 c0             	test   %rax,%rax
  800420b9e5:	75 07                	jne    800420b9ee <sys_page_map+0x123>
  800420b9e7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420b9ec:	eb 2b                	jmp    800420ba19 <sys_page_map+0x14e>
	int r = page_insert(dst->env_pml4e, page, dstva, perm);
  800420b9ee:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b9f2:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420b9f9:	8b 4d a4             	mov    -0x5c(%rbp),%ecx
  800420b9fc:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420ba00:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420ba04:	48 89 c7             	mov    %rax,%rdi
  800420ba07:	48 b8 b4 3b 20 04 80 	movabs $0x8004203bb4,%rax
  800420ba0e:	00 00 00 
  800420ba11:	ff d0                	callq  *%rax
  800420ba13:	89 45 dc             	mov    %eax,-0x24(%rbp)
	return r;
  800420ba16:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  800420ba19:	48 83 c4 58          	add    $0x58,%rsp
  800420ba1d:	5b                   	pop    %rbx
  800420ba1e:	5d                   	pop    %rbp
  800420ba1f:	c3                   	retq   

000000800420ba20 <sys_page_unmap>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int
sys_page_unmap(envid_t envid, void *va)
{
  800420ba20:	55                   	push   %rbp
  800420ba21:	48 89 e5             	mov    %rsp,%rbp
  800420ba24:	48 83 ec 20          	sub    $0x20,%rsp
  800420ba28:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420ba2b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	//panic("sys_page_unmap not implemented");
	struct Env* env;
	int result = envid2env(envid, &env, 1);
  800420ba2f:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420ba33:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ba36:	ba 01 00 00 00       	mov    $0x1,%edx
  800420ba3b:	48 89 ce             	mov    %rcx,%rsi
  800420ba3e:	89 c7                	mov    %eax,%edi
  800420ba40:	48 b8 5c 7d 20 04 80 	movabs $0x8004207d5c,%rax
  800420ba47:	00 00 00 
  800420ba4a:	ff d0                	callq  *%rax
  800420ba4c:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(result < 0) return result;
  800420ba4f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420ba53:	79 05                	jns    800420ba5a <sys_page_unmap+0x3a>
  800420ba55:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420ba58:	eb 4e                	jmp    800420baa8 <sys_page_unmap+0x88>
	if((uintptr_t)va >= UTOP ||	PGOFF(va)) return -E_INVAL;
  800420ba5a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420ba5e:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420ba65:	00 00 00 
  800420ba68:	48 39 c2             	cmp    %rax,%rdx
  800420ba6b:	77 0e                	ja     800420ba7b <sys_page_unmap+0x5b>
  800420ba6d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ba71:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420ba76:	48 85 c0             	test   %rax,%rax
  800420ba79:	74 07                	je     800420ba82 <sys_page_unmap+0x62>
  800420ba7b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ba80:	eb 26                	jmp    800420baa8 <sys_page_unmap+0x88>
	page_remove(env->env_pml4e, va);
  800420ba82:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ba86:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420ba8d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420ba91:	48 89 d6             	mov    %rdx,%rsi
  800420ba94:	48 89 c7             	mov    %rax,%rdi
  800420ba97:	48 b8 64 3d 20 04 80 	movabs $0x8004203d64,%rax
  800420ba9e:	00 00 00 
  800420baa1:	ff d0                	callq  *%rax
	return 0;
  800420baa3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420baa8:	c9                   	leaveq 
  800420baa9:	c3                   	retq   

000000800420baaa <sys_ipc_try_send>:
//		current environment's address space.
//	-E_NO_MEM if there's not enough memory to map srcva in envid's
//		address space.
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
  800420baaa:	55                   	push   %rbp
  800420baab:	48 89 e5             	mov    %rsp,%rbp
  800420baae:	53                   	push   %rbx
  800420baaf:	48 83 ec 58          	sub    $0x58,%rsp
  800420bab3:	89 7d bc             	mov    %edi,-0x44(%rbp)
  800420bab6:	89 75 b8             	mov    %esi,-0x48(%rbp)
  800420bab9:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420babd:	89 4d ac             	mov    %ecx,-0x54(%rbp)
		// LAB 4: Your code here.
		//panic("sys_ipc_try_send not implemented");

	//cprintf("result \n");
	struct Env* env;
	int result = envid2env(envid, &env, 0);
  800420bac0:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800420bac4:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420bac7:	ba 00 00 00 00       	mov    $0x0,%edx
  800420bacc:	48 89 ce             	mov    %rcx,%rsi
  800420bacf:	89 c7                	mov    %eax,%edi
  800420bad1:	48 b8 5c 7d 20 04 80 	movabs $0x8004207d5c,%rax
  800420bad8:	00 00 00 
  800420badb:	ff d0                	callq  *%rax
  800420badd:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if(result < 0) return result;
  800420bae0:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420bae4:	79 08                	jns    800420baee <sys_ipc_try_send+0x44>
  800420bae6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420bae9:	e9 ed 01 00 00       	jmpq   800420bcdb <sys_ipc_try_send+0x231>
	if(!(env->env_ipc_recving)) return -E_IPC_NOT_RECV;
  800420baee:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420baf2:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420baf9:	83 f0 01             	xor    $0x1,%eax
  800420bafc:	84 c0                	test   %al,%al
  800420bafe:	74 0a                	je     800420bb0a <sys_ipc_try_send+0x60>
  800420bb00:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  800420bb05:	e9 d1 01 00 00       	jmpq   800420bcdb <sys_ipc_try_send+0x231>
	void* dstva = env->env_ipc_dstva;
  800420bb0a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420bb0e:	48 8b 80 00 01 00 00 	mov    0x100(%rax),%rax
  800420bb15:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	env->env_ipc_recving = 0;
  800420bb19:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420bb1d:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)
	env->env_ipc_perm = 0;
  800420bb24:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420bb28:	c7 80 10 01 00 00 00 	movl   $0x0,0x110(%rax)
  800420bb2f:	00 00 00 
	if((uintptr_t)srcva < UTOP && (uintptr_t)dstva < UTOP){
  800420bb32:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420bb36:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420bb3d:	00 00 00 
  800420bb40:	48 39 c2             	cmp    %rax,%rdx
  800420bb43:	0f 87 25 01 00 00    	ja     800420bc6e <sys_ipc_try_send+0x1c4>
  800420bb49:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420bb4d:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420bb54:	00 00 00 
  800420bb57:	48 39 c2             	cmp    %rax,%rdx
  800420bb5a:	0f 87 0e 01 00 00    	ja     800420bc6e <sys_ipc_try_send+0x1c4>
		if(PGOFF(srcva) || PGOFF(dstva) || !(perm & PTE_U) || !(perm & PTE_P) || (perm & ~PTE_SYSCALL))	return -E_INVAL;
  800420bb60:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420bb64:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420bb69:	48 85 c0             	test   %rax,%rax
  800420bb6c:	75 2e                	jne    800420bb9c <sys_ipc_try_send+0xf2>
  800420bb6e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420bb72:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420bb77:	48 85 c0             	test   %rax,%rax
  800420bb7a:	75 20                	jne    800420bb9c <sys_ipc_try_send+0xf2>
  800420bb7c:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800420bb7f:	83 e0 04             	and    $0x4,%eax
  800420bb82:	85 c0                	test   %eax,%eax
  800420bb84:	74 16                	je     800420bb9c <sys_ipc_try_send+0xf2>
  800420bb86:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800420bb89:	83 e0 01             	and    $0x1,%eax
  800420bb8c:	85 c0                	test   %eax,%eax
  800420bb8e:	74 0c                	je     800420bb9c <sys_ipc_try_send+0xf2>
  800420bb90:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800420bb93:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420bb98:	85 c0                	test   %eax,%eax
  800420bb9a:	74 0a                	je     800420bba6 <sys_ipc_try_send+0xfc>
  800420bb9c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420bba1:	e9 35 01 00 00       	jmpq   800420bcdb <sys_ipc_try_send+0x231>
		pte_t* pte;
		struct PageInfo* page = page_lookup(curenv->env_pml4e, srcva, &pte);
  800420bba6:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420bbad:	00 00 00 
  800420bbb0:	ff d0                	callq  *%rax
  800420bbb2:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420bbb9:	00 00 00 
  800420bbbc:	48 98                	cltq   
  800420bbbe:	48 c1 e0 03          	shl    $0x3,%rax
  800420bbc2:	48 89 c2             	mov    %rax,%rdx
  800420bbc5:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bbc9:	48 29 c2             	sub    %rax,%rdx
  800420bbcc:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bbd0:	48 83 c0 08          	add    $0x8,%rax
  800420bbd4:	48 8b 00             	mov    (%rax),%rax
  800420bbd7:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420bbde:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  800420bbe2:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800420bbe6:	48 89 ce             	mov    %rcx,%rsi
  800420bbe9:	48 89 c7             	mov    %rax,%rdi
  800420bbec:	48 b8 e0 3c 20 04 80 	movabs $0x8004203ce0,%rax
  800420bbf3:	00 00 00 
  800420bbf6:	ff d0                	callq  *%rax
  800420bbf8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		if(!page || (!(*pte & PTE_W) && (perm & PTE_W))) {
  800420bbfc:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420bc01:	74 19                	je     800420bc1c <sys_ipc_try_send+0x172>
  800420bc03:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bc07:	48 8b 00             	mov    (%rax),%rax
  800420bc0a:	83 e0 02             	and    $0x2,%eax
  800420bc0d:	48 85 c0             	test   %rax,%rax
  800420bc10:	75 1f                	jne    800420bc31 <sys_ipc_try_send+0x187>
  800420bc12:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800420bc15:	83 e0 02             	and    $0x2,%eax
  800420bc18:	85 c0                	test   %eax,%eax
  800420bc1a:	74 15                	je     800420bc31 <sys_ipc_try_send+0x187>
			env->env_ipc_recving = 1;
  800420bc1c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420bc20:	c6 80 f8 00 00 00 01 	movb   $0x1,0xf8(%rax)
			return -E_INVAL;
  800420bc27:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420bc2c:	e9 aa 00 00 00       	jmpq   800420bcdb <sys_ipc_try_send+0x231>
		}
		if(page_insert(env->env_pml4e, page, dstva, perm)) return -E_NO_MEM;
  800420bc31:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  800420bc34:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420bc38:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420bc3f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420bc43:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420bc47:	48 89 c7             	mov    %rax,%rdi
  800420bc4a:	48 b8 b4 3b 20 04 80 	movabs $0x8004203bb4,%rax
  800420bc51:	00 00 00 
  800420bc54:	ff d0                	callq  *%rax
  800420bc56:	85 c0                	test   %eax,%eax
  800420bc58:	74 07                	je     800420bc61 <sys_ipc_try_send+0x1b7>
  800420bc5a:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420bc5f:	eb 7a                	jmp    800420bcdb <sys_ipc_try_send+0x231>
		env->env_ipc_perm = perm;
  800420bc61:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420bc65:	8b 55 ac             	mov    -0x54(%rbp),%edx
  800420bc68:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
	}
	env->env_ipc_value = value;
  800420bc6e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420bc72:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420bc75:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
	env->env_ipc_from = curenv->env_id;
  800420bc7b:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
  800420bc7f:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420bc86:	00 00 00 
  800420bc89:	ff d0                	callq  *%rax
  800420bc8b:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420bc92:	00 00 00 
  800420bc95:	48 98                	cltq   
  800420bc97:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc9b:	48 89 c2             	mov    %rax,%rdx
  800420bc9e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bca2:	48 29 c2             	sub    %rax,%rdx
  800420bca5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bca9:	48 83 c0 08          	add    $0x8,%rax
  800420bcad:	48 8b 00             	mov    (%rax),%rax
  800420bcb0:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420bcb6:	89 83 0c 01 00 00    	mov    %eax,0x10c(%rbx)
	env->env_tf.tf_regs.reg_rax = 0;
  800420bcbc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420bcc0:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420bcc7:	00 
	env->env_status = ENV_RUNNABLE;
  800420bcc8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420bccc:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420bcd3:	00 00 00 
	return 0;
  800420bcd6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420bcdb:	48 83 c4 58          	add    $0x58,%rsp
  800420bcdf:	5b                   	pop    %rbx
  800420bce0:	5d                   	pop    %rbp
  800420bce1:	c3                   	retq   

000000800420bce2 <sys_ipc_recv>:
// return 0 on success.
// Return < 0 on error.  Errors are:
//	-E_INVAL if dstva < UTOP but dstva is not page-aligned.
static int
sys_ipc_recv(void *dstva)
{
  800420bce2:	55                   	push   %rbp
  800420bce3:	48 89 e5             	mov    %rsp,%rbp
  800420bce6:	48 83 ec 10          	sub    $0x10,%rsp
  800420bcea:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// LAB 4: Your code here.
	if((uintptr_t)dstva < UTOP && PGOFF(dstva)) return -E_INVAL;
  800420bcee:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420bcf2:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420bcf9:	00 00 00 
  800420bcfc:	48 39 c2             	cmp    %rax,%rdx
  800420bcff:	77 18                	ja     800420bd19 <sys_ipc_recv+0x37>
  800420bd01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420bd05:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420bd0a:	48 85 c0             	test   %rax,%rax
  800420bd0d:	74 0a                	je     800420bd19 <sys_ipc_recv+0x37>
  800420bd0f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420bd14:	e9 bb 00 00 00       	jmpq   800420bdd4 <sys_ipc_recv+0xf2>
	curenv->env_ipc_recving = 1;
  800420bd19:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420bd20:	00 00 00 
  800420bd23:	ff d0                	callq  *%rax
  800420bd25:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420bd2c:	00 00 00 
  800420bd2f:	48 98                	cltq   
  800420bd31:	48 c1 e0 03          	shl    $0x3,%rax
  800420bd35:	48 89 c2             	mov    %rax,%rdx
  800420bd38:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bd3c:	48 29 c2             	sub    %rax,%rdx
  800420bd3f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bd43:	48 83 c0 08          	add    $0x8,%rax
  800420bd47:	48 8b 00             	mov    (%rax),%rax
  800420bd4a:	c6 80 f8 00 00 00 01 	movb   $0x1,0xf8(%rax)
	curenv->env_ipc_dstva = dstva;
  800420bd51:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420bd58:	00 00 00 
  800420bd5b:	ff d0                	callq  *%rax
  800420bd5d:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420bd64:	00 00 00 
  800420bd67:	48 98                	cltq   
  800420bd69:	48 c1 e0 03          	shl    $0x3,%rax
  800420bd6d:	48 89 c2             	mov    %rax,%rdx
  800420bd70:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bd74:	48 29 c2             	sub    %rax,%rdx
  800420bd77:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bd7b:	48 83 c0 08          	add    $0x8,%rax
  800420bd7f:	48 8b 00             	mov    (%rax),%rax
  800420bd82:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420bd86:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)
	curenv->env_status = ENV_NOT_RUNNABLE;
  800420bd8d:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420bd94:	00 00 00 
  800420bd97:	ff d0                	callq  *%rax
  800420bd99:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420bda0:	00 00 00 
  800420bda3:	48 98                	cltq   
  800420bda5:	48 c1 e0 03          	shl    $0x3,%rax
  800420bda9:	48 89 c2             	mov    %rax,%rdx
  800420bdac:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bdb0:	48 29 c2             	sub    %rax,%rdx
  800420bdb3:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bdb7:	48 83 c0 08          	add    $0x8,%rax
  800420bdbb:	48 8b 00             	mov    (%rax),%rax
  800420bdbe:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420bdc5:	00 00 00 
	sched_yield();
  800420bdc8:	48 b8 c1 b0 20 04 80 	movabs $0x800420b0c1,%rax
  800420bdcf:	00 00 00 
  800420bdd2:	ff d0                	callq  *%rax
	//panic("sys_ipc_recv not implemented");
	return 0;
}
  800420bdd4:	c9                   	leaveq 
  800420bdd5:	c3                   	retq   

000000800420bdd6 <syscall>:


// Dispatches to the correct kernel function, passing the arguments.
int64_t
syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420bdd6:	55                   	push   %rbp
  800420bdd7:	48 89 e5             	mov    %rsp,%rbp
  800420bdda:	48 83 ec 30          	sub    $0x30,%rsp
  800420bdde:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420bde2:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420bde6:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420bdea:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420bdee:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  800420bdf2:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
	/*uint64_t rdi, rsi, rdx;
	asm volatile("mov %%rdi, %0":"=r"(rdi));
	asm volatile("mov %%rsi, %0":"=r"(rsi));
	asm volatile("mov %%rdx, %0":"=r"(rdx));
	cprintf("rdi = %016x, sysno = %d\n", rdi, syscallno);*/
	if(syscallno >= NSYSCALLS) return -E_INVAL;
  800420bdf6:	48 83 7d f8 0d       	cmpq   $0xd,-0x8(%rbp)
  800420bdfb:	76 0c                	jbe    800420be09 <syscall+0x33>
  800420bdfd:	48 c7 c0 fd ff ff ff 	mov    $0xfffffffffffffffd,%rax
  800420be04:	e9 c7 01 00 00       	jmpq   800420bfd0 <syscall+0x1fa>
	/*cprintf("a1 = %016x, a2 = %d\n", a1, a2);
	cprintf("rsi = %016x, rdx = %d\n", rsi, rdx);*/
	switch (syscallno) {
  800420be09:	48 83 7d f8 0d       	cmpq   $0xd,-0x8(%rbp)
  800420be0e:	0f 87 b5 01 00 00    	ja     800420bfc9 <syscall+0x1f3>
  800420be14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420be18:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420be1f:	00 
  800420be20:	48 b8 10 72 21 04 80 	movabs $0x8004217210,%rax
  800420be27:	00 00 00 
  800420be2a:	48 01 d0             	add    %rdx,%rax
  800420be2d:	48 8b 00             	mov    (%rax),%rax
  800420be30:	ff e0                	jmpq   *%rax
		case SYS_cputs:
			sys_cputs((const char*) a1, a2);
  800420be32:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420be36:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420be3a:	48 89 d6             	mov    %rdx,%rsi
  800420be3d:	48 89 c7             	mov    %rax,%rdi
  800420be40:	48 b8 e4 b4 20 04 80 	movabs $0x800420b4e4,%rax
  800420be47:	00 00 00 
  800420be4a:	ff d0                	callq  *%rax
			return 0;
  800420be4c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420be51:	e9 7a 01 00 00       	jmpq   800420bfd0 <syscall+0x1fa>
		case SYS_cgetc:
			return sys_cgetc();
  800420be56:	48 b8 69 b5 20 04 80 	movabs $0x800420b569,%rax
  800420be5d:	00 00 00 
  800420be60:	ff d0                	callq  *%rax
  800420be62:	48 98                	cltq   
  800420be64:	e9 67 01 00 00       	jmpq   800420bfd0 <syscall+0x1fa>
		case SYS_getenvid:
			return sys_getenvid();
  800420be69:	48 b8 7b b5 20 04 80 	movabs $0x800420b57b,%rax
  800420be70:	00 00 00 
  800420be73:	ff d0                	callq  *%rax
  800420be75:	48 98                	cltq   
  800420be77:	e9 54 01 00 00       	jmpq   800420bfd0 <syscall+0x1fa>
		case SYS_env_destroy:
			return sys_env_destroy(a1);
  800420be7c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420be80:	89 c7                	mov    %eax,%edi
  800420be82:	48 b8 b8 b5 20 04 80 	movabs $0x800420b5b8,%rax
  800420be89:	00 00 00 
  800420be8c:	ff d0                	callq  *%rax
  800420be8e:	48 98                	cltq   
  800420be90:	e9 3b 01 00 00       	jmpq   800420bfd0 <syscall+0x1fa>
		case SYS_yield:
			sys_yield();
  800420be95:	48 b8 08 b6 20 04 80 	movabs $0x800420b608,%rax
  800420be9c:	00 00 00 
  800420be9f:	ff d0                	callq  *%rax
			return 0;
  800420bea1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bea6:	e9 25 01 00 00       	jmpq   800420bfd0 <syscall+0x1fa>
		case SYS_exofork:
			return sys_exofork();
  800420beab:	48 b8 18 b6 20 04 80 	movabs $0x800420b618,%rax
  800420beb2:	00 00 00 
  800420beb5:	ff d0                	callq  *%rax
  800420beb7:	48 98                	cltq   
  800420beb9:	e9 12 01 00 00       	jmpq   800420bfd0 <syscall+0x1fa>
		case SYS_page_alloc:
			return sys_page_alloc((envid_t) a1, (void*) a2, a3);
  800420bebe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420bec2:	89 c2                	mov    %eax,%edx
  800420bec4:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420bec8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420becc:	48 89 ce             	mov    %rcx,%rsi
  800420becf:	89 c7                	mov    %eax,%edi
  800420bed1:	48 b8 f9 b7 20 04 80 	movabs $0x800420b7f9,%rax
  800420bed8:	00 00 00 
  800420bedb:	ff d0                	callq  *%rax
  800420bedd:	48 98                	cltq   
  800420bedf:	e9 ec 00 00 00       	jmpq   800420bfd0 <syscall+0x1fa>
		case SYS_page_map:
			return sys_page_map((envid_t)a1, (void*)a2, (envid_t)a3, (void*)a4, a5);
  800420bee4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420bee8:	89 c7                	mov    %eax,%edi
  800420beea:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420beee:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420bef2:	89 c2                	mov    %eax,%edx
  800420bef4:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420bef8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420befc:	41 89 f8             	mov    %edi,%r8d
  800420beff:	89 c7                	mov    %eax,%edi
  800420bf01:	48 b8 cb b8 20 04 80 	movabs $0x800420b8cb,%rax
  800420bf08:	00 00 00 
  800420bf0b:	ff d0                	callq  *%rax
  800420bf0d:	48 98                	cltq   
  800420bf0f:	e9 bc 00 00 00       	jmpq   800420bfd0 <syscall+0x1fa>
		case SYS_page_unmap:
			return sys_page_unmap((envid_t) a1, (void*) a2);
  800420bf14:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420bf18:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bf1c:	48 89 d6             	mov    %rdx,%rsi
  800420bf1f:	89 c7                	mov    %eax,%edi
  800420bf21:	48 b8 20 ba 20 04 80 	movabs $0x800420ba20,%rax
  800420bf28:	00 00 00 
  800420bf2b:	ff d0                	callq  *%rax
  800420bf2d:	48 98                	cltq   
  800420bf2f:	e9 9c 00 00 00       	jmpq   800420bfd0 <syscall+0x1fa>
		case SYS_env_set_status:
			return sys_env_set_status((envid_t)a1, a2);
  800420bf34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf38:	89 c2                	mov    %eax,%edx
  800420bf3a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bf3e:	89 d6                	mov    %edx,%esi
  800420bf40:	89 c7                	mov    %eax,%edi
  800420bf42:	48 b8 ef b6 20 04 80 	movabs $0x800420b6ef,%rax
  800420bf49:	00 00 00 
  800420bf4c:	ff d0                	callq  *%rax
  800420bf4e:	48 98                	cltq   
  800420bf50:	eb 7e                	jmp    800420bfd0 <syscall+0x1fa>
		case SYS_env_set_pgfault_upcall:
			return sys_env_set_pgfault_upcall((envid_t)a1, (void*)a2);
  800420bf52:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420bf56:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bf5a:	48 89 d6             	mov    %rdx,%rsi
  800420bf5d:	89 c7                	mov    %eax,%edi
  800420bf5f:	48 b8 a9 b7 20 04 80 	movabs $0x800420b7a9,%rax
  800420bf66:	00 00 00 
  800420bf69:	ff d0                	callq  *%rax
  800420bf6b:	48 98                	cltq   
  800420bf6d:	eb 61                	jmp    800420bfd0 <syscall+0x1fa>
		case SYS_ipc_try_send:
			return sys_ipc_try_send((envid_t)a1, a2, (void*)a3, a4);
  800420bf6f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bf73:	89 c1                	mov    %eax,%ecx
  800420bf75:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420bf79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf7d:	89 c6                	mov    %eax,%esi
  800420bf7f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bf83:	89 c7                	mov    %eax,%edi
  800420bf85:	48 b8 aa ba 20 04 80 	movabs $0x800420baaa,%rax
  800420bf8c:	00 00 00 
  800420bf8f:	ff d0                	callq  *%rax
  800420bf91:	48 98                	cltq   
  800420bf93:	eb 3b                	jmp    800420bfd0 <syscall+0x1fa>
		case SYS_ipc_recv:
			return sys_ipc_recv((void*)a1);
  800420bf95:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bf99:	48 89 c7             	mov    %rax,%rdi
  800420bf9c:	48 b8 e2 bc 20 04 80 	movabs $0x800420bce2,%rax
  800420bfa3:	00 00 00 
  800420bfa6:	ff d0                	callq  *%rax
  800420bfa8:	48 98                	cltq   
  800420bfaa:	eb 24                	jmp    800420bfd0 <syscall+0x1fa>
		case SYS_env_set_trapframe:
			return sys_env_set_trapframe((envid_t)a1, (struct Trapframe*)a2);
  800420bfac:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420bfb0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bfb4:	48 89 d6             	mov    %rdx,%rsi
  800420bfb7:	89 c7                	mov    %eax,%edi
  800420bfb9:	48 b8 4f b7 20 04 80 	movabs $0x800420b74f,%rax
  800420bfc0:	00 00 00 
  800420bfc3:	ff d0                	callq  *%rax
  800420bfc5:	48 98                	cltq   
  800420bfc7:	eb 07                	jmp    800420bfd0 <syscall+0x1fa>
	default:
		return -E_NO_SYS;
  800420bfc9:	48 c7 c0 f9 ff ff ff 	mov    $0xfffffffffffffff9,%rax
	}
}
  800420bfd0:	c9                   	leaveq 
  800420bfd1:	c3                   	retq   

000000800420bfd2 <stub_sys>:
int64_t
stub_sys(int num, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5){
  800420bfd2:	55                   	push   %rbp
  800420bfd3:	48 89 e5             	mov    %rsp,%rbp
  800420bfd6:	48 83 ec 30          	sub    $0x30,%rsp
  800420bfda:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420bfdd:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420bfe1:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420bfe5:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420bfe9:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  800420bfed:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
	//asm volatile("mov %%rsi, %0":"=r"(rsi));
	//asm volatile("mov %%rdx, %0":"=r"(rdx));
	//cprintf("rdi = %016x, sysno = %d\n", rdi, num);
	//cprintf("a1 = %016x, a2 = %d\n", a1, a2);
	//cprintf("rsi = %016x, rdx = %d\n", rsi, rdx);
	return 1;
  800420bff1:	b8 01 00 00 00       	mov    $0x1,%eax
}
  800420bff6:	c9                   	leaveq 
  800420bff7:	c3                   	retq   

000000800420bff8 <list_func_die>:
	const char *stabstr;
	const char *stabstr_end;
};

int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420bff8:	55                   	push   %rbp
  800420bff9:	48 89 e5             	mov    %rsp,%rbp
  800420bffc:	48 81 ec f0 61 00 00 	sub    $0x61f0,%rsp
  800420c003:	48 89 bd 58 9e ff ff 	mov    %rdi,-0x61a8(%rbp)
  800420c00a:	48 89 b5 50 9e ff ff 	mov    %rsi,-0x61b0(%rbp)
  800420c011:	48 89 95 48 9e ff ff 	mov    %rdx,-0x61b8(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420c018:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420c01f:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420c026:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420c02a:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420c031:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420c038:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420c03c:	48 8b 95 50 9e ff ff 	mov    -0x61b0(%rbp),%rdx
  800420c043:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420c04a:	48 89 d1             	mov    %rdx,%rcx
  800420c04d:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420c052:	48 89 ce             	mov    %rcx,%rsi
  800420c055:	48 89 c7             	mov    %rax,%rdi
  800420c058:	48 b8 98 dc 20 04 80 	movabs $0x800420dc98,%rax
  800420c05f:	00 00 00 
  800420c062:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420c064:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420c06b:	00 
	uint64_t ret_offset=0;
  800420c06c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420c073:	00 

	if(die->die_tag != DW_TAG_subprogram)
  800420c074:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420c07b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420c07f:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420c083:	74 0a                	je     800420c08f <list_func_die+0x97>
		return 0;
  800420c085:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c08a:	e9 cd 06 00 00       	jmpq   800420c75c <list_func_die+0x764>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420c08f:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420c096:	ba 38 00 00 00       	mov    $0x38,%edx
  800420c09b:	be 00 00 00 00       	mov    $0x0,%esi
  800420c0a0:	48 89 c7             	mov    %rax,%rdi
  800420c0a3:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  800420c0aa:	00 00 00 
  800420c0ad:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420c0af:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420c0b6:	be 11 00 00 00       	mov    $0x11,%esi
  800420c0bb:	48 89 c7             	mov    %rax,%rdi
  800420c0be:	48 b8 2b fa 20 04 80 	movabs $0x800420fa2b,%rax
  800420c0c5:	00 00 00 
  800420c0c8:	ff d0                	callq  *%rax
  800420c0ca:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420c0ce:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420c0d5:	be 12 00 00 00       	mov    $0x12,%esi
  800420c0da:	48 89 c7             	mov    %rax,%rdi
  800420c0dd:	48 b8 2b fa 20 04 80 	movabs $0x800420fa2b,%rax
  800420c0e4:	00 00 00 
  800420c0e7:	ff d0                	callq  *%rax
  800420c0e9:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420c0ed:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420c0f2:	0f 84 5f 06 00 00    	je     800420c757 <list_func_die+0x75f>
  800420c0f8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c0fc:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420c100:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420c107:	0f 83 4a 06 00 00    	jae    800420c757 <list_func_die+0x75f>
  800420c10d:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420c112:	0f 84 3f 06 00 00    	je     800420c757 <list_func_die+0x75f>
  800420c118:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c11c:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420c120:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420c127:	0f 86 2a 06 00 00    	jbe    800420c757 <list_func_die+0x75f>
	{
		info->rip_file = die->cu_die->die_name;
  800420c12d:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420c134:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420c13b:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420c142:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420c149:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420c14c:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420c153:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420c15a:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420c161:	48 89 50 10          	mov    %rdx,0x10(%rax)
		info->rip_fn_namelen = strlen(die->die_name);
  800420c165:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420c16c:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420c173:	48 89 c7             	mov    %rax,%rdi
  800420c176:	48 b8 f1 d7 20 04 80 	movabs $0x800420d7f1,%rax
  800420c17d:	00 00 00 
  800420c180:	ff d0                	callq  *%rax
  800420c182:	48 8b 95 58 9e ff ff 	mov    -0x61a8(%rbp),%rdx
  800420c189:	89 42 18             	mov    %eax,0x18(%rdx)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420c18c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c190:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420c194:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420c19b:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420c19f:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420c1a6:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420c1ad:	48 85 c0             	test   %rax,%rax
  800420c1b0:	75 35                	jne    800420c1e7 <list_func_die+0x1ef>
  800420c1b2:	48 b9 a0 75 21 04 80 	movabs $0x80042175a0,%rcx
  800420c1b9:	00 00 00 
  800420c1bc:	48 ba ac 75 21 04 80 	movabs $0x80042175ac,%rdx
  800420c1c3:	00 00 00 
  800420c1c6:	be 91 00 00 00       	mov    $0x91,%esi
  800420c1cb:	48 bf c1 75 21 04 80 	movabs $0x80042175c1,%rdi
  800420c1d2:	00 00 00 
  800420c1d5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c1da:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420c1e1:	00 00 00 
  800420c1e4:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420c1e7:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420c1ee:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420c1f5:	48 8b 95 48 9e ff ff 	mov    -0x61b8(%rbp),%rdx
  800420c1fc:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
  800420c203:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420c208:	48 89 c7             	mov    %rax,%rdi
  800420c20b:	48 b8 52 30 21 04 80 	movabs $0x8004213052,%rax
  800420c212:	00 00 00 
  800420c215:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420c217:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420c21e:	89 c2                	mov    %eax,%edx
  800420c220:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420c227:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420c22a:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420c231:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420c238:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  800420c23f:	00 00 00 
  800420c242:	48 8b 00             	mov    (%rax),%rax
  800420c245:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420c24c:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420c253:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420c257:	48 89 c7             	mov    %rax,%rdi
  800420c25a:	48 b8 02 fd 20 04 80 	movabs $0x800420fd02,%rax
  800420c261:	00 00 00 
  800420c264:	ff d0                	callq  *%rax
  800420c266:	83 f8 04             	cmp    $0x4,%eax
  800420c269:	0f 84 e1 04 00 00    	je     800420c750 <list_func_die+0x758>
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
  800420c26f:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420c276:	48 83 f8 05          	cmp    $0x5,%rax
  800420c27a:	74 05                	je     800420c281 <list_func_die+0x289>
				goto last;
  800420c27c:	e9 cf 04 00 00       	jmpq   800420c750 <list_func_die+0x758>

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420c281:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420c288:	be 49 00 00 00       	mov    $0x49,%esi
  800420c28d:	48 89 c7             	mov    %rax,%rdi
  800420c290:	48 b8 2b fa 20 04 80 	movabs $0x800420fa2b,%rax
  800420c297:	00 00 00 
  800420c29a:	ff d0                	callq  *%rax
  800420c29c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
		try_again:
			if(attr != NULL)
  800420c2a0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420c2a5:	0f 84 d7 00 00 00    	je     800420c382 <list_func_die+0x38a>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420c2ab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c2af:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420c2b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c2b7:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420c2bb:	48 01 d0             	add    %rdx,%rax
  800420c2be:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420c2c2:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  800420c2c9:	00 00 00 
  800420c2cc:	48 8b 08             	mov    (%rax),%rcx
  800420c2cf:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420c2d6:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420c2da:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c2de:	48 8b 38             	mov    (%rax),%rdi
  800420c2e1:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420c2e5:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420c2e9:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420c2ee:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420c2f2:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420c2f7:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420c2fb:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420c300:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420c304:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420c309:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420c30d:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420c312:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420c316:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420c31b:	48 89 cf             	mov    %rcx,%rdi
  800420c31e:	48 b8 28 f9 20 04 80 	movabs $0x800420f928,%rax
  800420c325:	00 00 00 
  800420c328:	ff d0                	callq  *%rax
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420c32a:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420c331:	be 0b 00 00 00       	mov    $0xb,%esi
  800420c336:	48 89 c7             	mov    %rax,%rdi
  800420c339:	48 b8 2b fa 20 04 80 	movabs $0x800420fa2b,%rax
  800420c340:	00 00 00 
  800420c343:	ff d0                	callq  *%rax
  800420c345:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		
				if(attr != NULL)
  800420c349:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420c34e:	74 0e                	je     800420c35e <list_func_die+0x366>
				{
					ret_val = attr->u[0].u64;
  800420c350:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c354:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420c358:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420c35c:	eb 24                	jmp    800420c382 <list_func_die+0x38a>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420c35e:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420c365:	be 49 00 00 00       	mov    $0x49,%esi
  800420c36a:	48 89 c7             	mov    %rax,%rdi
  800420c36d:	48 b8 2b fa 20 04 80 	movabs $0x800420fa2b,%rax
  800420c374:	00 00 00 
  800420c377:	ff d0                	callq  *%rax
  800420c379:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					goto try_again;
  800420c37d:	e9 1e ff ff ff       	jmpq   800420c2a0 <list_func_die+0x2a8>
				}
			}

			ret_offset = 0;
  800420c382:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420c389:	00 
			attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420c38a:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420c391:	be 02 00 00 00       	mov    $0x2,%esi
  800420c396:	48 89 c7             	mov    %rax,%rdi
  800420c399:	48 b8 2b fa 20 04 80 	movabs $0x800420fa2b,%rax
  800420c3a0:	00 00 00 
  800420c3a3:	ff d0                	callq  *%rax
  800420c3a5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if (attr != NULL)
  800420c3a9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420c3ae:	0f 84 a2 00 00 00    	je     800420c456 <list_func_die+0x45e>
			{
				Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420c3b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c3b8:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420c3bc:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
				Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420c3c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c3c4:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420c3c8:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
				Dwarf_Small atom;
				Dwarf_Unsigned op1, op2;

				switch(attr->at_form) {
  800420c3cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c3d0:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420c3d4:	48 83 f8 03          	cmp    $0x3,%rax
  800420c3d8:	72 7c                	jb     800420c456 <list_func_die+0x45e>
  800420c3da:	48 83 f8 04          	cmp    $0x4,%rax
  800420c3de:	76 06                	jbe    800420c3e6 <list_func_die+0x3ee>
  800420c3e0:	48 83 f8 0a          	cmp    $0xa,%rax
  800420c3e4:	75 70                	jne    800420c456 <list_func_die+0x45e>
					case DW_FORM_block1:
					case DW_FORM_block2:
					case DW_FORM_block4:
						offset = 0;
  800420c3e6:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420c3ed:	00 
						atom = *(loc_ptr++);
  800420c3ee:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420c3f2:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420c3f6:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420c3fa:	0f b6 00             	movzbl (%rax),%eax
  800420c3fd:	88 45 af             	mov    %al,-0x51(%rbp)
						offset++;
  800420c400:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
						if (atom == DW_OP_fbreg) {
  800420c405:	80 7d af 91          	cmpb   $0x91,-0x51(%rbp)
  800420c409:	75 4a                	jne    800420c455 <list_func_die+0x45d>
							uint8_t *p = loc_ptr;
  800420c40b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420c40f:	48 89 85 68 9e ff ff 	mov    %rax,-0x6198(%rbp)
							ret_offset = _dwarf_decode_sleb128(&p);
  800420c416:	48 8d 85 68 9e ff ff 	lea    -0x6198(%rbp),%rax
  800420c41d:	48 89 c7             	mov    %rax,%rdi
  800420c420:	48 b8 87 e6 20 04 80 	movabs $0x800420e687,%rax
  800420c427:	00 00 00 
  800420c42a:	ff d0                	callq  *%rax
  800420c42c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
							offset += p - loc_ptr;
  800420c430:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420c437:	48 89 c2             	mov    %rax,%rdx
  800420c43a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420c43e:	48 29 c2             	sub    %rax,%rdx
  800420c441:	48 89 d0             	mov    %rdx,%rax
  800420c444:	48 01 45 c0          	add    %rax,-0x40(%rbp)
							loc_ptr = p;
  800420c448:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420c44f:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
						}
						break;
  800420c453:	eb 00                	jmp    800420c455 <list_func_die+0x45d>
  800420c455:	90                   	nop
				}
			}

			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420c456:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420c45d:	8b 48 28             	mov    0x28(%rax),%ecx
  800420c460:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c464:	89 c2                	mov    %eax,%edx
  800420c466:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420c46d:	48 63 c9             	movslq %ecx,%rcx
  800420c470:	48 83 c1 08          	add    $0x8,%rcx
  800420c474:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
  800420c478:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420c47f:	8b 50 28             	mov    0x28(%rax),%edx
  800420c482:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420c489:	48 63 d2             	movslq %edx,%rdx
  800420c48c:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420c490:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c494:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
			info->rip_fn_narg++;
  800420c499:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420c4a0:	8b 40 28             	mov    0x28(%rax),%eax
  800420c4a3:	8d 50 01             	lea    0x1(%rax),%edx
  800420c4a6:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420c4ad:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420c4b0:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420c4b7:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420c4be:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420c4c3:	48 89 ce             	mov    %rcx,%rsi
  800420c4c6:	48 89 c7             	mov    %rax,%rdi
  800420c4c9:	48 b8 98 dc 20 04 80 	movabs $0x800420dc98,%rax
  800420c4d0:	00 00 00 
  800420c4d3:	ff d0                	callq  *%rax

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420c4d5:	e9 40 02 00 00       	jmpq   800420c71a <list_func_die+0x722>
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
  800420c4da:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420c4e1:	48 83 f8 05          	cmp    $0x5,%rax
  800420c4e5:	74 05                	je     800420c4ec <list_func_die+0x4f4>
					break;
  800420c4e7:	e9 64 02 00 00       	jmpq   800420c750 <list_func_die+0x758>

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420c4ec:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420c4f3:	be 49 00 00 00       	mov    $0x49,%esi
  800420c4f8:	48 89 c7             	mov    %rax,%rdi
  800420c4fb:	48 b8 2b fa 20 04 80 	movabs $0x800420fa2b,%rax
  800420c502:	00 00 00 
  800420c505:	ff d0                	callq  *%rax
  800420c507:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
				if(attr != NULL)
  800420c50b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420c510:	0f 84 b1 00 00 00    	je     800420c5c7 <list_func_die+0x5cf>
				{	   
					offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420c516:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c51a:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420c51e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c522:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420c526:	48 01 d0             	add    %rdx,%rax
  800420c529:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
					dwarf_offdie(dbg, offset, &sib, *cu);
  800420c52d:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  800420c534:	00 00 00 
  800420c537:	48 8b 08             	mov    (%rax),%rcx
  800420c53a:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420c541:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420c545:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c549:	48 8b 38             	mov    (%rax),%rdi
  800420c54c:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420c550:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420c554:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420c559:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420c55d:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420c562:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420c566:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420c56b:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420c56f:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420c574:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420c578:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420c57d:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420c581:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420c586:	48 89 cf             	mov    %rcx,%rdi
  800420c589:	48 b8 28 f9 20 04 80 	movabs $0x800420f928,%rax
  800420c590:	00 00 00 
  800420c593:	ff d0                	callq  *%rax
					attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420c595:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420c59c:	be 0b 00 00 00       	mov    $0xb,%esi
  800420c5a1:	48 89 c7             	mov    %rax,%rdi
  800420c5a4:	48 b8 2b fa 20 04 80 	movabs $0x800420fa2b,%rax
  800420c5ab:	00 00 00 
  800420c5ae:	ff d0                	callq  *%rax
  800420c5b0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
					if(attr != NULL)
  800420c5b4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420c5b9:	74 0c                	je     800420c5c7 <list_func_die+0x5cf>
					{
						ret_val = attr->u[0].u64;
  800420c5bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c5bf:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420c5c3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
					}
				}
	
				ret_offset = 0;
  800420c5c7:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420c5ce:	00 
				attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420c5cf:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420c5d6:	be 02 00 00 00       	mov    $0x2,%esi
  800420c5db:	48 89 c7             	mov    %rax,%rdi
  800420c5de:	48 b8 2b fa 20 04 80 	movabs $0x800420fa2b,%rax
  800420c5e5:	00 00 00 
  800420c5e8:	ff d0                	callq  *%rax
  800420c5ea:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if (attr != NULL)
  800420c5ee:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420c5f3:	0f 84 a2 00 00 00    	je     800420c69b <list_func_die+0x6a3>
				{
					Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420c5f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c5fd:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420c601:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
					Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420c605:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c609:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420c60d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
					Dwarf_Small atom;
					Dwarf_Unsigned op1, op2;

					switch(attr->at_form) {
  800420c611:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c615:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420c619:	48 83 f8 03          	cmp    $0x3,%rax
  800420c61d:	72 7c                	jb     800420c69b <list_func_die+0x6a3>
  800420c61f:	48 83 f8 04          	cmp    $0x4,%rax
  800420c623:	76 06                	jbe    800420c62b <list_func_die+0x633>
  800420c625:	48 83 f8 0a          	cmp    $0xa,%rax
  800420c629:	75 70                	jne    800420c69b <list_func_die+0x6a3>
						case DW_FORM_block1:
						case DW_FORM_block2:
						case DW_FORM_block4:
							offset = 0;
  800420c62b:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420c632:	00 
							atom = *(loc_ptr++);
  800420c633:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420c637:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420c63b:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420c63f:	0f b6 00             	movzbl (%rax),%eax
  800420c642:	88 45 97             	mov    %al,-0x69(%rbp)
							offset++;
  800420c645:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
							if (atom == DW_OP_fbreg) {
  800420c64a:	80 7d 97 91          	cmpb   $0x91,-0x69(%rbp)
  800420c64e:	75 4a                	jne    800420c69a <list_func_die+0x6a2>
								uint8_t *p = loc_ptr;
  800420c650:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420c654:	48 89 85 60 9e ff ff 	mov    %rax,-0x61a0(%rbp)
								ret_offset = _dwarf_decode_sleb128(&p);
  800420c65b:	48 8d 85 60 9e ff ff 	lea    -0x61a0(%rbp),%rax
  800420c662:	48 89 c7             	mov    %rax,%rdi
  800420c665:	48 b8 87 e6 20 04 80 	movabs $0x800420e687,%rax
  800420c66c:	00 00 00 
  800420c66f:	ff d0                	callq  *%rax
  800420c671:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
								offset += p - loc_ptr;
  800420c675:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420c67c:	48 89 c2             	mov    %rax,%rdx
  800420c67f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420c683:	48 29 c2             	sub    %rax,%rdx
  800420c686:	48 89 d0             	mov    %rdx,%rax
  800420c689:	48 01 45 c0          	add    %rax,-0x40(%rbp)
								loc_ptr = p;
  800420c68d:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420c694:	48 89 45 98          	mov    %rax,-0x68(%rbp)
							}
							break;
  800420c698:	eb 00                	jmp    800420c69a <list_func_die+0x6a2>
  800420c69a:	90                   	nop
					}
				}

				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420c69b:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420c6a2:	8b 48 28             	mov    0x28(%rax),%ecx
  800420c6a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c6a9:	89 c2                	mov    %eax,%edx
  800420c6ab:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420c6b2:	48 63 c9             	movslq %ecx,%rcx
  800420c6b5:	48 83 c1 08          	add    $0x8,%rcx
  800420c6b9:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
				info->offset_fn_arg[info->rip_fn_narg]=ret_offset;
  800420c6bd:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420c6c4:	8b 50 28             	mov    0x28(%rax),%edx
  800420c6c7:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420c6ce:	48 63 d2             	movslq %edx,%rdx
  800420c6d1:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420c6d5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c6d9:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
				info->rip_fn_narg++;
  800420c6de:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420c6e5:	8b 40 28             	mov    0x28(%rax),%eax
  800420c6e8:	8d 50 01             	lea    0x1(%rax),%edx
  800420c6eb:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420c6f2:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420c6f5:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420c6fc:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420c703:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420c708:	48 89 ce             	mov    %rcx,%rsi
  800420c70b:	48 89 c7             	mov    %rax,%rdi
  800420c70e:	48 b8 98 dc 20 04 80 	movabs $0x800420dc98,%rax
  800420c715:	00 00 00 
  800420c718:	ff d0                	callq  *%rax
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
			info->rip_fn_narg++;
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420c71a:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  800420c721:	00 00 00 
  800420c724:	48 8b 00             	mov    (%rax),%rax
  800420c727:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420c72b:	48 8d 95 e0 ce ff ff 	lea    -0x3120(%rbp),%rdx
  800420c732:	48 8d b5 70 9e ff ff 	lea    -0x6190(%rbp),%rsi
  800420c739:	48 89 c7             	mov    %rax,%rdi
  800420c73c:	48 b8 be fa 20 04 80 	movabs $0x800420fabe,%rax
  800420c743:	00 00 00 
  800420c746:	ff d0                	callq  *%rax
  800420c748:	85 c0                	test   %eax,%eax
  800420c74a:	0f 84 8a fd ff ff    	je     800420c4da <list_func_die+0x4e2>
				info->rip_fn_narg++;
				sib = ret; 
			}
		}
	last:	
		return 1;
  800420c750:	b8 01 00 00 00       	mov    $0x1,%eax
  800420c755:	eb 05                	jmp    800420c75c <list_func_die+0x764>
	}

	return 0;
  800420c757:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420c75c:	c9                   	leaveq 
  800420c75d:	c3                   	retq   

000000800420c75e <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420c75e:	55                   	push   %rbp
  800420c75f:	48 89 e5             	mov    %rsp,%rbp
  800420c762:	53                   	push   %rbx
  800420c763:	48 81 ec c8 91 00 00 	sub    $0x91c8,%rsp
  800420c76a:	48 89 bd 38 6e ff ff 	mov    %rdi,-0x91c8(%rbp)
  800420c771:	48 89 b5 30 6e ff ff 	mov    %rsi,-0x91d0(%rbp)
	static struct Env* lastenv = NULL;
	void* elf;    
	Dwarf_Section *sect;
	Dwarf_CU cu;
	Dwarf_Die die, cudie, die2;
	Dwarf_Regtable *rt = NULL;
  800420c778:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420c77f:	00 
	//Set up initial pc
	uint64_t pc  = (uintptr_t)addr;
  800420c780:	48 8b 85 38 6e ff ff 	mov    -0x91c8(%rbp),%rax
  800420c787:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    
	// Initialize *info
	info->rip_file = "<unknown>";
  800420c78b:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420c792:	48 bb cf 75 21 04 80 	movabs $0x80042175cf,%rbx
  800420c799:	00 00 00 
  800420c79c:	48 89 18             	mov    %rbx,(%rax)
	info->rip_line = 0;
  800420c79f:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420c7a6:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	info->rip_fn_name = "<unknown>";
  800420c7ad:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420c7b4:	48 bb cf 75 21 04 80 	movabs $0x80042175cf,%rbx
  800420c7bb:	00 00 00 
  800420c7be:	48 89 58 10          	mov    %rbx,0x10(%rax)
	info->rip_fn_namelen = 9;
  800420c7c2:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420c7c9:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
	info->rip_fn_addr = addr;
  800420c7d0:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420c7d7:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420c7de:	48 89 50 20          	mov    %rdx,0x20(%rax)
	info->rip_fn_narg = 0;
  800420c7e2:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420c7e9:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
	// Find the relevant set of stabs
	if (addr >= ULIM) {
  800420c7f0:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420c7f7:	00 00 00 
  800420c7fa:	48 39 85 38 6e ff ff 	cmp    %rax,-0x91c8(%rbp)
  800420c801:	76 13                	jbe    800420c816 <debuginfo_rip+0xb8>
		elf = (void *)0x10000 + KERNBASE;
  800420c803:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800420c80a:	00 00 00 
  800420c80d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420c811:	e9 08 01 00 00       	jmpq   800420c91e <debuginfo_rip+0x1c0>
	} else {
		if(curenv != lastenv) {
  800420c816:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420c81d:	00 00 00 
  800420c820:	ff d0                	callq  *%rax
  800420c822:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420c829:	00 00 00 
  800420c82c:	48 98                	cltq   
  800420c82e:	48 c1 e0 03          	shl    $0x3,%rax
  800420c832:	48 89 c2             	mov    %rax,%rdx
  800420c835:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c839:	48 29 c2             	sub    %rax,%rdx
  800420c83c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c840:	48 83 c0 08          	add    $0x8,%rax
  800420c844:	48 8b 10             	mov    (%rax),%rdx
  800420c847:	48 b8 98 e2 49 04 80 	movabs $0x800449e298,%rax
  800420c84e:	00 00 00 
  800420c851:	48 8b 00             	mov    (%rax),%rax
  800420c854:	48 39 c2             	cmp    %rax,%rdx
  800420c857:	0f 84 85 00 00 00    	je     800420c8e2 <debuginfo_rip+0x184>
			find_debug_sections((uintptr_t)curenv->elf);
  800420c85d:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420c864:	00 00 00 
  800420c867:	ff d0                	callq  *%rax
  800420c869:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420c870:	00 00 00 
  800420c873:	48 98                	cltq   
  800420c875:	48 c1 e0 03          	shl    $0x3,%rax
  800420c879:	48 89 c2             	mov    %rax,%rdx
  800420c87c:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c880:	48 29 c2             	sub    %rax,%rdx
  800420c883:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c887:	48 83 c0 08          	add    $0x8,%rax
  800420c88b:	48 8b 00             	mov    (%rax),%rax
  800420c88e:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420c895:	48 89 c7             	mov    %rax,%rdi
  800420c898:	48 b8 4d 32 21 04 80 	movabs $0x800421324d,%rax
  800420c89f:	00 00 00 
  800420c8a2:	ff d0                	callq  *%rax
			lastenv = curenv;
  800420c8a4:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420c8ab:	00 00 00 
  800420c8ae:	ff d0                	callq  *%rax
  800420c8b0:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420c8b7:	00 00 00 
  800420c8ba:	48 98                	cltq   
  800420c8bc:	48 c1 e0 03          	shl    $0x3,%rax
  800420c8c0:	48 89 c2             	mov    %rax,%rdx
  800420c8c3:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c8c7:	48 29 c2             	sub    %rax,%rdx
  800420c8ca:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c8ce:	48 83 c0 08          	add    $0x8,%rax
  800420c8d2:	48 8b 10             	mov    (%rax),%rdx
  800420c8d5:	48 b8 98 e2 49 04 80 	movabs $0x800449e298,%rax
  800420c8dc:	00 00 00 
  800420c8df:	48 89 10             	mov    %rdx,(%rax)
		}
		elf = curenv->elf;
  800420c8e2:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  800420c8e9:	00 00 00 
  800420c8ec:	ff d0                	callq  *%rax
  800420c8ee:	48 b9 20 00 4a 04 80 	movabs $0x80044a0020,%rcx
  800420c8f5:	00 00 00 
  800420c8f8:	48 98                	cltq   
  800420c8fa:	48 c1 e0 03          	shl    $0x3,%rax
  800420c8fe:	48 89 c2             	mov    %rax,%rdx
  800420c901:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c905:	48 29 c2             	sub    %rax,%rdx
  800420c908:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c90c:	48 83 c0 08          	add    $0x8,%rax
  800420c910:	48 8b 00             	mov    (%rax),%rax
  800420c913:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420c91a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}
	_dwarf_init(dbg, elf);
  800420c91e:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  800420c925:	00 00 00 
  800420c928:	48 8b 00             	mov    (%rax),%rax
  800420c92b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420c92f:	48 89 d6             	mov    %rdx,%rsi
  800420c932:	48 89 c7             	mov    %rax,%rdi
  800420c935:	48 b8 36 e9 20 04 80 	movabs $0x800420e936,%rax
  800420c93c:	00 00 00 
  800420c93f:	ff d0                	callq  *%rax

	sect = _dwarf_find_section(".debug_info");	
  800420c941:	48 bf d9 75 21 04 80 	movabs $0x80042175d9,%rdi
  800420c948:	00 00 00 
  800420c94b:	48 b8 cd 31 21 04 80 	movabs $0x80042131cd,%rax
  800420c952:	00 00 00 
  800420c955:	ff d0                	callq  *%rax
  800420c957:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800420c95b:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  800420c962:	00 00 00 
  800420c965:	48 8b 00             	mov    (%rax),%rax
  800420c968:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420c96c:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420c970:	48 89 50 08          	mov    %rdx,0x8(%rax)
	dbg->dbg_info_size = sect->ds_size;
  800420c974:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  800420c97b:	00 00 00 
  800420c97e:	48 8b 00             	mov    (%rax),%rax
  800420c981:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420c985:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800420c989:	48 89 50 10          	mov    %rdx,0x10(%rax)

	assert(dbg->dbg_info_size);
  800420c98d:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  800420c994:	00 00 00 
  800420c997:	48 8b 00             	mov    (%rax),%rax
  800420c99a:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420c99e:	48 85 c0             	test   %rax,%rax
  800420c9a1:	75 35                	jne    800420c9d8 <debuginfo_rip+0x27a>
  800420c9a3:	48 b9 e5 75 21 04 80 	movabs $0x80042175e5,%rcx
  800420c9aa:	00 00 00 
  800420c9ad:	48 ba ac 75 21 04 80 	movabs $0x80042175ac,%rdx
  800420c9b4:	00 00 00 
  800420c9b7:	be 37 01 00 00       	mov    $0x137,%esi
  800420c9bc:	48 bf c1 75 21 04 80 	movabs $0x80042175c1,%rdi
  800420c9c3:	00 00 00 
  800420c9c6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c9cb:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420c9d2:	00 00 00 
  800420c9d5:	41 ff d0             	callq  *%r8
	while(_get_next_cu(dbg, &cu) == 0)
  800420c9d8:	e9 6f 01 00 00       	jmpq   800420cb4c <debuginfo_rip+0x3ee>
	{
		if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  800420c9dd:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  800420c9e4:	00 00 00 
  800420c9e7:	48 8b 00             	mov    (%rax),%rax
  800420c9ea:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420c9ee:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420c9f5:	be 00 00 00 00       	mov    $0x0,%esi
  800420c9fa:	48 89 c7             	mov    %rax,%rdi
  800420c9fd:	48 b8 be fa 20 04 80 	movabs $0x800420fabe,%rax
  800420ca04:	00 00 00 
  800420ca07:	ff d0                	callq  *%rax
  800420ca09:	83 f8 04             	cmp    $0x4,%eax
  800420ca0c:	75 05                	jne    800420ca13 <debuginfo_rip+0x2b5>
			continue;
  800420ca0e:	e9 39 01 00 00       	jmpq   800420cb4c <debuginfo_rip+0x3ee>

		cudie.cu_header = &cu;
  800420ca13:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420ca17:	48 89 85 10 a2 ff ff 	mov    %rax,-0x5df0(%rbp)
		cudie.cu_die = NULL;
  800420ca1e:	48 c7 85 18 a2 ff ff 	movq   $0x0,-0x5de8(%rbp)
  800420ca25:	00 00 00 00 

		if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  800420ca29:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  800420ca30:	00 00 00 
  800420ca33:	48 8b 00             	mov    (%rax),%rax
  800420ca36:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420ca3d:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420ca44:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800420ca48:	48 89 c7             	mov    %rax,%rdi
  800420ca4b:	48 b8 02 fd 20 04 80 	movabs $0x800420fd02,%rax
  800420ca52:	00 00 00 
  800420ca55:	ff d0                	callq  *%rax
  800420ca57:	83 f8 04             	cmp    $0x4,%eax
  800420ca5a:	75 05                	jne    800420ca61 <debuginfo_rip+0x303>
			continue;
  800420ca5c:	e9 eb 00 00 00       	jmpq   800420cb4c <debuginfo_rip+0x3ee>

		die.cu_header = &cu;
  800420ca61:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420ca65:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
		die.cu_die = &cudie;
  800420ca6c:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420ca73:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		while(1)
		{
			if(list_func_die(info, &die, addr))
  800420ca7a:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420ca81:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420ca88:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420ca8f:	48 89 ce             	mov    %rcx,%rsi
  800420ca92:	48 89 c7             	mov    %rax,%rdi
  800420ca95:	48 b8 f8 bf 20 04 80 	movabs $0x800420bff8,%rax
  800420ca9c:	00 00 00 
  800420ca9f:	ff d0                	callq  *%rax
  800420caa1:	85 c0                	test   %eax,%eax
  800420caa3:	74 30                	je     800420cad5 <debuginfo_rip+0x377>
				goto find_done;
  800420caa5:	90                   	nop

	return -1;

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
  800420caa6:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  800420caad:	00 00 00 
  800420cab0:	48 8b 00             	mov    (%rax),%rax
  800420cab3:	be 00 00 00 00       	mov    $0x0,%esi
  800420cab8:	48 89 c7             	mov    %rax,%rdi
  800420cabb:	48 b8 da 23 21 04 80 	movabs $0x80042123da,%rax
  800420cac2:	00 00 00 
  800420cac5:	ff d0                	callq  *%rax
  800420cac7:	83 f8 01             	cmp    $0x1,%eax
  800420caca:	0f 85 bb 00 00 00    	jne    800420cb8b <debuginfo_rip+0x42d>
  800420cad0:	e9 ac 00 00 00       	jmpq   800420cb81 <debuginfo_rip+0x423>
		die.cu_die = &cudie;
		while(1)
		{
			if(list_func_die(info, &die, addr))
				goto find_done;
			if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  800420cad5:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  800420cadc:	00 00 00 
  800420cadf:	48 8b 00             	mov    (%rax),%rax
  800420cae2:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420cae6:	48 8d 95 40 6e ff ff 	lea    -0x91c0(%rbp),%rdx
  800420caed:	48 8d b5 20 cf ff ff 	lea    -0x30e0(%rbp),%rsi
  800420caf4:	48 89 c7             	mov    %rax,%rdi
  800420caf7:	48 b8 be fa 20 04 80 	movabs $0x800420fabe,%rax
  800420cafe:	00 00 00 
  800420cb01:	ff d0                	callq  *%rax
  800420cb03:	85 c0                	test   %eax,%eax
  800420cb05:	79 02                	jns    800420cb09 <debuginfo_rip+0x3ab>
				break; 
  800420cb07:	eb 43                	jmp    800420cb4c <debuginfo_rip+0x3ee>
			die = die2;
  800420cb09:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420cb10:	48 8d 8d 40 6e ff ff 	lea    -0x91c0(%rbp),%rcx
  800420cb17:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420cb1c:	48 89 ce             	mov    %rcx,%rsi
  800420cb1f:	48 89 c7             	mov    %rax,%rdi
  800420cb22:	48 b8 98 dc 20 04 80 	movabs $0x800420dc98,%rax
  800420cb29:	00 00 00 
  800420cb2c:	ff d0                	callq  *%rax
			die.cu_header = &cu;
  800420cb2e:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420cb32:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
			die.cu_die = &cudie;
  800420cb39:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420cb40:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		}
  800420cb47:	e9 2e ff ff ff       	jmpq   800420ca7a <debuginfo_rip+0x31c>
	sect = _dwarf_find_section(".debug_info");	
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
	dbg->dbg_info_size = sect->ds_size;

	assert(dbg->dbg_info_size);
	while(_get_next_cu(dbg, &cu) == 0)
  800420cb4c:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  800420cb53:	00 00 00 
  800420cb56:	48 8b 00             	mov    (%rax),%rax
  800420cb59:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  800420cb5d:	48 89 d6             	mov    %rdx,%rsi
  800420cb60:	48 89 c7             	mov    %rax,%rdi
  800420cb63:	48 b8 18 ea 20 04 80 	movabs $0x800420ea18,%rax
  800420cb6a:	00 00 00 
  800420cb6d:	ff d0                	callq  *%rax
  800420cb6f:	85 c0                	test   %eax,%eax
  800420cb71:	0f 84 66 fe ff ff    	je     800420c9dd <debuginfo_rip+0x27f>
			die.cu_header = &cu;
			die.cu_die = &cudie;
		}
	}

	return -1;
  800420cb77:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420cb7c:	e9 a0 00 00 00       	jmpq   800420cc21 <debuginfo_rip+0x4c3>

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
		return -1;
  800420cb81:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420cb86:	e9 96 00 00 00       	jmpq   800420cc21 <debuginfo_rip+0x4c3>

	if (dwarf_get_fde_at_pc(dbg, addr, fde, cie, NULL) == DW_DLV_OK) {
  800420cb8b:	48 b8 50 a8 22 04 80 	movabs $0x800422a850,%rax
  800420cb92:	00 00 00 
  800420cb95:	48 8b 08             	mov    (%rax),%rcx
  800420cb98:	48 b8 48 a8 22 04 80 	movabs $0x800422a848,%rax
  800420cb9f:	00 00 00 
  800420cba2:	48 8b 10             	mov    (%rax),%rdx
  800420cba5:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  800420cbac:	00 00 00 
  800420cbaf:	48 8b 00             	mov    (%rax),%rax
  800420cbb2:	48 8b b5 38 6e ff ff 	mov    -0x91c8(%rbp),%rsi
  800420cbb9:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420cbbf:	48 89 c7             	mov    %rax,%rdi
  800420cbc2:	48 b8 43 ff 20 04 80 	movabs $0x800420ff43,%rax
  800420cbc9:	00 00 00 
  800420cbcc:	ff d0                	callq  *%rax
  800420cbce:	85 c0                	test   %eax,%eax
  800420cbd0:	75 4a                	jne    800420cc1c <debuginfo_rip+0x4be>
		dwarf_get_fde_info_for_all_regs(dbg, fde, addr,
  800420cbd2:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420cbd9:	48 8d 88 a8 00 00 00 	lea    0xa8(%rax),%rcx
  800420cbe0:	48 b8 48 a8 22 04 80 	movabs $0x800422a848,%rax
  800420cbe7:	00 00 00 
  800420cbea:	48 8b 30             	mov    (%rax),%rsi
  800420cbed:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  800420cbf4:	00 00 00 
  800420cbf7:	48 8b 00             	mov    (%rax),%rax
  800420cbfa:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420cc01:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420cc07:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420cc0d:	48 89 c7             	mov    %rax,%rdi
  800420cc10:	48 b8 4f 12 21 04 80 	movabs $0x800421124f,%rax
  800420cc17:	00 00 00 
  800420cc1a:	ff d0                	callq  *%rax
					break;
			}
		}
#endif
	}
	return 0;
  800420cc1c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420cc21:	48 81 c4 c8 91 00 00 	add    $0x91c8,%rsp
  800420cc28:	5b                   	pop    %rbx
  800420cc29:	5d                   	pop    %rbp
  800420cc2a:	c3                   	retq   

000000800420cc2b <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800420cc2b:	55                   	push   %rbp
  800420cc2c:	48 89 e5             	mov    %rsp,%rbp
  800420cc2f:	53                   	push   %rbx
  800420cc30:	48 83 ec 38          	sub    $0x38,%rsp
  800420cc34:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420cc38:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420cc3c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420cc40:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  800420cc43:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
  800420cc47:	44 89 4d cc          	mov    %r9d,-0x34(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800420cc4b:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420cc4e:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420cc52:	77 3b                	ja     800420cc8f <printnum+0x64>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800420cc54:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800420cc57:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  800420cc5b:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
  800420cc5e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cc62:	ba 00 00 00 00       	mov    $0x0,%edx
  800420cc67:	48 f7 f3             	div    %rbx
  800420cc6a:	48 89 c2             	mov    %rax,%rdx
  800420cc6d:	8b 7d cc             	mov    -0x34(%rbp),%edi
  800420cc70:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420cc73:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420cc77:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cc7b:	41 89 f9             	mov    %edi,%r9d
  800420cc7e:	48 89 c7             	mov    %rax,%rdi
  800420cc81:	48 b8 2b cc 20 04 80 	movabs $0x800420cc2b,%rax
  800420cc88:	00 00 00 
  800420cc8b:	ff d0                	callq  *%rax
  800420cc8d:	eb 1e                	jmp    800420ccad <printnum+0x82>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420cc8f:	eb 12                	jmp    800420cca3 <printnum+0x78>
			putch(padc, putdat);
  800420cc91:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420cc95:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420cc98:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cc9c:	48 89 ce             	mov    %rcx,%rsi
  800420cc9f:	89 d7                	mov    %edx,%edi
  800420cca1:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420cca3:	83 6d d0 01          	subl   $0x1,-0x30(%rbp)
  800420cca7:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  800420ccab:	7f e4                	jg     800420cc91 <printnum+0x66>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800420ccad:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420ccb0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ccb4:	ba 00 00 00 00       	mov    $0x0,%edx
  800420ccb9:	48 f7 f1             	div    %rcx
  800420ccbc:	48 89 d0             	mov    %rdx,%rax
  800420ccbf:	48 ba f0 77 21 04 80 	movabs $0x80042177f0,%rdx
  800420ccc6:	00 00 00 
  800420ccc9:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420cccd:	0f be d0             	movsbl %al,%edx
  800420ccd0:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420ccd4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ccd8:	48 89 ce             	mov    %rcx,%rsi
  800420ccdb:	89 d7                	mov    %edx,%edi
  800420ccdd:	ff d0                	callq  *%rax
}
  800420ccdf:	48 83 c4 38          	add    $0x38,%rsp
  800420cce3:	5b                   	pop    %rbx
  800420cce4:	5d                   	pop    %rbp
  800420cce5:	c3                   	retq   

000000800420cce6 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800420cce6:	55                   	push   %rbp
  800420cce7:	48 89 e5             	mov    %rsp,%rbp
  800420ccea:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420ccee:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ccf2:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  800420ccf5:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420ccf9:	7e 52                	jle    800420cd4d <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  800420ccfb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ccff:	8b 00                	mov    (%rax),%eax
  800420cd01:	83 f8 30             	cmp    $0x30,%eax
  800420cd04:	73 24                	jae    800420cd2a <getuint+0x44>
  800420cd06:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cd0a:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420cd0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cd12:	8b 00                	mov    (%rax),%eax
  800420cd14:	89 c0                	mov    %eax,%eax
  800420cd16:	48 01 d0             	add    %rdx,%rax
  800420cd19:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cd1d:	8b 12                	mov    (%rdx),%edx
  800420cd1f:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420cd22:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cd26:	89 0a                	mov    %ecx,(%rdx)
  800420cd28:	eb 17                	jmp    800420cd41 <getuint+0x5b>
  800420cd2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cd2e:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420cd32:	48 89 d0             	mov    %rdx,%rax
  800420cd35:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420cd39:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cd3d:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420cd41:	48 8b 00             	mov    (%rax),%rax
  800420cd44:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420cd48:	e9 a3 00 00 00       	jmpq   800420cdf0 <getuint+0x10a>
	else if (lflag)
  800420cd4d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420cd51:	74 4f                	je     800420cda2 <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  800420cd53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cd57:	8b 00                	mov    (%rax),%eax
  800420cd59:	83 f8 30             	cmp    $0x30,%eax
  800420cd5c:	73 24                	jae    800420cd82 <getuint+0x9c>
  800420cd5e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cd62:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420cd66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cd6a:	8b 00                	mov    (%rax),%eax
  800420cd6c:	89 c0                	mov    %eax,%eax
  800420cd6e:	48 01 d0             	add    %rdx,%rax
  800420cd71:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cd75:	8b 12                	mov    (%rdx),%edx
  800420cd77:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420cd7a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cd7e:	89 0a                	mov    %ecx,(%rdx)
  800420cd80:	eb 17                	jmp    800420cd99 <getuint+0xb3>
  800420cd82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cd86:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420cd8a:	48 89 d0             	mov    %rdx,%rax
  800420cd8d:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420cd91:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cd95:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420cd99:	48 8b 00             	mov    (%rax),%rax
  800420cd9c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420cda0:	eb 4e                	jmp    800420cdf0 <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  800420cda2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cda6:	8b 00                	mov    (%rax),%eax
  800420cda8:	83 f8 30             	cmp    $0x30,%eax
  800420cdab:	73 24                	jae    800420cdd1 <getuint+0xeb>
  800420cdad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cdb1:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420cdb5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cdb9:	8b 00                	mov    (%rax),%eax
  800420cdbb:	89 c0                	mov    %eax,%eax
  800420cdbd:	48 01 d0             	add    %rdx,%rax
  800420cdc0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cdc4:	8b 12                	mov    (%rdx),%edx
  800420cdc6:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420cdc9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cdcd:	89 0a                	mov    %ecx,(%rdx)
  800420cdcf:	eb 17                	jmp    800420cde8 <getuint+0x102>
  800420cdd1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cdd5:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420cdd9:	48 89 d0             	mov    %rdx,%rax
  800420cddc:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420cde0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cde4:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420cde8:	8b 00                	mov    (%rax),%eax
  800420cdea:	89 c0                	mov    %eax,%eax
  800420cdec:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420cdf0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420cdf4:	c9                   	leaveq 
  800420cdf5:	c3                   	retq   

000000800420cdf6 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800420cdf6:	55                   	push   %rbp
  800420cdf7:	48 89 e5             	mov    %rsp,%rbp
  800420cdfa:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420cdfe:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ce02:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  800420ce05:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420ce09:	7e 52                	jle    800420ce5d <getint+0x67>
		x=va_arg(*ap, long long);
  800420ce0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ce0f:	8b 00                	mov    (%rax),%eax
  800420ce11:	83 f8 30             	cmp    $0x30,%eax
  800420ce14:	73 24                	jae    800420ce3a <getint+0x44>
  800420ce16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ce1a:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ce1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ce22:	8b 00                	mov    (%rax),%eax
  800420ce24:	89 c0                	mov    %eax,%eax
  800420ce26:	48 01 d0             	add    %rdx,%rax
  800420ce29:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ce2d:	8b 12                	mov    (%rdx),%edx
  800420ce2f:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ce32:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ce36:	89 0a                	mov    %ecx,(%rdx)
  800420ce38:	eb 17                	jmp    800420ce51 <getint+0x5b>
  800420ce3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ce3e:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ce42:	48 89 d0             	mov    %rdx,%rax
  800420ce45:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ce49:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ce4d:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ce51:	48 8b 00             	mov    (%rax),%rax
  800420ce54:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ce58:	e9 a3 00 00 00       	jmpq   800420cf00 <getint+0x10a>
	else if (lflag)
  800420ce5d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420ce61:	74 4f                	je     800420ceb2 <getint+0xbc>
		x=va_arg(*ap, long);
  800420ce63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ce67:	8b 00                	mov    (%rax),%eax
  800420ce69:	83 f8 30             	cmp    $0x30,%eax
  800420ce6c:	73 24                	jae    800420ce92 <getint+0x9c>
  800420ce6e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ce72:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ce76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ce7a:	8b 00                	mov    (%rax),%eax
  800420ce7c:	89 c0                	mov    %eax,%eax
  800420ce7e:	48 01 d0             	add    %rdx,%rax
  800420ce81:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ce85:	8b 12                	mov    (%rdx),%edx
  800420ce87:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ce8a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ce8e:	89 0a                	mov    %ecx,(%rdx)
  800420ce90:	eb 17                	jmp    800420cea9 <getint+0xb3>
  800420ce92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ce96:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ce9a:	48 89 d0             	mov    %rdx,%rax
  800420ce9d:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420cea1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cea5:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420cea9:	48 8b 00             	mov    (%rax),%rax
  800420ceac:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ceb0:	eb 4e                	jmp    800420cf00 <getint+0x10a>
	else
		x=va_arg(*ap, int);
  800420ceb2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ceb6:	8b 00                	mov    (%rax),%eax
  800420ceb8:	83 f8 30             	cmp    $0x30,%eax
  800420cebb:	73 24                	jae    800420cee1 <getint+0xeb>
  800420cebd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cec1:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420cec5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cec9:	8b 00                	mov    (%rax),%eax
  800420cecb:	89 c0                	mov    %eax,%eax
  800420cecd:	48 01 d0             	add    %rdx,%rax
  800420ced0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ced4:	8b 12                	mov    (%rdx),%edx
  800420ced6:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ced9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cedd:	89 0a                	mov    %ecx,(%rdx)
  800420cedf:	eb 17                	jmp    800420cef8 <getint+0x102>
  800420cee1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cee5:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420cee9:	48 89 d0             	mov    %rdx,%rax
  800420ceec:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420cef0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cef4:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420cef8:	8b 00                	mov    (%rax),%eax
  800420cefa:	48 98                	cltq   
  800420cefc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420cf00:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420cf04:	c9                   	leaveq 
  800420cf05:	c3                   	retq   

000000800420cf06 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800420cf06:	55                   	push   %rbp
  800420cf07:	48 89 e5             	mov    %rsp,%rbp
  800420cf0a:	41 54                	push   %r12
  800420cf0c:	53                   	push   %rbx
  800420cf0d:	48 83 ec 60          	sub    $0x60,%rsp
  800420cf11:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420cf15:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420cf19:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420cf1d:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  800420cf21:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420cf25:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420cf29:	48 8b 0a             	mov    (%rdx),%rcx
  800420cf2c:	48 89 08             	mov    %rcx,(%rax)
  800420cf2f:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420cf33:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420cf37:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420cf3b:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420cf3f:	eb 17                	jmp    800420cf58 <vprintfmt+0x52>
			if (ch == '\0')
  800420cf41:	85 db                	test   %ebx,%ebx
  800420cf43:	0f 84 cc 04 00 00    	je     800420d415 <vprintfmt+0x50f>
				return;
			putch(ch, putdat);
  800420cf49:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420cf4d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420cf51:	48 89 d6             	mov    %rdx,%rsi
  800420cf54:	89 df                	mov    %ebx,%edi
  800420cf56:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420cf58:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420cf5c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420cf60:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420cf64:	0f b6 00             	movzbl (%rax),%eax
  800420cf67:	0f b6 d8             	movzbl %al,%ebx
  800420cf6a:	83 fb 25             	cmp    $0x25,%ebx
  800420cf6d:	75 d2                	jne    800420cf41 <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  800420cf6f:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  800420cf73:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  800420cf7a:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  800420cf81:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  800420cf88:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800420cf8f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420cf93:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420cf97:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420cf9b:	0f b6 00             	movzbl (%rax),%eax
  800420cf9e:	0f b6 d8             	movzbl %al,%ebx
  800420cfa1:	8d 43 dd             	lea    -0x23(%rbx),%eax
  800420cfa4:	83 f8 55             	cmp    $0x55,%eax
  800420cfa7:	0f 87 34 04 00 00    	ja     800420d3e1 <vprintfmt+0x4db>
  800420cfad:	89 c0                	mov    %eax,%eax
  800420cfaf:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420cfb6:	00 
  800420cfb7:	48 b8 18 78 21 04 80 	movabs $0x8004217818,%rax
  800420cfbe:	00 00 00 
  800420cfc1:	48 01 d0             	add    %rdx,%rax
  800420cfc4:	48 8b 00             	mov    (%rax),%rax
  800420cfc7:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  800420cfc9:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  800420cfcd:	eb c0                	jmp    800420cf8f <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800420cfcf:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  800420cfd3:	eb ba                	jmp    800420cf8f <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420cfd5:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  800420cfdc:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420cfdf:	89 d0                	mov    %edx,%eax
  800420cfe1:	c1 e0 02             	shl    $0x2,%eax
  800420cfe4:	01 d0                	add    %edx,%eax
  800420cfe6:	01 c0                	add    %eax,%eax
  800420cfe8:	01 d8                	add    %ebx,%eax
  800420cfea:	83 e8 30             	sub    $0x30,%eax
  800420cfed:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  800420cff0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420cff4:	0f b6 00             	movzbl (%rax),%eax
  800420cff7:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  800420cffa:	83 fb 2f             	cmp    $0x2f,%ebx
  800420cffd:	7e 0c                	jle    800420d00b <vprintfmt+0x105>
  800420cfff:	83 fb 39             	cmp    $0x39,%ebx
  800420d002:	7f 07                	jg     800420d00b <vprintfmt+0x105>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420d004:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  800420d009:	eb d1                	jmp    800420cfdc <vprintfmt+0xd6>
			goto process_precision;
  800420d00b:	eb 58                	jmp    800420d065 <vprintfmt+0x15f>

		case '*':
			precision = va_arg(aq, int);
  800420d00d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420d010:	83 f8 30             	cmp    $0x30,%eax
  800420d013:	73 17                	jae    800420d02c <vprintfmt+0x126>
  800420d015:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420d019:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420d01c:	89 c0                	mov    %eax,%eax
  800420d01e:	48 01 d0             	add    %rdx,%rax
  800420d021:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420d024:	83 c2 08             	add    $0x8,%edx
  800420d027:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420d02a:	eb 0f                	jmp    800420d03b <vprintfmt+0x135>
  800420d02c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420d030:	48 89 d0             	mov    %rdx,%rax
  800420d033:	48 83 c2 08          	add    $0x8,%rdx
  800420d037:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420d03b:	8b 00                	mov    (%rax),%eax
  800420d03d:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  800420d040:	eb 23                	jmp    800420d065 <vprintfmt+0x15f>

		case '.':
			if (width < 0)
  800420d042:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420d046:	79 0c                	jns    800420d054 <vprintfmt+0x14e>
				width = 0;
  800420d048:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  800420d04f:	e9 3b ff ff ff       	jmpq   800420cf8f <vprintfmt+0x89>
  800420d054:	e9 36 ff ff ff       	jmpq   800420cf8f <vprintfmt+0x89>

		case '#':
			altflag = 1;
  800420d059:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  800420d060:	e9 2a ff ff ff       	jmpq   800420cf8f <vprintfmt+0x89>

		process_precision:
			if (width < 0)
  800420d065:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420d069:	79 12                	jns    800420d07d <vprintfmt+0x177>
				width = precision, precision = -1;
  800420d06b:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420d06e:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420d071:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  800420d078:	e9 12 ff ff ff       	jmpq   800420cf8f <vprintfmt+0x89>
  800420d07d:	e9 0d ff ff ff       	jmpq   800420cf8f <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  800420d082:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  800420d086:	e9 04 ff ff ff       	jmpq   800420cf8f <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  800420d08b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420d08e:	83 f8 30             	cmp    $0x30,%eax
  800420d091:	73 17                	jae    800420d0aa <vprintfmt+0x1a4>
  800420d093:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420d097:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420d09a:	89 c0                	mov    %eax,%eax
  800420d09c:	48 01 d0             	add    %rdx,%rax
  800420d09f:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420d0a2:	83 c2 08             	add    $0x8,%edx
  800420d0a5:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420d0a8:	eb 0f                	jmp    800420d0b9 <vprintfmt+0x1b3>
  800420d0aa:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420d0ae:	48 89 d0             	mov    %rdx,%rax
  800420d0b1:	48 83 c2 08          	add    $0x8,%rdx
  800420d0b5:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420d0b9:	8b 10                	mov    (%rax),%edx
  800420d0bb:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420d0bf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d0c3:	48 89 ce             	mov    %rcx,%rsi
  800420d0c6:	89 d7                	mov    %edx,%edi
  800420d0c8:	ff d0                	callq  *%rax
			break;
  800420d0ca:	e9 40 03 00 00       	jmpq   800420d40f <vprintfmt+0x509>

			// error message
		case 'e':
			err = va_arg(aq, int);
  800420d0cf:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420d0d2:	83 f8 30             	cmp    $0x30,%eax
  800420d0d5:	73 17                	jae    800420d0ee <vprintfmt+0x1e8>
  800420d0d7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420d0db:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420d0de:	89 c0                	mov    %eax,%eax
  800420d0e0:	48 01 d0             	add    %rdx,%rax
  800420d0e3:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420d0e6:	83 c2 08             	add    $0x8,%edx
  800420d0e9:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420d0ec:	eb 0f                	jmp    800420d0fd <vprintfmt+0x1f7>
  800420d0ee:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420d0f2:	48 89 d0             	mov    %rdx,%rax
  800420d0f5:	48 83 c2 08          	add    $0x8,%rdx
  800420d0f9:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420d0fd:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  800420d0ff:	85 db                	test   %ebx,%ebx
  800420d101:	79 02                	jns    800420d105 <vprintfmt+0x1ff>
				err = -err;
  800420d103:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800420d105:	83 fb 15             	cmp    $0x15,%ebx
  800420d108:	7f 16                	jg     800420d120 <vprintfmt+0x21a>
  800420d10a:	48 b8 40 77 21 04 80 	movabs $0x8004217740,%rax
  800420d111:	00 00 00 
  800420d114:	48 63 d3             	movslq %ebx,%rdx
  800420d117:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  800420d11b:	4d 85 e4             	test   %r12,%r12
  800420d11e:	75 2e                	jne    800420d14e <vprintfmt+0x248>
				printfmt(putch, putdat, "error %d", err);
  800420d120:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420d124:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d128:	89 d9                	mov    %ebx,%ecx
  800420d12a:	48 ba 01 78 21 04 80 	movabs $0x8004217801,%rdx
  800420d131:	00 00 00 
  800420d134:	48 89 c7             	mov    %rax,%rdi
  800420d137:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d13c:	49 b8 1e d4 20 04 80 	movabs $0x800420d41e,%r8
  800420d143:	00 00 00 
  800420d146:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  800420d149:	e9 c1 02 00 00       	jmpq   800420d40f <vprintfmt+0x509>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800420d14e:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420d152:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d156:	4c 89 e1             	mov    %r12,%rcx
  800420d159:	48 ba 0a 78 21 04 80 	movabs $0x800421780a,%rdx
  800420d160:	00 00 00 
  800420d163:	48 89 c7             	mov    %rax,%rdi
  800420d166:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d16b:	49 b8 1e d4 20 04 80 	movabs $0x800420d41e,%r8
  800420d172:	00 00 00 
  800420d175:	41 ff d0             	callq  *%r8
			break;
  800420d178:	e9 92 02 00 00       	jmpq   800420d40f <vprintfmt+0x509>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  800420d17d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420d180:	83 f8 30             	cmp    $0x30,%eax
  800420d183:	73 17                	jae    800420d19c <vprintfmt+0x296>
  800420d185:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420d189:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420d18c:	89 c0                	mov    %eax,%eax
  800420d18e:	48 01 d0             	add    %rdx,%rax
  800420d191:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420d194:	83 c2 08             	add    $0x8,%edx
  800420d197:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420d19a:	eb 0f                	jmp    800420d1ab <vprintfmt+0x2a5>
  800420d19c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420d1a0:	48 89 d0             	mov    %rdx,%rax
  800420d1a3:	48 83 c2 08          	add    $0x8,%rdx
  800420d1a7:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420d1ab:	4c 8b 20             	mov    (%rax),%r12
  800420d1ae:	4d 85 e4             	test   %r12,%r12
  800420d1b1:	75 0a                	jne    800420d1bd <vprintfmt+0x2b7>
				p = "(null)";
  800420d1b3:	49 bc 0d 78 21 04 80 	movabs $0x800421780d,%r12
  800420d1ba:	00 00 00 
			if (width > 0 && padc != '-')
  800420d1bd:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420d1c1:	7e 3f                	jle    800420d202 <vprintfmt+0x2fc>
  800420d1c3:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  800420d1c7:	74 39                	je     800420d202 <vprintfmt+0x2fc>
				for (width -= strnlen(p, precision); width > 0; width--)
  800420d1c9:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420d1cc:	48 98                	cltq   
  800420d1ce:	48 89 c6             	mov    %rax,%rsi
  800420d1d1:	4c 89 e7             	mov    %r12,%rdi
  800420d1d4:	48 b8 1f d8 20 04 80 	movabs $0x800420d81f,%rax
  800420d1db:	00 00 00 
  800420d1de:	ff d0                	callq  *%rax
  800420d1e0:	29 45 dc             	sub    %eax,-0x24(%rbp)
  800420d1e3:	eb 17                	jmp    800420d1fc <vprintfmt+0x2f6>
					putch(padc, putdat);
  800420d1e5:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  800420d1e9:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420d1ed:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d1f1:	48 89 ce             	mov    %rcx,%rsi
  800420d1f4:	89 d7                	mov    %edx,%edi
  800420d1f6:	ff d0                	callq  *%rax
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800420d1f8:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420d1fc:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420d200:	7f e3                	jg     800420d1e5 <vprintfmt+0x2df>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420d202:	eb 37                	jmp    800420d23b <vprintfmt+0x335>
				if (altflag && (ch < ' ' || ch > '~'))
  800420d204:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  800420d208:	74 1e                	je     800420d228 <vprintfmt+0x322>
  800420d20a:	83 fb 1f             	cmp    $0x1f,%ebx
  800420d20d:	7e 05                	jle    800420d214 <vprintfmt+0x30e>
  800420d20f:	83 fb 7e             	cmp    $0x7e,%ebx
  800420d212:	7e 14                	jle    800420d228 <vprintfmt+0x322>
					putch('?', putdat);
  800420d214:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420d218:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d21c:	48 89 d6             	mov    %rdx,%rsi
  800420d21f:	bf 3f 00 00 00       	mov    $0x3f,%edi
  800420d224:	ff d0                	callq  *%rax
  800420d226:	eb 0f                	jmp    800420d237 <vprintfmt+0x331>
				else
					putch(ch, putdat);
  800420d228:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420d22c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d230:	48 89 d6             	mov    %rdx,%rsi
  800420d233:	89 df                	mov    %ebx,%edi
  800420d235:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420d237:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420d23b:	4c 89 e0             	mov    %r12,%rax
  800420d23e:	4c 8d 60 01          	lea    0x1(%rax),%r12
  800420d242:	0f b6 00             	movzbl (%rax),%eax
  800420d245:	0f be d8             	movsbl %al,%ebx
  800420d248:	85 db                	test   %ebx,%ebx
  800420d24a:	74 10                	je     800420d25c <vprintfmt+0x356>
  800420d24c:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420d250:	78 b2                	js     800420d204 <vprintfmt+0x2fe>
  800420d252:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  800420d256:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420d25a:	79 a8                	jns    800420d204 <vprintfmt+0x2fe>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420d25c:	eb 16                	jmp    800420d274 <vprintfmt+0x36e>
				putch(' ', putdat);
  800420d25e:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420d262:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d266:	48 89 d6             	mov    %rdx,%rsi
  800420d269:	bf 20 00 00 00       	mov    $0x20,%edi
  800420d26e:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420d270:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420d274:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420d278:	7f e4                	jg     800420d25e <vprintfmt+0x358>
				putch(' ', putdat);
			break;
  800420d27a:	e9 90 01 00 00       	jmpq   800420d40f <vprintfmt+0x509>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  800420d27f:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420d283:	be 03 00 00 00       	mov    $0x3,%esi
  800420d288:	48 89 c7             	mov    %rax,%rdi
  800420d28b:	48 b8 f6 cd 20 04 80 	movabs $0x800420cdf6,%rax
  800420d292:	00 00 00 
  800420d295:	ff d0                	callq  *%rax
  800420d297:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800420d29b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d29f:	48 85 c0             	test   %rax,%rax
  800420d2a2:	79 1d                	jns    800420d2c1 <vprintfmt+0x3bb>
				putch('-', putdat);
  800420d2a4:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420d2a8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d2ac:	48 89 d6             	mov    %rdx,%rsi
  800420d2af:	bf 2d 00 00 00       	mov    $0x2d,%edi
  800420d2b4:	ff d0                	callq  *%rax
				num = -(long long) num;
  800420d2b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d2ba:	48 f7 d8             	neg    %rax
  800420d2bd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  800420d2c1:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420d2c8:	e9 d5 00 00 00       	jmpq   800420d3a2 <vprintfmt+0x49c>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  800420d2cd:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420d2d1:	be 03 00 00 00       	mov    $0x3,%esi
  800420d2d6:	48 89 c7             	mov    %rax,%rdi
  800420d2d9:	48 b8 e6 cc 20 04 80 	movabs $0x800420cce6,%rax
  800420d2e0:	00 00 00 
  800420d2e3:	ff d0                	callq  *%rax
  800420d2e5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  800420d2e9:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420d2f0:	e9 ad 00 00 00       	jmpq   800420d3a2 <vprintfmt+0x49c>

			// (unsigned) octal
		case 'o':
			// Replace this with your code.
      num = getuint(&aq, 3);
  800420d2f5:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420d2f9:	be 03 00 00 00       	mov    $0x3,%esi
  800420d2fe:	48 89 c7             	mov    %rax,%rdi
  800420d301:	48 b8 e6 cc 20 04 80 	movabs $0x800420cce6,%rax
  800420d308:	00 00 00 
  800420d30b:	ff d0                	callq  *%rax
  800420d30d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      base = 8;
  800420d311:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
      goto number;
  800420d318:	e9 85 00 00 00       	jmpq   800420d3a2 <vprintfmt+0x49c>

			// pointer
		case 'p':
			putch('0', putdat);
  800420d31d:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420d321:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d325:	48 89 d6             	mov    %rdx,%rsi
  800420d328:	bf 30 00 00 00       	mov    $0x30,%edi
  800420d32d:	ff d0                	callq  *%rax
			putch('x', putdat);
  800420d32f:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420d333:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d337:	48 89 d6             	mov    %rdx,%rsi
  800420d33a:	bf 78 00 00 00       	mov    $0x78,%edi
  800420d33f:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  800420d341:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420d344:	83 f8 30             	cmp    $0x30,%eax
  800420d347:	73 17                	jae    800420d360 <vprintfmt+0x45a>
  800420d349:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420d34d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420d350:	89 c0                	mov    %eax,%eax
  800420d352:	48 01 d0             	add    %rdx,%rax
  800420d355:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420d358:	83 c2 08             	add    $0x8,%edx
  800420d35b:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420d35e:	eb 0f                	jmp    800420d36f <vprintfmt+0x469>
				(uintptr_t) va_arg(aq, void *);
  800420d360:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420d364:	48 89 d0             	mov    %rdx,%rax
  800420d367:	48 83 c2 08          	add    $0x8,%rdx
  800420d36b:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420d36f:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420d372:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  800420d376:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  800420d37d:	eb 23                	jmp    800420d3a2 <vprintfmt+0x49c>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  800420d37f:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420d383:	be 03 00 00 00       	mov    $0x3,%esi
  800420d388:	48 89 c7             	mov    %rax,%rdi
  800420d38b:	48 b8 e6 cc 20 04 80 	movabs $0x800420cce6,%rax
  800420d392:	00 00 00 
  800420d395:	ff d0                	callq  *%rax
  800420d397:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  800420d39b:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  800420d3a2:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  800420d3a7:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420d3aa:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800420d3ad:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d3b1:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420d3b5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d3b9:	45 89 c1             	mov    %r8d,%r9d
  800420d3bc:	41 89 f8             	mov    %edi,%r8d
  800420d3bf:	48 89 c7             	mov    %rax,%rdi
  800420d3c2:	48 b8 2b cc 20 04 80 	movabs $0x800420cc2b,%rax
  800420d3c9:	00 00 00 
  800420d3cc:	ff d0                	callq  *%rax
			break;
  800420d3ce:	eb 3f                	jmp    800420d40f <vprintfmt+0x509>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  800420d3d0:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420d3d4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d3d8:	48 89 d6             	mov    %rdx,%rsi
  800420d3db:	89 df                	mov    %ebx,%edi
  800420d3dd:	ff d0                	callq  *%rax
			break;
  800420d3df:	eb 2e                	jmp    800420d40f <vprintfmt+0x509>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800420d3e1:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420d3e5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d3e9:	48 89 d6             	mov    %rdx,%rsi
  800420d3ec:	bf 25 00 00 00       	mov    $0x25,%edi
  800420d3f1:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  800420d3f3:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420d3f8:	eb 05                	jmp    800420d3ff <vprintfmt+0x4f9>
  800420d3fa:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420d3ff:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420d403:	48 83 e8 01          	sub    $0x1,%rax
  800420d407:	0f b6 00             	movzbl (%rax),%eax
  800420d40a:	3c 25                	cmp    $0x25,%al
  800420d40c:	75 ec                	jne    800420d3fa <vprintfmt+0x4f4>
				/* do nothing */;
			break;
  800420d40e:	90                   	nop
		}
	}
  800420d40f:	90                   	nop
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420d410:	e9 43 fb ff ff       	jmpq   800420cf58 <vprintfmt+0x52>
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  800420d415:	48 83 c4 60          	add    $0x60,%rsp
  800420d419:	5b                   	pop    %rbx
  800420d41a:	41 5c                	pop    %r12
  800420d41c:	5d                   	pop    %rbp
  800420d41d:	c3                   	retq   

000000800420d41e <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800420d41e:	55                   	push   %rbp
  800420d41f:	48 89 e5             	mov    %rsp,%rbp
  800420d422:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420d429:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420d430:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  800420d437:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420d43e:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420d445:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420d44c:	84 c0                	test   %al,%al
  800420d44e:	74 20                	je     800420d470 <printfmt+0x52>
  800420d450:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420d454:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420d458:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420d45c:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420d460:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420d464:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420d468:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420d46c:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420d470:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420d477:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420d47e:	00 00 00 
  800420d481:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420d488:	00 00 00 
  800420d48b:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420d48f:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420d496:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420d49d:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  800420d4a4:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  800420d4ab:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420d4b2:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420d4b9:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420d4c0:	48 89 c7             	mov    %rax,%rdi
  800420d4c3:	48 b8 06 cf 20 04 80 	movabs $0x800420cf06,%rax
  800420d4ca:	00 00 00 
  800420d4cd:	ff d0                	callq  *%rax
	va_end(ap);
}
  800420d4cf:	c9                   	leaveq 
  800420d4d0:	c3                   	retq   

000000800420d4d1 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800420d4d1:	55                   	push   %rbp
  800420d4d2:	48 89 e5             	mov    %rsp,%rbp
  800420d4d5:	48 83 ec 10          	sub    $0x10,%rsp
  800420d4d9:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420d4dc:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  800420d4e0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d4e4:	8b 40 10             	mov    0x10(%rax),%eax
  800420d4e7:	8d 50 01             	lea    0x1(%rax),%edx
  800420d4ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d4ee:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  800420d4f1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d4f5:	48 8b 10             	mov    (%rax),%rdx
  800420d4f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d4fc:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420d500:	48 39 c2             	cmp    %rax,%rdx
  800420d503:	73 17                	jae    800420d51c <sprintputch+0x4b>
		*b->buf++ = ch;
  800420d505:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d509:	48 8b 00             	mov    (%rax),%rax
  800420d50c:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800420d510:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d514:	48 89 0a             	mov    %rcx,(%rdx)
  800420d517:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420d51a:	88 10                	mov    %dl,(%rax)
}
  800420d51c:	c9                   	leaveq 
  800420d51d:	c3                   	retq   

000000800420d51e <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  800420d51e:	55                   	push   %rbp
  800420d51f:	48 89 e5             	mov    %rsp,%rbp
  800420d522:	48 83 ec 50          	sub    $0x50,%rsp
  800420d526:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420d52a:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800420d52d:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420d531:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  800420d535:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420d539:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420d53d:	48 8b 0a             	mov    (%rdx),%rcx
  800420d540:	48 89 08             	mov    %rcx,(%rax)
  800420d543:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420d547:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420d54b:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420d54f:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  800420d553:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d557:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420d55b:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420d55e:	48 98                	cltq   
  800420d560:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420d564:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d568:	48 01 d0             	add    %rdx,%rax
  800420d56b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420d56f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  800420d576:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420d57b:	74 06                	je     800420d583 <vsnprintf+0x65>
  800420d57d:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800420d581:	7f 07                	jg     800420d58a <vsnprintf+0x6c>
		return -E_INVAL;
  800420d583:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d588:	eb 2f                	jmp    800420d5b9 <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  800420d58a:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420d58e:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420d592:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800420d596:	48 89 c6             	mov    %rax,%rsi
  800420d599:	48 bf d1 d4 20 04 80 	movabs $0x800420d4d1,%rdi
  800420d5a0:	00 00 00 
  800420d5a3:	48 b8 06 cf 20 04 80 	movabs $0x800420cf06,%rax
  800420d5aa:	00 00 00 
  800420d5ad:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  800420d5af:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d5b3:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  800420d5b6:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  800420d5b9:	c9                   	leaveq 
  800420d5ba:	c3                   	retq   

000000800420d5bb <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  800420d5bb:	55                   	push   %rbp
  800420d5bc:	48 89 e5             	mov    %rsp,%rbp
  800420d5bf:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800420d5c6:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  800420d5cd:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  800420d5d3:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420d5da:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420d5e1:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420d5e8:	84 c0                	test   %al,%al
  800420d5ea:	74 20                	je     800420d60c <snprintf+0x51>
  800420d5ec:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420d5f0:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420d5f4:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420d5f8:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420d5fc:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420d600:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420d604:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420d608:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420d60c:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  800420d613:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  800420d61a:	00 00 00 
  800420d61d:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  800420d624:	00 00 00 
  800420d627:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420d62b:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  800420d632:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420d639:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  800420d640:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420d647:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420d64e:	48 8b 0a             	mov    (%rdx),%rcx
  800420d651:	48 89 08             	mov    %rcx,(%rax)
  800420d654:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420d658:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420d65c:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420d660:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  800420d664:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  800420d66b:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  800420d672:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  800420d678:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420d67f:	48 89 c7             	mov    %rax,%rdi
  800420d682:	48 b8 1e d5 20 04 80 	movabs $0x800420d51e,%rax
  800420d689:	00 00 00 
  800420d68c:	ff d0                	callq  *%rax
  800420d68e:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  800420d694:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  800420d69a:	c9                   	leaveq 
  800420d69b:	c3                   	retq   

000000800420d69c <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  800420d69c:	55                   	push   %rbp
  800420d69d:	48 89 e5             	mov    %rsp,%rbp
  800420d6a0:	48 83 ec 20          	sub    $0x20,%rsp
  800420d6a4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;

#if JOS_KERNEL
	if (prompt != NULL)
  800420d6a8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d6ad:	74 22                	je     800420d6d1 <readline+0x35>
		cprintf("%s", prompt);
  800420d6af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d6b3:	48 89 c6             	mov    %rax,%rsi
  800420d6b6:	48 bf c8 7a 21 04 80 	movabs $0x8004217ac8,%rdi
  800420d6bd:	00 00 00 
  800420d6c0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d6c5:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420d6cc:	00 00 00 
  800420d6cf:	ff d2                	callq  *%rdx
#else
	if (prompt != NULL)
		fprintf(1, "%s", prompt);
#endif

	i = 0;
  800420d6d1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  800420d6d8:	bf 00 00 00 00       	mov    $0x0,%edi
  800420d6dd:	48 b8 18 12 20 04 80 	movabs $0x8004201218,%rax
  800420d6e4:	00 00 00 
  800420d6e7:	ff d0                	callq  *%rax
  800420d6e9:	89 45 f8             	mov    %eax,-0x8(%rbp)
	while (1) {
		c = getchar();
  800420d6ec:	48 b8 f6 11 20 04 80 	movabs $0x80042011f6,%rax
  800420d6f3:	00 00 00 
  800420d6f6:	ff d0                	callq  *%rax
  800420d6f8:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  800420d6fb:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420d6ff:	79 30                	jns    800420d731 <readline+0x95>
			if (c != -E_EOF)
  800420d701:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%rbp)
  800420d705:	74 20                	je     800420d727 <readline+0x8b>
				cprintf("read error: %e\n", c);
  800420d707:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420d70a:	89 c6                	mov    %eax,%esi
  800420d70c:	48 bf cb 7a 21 04 80 	movabs $0x8004217acb,%rdi
  800420d713:	00 00 00 
  800420d716:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d71b:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800420d722:	00 00 00 
  800420d725:	ff d2                	callq  *%rdx
			return NULL;
  800420d727:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d72c:	e9 be 00 00 00       	jmpq   800420d7ef <readline+0x153>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  800420d731:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  800420d735:	74 06                	je     800420d73d <readline+0xa1>
  800420d737:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  800420d73b:	75 26                	jne    800420d763 <readline+0xc7>
  800420d73d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d741:	7e 20                	jle    800420d763 <readline+0xc7>
			if (echoing)
  800420d743:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420d747:	74 11                	je     800420d75a <readline+0xbe>
				cputchar('\b');
  800420d749:	bf 08 00 00 00       	mov    $0x8,%edi
  800420d74e:	48 b8 d8 11 20 04 80 	movabs $0x80042011d8,%rax
  800420d755:	00 00 00 
  800420d758:	ff d0                	callq  *%rax
			i--;
  800420d75a:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  800420d75e:	e9 87 00 00 00       	jmpq   800420d7ea <readline+0x14e>
		} else if (c >= ' ' && i < BUFLEN-1) {
  800420d763:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420d767:	7e 3f                	jle    800420d7a8 <readline+0x10c>
  800420d769:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  800420d770:	7f 36                	jg     800420d7a8 <readline+0x10c>
			if (echoing)
  800420d772:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420d776:	74 11                	je     800420d789 <readline+0xed>
				cputchar(c);
  800420d778:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420d77b:	89 c7                	mov    %eax,%edi
  800420d77d:	48 b8 d8 11 20 04 80 	movabs $0x80042011d8,%rax
  800420d784:	00 00 00 
  800420d787:	ff d0                	callq  *%rax
			buf[i++] = c;
  800420d789:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d78c:	8d 50 01             	lea    0x1(%rax),%edx
  800420d78f:	89 55 fc             	mov    %edx,-0x4(%rbp)
  800420d792:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420d795:	89 d1                	mov    %edx,%ecx
  800420d797:	48 ba a0 e2 49 04 80 	movabs $0x800449e2a0,%rdx
  800420d79e:	00 00 00 
  800420d7a1:	48 98                	cltq   
  800420d7a3:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  800420d7a6:	eb 42                	jmp    800420d7ea <readline+0x14e>
		} else if (c == '\n' || c == '\r') {
  800420d7a8:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  800420d7ac:	74 06                	je     800420d7b4 <readline+0x118>
  800420d7ae:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  800420d7b2:	75 36                	jne    800420d7ea <readline+0x14e>
			if (echoing)
  800420d7b4:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420d7b8:	74 11                	je     800420d7cb <readline+0x12f>
				cputchar('\n');
  800420d7ba:	bf 0a 00 00 00       	mov    $0xa,%edi
  800420d7bf:	48 b8 d8 11 20 04 80 	movabs $0x80042011d8,%rax
  800420d7c6:	00 00 00 
  800420d7c9:	ff d0                	callq  *%rax
			buf[i] = 0;
  800420d7cb:	48 ba a0 e2 49 04 80 	movabs $0x800449e2a0,%rdx
  800420d7d2:	00 00 00 
  800420d7d5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d7d8:	48 98                	cltq   
  800420d7da:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  800420d7de:	48 b8 a0 e2 49 04 80 	movabs $0x800449e2a0,%rax
  800420d7e5:	00 00 00 
  800420d7e8:	eb 05                	jmp    800420d7ef <readline+0x153>
		}
	}
  800420d7ea:	e9 fd fe ff ff       	jmpq   800420d6ec <readline+0x50>
}
  800420d7ef:	c9                   	leaveq 
  800420d7f0:	c3                   	retq   

000000800420d7f1 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  800420d7f1:	55                   	push   %rbp
  800420d7f2:	48 89 e5             	mov    %rsp,%rbp
  800420d7f5:	48 83 ec 18          	sub    $0x18,%rsp
  800420d7f9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  800420d7fd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420d804:	eb 09                	jmp    800420d80f <strlen+0x1e>
		n++;
  800420d806:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  800420d80a:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420d80f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d813:	0f b6 00             	movzbl (%rax),%eax
  800420d816:	84 c0                	test   %al,%al
  800420d818:	75 ec                	jne    800420d806 <strlen+0x15>
		n++;
	return n;
  800420d81a:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420d81d:	c9                   	leaveq 
  800420d81e:	c3                   	retq   

000000800420d81f <strnlen>:

int
strnlen(const char *s, size_t size)
{
  800420d81f:	55                   	push   %rbp
  800420d820:	48 89 e5             	mov    %rsp,%rbp
  800420d823:	48 83 ec 20          	sub    $0x20,%rsp
  800420d827:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d82b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420d82f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420d836:	eb 0e                	jmp    800420d846 <strnlen+0x27>
		n++;
  800420d838:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420d83c:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420d841:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  800420d846:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420d84b:	74 0b                	je     800420d858 <strnlen+0x39>
  800420d84d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d851:	0f b6 00             	movzbl (%rax),%eax
  800420d854:	84 c0                	test   %al,%al
  800420d856:	75 e0                	jne    800420d838 <strnlen+0x19>
		n++;
	return n;
  800420d858:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420d85b:	c9                   	leaveq 
  800420d85c:	c3                   	retq   

000000800420d85d <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  800420d85d:	55                   	push   %rbp
  800420d85e:	48 89 e5             	mov    %rsp,%rbp
  800420d861:	48 83 ec 20          	sub    $0x20,%rsp
  800420d865:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d869:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  800420d86d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d871:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  800420d875:	90                   	nop
  800420d876:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d87a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d87e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420d882:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d886:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420d88a:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420d88e:	0f b6 12             	movzbl (%rdx),%edx
  800420d891:	88 10                	mov    %dl,(%rax)
  800420d893:	0f b6 00             	movzbl (%rax),%eax
  800420d896:	84 c0                	test   %al,%al
  800420d898:	75 dc                	jne    800420d876 <strcpy+0x19>
		/* do nothing */;
	return ret;
  800420d89a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420d89e:	c9                   	leaveq 
  800420d89f:	c3                   	retq   

000000800420d8a0 <strcat>:

char *
strcat(char *dst, const char *src)
{
  800420d8a0:	55                   	push   %rbp
  800420d8a1:	48 89 e5             	mov    %rsp,%rbp
  800420d8a4:	48 83 ec 20          	sub    $0x20,%rsp
  800420d8a8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d8ac:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  800420d8b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d8b4:	48 89 c7             	mov    %rax,%rdi
  800420d8b7:	48 b8 f1 d7 20 04 80 	movabs $0x800420d7f1,%rax
  800420d8be:	00 00 00 
  800420d8c1:	ff d0                	callq  *%rax
  800420d8c3:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  800420d8c6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d8c9:	48 63 d0             	movslq %eax,%rdx
  800420d8cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d8d0:	48 01 c2             	add    %rax,%rdx
  800420d8d3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d8d7:	48 89 c6             	mov    %rax,%rsi
  800420d8da:	48 89 d7             	mov    %rdx,%rdi
  800420d8dd:	48 b8 5d d8 20 04 80 	movabs $0x800420d85d,%rax
  800420d8e4:	00 00 00 
  800420d8e7:	ff d0                	callq  *%rax
	return dst;
  800420d8e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420d8ed:	c9                   	leaveq 
  800420d8ee:	c3                   	retq   

000000800420d8ef <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  800420d8ef:	55                   	push   %rbp
  800420d8f0:	48 89 e5             	mov    %rsp,%rbp
  800420d8f3:	48 83 ec 28          	sub    $0x28,%rsp
  800420d8f7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d8fb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420d8ff:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  800420d903:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d907:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  800420d90b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420d912:	00 
  800420d913:	eb 2a                	jmp    800420d93f <strncpy+0x50>
		*dst++ = *src;
  800420d915:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d919:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d91d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420d921:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d925:	0f b6 12             	movzbl (%rdx),%edx
  800420d928:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  800420d92a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d92e:	0f b6 00             	movzbl (%rax),%eax
  800420d931:	84 c0                	test   %al,%al
  800420d933:	74 05                	je     800420d93a <strncpy+0x4b>
			src++;
  800420d935:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  800420d93a:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420d93f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d943:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420d947:	72 cc                	jb     800420d915 <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  800420d949:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420d94d:	c9                   	leaveq 
  800420d94e:	c3                   	retq   

000000800420d94f <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  800420d94f:	55                   	push   %rbp
  800420d950:	48 89 e5             	mov    %rsp,%rbp
  800420d953:	48 83 ec 28          	sub    $0x28,%rsp
  800420d957:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d95b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420d95f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  800420d963:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d967:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  800420d96b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420d970:	74 3d                	je     800420d9af <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  800420d972:	eb 1d                	jmp    800420d991 <strlcpy+0x42>
			*dst++ = *src++;
  800420d974:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d978:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d97c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420d980:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d984:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420d988:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420d98c:	0f b6 12             	movzbl (%rdx),%edx
  800420d98f:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  800420d991:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  800420d996:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420d99b:	74 0b                	je     800420d9a8 <strlcpy+0x59>
  800420d99d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d9a1:	0f b6 00             	movzbl (%rax),%eax
  800420d9a4:	84 c0                	test   %al,%al
  800420d9a6:	75 cc                	jne    800420d974 <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  800420d9a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d9ac:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  800420d9af:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d9b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d9b7:	48 29 c2             	sub    %rax,%rdx
  800420d9ba:	48 89 d0             	mov    %rdx,%rax
}
  800420d9bd:	c9                   	leaveq 
  800420d9be:	c3                   	retq   

000000800420d9bf <strcmp>:

int
strcmp(const char *p, const char *q)
{
  800420d9bf:	55                   	push   %rbp
  800420d9c0:	48 89 e5             	mov    %rsp,%rbp
  800420d9c3:	48 83 ec 10          	sub    $0x10,%rsp
  800420d9c7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420d9cb:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  800420d9cf:	eb 0a                	jmp    800420d9db <strcmp+0x1c>
		p++, q++;
  800420d9d1:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420d9d6:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  800420d9db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d9df:	0f b6 00             	movzbl (%rax),%eax
  800420d9e2:	84 c0                	test   %al,%al
  800420d9e4:	74 12                	je     800420d9f8 <strcmp+0x39>
  800420d9e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d9ea:	0f b6 10             	movzbl (%rax),%edx
  800420d9ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d9f1:	0f b6 00             	movzbl (%rax),%eax
  800420d9f4:	38 c2                	cmp    %al,%dl
  800420d9f6:	74 d9                	je     800420d9d1 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  800420d9f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d9fc:	0f b6 00             	movzbl (%rax),%eax
  800420d9ff:	0f b6 d0             	movzbl %al,%edx
  800420da02:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420da06:	0f b6 00             	movzbl (%rax),%eax
  800420da09:	0f b6 c0             	movzbl %al,%eax
  800420da0c:	29 c2                	sub    %eax,%edx
  800420da0e:	89 d0                	mov    %edx,%eax
}
  800420da10:	c9                   	leaveq 
  800420da11:	c3                   	retq   

000000800420da12 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  800420da12:	55                   	push   %rbp
  800420da13:	48 89 e5             	mov    %rsp,%rbp
  800420da16:	48 83 ec 18          	sub    $0x18,%rsp
  800420da1a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420da1e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420da22:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  800420da26:	eb 0f                	jmp    800420da37 <strncmp+0x25>
		n--, p++, q++;
  800420da28:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  800420da2d:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420da32:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  800420da37:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420da3c:	74 1d                	je     800420da5b <strncmp+0x49>
  800420da3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420da42:	0f b6 00             	movzbl (%rax),%eax
  800420da45:	84 c0                	test   %al,%al
  800420da47:	74 12                	je     800420da5b <strncmp+0x49>
  800420da49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420da4d:	0f b6 10             	movzbl (%rax),%edx
  800420da50:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420da54:	0f b6 00             	movzbl (%rax),%eax
  800420da57:	38 c2                	cmp    %al,%dl
  800420da59:	74 cd                	je     800420da28 <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  800420da5b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420da60:	75 07                	jne    800420da69 <strncmp+0x57>
		return 0;
  800420da62:	b8 00 00 00 00       	mov    $0x0,%eax
  800420da67:	eb 18                	jmp    800420da81 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  800420da69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420da6d:	0f b6 00             	movzbl (%rax),%eax
  800420da70:	0f b6 d0             	movzbl %al,%edx
  800420da73:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420da77:	0f b6 00             	movzbl (%rax),%eax
  800420da7a:	0f b6 c0             	movzbl %al,%eax
  800420da7d:	29 c2                	sub    %eax,%edx
  800420da7f:	89 d0                	mov    %edx,%eax
}
  800420da81:	c9                   	leaveq 
  800420da82:	c3                   	retq   

000000800420da83 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  800420da83:	55                   	push   %rbp
  800420da84:	48 89 e5             	mov    %rsp,%rbp
  800420da87:	48 83 ec 0c          	sub    $0xc,%rsp
  800420da8b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420da8f:	89 f0                	mov    %esi,%eax
  800420da91:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420da94:	eb 17                	jmp    800420daad <strchr+0x2a>
		if (*s == c)
  800420da96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420da9a:	0f b6 00             	movzbl (%rax),%eax
  800420da9d:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420daa0:	75 06                	jne    800420daa8 <strchr+0x25>
			return (char *) s;
  800420daa2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420daa6:	eb 15                	jmp    800420dabd <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  800420daa8:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420daad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dab1:	0f b6 00             	movzbl (%rax),%eax
  800420dab4:	84 c0                	test   %al,%al
  800420dab6:	75 de                	jne    800420da96 <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  800420dab8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420dabd:	c9                   	leaveq 
  800420dabe:	c3                   	retq   

000000800420dabf <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  800420dabf:	55                   	push   %rbp
  800420dac0:	48 89 e5             	mov    %rsp,%rbp
  800420dac3:	48 83 ec 0c          	sub    $0xc,%rsp
  800420dac7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420dacb:	89 f0                	mov    %esi,%eax
  800420dacd:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420dad0:	eb 13                	jmp    800420dae5 <strfind+0x26>
		if (*s == c)
  800420dad2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dad6:	0f b6 00             	movzbl (%rax),%eax
  800420dad9:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420dadc:	75 02                	jne    800420dae0 <strfind+0x21>
			break;
  800420dade:	eb 10                	jmp    800420daf0 <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  800420dae0:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420dae5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dae9:	0f b6 00             	movzbl (%rax),%eax
  800420daec:	84 c0                	test   %al,%al
  800420daee:	75 e2                	jne    800420dad2 <strfind+0x13>
		if (*s == c)
			break;
	return (char *) s;
  800420daf0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420daf4:	c9                   	leaveq 
  800420daf5:	c3                   	retq   

000000800420daf6 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  800420daf6:	55                   	push   %rbp
  800420daf7:	48 89 e5             	mov    %rsp,%rbp
  800420dafa:	48 83 ec 18          	sub    $0x18,%rsp
  800420dafe:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420db02:	89 75 f4             	mov    %esi,-0xc(%rbp)
  800420db05:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  800420db09:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420db0e:	75 06                	jne    800420db16 <memset+0x20>
		return v;
  800420db10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420db14:	eb 69                	jmp    800420db7f <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  800420db16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420db1a:	83 e0 03             	and    $0x3,%eax
  800420db1d:	48 85 c0             	test   %rax,%rax
  800420db20:	75 48                	jne    800420db6a <memset+0x74>
  800420db22:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420db26:	83 e0 03             	and    $0x3,%eax
  800420db29:	48 85 c0             	test   %rax,%rax
  800420db2c:	75 3c                	jne    800420db6a <memset+0x74>
		c &= 0xFF;
  800420db2e:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  800420db35:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420db38:	c1 e0 18             	shl    $0x18,%eax
  800420db3b:	89 c2                	mov    %eax,%edx
  800420db3d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420db40:	c1 e0 10             	shl    $0x10,%eax
  800420db43:	09 c2                	or     %eax,%edx
  800420db45:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420db48:	c1 e0 08             	shl    $0x8,%eax
  800420db4b:	09 d0                	or     %edx,%eax
  800420db4d:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  800420db50:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420db54:	48 c1 e8 02          	shr    $0x2,%rax
  800420db58:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  800420db5b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420db5f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420db62:	48 89 d7             	mov    %rdx,%rdi
  800420db65:	fc                   	cld    
  800420db66:	f3 ab                	rep stos %eax,%es:(%rdi)
  800420db68:	eb 11                	jmp    800420db7b <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  800420db6a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420db6e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420db71:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420db75:	48 89 d7             	mov    %rdx,%rdi
  800420db78:	fc                   	cld    
  800420db79:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  800420db7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420db7f:	c9                   	leaveq 
  800420db80:	c3                   	retq   

000000800420db81 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  800420db81:	55                   	push   %rbp
  800420db82:	48 89 e5             	mov    %rsp,%rbp
  800420db85:	48 83 ec 28          	sub    $0x28,%rsp
  800420db89:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420db8d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420db91:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  800420db95:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420db99:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  800420db9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dba1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  800420dba5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dba9:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420dbad:	0f 83 88 00 00 00    	jae    800420dc3b <memmove+0xba>
  800420dbb3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dbb7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420dbbb:	48 01 d0             	add    %rdx,%rax
  800420dbbe:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420dbc2:	76 77                	jbe    800420dc3b <memmove+0xba>
		s += n;
  800420dbc4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dbc8:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  800420dbcc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dbd0:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420dbd4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dbd8:	83 e0 03             	and    $0x3,%eax
  800420dbdb:	48 85 c0             	test   %rax,%rax
  800420dbde:	75 3b                	jne    800420dc1b <memmove+0x9a>
  800420dbe0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dbe4:	83 e0 03             	and    $0x3,%eax
  800420dbe7:	48 85 c0             	test   %rax,%rax
  800420dbea:	75 2f                	jne    800420dc1b <memmove+0x9a>
  800420dbec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dbf0:	83 e0 03             	and    $0x3,%eax
  800420dbf3:	48 85 c0             	test   %rax,%rax
  800420dbf6:	75 23                	jne    800420dc1b <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  800420dbf8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dbfc:	48 83 e8 04          	sub    $0x4,%rax
  800420dc00:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420dc04:	48 83 ea 04          	sub    $0x4,%rdx
  800420dc08:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420dc0c:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  800420dc10:	48 89 c7             	mov    %rax,%rdi
  800420dc13:	48 89 d6             	mov    %rdx,%rsi
  800420dc16:	fd                   	std    
  800420dc17:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420dc19:	eb 1d                	jmp    800420dc38 <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  800420dc1b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dc1f:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420dc23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dc27:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  800420dc2b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dc2f:	48 89 d7             	mov    %rdx,%rdi
  800420dc32:	48 89 c1             	mov    %rax,%rcx
  800420dc35:	fd                   	std    
  800420dc36:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  800420dc38:	fc                   	cld    
  800420dc39:	eb 57                	jmp    800420dc92 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420dc3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dc3f:	83 e0 03             	and    $0x3,%eax
  800420dc42:	48 85 c0             	test   %rax,%rax
  800420dc45:	75 36                	jne    800420dc7d <memmove+0xfc>
  800420dc47:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dc4b:	83 e0 03             	and    $0x3,%eax
  800420dc4e:	48 85 c0             	test   %rax,%rax
  800420dc51:	75 2a                	jne    800420dc7d <memmove+0xfc>
  800420dc53:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dc57:	83 e0 03             	and    $0x3,%eax
  800420dc5a:	48 85 c0             	test   %rax,%rax
  800420dc5d:	75 1e                	jne    800420dc7d <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  800420dc5f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dc63:	48 c1 e8 02          	shr    $0x2,%rax
  800420dc67:	48 89 c1             	mov    %rax,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  800420dc6a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dc6e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420dc72:	48 89 c7             	mov    %rax,%rdi
  800420dc75:	48 89 d6             	mov    %rdx,%rsi
  800420dc78:	fc                   	cld    
  800420dc79:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420dc7b:	eb 15                	jmp    800420dc92 <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  800420dc7d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dc81:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420dc85:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420dc89:	48 89 c7             	mov    %rax,%rdi
  800420dc8c:	48 89 d6             	mov    %rdx,%rsi
  800420dc8f:	fc                   	cld    
  800420dc90:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  800420dc92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420dc96:	c9                   	leaveq 
  800420dc97:	c3                   	retq   

000000800420dc98 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  800420dc98:	55                   	push   %rbp
  800420dc99:	48 89 e5             	mov    %rsp,%rbp
  800420dc9c:	48 83 ec 18          	sub    $0x18,%rsp
  800420dca0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420dca4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420dca8:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  800420dcac:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dcb0:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420dcb4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dcb8:	48 89 ce             	mov    %rcx,%rsi
  800420dcbb:	48 89 c7             	mov    %rax,%rdi
  800420dcbe:	48 b8 81 db 20 04 80 	movabs $0x800420db81,%rax
  800420dcc5:	00 00 00 
  800420dcc8:	ff d0                	callq  *%rax
}
  800420dcca:	c9                   	leaveq 
  800420dccb:	c3                   	retq   

000000800420dccc <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  800420dccc:	55                   	push   %rbp
  800420dccd:	48 89 e5             	mov    %rsp,%rbp
  800420dcd0:	48 83 ec 28          	sub    $0x28,%rsp
  800420dcd4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420dcd8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420dcdc:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  800420dce0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dce4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  800420dce8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dcec:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  800420dcf0:	eb 36                	jmp    800420dd28 <memcmp+0x5c>
		if (*s1 != *s2)
  800420dcf2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dcf6:	0f b6 10             	movzbl (%rax),%edx
  800420dcf9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dcfd:	0f b6 00             	movzbl (%rax),%eax
  800420dd00:	38 c2                	cmp    %al,%dl
  800420dd02:	74 1a                	je     800420dd1e <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  800420dd04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dd08:	0f b6 00             	movzbl (%rax),%eax
  800420dd0b:	0f b6 d0             	movzbl %al,%edx
  800420dd0e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dd12:	0f b6 00             	movzbl (%rax),%eax
  800420dd15:	0f b6 c0             	movzbl %al,%eax
  800420dd18:	29 c2                	sub    %eax,%edx
  800420dd1a:	89 d0                	mov    %edx,%eax
  800420dd1c:	eb 20                	jmp    800420dd3e <memcmp+0x72>
		s1++, s2++;
  800420dd1e:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420dd23:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  800420dd28:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dd2c:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420dd30:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420dd34:	48 85 c0             	test   %rax,%rax
  800420dd37:	75 b9                	jne    800420dcf2 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  800420dd39:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420dd3e:	c9                   	leaveq 
  800420dd3f:	c3                   	retq   

000000800420dd40 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  800420dd40:	55                   	push   %rbp
  800420dd41:	48 89 e5             	mov    %rsp,%rbp
  800420dd44:	48 83 ec 28          	sub    $0x28,%rsp
  800420dd48:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420dd4c:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  800420dd4f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  800420dd53:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dd57:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dd5b:	48 01 d0             	add    %rdx,%rax
  800420dd5e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  800420dd62:	eb 15                	jmp    800420dd79 <memfind+0x39>
		if (*(const unsigned char *) s == (unsigned char) c)
  800420dd64:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dd68:	0f b6 10             	movzbl (%rax),%edx
  800420dd6b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420dd6e:	38 c2                	cmp    %al,%dl
  800420dd70:	75 02                	jne    800420dd74 <memfind+0x34>
			break;
  800420dd72:	eb 0f                	jmp    800420dd83 <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  800420dd74:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420dd79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dd7d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420dd81:	72 e1                	jb     800420dd64 <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
  800420dd83:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420dd87:	c9                   	leaveq 
  800420dd88:	c3                   	retq   

000000800420dd89 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  800420dd89:	55                   	push   %rbp
  800420dd8a:	48 89 e5             	mov    %rsp,%rbp
  800420dd8d:	48 83 ec 34          	sub    $0x34,%rsp
  800420dd91:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420dd95:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420dd99:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  800420dd9c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  800420dda3:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420ddaa:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420ddab:	eb 05                	jmp    800420ddb2 <strtol+0x29>
		s++;
  800420ddad:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420ddb2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ddb6:	0f b6 00             	movzbl (%rax),%eax
  800420ddb9:	3c 20                	cmp    $0x20,%al
  800420ddbb:	74 f0                	je     800420ddad <strtol+0x24>
  800420ddbd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ddc1:	0f b6 00             	movzbl (%rax),%eax
  800420ddc4:	3c 09                	cmp    $0x9,%al
  800420ddc6:	74 e5                	je     800420ddad <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  800420ddc8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ddcc:	0f b6 00             	movzbl (%rax),%eax
  800420ddcf:	3c 2b                	cmp    $0x2b,%al
  800420ddd1:	75 07                	jne    800420ddda <strtol+0x51>
		s++;
  800420ddd3:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420ddd8:	eb 17                	jmp    800420ddf1 <strtol+0x68>
	else if (*s == '-')
  800420ddda:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ddde:	0f b6 00             	movzbl (%rax),%eax
  800420dde1:	3c 2d                	cmp    $0x2d,%al
  800420dde3:	75 0c                	jne    800420ddf1 <strtol+0x68>
		s++, neg = 1;
  800420dde5:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420ddea:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  800420ddf1:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420ddf5:	74 06                	je     800420ddfd <strtol+0x74>
  800420ddf7:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  800420ddfb:	75 28                	jne    800420de25 <strtol+0x9c>
  800420ddfd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420de01:	0f b6 00             	movzbl (%rax),%eax
  800420de04:	3c 30                	cmp    $0x30,%al
  800420de06:	75 1d                	jne    800420de25 <strtol+0x9c>
  800420de08:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420de0c:	48 83 c0 01          	add    $0x1,%rax
  800420de10:	0f b6 00             	movzbl (%rax),%eax
  800420de13:	3c 78                	cmp    $0x78,%al
  800420de15:	75 0e                	jne    800420de25 <strtol+0x9c>
		s += 2, base = 16;
  800420de17:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  800420de1c:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  800420de23:	eb 2c                	jmp    800420de51 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  800420de25:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420de29:	75 19                	jne    800420de44 <strtol+0xbb>
  800420de2b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420de2f:	0f b6 00             	movzbl (%rax),%eax
  800420de32:	3c 30                	cmp    $0x30,%al
  800420de34:	75 0e                	jne    800420de44 <strtol+0xbb>
		s++, base = 8;
  800420de36:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420de3b:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  800420de42:	eb 0d                	jmp    800420de51 <strtol+0xc8>
	else if (base == 0)
  800420de44:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420de48:	75 07                	jne    800420de51 <strtol+0xc8>
		base = 10;
  800420de4a:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  800420de51:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420de55:	0f b6 00             	movzbl (%rax),%eax
  800420de58:	3c 2f                	cmp    $0x2f,%al
  800420de5a:	7e 1d                	jle    800420de79 <strtol+0xf0>
  800420de5c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420de60:	0f b6 00             	movzbl (%rax),%eax
  800420de63:	3c 39                	cmp    $0x39,%al
  800420de65:	7f 12                	jg     800420de79 <strtol+0xf0>
			dig = *s - '0';
  800420de67:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420de6b:	0f b6 00             	movzbl (%rax),%eax
  800420de6e:	0f be c0             	movsbl %al,%eax
  800420de71:	83 e8 30             	sub    $0x30,%eax
  800420de74:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420de77:	eb 4e                	jmp    800420dec7 <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  800420de79:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420de7d:	0f b6 00             	movzbl (%rax),%eax
  800420de80:	3c 60                	cmp    $0x60,%al
  800420de82:	7e 1d                	jle    800420dea1 <strtol+0x118>
  800420de84:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420de88:	0f b6 00             	movzbl (%rax),%eax
  800420de8b:	3c 7a                	cmp    $0x7a,%al
  800420de8d:	7f 12                	jg     800420dea1 <strtol+0x118>
			dig = *s - 'a' + 10;
  800420de8f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420de93:	0f b6 00             	movzbl (%rax),%eax
  800420de96:	0f be c0             	movsbl %al,%eax
  800420de99:	83 e8 57             	sub    $0x57,%eax
  800420de9c:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420de9f:	eb 26                	jmp    800420dec7 <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  800420dea1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dea5:	0f b6 00             	movzbl (%rax),%eax
  800420dea8:	3c 40                	cmp    $0x40,%al
  800420deaa:	7e 48                	jle    800420def4 <strtol+0x16b>
  800420deac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420deb0:	0f b6 00             	movzbl (%rax),%eax
  800420deb3:	3c 5a                	cmp    $0x5a,%al
  800420deb5:	7f 3d                	jg     800420def4 <strtol+0x16b>
			dig = *s - 'A' + 10;
  800420deb7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420debb:	0f b6 00             	movzbl (%rax),%eax
  800420debe:	0f be c0             	movsbl %al,%eax
  800420dec1:	83 e8 37             	sub    $0x37,%eax
  800420dec4:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  800420dec7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420deca:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  800420decd:	7c 02                	jl     800420ded1 <strtol+0x148>
			break;
  800420decf:	eb 23                	jmp    800420def4 <strtol+0x16b>
		s++, val = (val * base) + dig;
  800420ded1:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420ded6:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420ded9:	48 98                	cltq   
  800420dedb:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  800420dee0:	48 89 c2             	mov    %rax,%rdx
  800420dee3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420dee6:	48 98                	cltq   
  800420dee8:	48 01 d0             	add    %rdx,%rax
  800420deeb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  800420deef:	e9 5d ff ff ff       	jmpq   800420de51 <strtol+0xc8>

	if (endptr)
  800420def4:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420def9:	74 0b                	je     800420df06 <strtol+0x17d>
		*endptr = (char *) s;
  800420defb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420deff:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420df03:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  800420df06:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420df0a:	74 09                	je     800420df15 <strtol+0x18c>
  800420df0c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420df10:	48 f7 d8             	neg    %rax
  800420df13:	eb 04                	jmp    800420df19 <strtol+0x190>
  800420df15:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420df19:	c9                   	leaveq 
  800420df1a:	c3                   	retq   

000000800420df1b <strstr>:

char * strstr(const char *in, const char *str)
{
  800420df1b:	55                   	push   %rbp
  800420df1c:	48 89 e5             	mov    %rsp,%rbp
  800420df1f:	48 83 ec 30          	sub    $0x30,%rsp
  800420df23:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420df27:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  800420df2b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420df2f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420df33:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420df37:	0f b6 00             	movzbl (%rax),%eax
  800420df3a:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  800420df3d:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800420df41:	75 06                	jne    800420df49 <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  800420df43:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420df47:	eb 6b                	jmp    800420dfb4 <strstr+0x99>

	len = strlen(str);
  800420df49:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420df4d:	48 89 c7             	mov    %rax,%rdi
  800420df50:	48 b8 f1 d7 20 04 80 	movabs $0x800420d7f1,%rax
  800420df57:	00 00 00 
  800420df5a:	ff d0                	callq  *%rax
  800420df5c:	48 98                	cltq   
  800420df5e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  800420df62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420df66:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420df6a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420df6e:	0f b6 00             	movzbl (%rax),%eax
  800420df71:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  800420df74:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800420df78:	75 07                	jne    800420df81 <strstr+0x66>
				return (char *) 0;
  800420df7a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420df7f:	eb 33                	jmp    800420dfb4 <strstr+0x99>
		} while (sc != c);
  800420df81:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800420df85:	3a 45 ff             	cmp    -0x1(%rbp),%al
  800420df88:	75 d8                	jne    800420df62 <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  800420df8a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420df8e:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420df92:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420df96:	48 89 ce             	mov    %rcx,%rsi
  800420df99:	48 89 c7             	mov    %rax,%rdi
  800420df9c:	48 b8 12 da 20 04 80 	movabs $0x800420da12,%rax
  800420dfa3:	00 00 00 
  800420dfa6:	ff d0                	callq  *%rax
  800420dfa8:	85 c0                	test   %eax,%eax
  800420dfaa:	75 b6                	jne    800420df62 <strstr+0x47>

	return (char *) (in - 1);
  800420dfac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dfb0:	48 83 e8 01          	sub    $0x1,%rax
}
  800420dfb4:	c9                   	leaveq 
  800420dfb5:	c3                   	retq   

000000800420dfb6 <_dwarf_read_lsb>:
Dwarf_Section *
_dwarf_find_section(const char *name);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420dfb6:	55                   	push   %rbp
  800420dfb7:	48 89 e5             	mov    %rsp,%rbp
  800420dfba:	48 83 ec 24          	sub    $0x24,%rsp
  800420dfbe:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420dfc2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420dfc6:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420dfc9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dfcd:	48 8b 10             	mov    (%rax),%rdx
  800420dfd0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dfd4:	48 01 d0             	add    %rdx,%rax
  800420dfd7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420dfdb:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420dfe2:	00 
	switch (bytes_to_read) {
  800420dfe3:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420dfe6:	83 f8 02             	cmp    $0x2,%eax
  800420dfe9:	0f 84 ab 00 00 00    	je     800420e09a <_dwarf_read_lsb+0xe4>
  800420dfef:	83 f8 02             	cmp    $0x2,%eax
  800420dff2:	7f 0e                	jg     800420e002 <_dwarf_read_lsb+0x4c>
  800420dff4:	83 f8 01             	cmp    $0x1,%eax
  800420dff7:	0f 84 b3 00 00 00    	je     800420e0b0 <_dwarf_read_lsb+0xfa>
  800420dffd:	e9 d9 00 00 00       	jmpq   800420e0db <_dwarf_read_lsb+0x125>
  800420e002:	83 f8 04             	cmp    $0x4,%eax
  800420e005:	74 65                	je     800420e06c <_dwarf_read_lsb+0xb6>
  800420e007:	83 f8 08             	cmp    $0x8,%eax
  800420e00a:	0f 85 cb 00 00 00    	jne    800420e0db <_dwarf_read_lsb+0x125>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420e010:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e014:	48 83 c0 04          	add    $0x4,%rax
  800420e018:	0f b6 00             	movzbl (%rax),%eax
  800420e01b:	0f b6 c0             	movzbl %al,%eax
  800420e01e:	48 c1 e0 20          	shl    $0x20,%rax
  800420e022:	48 89 c2             	mov    %rax,%rdx
  800420e025:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e029:	48 83 c0 05          	add    $0x5,%rax
  800420e02d:	0f b6 00             	movzbl (%rax),%eax
  800420e030:	0f b6 c0             	movzbl %al,%eax
  800420e033:	48 c1 e0 28          	shl    $0x28,%rax
  800420e037:	48 09 d0             	or     %rdx,%rax
  800420e03a:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420e03e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e042:	48 83 c0 06          	add    $0x6,%rax
  800420e046:	0f b6 00             	movzbl (%rax),%eax
  800420e049:	0f b6 c0             	movzbl %al,%eax
  800420e04c:	48 c1 e0 30          	shl    $0x30,%rax
  800420e050:	48 89 c2             	mov    %rax,%rdx
  800420e053:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e057:	48 83 c0 07          	add    $0x7,%rax
  800420e05b:	0f b6 00             	movzbl (%rax),%eax
  800420e05e:	0f b6 c0             	movzbl %al,%eax
  800420e061:	48 c1 e0 38          	shl    $0x38,%rax
  800420e065:	48 09 d0             	or     %rdx,%rax
  800420e068:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420e06c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e070:	48 83 c0 02          	add    $0x2,%rax
  800420e074:	0f b6 00             	movzbl (%rax),%eax
  800420e077:	0f b6 c0             	movzbl %al,%eax
  800420e07a:	48 c1 e0 10          	shl    $0x10,%rax
  800420e07e:	48 89 c2             	mov    %rax,%rdx
  800420e081:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e085:	48 83 c0 03          	add    $0x3,%rax
  800420e089:	0f b6 00             	movzbl (%rax),%eax
  800420e08c:	0f b6 c0             	movzbl %al,%eax
  800420e08f:	48 c1 e0 18          	shl    $0x18,%rax
  800420e093:	48 09 d0             	or     %rdx,%rax
  800420e096:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420e09a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e09e:	48 83 c0 01          	add    $0x1,%rax
  800420e0a2:	0f b6 00             	movzbl (%rax),%eax
  800420e0a5:	0f b6 c0             	movzbl %al,%eax
  800420e0a8:	48 c1 e0 08          	shl    $0x8,%rax
  800420e0ac:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420e0b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e0b4:	0f b6 00             	movzbl (%rax),%eax
  800420e0b7:	0f b6 c0             	movzbl %al,%eax
  800420e0ba:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420e0be:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  800420e0bf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e0c3:	48 8b 10             	mov    (%rax),%rdx
  800420e0c6:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420e0c9:	48 98                	cltq   
  800420e0cb:	48 01 c2             	add    %rax,%rdx
  800420e0ce:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e0d2:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420e0d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e0d9:	eb 05                	jmp    800420e0e0 <_dwarf_read_lsb+0x12a>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420e0db:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*offsetp += bytes_to_read;

	return (ret);
}
  800420e0e0:	c9                   	leaveq 
  800420e0e1:	c3                   	retq   

000000800420e0e2 <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  800420e0e2:	55                   	push   %rbp
  800420e0e3:	48 89 e5             	mov    %rsp,%rbp
  800420e0e6:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420e0ea:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e0ee:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420e0f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e0f5:	48 8b 00             	mov    (%rax),%rax
  800420e0f8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420e0fc:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420e103:	00 
	switch (bytes_to_read) {
  800420e104:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420e107:	83 f8 02             	cmp    $0x2,%eax
  800420e10a:	0f 84 ab 00 00 00    	je     800420e1bb <_dwarf_decode_lsb+0xd9>
  800420e110:	83 f8 02             	cmp    $0x2,%eax
  800420e113:	7f 0e                	jg     800420e123 <_dwarf_decode_lsb+0x41>
  800420e115:	83 f8 01             	cmp    $0x1,%eax
  800420e118:	0f 84 b3 00 00 00    	je     800420e1d1 <_dwarf_decode_lsb+0xef>
  800420e11e:	e9 d9 00 00 00       	jmpq   800420e1fc <_dwarf_decode_lsb+0x11a>
  800420e123:	83 f8 04             	cmp    $0x4,%eax
  800420e126:	74 65                	je     800420e18d <_dwarf_decode_lsb+0xab>
  800420e128:	83 f8 08             	cmp    $0x8,%eax
  800420e12b:	0f 85 cb 00 00 00    	jne    800420e1fc <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420e131:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e135:	48 83 c0 04          	add    $0x4,%rax
  800420e139:	0f b6 00             	movzbl (%rax),%eax
  800420e13c:	0f b6 c0             	movzbl %al,%eax
  800420e13f:	48 c1 e0 20          	shl    $0x20,%rax
  800420e143:	48 89 c2             	mov    %rax,%rdx
  800420e146:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e14a:	48 83 c0 05          	add    $0x5,%rax
  800420e14e:	0f b6 00             	movzbl (%rax),%eax
  800420e151:	0f b6 c0             	movzbl %al,%eax
  800420e154:	48 c1 e0 28          	shl    $0x28,%rax
  800420e158:	48 09 d0             	or     %rdx,%rax
  800420e15b:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420e15f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e163:	48 83 c0 06          	add    $0x6,%rax
  800420e167:	0f b6 00             	movzbl (%rax),%eax
  800420e16a:	0f b6 c0             	movzbl %al,%eax
  800420e16d:	48 c1 e0 30          	shl    $0x30,%rax
  800420e171:	48 89 c2             	mov    %rax,%rdx
  800420e174:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e178:	48 83 c0 07          	add    $0x7,%rax
  800420e17c:	0f b6 00             	movzbl (%rax),%eax
  800420e17f:	0f b6 c0             	movzbl %al,%eax
  800420e182:	48 c1 e0 38          	shl    $0x38,%rax
  800420e186:	48 09 d0             	or     %rdx,%rax
  800420e189:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420e18d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e191:	48 83 c0 02          	add    $0x2,%rax
  800420e195:	0f b6 00             	movzbl (%rax),%eax
  800420e198:	0f b6 c0             	movzbl %al,%eax
  800420e19b:	48 c1 e0 10          	shl    $0x10,%rax
  800420e19f:	48 89 c2             	mov    %rax,%rdx
  800420e1a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e1a6:	48 83 c0 03          	add    $0x3,%rax
  800420e1aa:	0f b6 00             	movzbl (%rax),%eax
  800420e1ad:	0f b6 c0             	movzbl %al,%eax
  800420e1b0:	48 c1 e0 18          	shl    $0x18,%rax
  800420e1b4:	48 09 d0             	or     %rdx,%rax
  800420e1b7:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420e1bb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e1bf:	48 83 c0 01          	add    $0x1,%rax
  800420e1c3:	0f b6 00             	movzbl (%rax),%eax
  800420e1c6:	0f b6 c0             	movzbl %al,%eax
  800420e1c9:	48 c1 e0 08          	shl    $0x8,%rax
  800420e1cd:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420e1d1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e1d5:	0f b6 00             	movzbl (%rax),%eax
  800420e1d8:	0f b6 c0             	movzbl %al,%eax
  800420e1db:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420e1df:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  800420e1e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e1e4:	48 8b 10             	mov    (%rax),%rdx
  800420e1e7:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420e1ea:	48 98                	cltq   
  800420e1ec:	48 01 c2             	add    %rax,%rdx
  800420e1ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e1f3:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420e1f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e1fa:	eb 05                	jmp    800420e201 <_dwarf_decode_lsb+0x11f>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420e1fc:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*data += bytes_to_read;

	return (ret);
}
  800420e201:	c9                   	leaveq 
  800420e202:	c3                   	retq   

000000800420e203 <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420e203:	55                   	push   %rbp
  800420e204:	48 89 e5             	mov    %rsp,%rbp
  800420e207:	48 83 ec 24          	sub    $0x24,%rsp
  800420e20b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e20f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420e213:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420e216:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e21a:	48 8b 10             	mov    (%rax),%rdx
  800420e21d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e221:	48 01 d0             	add    %rdx,%rax
  800420e224:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  800420e228:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420e22b:	83 f8 02             	cmp    $0x2,%eax
  800420e22e:	74 35                	je     800420e265 <_dwarf_read_msb+0x62>
  800420e230:	83 f8 02             	cmp    $0x2,%eax
  800420e233:	7f 0a                	jg     800420e23f <_dwarf_read_msb+0x3c>
  800420e235:	83 f8 01             	cmp    $0x1,%eax
  800420e238:	74 18                	je     800420e252 <_dwarf_read_msb+0x4f>
  800420e23a:	e9 53 01 00 00       	jmpq   800420e392 <_dwarf_read_msb+0x18f>
  800420e23f:	83 f8 04             	cmp    $0x4,%eax
  800420e242:	74 49                	je     800420e28d <_dwarf_read_msb+0x8a>
  800420e244:	83 f8 08             	cmp    $0x8,%eax
  800420e247:	0f 84 96 00 00 00    	je     800420e2e3 <_dwarf_read_msb+0xe0>
  800420e24d:	e9 40 01 00 00       	jmpq   800420e392 <_dwarf_read_msb+0x18f>
	case 1:
		ret = src[0];
  800420e252:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e256:	0f b6 00             	movzbl (%rax),%eax
  800420e259:	0f b6 c0             	movzbl %al,%eax
  800420e25c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420e260:	e9 34 01 00 00       	jmpq   800420e399 <_dwarf_read_msb+0x196>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800420e265:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e269:	48 83 c0 01          	add    $0x1,%rax
  800420e26d:	0f b6 00             	movzbl (%rax),%eax
  800420e270:	0f b6 d0             	movzbl %al,%edx
  800420e273:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e277:	0f b6 00             	movzbl (%rax),%eax
  800420e27a:	0f b6 c0             	movzbl %al,%eax
  800420e27d:	48 c1 e0 08          	shl    $0x8,%rax
  800420e281:	48 09 d0             	or     %rdx,%rax
  800420e284:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420e288:	e9 0c 01 00 00       	jmpq   800420e399 <_dwarf_read_msb+0x196>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800420e28d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e291:	48 83 c0 03          	add    $0x3,%rax
  800420e295:	0f b6 00             	movzbl (%rax),%eax
  800420e298:	0f b6 c0             	movzbl %al,%eax
  800420e29b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e29f:	48 83 c2 02          	add    $0x2,%rdx
  800420e2a3:	0f b6 12             	movzbl (%rdx),%edx
  800420e2a6:	0f b6 d2             	movzbl %dl,%edx
  800420e2a9:	48 c1 e2 08          	shl    $0x8,%rdx
  800420e2ad:	48 09 d0             	or     %rdx,%rax
  800420e2b0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800420e2b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e2b8:	48 83 c0 01          	add    $0x1,%rax
  800420e2bc:	0f b6 00             	movzbl (%rax),%eax
  800420e2bf:	0f b6 c0             	movzbl %al,%eax
  800420e2c2:	48 c1 e0 10          	shl    $0x10,%rax
  800420e2c6:	48 89 c2             	mov    %rax,%rdx
  800420e2c9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e2cd:	0f b6 00             	movzbl (%rax),%eax
  800420e2d0:	0f b6 c0             	movzbl %al,%eax
  800420e2d3:	48 c1 e0 18          	shl    $0x18,%rax
  800420e2d7:	48 09 d0             	or     %rdx,%rax
  800420e2da:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420e2de:	e9 b6 00 00 00       	jmpq   800420e399 <_dwarf_read_msb+0x196>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800420e2e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e2e7:	48 83 c0 07          	add    $0x7,%rax
  800420e2eb:	0f b6 00             	movzbl (%rax),%eax
  800420e2ee:	0f b6 c0             	movzbl %al,%eax
  800420e2f1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e2f5:	48 83 c2 06          	add    $0x6,%rdx
  800420e2f9:	0f b6 12             	movzbl (%rdx),%edx
  800420e2fc:	0f b6 d2             	movzbl %dl,%edx
  800420e2ff:	48 c1 e2 08          	shl    $0x8,%rdx
  800420e303:	48 09 d0             	or     %rdx,%rax
  800420e306:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800420e30a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e30e:	48 83 c0 05          	add    $0x5,%rax
  800420e312:	0f b6 00             	movzbl (%rax),%eax
  800420e315:	0f b6 c0             	movzbl %al,%eax
  800420e318:	48 c1 e0 10          	shl    $0x10,%rax
  800420e31c:	48 89 c2             	mov    %rax,%rdx
  800420e31f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e323:	48 83 c0 04          	add    $0x4,%rax
  800420e327:	0f b6 00             	movzbl (%rax),%eax
  800420e32a:	0f b6 c0             	movzbl %al,%eax
  800420e32d:	48 c1 e0 18          	shl    $0x18,%rax
  800420e331:	48 09 d0             	or     %rdx,%rax
  800420e334:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800420e338:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e33c:	48 83 c0 03          	add    $0x3,%rax
  800420e340:	0f b6 00             	movzbl (%rax),%eax
  800420e343:	0f b6 c0             	movzbl %al,%eax
  800420e346:	48 c1 e0 20          	shl    $0x20,%rax
  800420e34a:	48 89 c2             	mov    %rax,%rdx
  800420e34d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e351:	48 83 c0 02          	add    $0x2,%rax
  800420e355:	0f b6 00             	movzbl (%rax),%eax
  800420e358:	0f b6 c0             	movzbl %al,%eax
  800420e35b:	48 c1 e0 28          	shl    $0x28,%rax
  800420e35f:	48 09 d0             	or     %rdx,%rax
  800420e362:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800420e366:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e36a:	48 83 c0 01          	add    $0x1,%rax
  800420e36e:	0f b6 00             	movzbl (%rax),%eax
  800420e371:	0f b6 c0             	movzbl %al,%eax
  800420e374:	48 c1 e0 30          	shl    $0x30,%rax
  800420e378:	48 89 c2             	mov    %rax,%rdx
  800420e37b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e37f:	0f b6 00             	movzbl (%rax),%eax
  800420e382:	0f b6 c0             	movzbl %al,%eax
  800420e385:	48 c1 e0 38          	shl    $0x38,%rax
  800420e389:	48 09 d0             	or     %rdx,%rax
  800420e38c:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420e390:	eb 07                	jmp    800420e399 <_dwarf_read_msb+0x196>
	default:
		return (0);
  800420e392:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e397:	eb 1a                	jmp    800420e3b3 <_dwarf_read_msb+0x1b0>
	}

	*offsetp += bytes_to_read;
  800420e399:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e39d:	48 8b 10             	mov    (%rax),%rdx
  800420e3a0:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420e3a3:	48 98                	cltq   
  800420e3a5:	48 01 c2             	add    %rax,%rdx
  800420e3a8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e3ac:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420e3af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e3b3:	c9                   	leaveq 
  800420e3b4:	c3                   	retq   

000000800420e3b5 <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  800420e3b5:	55                   	push   %rbp
  800420e3b6:	48 89 e5             	mov    %rsp,%rbp
  800420e3b9:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420e3bd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e3c1:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420e3c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e3c8:	48 8b 00             	mov    (%rax),%rax
  800420e3cb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420e3cf:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420e3d6:	00 
	switch (bytes_to_read) {
  800420e3d7:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420e3da:	83 f8 02             	cmp    $0x2,%eax
  800420e3dd:	74 35                	je     800420e414 <_dwarf_decode_msb+0x5f>
  800420e3df:	83 f8 02             	cmp    $0x2,%eax
  800420e3e2:	7f 0a                	jg     800420e3ee <_dwarf_decode_msb+0x39>
  800420e3e4:	83 f8 01             	cmp    $0x1,%eax
  800420e3e7:	74 18                	je     800420e401 <_dwarf_decode_msb+0x4c>
  800420e3e9:	e9 53 01 00 00       	jmpq   800420e541 <_dwarf_decode_msb+0x18c>
  800420e3ee:	83 f8 04             	cmp    $0x4,%eax
  800420e3f1:	74 49                	je     800420e43c <_dwarf_decode_msb+0x87>
  800420e3f3:	83 f8 08             	cmp    $0x8,%eax
  800420e3f6:	0f 84 96 00 00 00    	je     800420e492 <_dwarf_decode_msb+0xdd>
  800420e3fc:	e9 40 01 00 00       	jmpq   800420e541 <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  800420e401:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e405:	0f b6 00             	movzbl (%rax),%eax
  800420e408:	0f b6 c0             	movzbl %al,%eax
  800420e40b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420e40f:	e9 34 01 00 00       	jmpq   800420e548 <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800420e414:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e418:	48 83 c0 01          	add    $0x1,%rax
  800420e41c:	0f b6 00             	movzbl (%rax),%eax
  800420e41f:	0f b6 d0             	movzbl %al,%edx
  800420e422:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e426:	0f b6 00             	movzbl (%rax),%eax
  800420e429:	0f b6 c0             	movzbl %al,%eax
  800420e42c:	48 c1 e0 08          	shl    $0x8,%rax
  800420e430:	48 09 d0             	or     %rdx,%rax
  800420e433:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420e437:	e9 0c 01 00 00       	jmpq   800420e548 <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800420e43c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e440:	48 83 c0 03          	add    $0x3,%rax
  800420e444:	0f b6 00             	movzbl (%rax),%eax
  800420e447:	0f b6 c0             	movzbl %al,%eax
  800420e44a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e44e:	48 83 c2 02          	add    $0x2,%rdx
  800420e452:	0f b6 12             	movzbl (%rdx),%edx
  800420e455:	0f b6 d2             	movzbl %dl,%edx
  800420e458:	48 c1 e2 08          	shl    $0x8,%rdx
  800420e45c:	48 09 d0             	or     %rdx,%rax
  800420e45f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800420e463:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e467:	48 83 c0 01          	add    $0x1,%rax
  800420e46b:	0f b6 00             	movzbl (%rax),%eax
  800420e46e:	0f b6 c0             	movzbl %al,%eax
  800420e471:	48 c1 e0 10          	shl    $0x10,%rax
  800420e475:	48 89 c2             	mov    %rax,%rdx
  800420e478:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e47c:	0f b6 00             	movzbl (%rax),%eax
  800420e47f:	0f b6 c0             	movzbl %al,%eax
  800420e482:	48 c1 e0 18          	shl    $0x18,%rax
  800420e486:	48 09 d0             	or     %rdx,%rax
  800420e489:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420e48d:	e9 b6 00 00 00       	jmpq   800420e548 <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800420e492:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e496:	48 83 c0 07          	add    $0x7,%rax
  800420e49a:	0f b6 00             	movzbl (%rax),%eax
  800420e49d:	0f b6 c0             	movzbl %al,%eax
  800420e4a0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e4a4:	48 83 c2 06          	add    $0x6,%rdx
  800420e4a8:	0f b6 12             	movzbl (%rdx),%edx
  800420e4ab:	0f b6 d2             	movzbl %dl,%edx
  800420e4ae:	48 c1 e2 08          	shl    $0x8,%rdx
  800420e4b2:	48 09 d0             	or     %rdx,%rax
  800420e4b5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800420e4b9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e4bd:	48 83 c0 05          	add    $0x5,%rax
  800420e4c1:	0f b6 00             	movzbl (%rax),%eax
  800420e4c4:	0f b6 c0             	movzbl %al,%eax
  800420e4c7:	48 c1 e0 10          	shl    $0x10,%rax
  800420e4cb:	48 89 c2             	mov    %rax,%rdx
  800420e4ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e4d2:	48 83 c0 04          	add    $0x4,%rax
  800420e4d6:	0f b6 00             	movzbl (%rax),%eax
  800420e4d9:	0f b6 c0             	movzbl %al,%eax
  800420e4dc:	48 c1 e0 18          	shl    $0x18,%rax
  800420e4e0:	48 09 d0             	or     %rdx,%rax
  800420e4e3:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800420e4e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e4eb:	48 83 c0 03          	add    $0x3,%rax
  800420e4ef:	0f b6 00             	movzbl (%rax),%eax
  800420e4f2:	0f b6 c0             	movzbl %al,%eax
  800420e4f5:	48 c1 e0 20          	shl    $0x20,%rax
  800420e4f9:	48 89 c2             	mov    %rax,%rdx
  800420e4fc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e500:	48 83 c0 02          	add    $0x2,%rax
  800420e504:	0f b6 00             	movzbl (%rax),%eax
  800420e507:	0f b6 c0             	movzbl %al,%eax
  800420e50a:	48 c1 e0 28          	shl    $0x28,%rax
  800420e50e:	48 09 d0             	or     %rdx,%rax
  800420e511:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800420e515:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e519:	48 83 c0 01          	add    $0x1,%rax
  800420e51d:	0f b6 00             	movzbl (%rax),%eax
  800420e520:	0f b6 c0             	movzbl %al,%eax
  800420e523:	48 c1 e0 30          	shl    $0x30,%rax
  800420e527:	48 89 c2             	mov    %rax,%rdx
  800420e52a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e52e:	0f b6 00             	movzbl (%rax),%eax
  800420e531:	0f b6 c0             	movzbl %al,%eax
  800420e534:	48 c1 e0 38          	shl    $0x38,%rax
  800420e538:	48 09 d0             	or     %rdx,%rax
  800420e53b:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420e53f:	eb 07                	jmp    800420e548 <_dwarf_decode_msb+0x193>
	default:
		return (0);
  800420e541:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e546:	eb 1a                	jmp    800420e562 <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  800420e548:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e54c:	48 8b 10             	mov    (%rax),%rdx
  800420e54f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420e552:	48 98                	cltq   
  800420e554:	48 01 c2             	add    %rax,%rdx
  800420e557:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e55b:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420e55e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e562:	c9                   	leaveq 
  800420e563:	c3                   	retq   

000000800420e564 <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  800420e564:	55                   	push   %rbp
  800420e565:	48 89 e5             	mov    %rsp,%rbp
  800420e568:	48 83 ec 30          	sub    $0x30,%rsp
  800420e56c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420e570:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int64_t ret = 0;
  800420e574:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420e57b:	00 
	uint8_t b;
	int shift = 0;
  800420e57c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800420e583:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e587:	48 8b 10             	mov    (%rax),%rdx
  800420e58a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e58e:	48 01 d0             	add    %rdx,%rax
  800420e591:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420e595:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e599:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e59d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420e5a1:	0f b6 00             	movzbl (%rax),%eax
  800420e5a4:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420e5a7:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420e5ab:	83 e0 7f             	and    $0x7f,%eax
  800420e5ae:	89 c2                	mov    %eax,%edx
  800420e5b0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e5b3:	89 c1                	mov    %eax,%ecx
  800420e5b5:	d3 e2                	shl    %cl,%edx
  800420e5b7:	89 d0                	mov    %edx,%eax
  800420e5b9:	48 98                	cltq   
  800420e5bb:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800420e5bf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e5c3:	48 8b 00             	mov    (%rax),%rax
  800420e5c6:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e5ca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e5ce:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800420e5d1:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420e5d5:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420e5d9:	84 c0                	test   %al,%al
  800420e5db:	78 b8                	js     800420e595 <_dwarf_read_sleb128+0x31>

	if (shift < 32 && (b & 0x40) != 0)
  800420e5dd:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420e5e1:	7f 1f                	jg     800420e602 <_dwarf_read_sleb128+0x9e>
  800420e5e3:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420e5e7:	83 e0 40             	and    $0x40,%eax
  800420e5ea:	85 c0                	test   %eax,%eax
  800420e5ec:	74 14                	je     800420e602 <_dwarf_read_sleb128+0x9e>
		ret |= (-1 << shift);
  800420e5ee:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e5f1:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800420e5f6:	89 c1                	mov    %eax,%ecx
  800420e5f8:	d3 e2                	shl    %cl,%edx
  800420e5fa:	89 d0                	mov    %edx,%eax
  800420e5fc:	48 98                	cltq   
  800420e5fe:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	return (ret);
  800420e602:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e606:	c9                   	leaveq 
  800420e607:	c3                   	retq   

000000800420e608 <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  800420e608:	55                   	push   %rbp
  800420e609:	48 89 e5             	mov    %rsp,%rbp
  800420e60c:	48 83 ec 30          	sub    $0x30,%rsp
  800420e610:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420e614:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t ret = 0;
  800420e618:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420e61f:	00 
	uint8_t b;
	int shift = 0;
  800420e620:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800420e627:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e62b:	48 8b 10             	mov    (%rax),%rdx
  800420e62e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e632:	48 01 d0             	add    %rdx,%rax
  800420e635:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420e639:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e63d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e641:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420e645:	0f b6 00             	movzbl (%rax),%eax
  800420e648:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420e64b:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420e64f:	83 e0 7f             	and    $0x7f,%eax
  800420e652:	89 c2                	mov    %eax,%edx
  800420e654:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e657:	89 c1                	mov    %eax,%ecx
  800420e659:	d3 e2                	shl    %cl,%edx
  800420e65b:	89 d0                	mov    %edx,%eax
  800420e65d:	48 98                	cltq   
  800420e65f:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800420e663:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e667:	48 8b 00             	mov    (%rax),%rax
  800420e66a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e66e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e672:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800420e675:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420e679:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420e67d:	84 c0                	test   %al,%al
  800420e67f:	78 b8                	js     800420e639 <_dwarf_read_uleb128+0x31>

	return (ret);
  800420e681:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e685:	c9                   	leaveq 
  800420e686:	c3                   	retq   

000000800420e687 <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  800420e687:	55                   	push   %rbp
  800420e688:	48 89 e5             	mov    %rsp,%rbp
  800420e68b:	48 83 ec 28          	sub    $0x28,%rsp
  800420e68f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int64_t ret = 0;
  800420e693:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420e69a:	00 
	uint8_t b;
	int shift = 0;
  800420e69b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  800420e6a2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e6a6:	48 8b 00             	mov    (%rax),%rax
  800420e6a9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420e6ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e6b1:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e6b5:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420e6b9:	0f b6 00             	movzbl (%rax),%eax
  800420e6bc:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420e6bf:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420e6c3:	83 e0 7f             	and    $0x7f,%eax
  800420e6c6:	89 c2                	mov    %eax,%edx
  800420e6c8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e6cb:	89 c1                	mov    %eax,%ecx
  800420e6cd:	d3 e2                	shl    %cl,%edx
  800420e6cf:	89 d0                	mov    %edx,%eax
  800420e6d1:	48 98                	cltq   
  800420e6d3:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  800420e6d7:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420e6db:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420e6df:	84 c0                	test   %al,%al
  800420e6e1:	78 ca                	js     800420e6ad <_dwarf_decode_sleb128+0x26>

	if (shift < 32 && (b & 0x40) != 0)
  800420e6e3:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420e6e7:	7f 1f                	jg     800420e708 <_dwarf_decode_sleb128+0x81>
  800420e6e9:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420e6ed:	83 e0 40             	and    $0x40,%eax
  800420e6f0:	85 c0                	test   %eax,%eax
  800420e6f2:	74 14                	je     800420e708 <_dwarf_decode_sleb128+0x81>
		ret |= (-1 << shift);
  800420e6f4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e6f7:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800420e6fc:	89 c1                	mov    %eax,%ecx
  800420e6fe:	d3 e2                	shl    %cl,%edx
  800420e700:	89 d0                	mov    %edx,%eax
  800420e702:	48 98                	cltq   
  800420e704:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	*dp = src;
  800420e708:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e70c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e710:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420e713:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e717:	c9                   	leaveq 
  800420e718:	c3                   	retq   

000000800420e719 <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  800420e719:	55                   	push   %rbp
  800420e71a:	48 89 e5             	mov    %rsp,%rbp
  800420e71d:	48 83 ec 28          	sub    $0x28,%rsp
  800420e721:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint64_t ret = 0;
  800420e725:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420e72c:	00 
	uint8_t b;
	int shift = 0;
  800420e72d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  800420e734:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e738:	48 8b 00             	mov    (%rax),%rax
  800420e73b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420e73f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e743:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e747:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420e74b:	0f b6 00             	movzbl (%rax),%eax
  800420e74e:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420e751:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420e755:	83 e0 7f             	and    $0x7f,%eax
  800420e758:	89 c2                	mov    %eax,%edx
  800420e75a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e75d:	89 c1                	mov    %eax,%ecx
  800420e75f:	d3 e2                	shl    %cl,%edx
  800420e761:	89 d0                	mov    %edx,%eax
  800420e763:	48 98                	cltq   
  800420e765:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  800420e769:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420e76d:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420e771:	84 c0                	test   %al,%al
  800420e773:	78 ca                	js     800420e73f <_dwarf_decode_uleb128+0x26>

	*dp = src;
  800420e775:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e779:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e77d:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420e780:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e784:	c9                   	leaveq 
  800420e785:	c3                   	retq   

000000800420e786 <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  800420e786:	55                   	push   %rbp
  800420e787:	48 89 e5             	mov    %rsp,%rbp
  800420e78a:	48 83 ec 28          	sub    $0x28,%rsp
  800420e78e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e792:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420e796:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  800420e79a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e79e:	48 8b 10             	mov    (%rax),%rdx
  800420e7a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e7a5:	48 01 d0             	add    %rdx,%rax
  800420e7a8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e7ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e7b0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  800420e7b4:	eb 17                	jmp    800420e7cd <_dwarf_read_string+0x47>
		src++;
  800420e7b6:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  800420e7bb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e7bf:	48 8b 00             	mov    (%rax),%rax
  800420e7c2:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e7c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e7ca:	48 89 10             	mov    %rdx,(%rax)
{
	char *ret, *src;

	ret = src = (char *) data + *offsetp;

	while (*src != '\0' && *offsetp < size) {
  800420e7cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e7d1:	0f b6 00             	movzbl (%rax),%eax
  800420e7d4:	84 c0                	test   %al,%al
  800420e7d6:	74 0d                	je     800420e7e5 <_dwarf_read_string+0x5f>
  800420e7d8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e7dc:	48 8b 00             	mov    (%rax),%rax
  800420e7df:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420e7e3:	72 d1                	jb     800420e7b6 <_dwarf_read_string+0x30>
		src++;
		(*offsetp)++;
	}

	if (*src == '\0' && *offsetp < size)
  800420e7e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e7e9:	0f b6 00             	movzbl (%rax),%eax
  800420e7ec:	84 c0                	test   %al,%al
  800420e7ee:	75 1f                	jne    800420e80f <_dwarf_read_string+0x89>
  800420e7f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e7f4:	48 8b 00             	mov    (%rax),%rax
  800420e7f7:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420e7fb:	73 12                	jae    800420e80f <_dwarf_read_string+0x89>
		(*offsetp)++;
  800420e7fd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e801:	48 8b 00             	mov    (%rax),%rax
  800420e804:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e808:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e80c:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420e80f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420e813:	c9                   	leaveq 
  800420e814:	c3                   	retq   

000000800420e815 <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  800420e815:	55                   	push   %rbp
  800420e816:	48 89 e5             	mov    %rsp,%rbp
  800420e819:	48 83 ec 28          	sub    $0x28,%rsp
  800420e81d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e821:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420e825:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  800420e829:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e82d:	48 8b 10             	mov    (%rax),%rdx
  800420e830:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e834:	48 01 d0             	add    %rdx,%rax
  800420e837:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e83b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e83f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  800420e843:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e847:	48 8b 10             	mov    (%rax),%rdx
  800420e84a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e84e:	48 01 c2             	add    %rax,%rdx
  800420e851:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e855:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420e858:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420e85c:	c9                   	leaveq 
  800420e85d:	c3                   	retq   

000000800420e85e <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  800420e85e:	55                   	push   %rbp
  800420e85f:	48 89 e5             	mov    %rsp,%rbp
  800420e862:	48 83 ec 20          	sub    $0x20,%rsp
  800420e866:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *)obj;
  800420e86a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e86e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  800420e872:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420e877:	75 35                	jne    800420e8ae <_dwarf_elf_get_byte_order+0x50>
  800420e879:	48 b9 e0 7a 21 04 80 	movabs $0x8004217ae0,%rcx
  800420e880:	00 00 00 
  800420e883:	48 ba ea 7a 21 04 80 	movabs $0x8004217aea,%rdx
  800420e88a:	00 00 00 
  800420e88d:	be 29 01 00 00       	mov    $0x129,%esi
  800420e892:	48 bf ff 7a 21 04 80 	movabs $0x8004217aff,%rdi
  800420e899:	00 00 00 
  800420e89c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e8a1:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420e8a8:	00 00 00 
  800420e8ab:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
	switch (e->e_ident[EI_DATA]) {
  800420e8ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e8b2:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  800420e8b6:	0f b6 c0             	movzbl %al,%eax
  800420e8b9:	83 f8 02             	cmp    $0x2,%eax
  800420e8bc:	75 07                	jne    800420e8c5 <_dwarf_elf_get_byte_order+0x67>
	case ELFDATA2MSB:
		return (DW_OBJECT_MSB);
  800420e8be:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e8c3:	eb 05                	jmp    800420e8ca <_dwarf_elf_get_byte_order+0x6c>

	case ELFDATA2LSB:
	case ELFDATANONE:
	default:
		return (DW_OBJECT_LSB);
  800420e8c5:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
  800420e8ca:	c9                   	leaveq 
  800420e8cb:	c3                   	retq   

000000800420e8cc <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  800420e8cc:	55                   	push   %rbp
  800420e8cd:	48 89 e5             	mov    %rsp,%rbp
  800420e8d0:	48 83 ec 20          	sub    $0x20,%rsp
  800420e8d4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *) obj;
  800420e8d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e8dc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  800420e8e0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420e8e5:	75 35                	jne    800420e91c <_dwarf_elf_get_pointer_size+0x50>
  800420e8e7:	48 b9 e0 7a 21 04 80 	movabs $0x8004217ae0,%rcx
  800420e8ee:	00 00 00 
  800420e8f1:	48 ba ea 7a 21 04 80 	movabs $0x8004217aea,%rdx
  800420e8f8:	00 00 00 
  800420e8fb:	be 3f 01 00 00       	mov    $0x13f,%esi
  800420e900:	48 bf ff 7a 21 04 80 	movabs $0x8004217aff,%rdi
  800420e907:	00 00 00 
  800420e90a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e90f:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420e916:	00 00 00 
  800420e919:	41 ff d0             	callq  *%r8

	if (e->e_ident[4] == ELFCLASS32)
  800420e91c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e920:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  800420e924:	3c 01                	cmp    $0x1,%al
  800420e926:	75 07                	jne    800420e92f <_dwarf_elf_get_pointer_size+0x63>
		return (4);
  800420e928:	b8 04 00 00 00       	mov    $0x4,%eax
  800420e92d:	eb 05                	jmp    800420e934 <_dwarf_elf_get_pointer_size+0x68>
	else
		return (8);
  800420e92f:	b8 08 00 00 00       	mov    $0x8,%eax
}
  800420e934:	c9                   	leaveq 
  800420e935:	c3                   	retq   

000000800420e936 <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  800420e936:	55                   	push   %rbp
  800420e937:	48 89 e5             	mov    %rsp,%rbp
  800420e93a:	53                   	push   %rbx
  800420e93b:	48 83 ec 18          	sub    $0x18,%rsp
  800420e93f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e943:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  800420e947:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e94b:	ba 60 00 00 00       	mov    $0x60,%edx
  800420e950:	be 00 00 00 00       	mov    $0x0,%esi
  800420e955:	48 89 c7             	mov    %rax,%rdi
  800420e958:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  800420e95f:	00 00 00 
  800420e962:	ff d0                	callq  *%rax
	dbg->curr_off_dbginfo = 0;
  800420e964:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e968:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	dbg->dbg_info_size = 0;
  800420e96f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e973:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800420e97a:	00 
	dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  800420e97b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e97f:	48 89 c7             	mov    %rax,%rdi
  800420e982:	48 b8 cc e8 20 04 80 	movabs $0x800420e8cc,%rax
  800420e989:	00 00 00 
  800420e98c:	ff d0                	callq  *%rax
  800420e98e:	0f b6 d0             	movzbl %al,%edx
  800420e991:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e995:	89 50 28             	mov    %edx,0x28(%rax)

	if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  800420e998:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e99c:	48 89 c7             	mov    %rax,%rdi
  800420e99f:	48 b8 5e e8 20 04 80 	movabs $0x800420e85e,%rax
  800420e9a6:	00 00 00 
  800420e9a9:	ff d0                	callq  *%rax
  800420e9ab:	85 c0                	test   %eax,%eax
  800420e9ad:	75 26                	jne    800420e9d5 <_dwarf_init+0x9f>
		dbg->read = _dwarf_read_msb;
  800420e9af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e9b3:	48 b9 03 e2 20 04 80 	movabs $0x800420e203,%rcx
  800420e9ba:	00 00 00 
  800420e9bd:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_msb;
  800420e9c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e9c5:	48 bb b5 e3 20 04 80 	movabs $0x800420e3b5,%rbx
  800420e9cc:	00 00 00 
  800420e9cf:	48 89 58 20          	mov    %rbx,0x20(%rax)
  800420e9d3:	eb 24                	jmp    800420e9f9 <_dwarf_init+0xc3>
	} else {
		dbg->read = _dwarf_read_lsb;
  800420e9d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e9d9:	48 b9 b6 df 20 04 80 	movabs $0x800420dfb6,%rcx
  800420e9e0:	00 00 00 
  800420e9e3:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_lsb;
  800420e9e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e9eb:	48 be e2 e0 20 04 80 	movabs $0x800420e0e2,%rsi
  800420e9f2:	00 00 00 
  800420e9f5:	48 89 70 20          	mov    %rsi,0x20(%rax)
	}
	_dwarf_frame_params_init(dbg);
  800420e9f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e9fd:	48 89 c7             	mov    %rax,%rdi
  800420ea00:	48 b8 03 ff 20 04 80 	movabs $0x800420ff03,%rax
  800420ea07:	00 00 00 
  800420ea0a:	ff d0                	callq  *%rax
	return 0;
  800420ea0c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420ea11:	48 83 c4 18          	add    $0x18,%rsp
  800420ea15:	5b                   	pop    %rbx
  800420ea16:	5d                   	pop    %rbp
  800420ea17:	c3                   	retq   

000000800420ea18 <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  800420ea18:	55                   	push   %rbp
  800420ea19:	48 89 e5             	mov    %rsp,%rbp
  800420ea1c:	48 83 ec 20          	sub    $0x20,%rsp
  800420ea20:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ea24:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t length;
	uint64_t offset;
	uint8_t dwarf_size;

	if(dbg->curr_off_dbginfo > dbg->dbg_info_size)
  800420ea28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ea2c:	48 8b 10             	mov    (%rax),%rdx
  800420ea2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ea33:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420ea37:	48 39 c2             	cmp    %rax,%rdx
  800420ea3a:	76 0a                	jbe    800420ea46 <_get_next_cu+0x2e>
		return -1;
  800420ea3c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420ea41:	e9 6b 01 00 00       	jmpq   800420ebb1 <_get_next_cu+0x199>

	offset = dbg->curr_off_dbginfo;
  800420ea46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ea4a:	48 8b 00             	mov    (%rax),%rax
  800420ea4d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  800420ea51:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420ea55:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ea59:	48 89 50 30          	mov    %rdx,0x30(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  800420ea5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ea61:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ea65:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ea69:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420ea6d:	48 89 d1             	mov    %rdx,%rcx
  800420ea70:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420ea74:	ba 04 00 00 00       	mov    $0x4,%edx
  800420ea79:	48 89 cf             	mov    %rcx,%rdi
  800420ea7c:	ff d0                	callq  *%rax
  800420ea7e:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (length == 0xffffffff) {
  800420ea81:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800420ea85:	75 2a                	jne    800420eab1 <_get_next_cu+0x99>
		length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  800420ea87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ea8b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ea8f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ea93:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420ea97:	48 89 d1             	mov    %rdx,%rcx
  800420ea9a:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420ea9e:	ba 08 00 00 00       	mov    $0x8,%edx
  800420eaa3:	48 89 cf             	mov    %rcx,%rdi
  800420eaa6:	ff d0                	callq  *%rax
  800420eaa8:	89 45 fc             	mov    %eax,-0x4(%rbp)
		dwarf_size = 8;
  800420eaab:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  800420eaaf:	eb 04                	jmp    800420eab5 <_get_next_cu+0x9d>
	} else {
		dwarf_size = 4;
  800420eab1:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
	}

	cu->cu_dwarf_size = dwarf_size;
  800420eab5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eab9:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800420eabd:	88 50 19             	mov    %dl,0x19(%rax)
	 if (length > ds->ds_size - offset) {
	 return (DW_DLE_CU_LENGTH_ERROR);
	 }*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  800420eac0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420eac3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eac7:	48 01 c2             	add    %rax,%rdx
  800420eaca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eace:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  800420ead1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ead5:	48 8b 10             	mov    (%rax),%rdx
  800420ead8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eadc:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  800420eae0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420eae3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eae7:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  800420eaea:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  800420eaee:	75 07                	jne    800420eaf7 <_get_next_cu+0xdf>
  800420eaf0:	b8 04 00 00 00       	mov    $0x4,%eax
  800420eaf5:	eb 05                	jmp    800420eafc <_get_next_cu+0xe4>
  800420eaf7:	b8 0c 00 00 00       	mov    $0xc,%eax
  800420eafc:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420eb00:	88 42 18             	mov    %al,0x18(%rdx)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  800420eb03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb07:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420eb0b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eb0f:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420eb13:	48 89 d1             	mov    %rdx,%rcx
  800420eb16:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420eb1a:	ba 02 00 00 00       	mov    $0x2,%edx
  800420eb1f:	48 89 cf             	mov    %rcx,%rdi
  800420eb22:	ff d0                	callq  *%rax
  800420eb24:	89 c2                	mov    %eax,%edx
  800420eb26:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eb2a:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  800420eb2e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb32:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420eb36:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800420eb3a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420eb3e:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  800420eb42:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420eb46:	48 89 cf             	mov    %rcx,%rdi
  800420eb49:	ff d0                	callq  *%rax
  800420eb4b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420eb4f:	48 89 42 10          	mov    %rax,0x10(%rdx)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  800420eb53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb57:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420eb5b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eb5f:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420eb63:	48 89 d1             	mov    %rdx,%rcx
  800420eb66:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420eb6a:	ba 01 00 00 00       	mov    $0x1,%edx
  800420eb6f:	48 89 cf             	mov    %rcx,%rdi
  800420eb72:	ff d0                	callq  *%rax
  800420eb74:	89 c2                	mov    %eax,%edx
  800420eb76:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eb7a:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  800420eb7d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eb81:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420eb85:	66 83 f8 01          	cmp    $0x1,%ax
  800420eb89:	76 0e                	jbe    800420eb99 <_get_next_cu+0x181>
  800420eb8b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eb8f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420eb93:	66 83 f8 04          	cmp    $0x4,%ax
  800420eb97:	76 07                	jbe    800420eba0 <_get_next_cu+0x188>
		return -1;
  800420eb99:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420eb9e:	eb 11                	jmp    800420ebb1 <_get_next_cu+0x199>
	}

	cu->cu_die_offset = offset;
  800420eba0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420eba4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eba8:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  800420ebac:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420ebb1:	c9                   	leaveq 
  800420ebb2:	c3                   	retq   

000000800420ebb3 <print_cu>:

void print_cu(Dwarf_CU cu)
{
  800420ebb3:	55                   	push   %rbp
  800420ebb4:	48 89 e5             	mov    %rsp,%rbp
	cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  800420ebb7:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  800420ebbb:	0f b6 c8             	movzbl %al,%ecx
  800420ebbe:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  800420ebc2:	0f b7 d0             	movzwl %ax,%edx
  800420ebc5:	48 8b 45 10          	mov    0x10(%rbp),%rax
  800420ebc9:	48 89 c6             	mov    %rax,%rsi
  800420ebcc:	48 bf 12 7b 21 04 80 	movabs $0x8004217b12,%rdi
  800420ebd3:	00 00 00 
  800420ebd6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ebdb:	49 b8 0e 92 20 04 80 	movabs $0x800420920e,%r8
  800420ebe2:	00 00 00 
  800420ebe5:	41 ff d0             	callq  *%r8
}
  800420ebe8:	5d                   	pop    %rbp
  800420ebe9:	c3                   	retq   

000000800420ebea <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
		    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  800420ebea:	55                   	push   %rbp
  800420ebeb:	48 89 e5             	mov    %rsp,%rbp
  800420ebee:	48 83 ec 60          	sub    $0x60,%rsp
  800420ebf2:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800420ebf6:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800420ebfa:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  800420ebfe:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
	uint64_t tag;
	uint8_t children;
	uint64_t abbr_addr;
	int ret;

	assert(abp != NULL);
  800420ec02:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  800420ec07:	75 35                	jne    800420ec3e <_dwarf_abbrev_parse+0x54>
  800420ec09:	48 b9 21 7b 21 04 80 	movabs $0x8004217b21,%rcx
  800420ec10:	00 00 00 
  800420ec13:	48 ba ea 7a 21 04 80 	movabs $0x8004217aea,%rdx
  800420ec1a:	00 00 00 
  800420ec1d:	be a4 01 00 00       	mov    $0x1a4,%esi
  800420ec22:	48 bf ff 7a 21 04 80 	movabs $0x8004217aff,%rdi
  800420ec29:	00 00 00 
  800420ec2c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ec31:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420ec38:	00 00 00 
  800420ec3b:	41 ff d0             	callq  *%r8
	assert(ds != NULL);
  800420ec3e:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  800420ec43:	75 35                	jne    800420ec7a <_dwarf_abbrev_parse+0x90>
  800420ec45:	48 b9 2d 7b 21 04 80 	movabs $0x8004217b2d,%rcx
  800420ec4c:	00 00 00 
  800420ec4f:	48 ba ea 7a 21 04 80 	movabs $0x8004217aea,%rdx
  800420ec56:	00 00 00 
  800420ec59:	be a5 01 00 00       	mov    $0x1a5,%esi
  800420ec5e:	48 bf ff 7a 21 04 80 	movabs $0x8004217aff,%rdi
  800420ec65:	00 00 00 
  800420ec68:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ec6d:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420ec74:	00 00 00 
  800420ec77:	41 ff d0             	callq  *%r8

	if (*offset >= ds->ds_size)
  800420ec7a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420ec7e:	48 8b 10             	mov    (%rax),%rdx
  800420ec81:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420ec85:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ec89:	48 39 c2             	cmp    %rax,%rdx
  800420ec8c:	72 0a                	jb     800420ec98 <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  800420ec8e:	b8 04 00 00 00       	mov    $0x4,%eax
  800420ec93:	e9 d3 01 00 00       	jmpq   800420ee6b <_dwarf_abbrev_parse+0x281>

	aboff = *offset;
  800420ec98:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420ec9c:	48 8b 00             	mov    (%rax),%rax
  800420ec9f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  800420eca3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420eca7:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420ecab:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420ecaf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ecb3:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420ecb7:	48 89 d6             	mov    %rdx,%rsi
  800420ecba:	48 89 c7             	mov    %rax,%rdi
  800420ecbd:	48 b8 08 e6 20 04 80 	movabs $0x800420e608,%rax
  800420ecc4:	00 00 00 
  800420ecc7:	ff d0                	callq  *%rax
  800420ecc9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if (entry == 0) {
  800420eccd:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ecd2:	75 15                	jne    800420ece9 <_dwarf_abbrev_parse+0xff>
		/* Last entry. */
		//Need to make connection from below function
		abp->ab_entry = 0;
  800420ecd4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ecd8:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return DW_DLE_NONE;
  800420ecdf:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ece4:	e9 82 01 00 00       	jmpq   800420ee6b <_dwarf_abbrev_parse+0x281>
	}

	tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420ece9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eced:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420ecf1:	48 89 d6             	mov    %rdx,%rsi
  800420ecf4:	48 89 c7             	mov    %rax,%rdi
  800420ecf7:	48 b8 08 e6 20 04 80 	movabs $0x800420e608,%rax
  800420ecfe:	00 00 00 
  800420ed01:	ff d0                	callq  *%rax
  800420ed03:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  800420ed07:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420ed0b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ed0f:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420ed13:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800420ed17:	ba 01 00 00 00       	mov    $0x1,%edx
  800420ed1c:	48 89 cf             	mov    %rcx,%rdi
  800420ed1f:	ff d0                	callq  *%rax
  800420ed21:	88 45 df             	mov    %al,-0x21(%rbp)

	abp->ab_entry    = entry;
  800420ed24:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ed28:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed2c:	48 89 10             	mov    %rdx,(%rax)
	abp->ab_tag      = tag;
  800420ed2f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ed33:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420ed37:	48 89 50 08          	mov    %rdx,0x8(%rax)
	abp->ab_children = children;
  800420ed3b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ed3f:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  800420ed43:	88 50 10             	mov    %dl,0x10(%rax)
	abp->ab_offset   = aboff;
  800420ed46:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ed4a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ed4e:	48 89 50 18          	mov    %rdx,0x18(%rax)
	abp->ab_length   = 0;    /* fill in later. */
  800420ed52:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ed56:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  800420ed5d:	00 
	abp->ab_atnum    = 0;
  800420ed5e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ed62:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  800420ed69:	00 

	/* Parse attribute definitions. */
	do {
		adoff = *offset;
  800420ed6a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420ed6e:	48 8b 00             	mov    (%rax),%rax
  800420ed71:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420ed75:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ed79:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420ed7d:	48 89 d6             	mov    %rdx,%rsi
  800420ed80:	48 89 c7             	mov    %rax,%rdi
  800420ed83:	48 b8 08 e6 20 04 80 	movabs $0x800420e608,%rax
  800420ed8a:	00 00 00 
  800420ed8d:	ff d0                	callq  *%rax
  800420ed8f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420ed93:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ed97:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420ed9b:	48 89 d6             	mov    %rdx,%rsi
  800420ed9e:	48 89 c7             	mov    %rax,%rdi
  800420eda1:	48 b8 08 e6 20 04 80 	movabs $0x800420e608,%rax
  800420eda8:	00 00 00 
  800420edab:	ff d0                	callq  *%rax
  800420edad:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		if (attr != 0)
  800420edb1:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420edb6:	0f 84 89 00 00 00    	je     800420ee45 <_dwarf_abbrev_parse+0x25b>
		{
			/* Initialise the attribute definition structure. */
			abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  800420edbc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420edc0:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420edc4:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420edc8:	48 89 d0             	mov    %rdx,%rax
  800420edcb:	48 01 c0             	add    %rax,%rax
  800420edce:	48 01 d0             	add    %rdx,%rax
  800420edd1:	48 c1 e0 03          	shl    $0x3,%rax
  800420edd5:	48 01 c8             	add    %rcx,%rax
  800420edd8:	48 8d 50 30          	lea    0x30(%rax),%rdx
  800420eddc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ede0:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  800420ede3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ede7:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420edeb:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420edef:	48 89 d0             	mov    %rdx,%rax
  800420edf2:	48 01 c0             	add    %rax,%rax
  800420edf5:	48 01 d0             	add    %rdx,%rax
  800420edf8:	48 c1 e0 03          	shl    $0x3,%rax
  800420edfc:	48 01 c8             	add    %rcx,%rax
  800420edff:	48 8d 50 38          	lea    0x38(%rax),%rdx
  800420ee03:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420ee07:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  800420ee0a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ee0e:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420ee12:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420ee16:	48 89 d0             	mov    %rdx,%rax
  800420ee19:	48 01 c0             	add    %rax,%rax
  800420ee1c:	48 01 d0             	add    %rdx,%rax
  800420ee1f:	48 c1 e0 03          	shl    $0x3,%rax
  800420ee23:	48 01 c8             	add    %rcx,%rax
  800420ee26:	48 8d 50 40          	lea    0x40(%rax),%rdx
  800420ee2a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ee2e:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_atnum++;
  800420ee31:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ee35:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420ee39:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ee3d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ee41:	48 89 50 28          	mov    %rdx,0x28(%rax)
		}
	} while (attr != 0);
  800420ee45:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420ee4a:	0f 85 1a ff ff ff    	jne    800420ed6a <_dwarf_abbrev_parse+0x180>

	//(*abp)->ab_length = *offset - aboff;
	abp->ab_length = (uint64_t)(*offset - aboff);
  800420ee50:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420ee54:	48 8b 00             	mov    (%rax),%rax
  800420ee57:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  800420ee5b:	48 89 c2             	mov    %rax,%rdx
  800420ee5e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ee62:	48 89 50 20          	mov    %rdx,0x20(%rax)

	return DW_DLV_OK;
  800420ee66:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420ee6b:	c9                   	leaveq 
  800420ee6c:	c3                   	retq   

000000800420ee6d <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  800420ee6d:	55                   	push   %rbp
  800420ee6e:	48 89 e5             	mov    %rsp,%rbp
  800420ee71:	48 83 ec 70          	sub    $0x70,%rsp
  800420ee75:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420ee79:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420ee7d:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	Dwarf_Section *ds;
	uint64_t offset;
	int ret;

	if (entry == 0)
  800420ee81:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420ee86:	75 0a                	jne    800420ee92 <_dwarf_abbrev_find+0x25>
	{
		return (DW_DLE_NO_ENTRY);
  800420ee88:	b8 04 00 00 00       	mov    $0x4,%eax
  800420ee8d:	e9 0a 01 00 00       	jmpq   800420ef9c <_dwarf_abbrev_find+0x12f>
	}

	/* Load and search the abbrev table. */
	ds = _dwarf_find_section(".debug_abbrev");
  800420ee92:	48 bf 38 7b 21 04 80 	movabs $0x8004217b38,%rdi
  800420ee99:	00 00 00 
  800420ee9c:	48 b8 cd 31 21 04 80 	movabs $0x80042131cd,%rax
  800420eea3:	00 00 00 
  800420eea6:	ff d0                	callq  *%rax
  800420eea8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(ds != NULL);
  800420eeac:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420eeb1:	75 35                	jne    800420eee8 <_dwarf_abbrev_find+0x7b>
  800420eeb3:	48 b9 2d 7b 21 04 80 	movabs $0x8004217b2d,%rcx
  800420eeba:	00 00 00 
  800420eebd:	48 ba ea 7a 21 04 80 	movabs $0x8004217aea,%rdx
  800420eec4:	00 00 00 
  800420eec7:	be e5 01 00 00       	mov    $0x1e5,%esi
  800420eecc:	48 bf ff 7a 21 04 80 	movabs $0x8004217aff,%rdi
  800420eed3:	00 00 00 
  800420eed6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420eedb:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420eee2:	00 00 00 
  800420eee5:	41 ff d0             	callq  *%r8

	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  800420eee8:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420eeec:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	while (offset < ds->ds_size) {
  800420eef0:	e9 8d 00 00 00       	jmpq   800420ef82 <_dwarf_abbrev_find+0x115>
		ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  800420eef5:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420eef9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420eefd:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  800420ef01:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef05:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  800420ef09:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420ef0d:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
  800420ef11:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420ef16:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  800420ef1a:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420ef1f:	48 8b 7d 28          	mov    0x28(%rbp),%rdi
  800420ef23:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420ef28:	48 8b 7d 30          	mov    0x30(%rbp),%rdi
  800420ef2c:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420ef31:	48 8b 7d 38          	mov    0x38(%rbp),%rdi
  800420ef35:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420ef3a:	48 8b 7d 40          	mov    0x40(%rbp),%rdi
  800420ef3e:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
  800420ef43:	48 89 c7             	mov    %rax,%rdi
  800420ef46:	48 b8 ea eb 20 04 80 	movabs $0x800420ebea,%rax
  800420ef4d:	00 00 00 
  800420ef50:	ff d0                	callq  *%rax
  800420ef52:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (ret != DW_DLE_NONE)
  800420ef55:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420ef59:	74 05                	je     800420ef60 <_dwarf_abbrev_find+0xf3>
			return (ret);
  800420ef5b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ef5e:	eb 3c                	jmp    800420ef9c <_dwarf_abbrev_find+0x12f>
		if (abp->ab_entry == entry) {
  800420ef60:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ef64:	48 8b 00             	mov    (%rax),%rax
  800420ef67:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420ef6b:	75 07                	jne    800420ef74 <_dwarf_abbrev_find+0x107>
			//cu->cu_abbrev_offset_cur = offset;
			return DW_DLE_NONE;
  800420ef6d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ef72:	eb 28                	jmp    800420ef9c <_dwarf_abbrev_find+0x12f>
		}
		if (abp->ab_entry == 0) {
  800420ef74:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ef78:	48 8b 00             	mov    (%rax),%rax
  800420ef7b:	48 85 c0             	test   %rax,%rax
  800420ef7e:	75 02                	jne    800420ef82 <_dwarf_abbrev_find+0x115>
			//cu->cu_abbrev_offset_cur = offset;
			//cu->cu_abbrev_loaded = 1;
			break;
  800420ef80:	eb 15                	jmp    800420ef97 <_dwarf_abbrev_find+0x12a>
	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
	while (offset < ds->ds_size) {
  800420ef82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ef86:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800420ef8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ef8e:	48 39 c2             	cmp    %rax,%rdx
  800420ef91:	0f 87 5e ff ff ff    	ja     800420eef5 <_dwarf_abbrev_find+0x88>
			//cu->cu_abbrev_loaded = 1;
			break;
		}
	}

	return DW_DLE_NO_ENTRY;
  800420ef97:	b8 04 00 00 00       	mov    $0x4,%eax
}
  800420ef9c:	c9                   	leaveq 
  800420ef9d:	c3                   	retq   

000000800420ef9e <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
		 uint64_t form, int indirect)
{
  800420ef9e:	55                   	push   %rbp
  800420ef9f:	48 89 e5             	mov    %rsp,%rbp
  800420efa2:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  800420efa9:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  800420efb0:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  800420efb7:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  800420efbe:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  800420efc5:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  800420efcc:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
	struct _Dwarf_Attribute atref;
	Dwarf_Section *str;
	int ret;
	Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  800420efd3:	48 bf 46 7b 21 04 80 	movabs $0x8004217b46,%rdi
  800420efda:	00 00 00 
  800420efdd:	48 b8 cd 31 21 04 80 	movabs $0x80042131cd,%rax
  800420efe4:	00 00 00 
  800420efe7:	ff d0                	callq  *%rax
  800420efe9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  800420efed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eff1:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420eff5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint8_t dwarf_size = cu->cu_dwarf_size;
  800420eff9:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420f000:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  800420f004:	88 45 e7             	mov    %al,-0x19(%rbp)

	ret = DW_DLE_NONE;
  800420f007:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	memset(&atref, 0, sizeof(atref));
  800420f00e:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  800420f015:	ba 60 00 00 00       	mov    $0x60,%edx
  800420f01a:	be 00 00 00 00       	mov    $0x0,%esi
  800420f01f:	48 89 c7             	mov    %rax,%rdi
  800420f022:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  800420f029:	00 00 00 
  800420f02c:	ff d0                	callq  *%rax
	atref.at_die = ret_die;
  800420f02e:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420f035:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	atref.at_attrib = ad->ad_attrib;
  800420f03c:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420f043:	48 8b 00             	mov    (%rax),%rax
  800420f046:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	atref.at_form = ad->ad_form;
  800420f04a:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420f051:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f055:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	atref.at_indirect = indirect;
  800420f059:	8b 45 10             	mov    0x10(%rbp),%eax
  800420f05c:	89 45 90             	mov    %eax,-0x70(%rbp)
	atref.at_ld = NULL;
  800420f05f:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  800420f066:	00 

	switch (form) {
  800420f067:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  800420f06e:	20 
  800420f06f:	0f 87 82 04 00 00    	ja     800420f4f7 <_dwarf_attr_init+0x559>
  800420f075:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  800420f07c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420f083:	00 
  800420f084:	48 b8 70 7b 21 04 80 	movabs $0x8004217b70,%rax
  800420f08b:	00 00 00 
  800420f08e:	48 01 d0             	add    %rdx,%rax
  800420f091:	48 8b 00             	mov    (%rax),%rax
  800420f094:	ff e0                	jmpq   *%rax
	case DW_FORM_addr:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  800420f096:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420f09d:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f0a1:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800420f0a8:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  800420f0ac:	0f b6 d2             	movzbl %dl,%edx
  800420f0af:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420f0b6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420f0ba:	48 89 cf             	mov    %rcx,%rdi
  800420f0bd:	ff d0                	callq  *%rax
  800420f0bf:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420f0c3:	e9 37 04 00 00       	jmpq   800420f4ff <_dwarf_attr_init+0x561>
	case DW_FORM_block:
	case DW_FORM_exprloc:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  800420f0c8:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420f0cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f0d3:	48 89 d6             	mov    %rdx,%rsi
  800420f0d6:	48 89 c7             	mov    %rax,%rdi
  800420f0d9:	48 b8 08 e6 20 04 80 	movabs $0x800420e608,%rax
  800420f0e0:	00 00 00 
  800420f0e3:	ff d0                	callq  *%rax
  800420f0e5:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420f0e9:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420f0ed:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420f0f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f0f8:	48 89 ce             	mov    %rcx,%rsi
  800420f0fb:	48 89 c7             	mov    %rax,%rdi
  800420f0fe:	48 b8 15 e8 20 04 80 	movabs $0x800420e815,%rax
  800420f105:	00 00 00 
  800420f108:	ff d0                	callq  *%rax
  800420f10a:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800420f10e:	e9 ec 03 00 00       	jmpq   800420f4ff <_dwarf_attr_init+0x561>
	case DW_FORM_block1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  800420f113:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420f11a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f11e:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420f125:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420f129:	ba 01 00 00 00       	mov    $0x1,%edx
  800420f12e:	48 89 cf             	mov    %rcx,%rdi
  800420f131:	ff d0                	callq  *%rax
  800420f133:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420f137:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420f13b:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420f142:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f146:	48 89 ce             	mov    %rcx,%rsi
  800420f149:	48 89 c7             	mov    %rax,%rdi
  800420f14c:	48 b8 15 e8 20 04 80 	movabs $0x800420e815,%rax
  800420f153:	00 00 00 
  800420f156:	ff d0                	callq  *%rax
  800420f158:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800420f15c:	e9 9e 03 00 00       	jmpq   800420f4ff <_dwarf_attr_init+0x561>
	case DW_FORM_block2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  800420f161:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420f168:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f16c:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420f173:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420f177:	ba 02 00 00 00       	mov    $0x2,%edx
  800420f17c:	48 89 cf             	mov    %rcx,%rdi
  800420f17f:	ff d0                	callq  *%rax
  800420f181:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420f185:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420f189:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420f190:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f194:	48 89 ce             	mov    %rcx,%rsi
  800420f197:	48 89 c7             	mov    %rax,%rdi
  800420f19a:	48 b8 15 e8 20 04 80 	movabs $0x800420e815,%rax
  800420f1a1:	00 00 00 
  800420f1a4:	ff d0                	callq  *%rax
  800420f1a6:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800420f1aa:	e9 50 03 00 00       	jmpq   800420f4ff <_dwarf_attr_init+0x561>
	case DW_FORM_block4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  800420f1af:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420f1b6:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f1ba:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420f1c1:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420f1c5:	ba 04 00 00 00       	mov    $0x4,%edx
  800420f1ca:	48 89 cf             	mov    %rcx,%rdi
  800420f1cd:	ff d0                	callq  *%rax
  800420f1cf:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420f1d3:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420f1d7:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420f1de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f1e2:	48 89 ce             	mov    %rcx,%rsi
  800420f1e5:	48 89 c7             	mov    %rax,%rdi
  800420f1e8:	48 b8 15 e8 20 04 80 	movabs $0x800420e815,%rax
  800420f1ef:	00 00 00 
  800420f1f2:	ff d0                	callq  *%rax
  800420f1f4:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800420f1f8:	e9 02 03 00 00       	jmpq   800420f4ff <_dwarf_attr_init+0x561>
	case DW_FORM_data1:
	case DW_FORM_flag:
	case DW_FORM_ref1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  800420f1fd:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420f204:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f208:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420f20f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420f213:	ba 01 00 00 00       	mov    $0x1,%edx
  800420f218:	48 89 cf             	mov    %rcx,%rdi
  800420f21b:	ff d0                	callq  *%rax
  800420f21d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420f221:	e9 d9 02 00 00       	jmpq   800420f4ff <_dwarf_attr_init+0x561>
	case DW_FORM_data2:
	case DW_FORM_ref2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  800420f226:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420f22d:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f231:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420f238:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420f23c:	ba 02 00 00 00       	mov    $0x2,%edx
  800420f241:	48 89 cf             	mov    %rcx,%rdi
  800420f244:	ff d0                	callq  *%rax
  800420f246:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420f24a:	e9 b0 02 00 00       	jmpq   800420f4ff <_dwarf_attr_init+0x561>
	case DW_FORM_data4:
	case DW_FORM_ref4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  800420f24f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420f256:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f25a:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420f261:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420f265:	ba 04 00 00 00       	mov    $0x4,%edx
  800420f26a:	48 89 cf             	mov    %rcx,%rdi
  800420f26d:	ff d0                	callq  *%rax
  800420f26f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420f273:	e9 87 02 00 00       	jmpq   800420f4ff <_dwarf_attr_init+0x561>
	case DW_FORM_data8:
	case DW_FORM_ref8:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  800420f278:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420f27f:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f283:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420f28a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420f28e:	ba 08 00 00 00       	mov    $0x8,%edx
  800420f293:	48 89 cf             	mov    %rcx,%rdi
  800420f296:	ff d0                	callq  *%rax
  800420f298:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420f29c:	e9 5e 02 00 00       	jmpq   800420f4ff <_dwarf_attr_init+0x561>
	case DW_FORM_indirect:
		form = _dwarf_read_uleb128(ds_data, offsetp);
  800420f2a1:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420f2a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f2ac:	48 89 d6             	mov    %rdx,%rsi
  800420f2af:	48 89 c7             	mov    %rax,%rdi
  800420f2b2:	48 b8 08 e6 20 04 80 	movabs $0x800420e608,%rax
  800420f2b9:	00 00 00 
  800420f2bc:	ff d0                	callq  *%rax
  800420f2be:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  800420f2c5:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  800420f2cc:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  800420f2d3:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  800420f2da:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800420f2e1:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420f2e8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420f2ef:	c7 04 24 01 00 00 00 	movl   $0x1,(%rsp)
  800420f2f6:	4d 89 c1             	mov    %r8,%r9
  800420f2f9:	49 89 f8             	mov    %rdi,%r8
  800420f2fc:	48 89 c7             	mov    %rax,%rdi
  800420f2ff:	48 b8 9e ef 20 04 80 	movabs $0x800420ef9e,%rax
  800420f306:	00 00 00 
  800420f309:	ff d0                	callq  *%rax
  800420f30b:	e9 1d 03 00 00       	jmpq   800420f62d <_dwarf_attr_init+0x68f>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
  800420f310:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420f317:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420f31b:	66 83 f8 02          	cmp    $0x2,%ax
  800420f31f:	75 2f                	jne    800420f350 <_dwarf_attr_init+0x3b2>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  800420f321:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420f328:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f32c:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800420f333:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  800420f337:	0f b6 d2             	movzbl %dl,%edx
  800420f33a:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420f341:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420f345:	48 89 cf             	mov    %rcx,%rdi
  800420f348:	ff d0                	callq  *%rax
  800420f34a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  800420f34e:	eb 39                	jmp    800420f389 <_dwarf_attr_init+0x3eb>
		else if (cu->version == 3)
  800420f350:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420f357:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420f35b:	66 83 f8 03          	cmp    $0x3,%ax
  800420f35f:	75 28                	jne    800420f389 <_dwarf_attr_init+0x3eb>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  800420f361:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420f368:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f36c:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  800420f370:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420f377:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420f37b:	48 89 cf             	mov    %rcx,%rdi
  800420f37e:	ff d0                	callq  *%rax
  800420f380:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420f384:	e9 76 01 00 00       	jmpq   800420f4ff <_dwarf_attr_init+0x561>
  800420f389:	e9 71 01 00 00       	jmpq   800420f4ff <_dwarf_attr_init+0x561>
	case DW_FORM_ref_udata:
	case DW_FORM_udata:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  800420f38e:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420f395:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f399:	48 89 d6             	mov    %rdx,%rsi
  800420f39c:	48 89 c7             	mov    %rax,%rdi
  800420f39f:	48 b8 08 e6 20 04 80 	movabs $0x800420e608,%rax
  800420f3a6:	00 00 00 
  800420f3a9:	ff d0                	callq  *%rax
  800420f3ab:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420f3af:	e9 4b 01 00 00       	jmpq   800420f4ff <_dwarf_attr_init+0x561>
	case DW_FORM_sdata:
		atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  800420f3b4:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420f3bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f3bf:	48 89 d6             	mov    %rdx,%rsi
  800420f3c2:	48 89 c7             	mov    %rax,%rdi
  800420f3c5:	48 b8 64 e5 20 04 80 	movabs $0x800420e564,%rax
  800420f3cc:	00 00 00 
  800420f3cf:	ff d0                	callq  *%rax
  800420f3d1:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420f3d5:	e9 25 01 00 00       	jmpq   800420f4ff <_dwarf_attr_init+0x561>
	case DW_FORM_sec_offset:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  800420f3da:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420f3e1:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f3e5:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  800420f3e9:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420f3f0:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420f3f4:	48 89 cf             	mov    %rcx,%rdi
  800420f3f7:	ff d0                	callq  *%rax
  800420f3f9:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420f3fd:	e9 fd 00 00 00       	jmpq   800420f4ff <_dwarf_attr_init+0x561>
	case DW_FORM_string:
		atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  800420f402:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f406:	48 8b 48 18          	mov    0x18(%rax),%rcx
  800420f40a:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420f411:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f415:	48 89 ce             	mov    %rcx,%rsi
  800420f418:	48 89 c7             	mov    %rax,%rdi
  800420f41b:	48 b8 86 e7 20 04 80 	movabs $0x800420e786,%rax
  800420f422:	00 00 00 
  800420f425:	ff d0                	callq  *%rax
  800420f427:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800420f42b:	e9 cf 00 00 00       	jmpq   800420f4ff <_dwarf_attr_init+0x561>
	case DW_FORM_strp:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  800420f430:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420f437:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f43b:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  800420f43f:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420f446:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420f44a:	48 89 cf             	mov    %rcx,%rdi
  800420f44d:	ff d0                	callq  *%rax
  800420f44f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		str = _dwarf_find_section(".debug_str");
  800420f453:	48 bf 52 7b 21 04 80 	movabs $0x8004217b52,%rdi
  800420f45a:	00 00 00 
  800420f45d:	48 b8 cd 31 21 04 80 	movabs $0x80042131cd,%rax
  800420f464:	00 00 00 
  800420f467:	ff d0                	callq  *%rax
  800420f469:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		assert(str != NULL);
  800420f46d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420f472:	75 35                	jne    800420f4a9 <_dwarf_attr_init+0x50b>
  800420f474:	48 b9 5d 7b 21 04 80 	movabs $0x8004217b5d,%rcx
  800420f47b:	00 00 00 
  800420f47e:	48 ba ea 7a 21 04 80 	movabs $0x8004217aea,%rdx
  800420f485:	00 00 00 
  800420f488:	be 51 02 00 00       	mov    $0x251,%esi
  800420f48d:	48 bf ff 7a 21 04 80 	movabs $0x8004217aff,%rdi
  800420f494:	00 00 00 
  800420f497:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f49c:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420f4a3:	00 00 00 
  800420f4a6:	41 ff d0             	callq  *%r8
		//atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
		atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  800420f4a9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f4ad:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420f4b1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f4b5:	48 01 d0             	add    %rdx,%rax
  800420f4b8:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800420f4bc:	eb 41                	jmp    800420f4ff <_dwarf_attr_init+0x561>
	case DW_FORM_ref_sig8:
		atref.u[0].u64 = 8;
  800420f4be:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  800420f4c5:	00 
		atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  800420f4c6:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420f4ca:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420f4d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f4d5:	48 89 ce             	mov    %rcx,%rsi
  800420f4d8:	48 89 c7             	mov    %rax,%rdi
  800420f4db:	48 b8 15 e8 20 04 80 	movabs $0x800420e815,%rax
  800420f4e2:	00 00 00 
  800420f4e5:	ff d0                	callq  *%rax
  800420f4e7:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800420f4eb:	eb 12                	jmp    800420f4ff <_dwarf_attr_init+0x561>
	case DW_FORM_flag_present:
		/* This form has no value encoded in the DIE. */
		atref.u[0].u64 = 1;
  800420f4ed:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  800420f4f4:	00 
		break;
  800420f4f5:	eb 08                	jmp    800420f4ff <_dwarf_attr_init+0x561>
	default:
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
  800420f4f7:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
		break;
  800420f4fe:	90                   	nop
	}

	if (ret == DW_DLE_NONE) {
  800420f4ff:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420f503:	0f 85 21 01 00 00    	jne    800420f62a <_dwarf_attr_init+0x68c>
		if (form == DW_FORM_block || form == DW_FORM_block1 ||
  800420f509:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  800420f510:	09 
  800420f511:	74 1e                	je     800420f531 <_dwarf_attr_init+0x593>
  800420f513:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  800420f51a:	0a 
  800420f51b:	74 14                	je     800420f531 <_dwarf_attr_init+0x593>
  800420f51d:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  800420f524:	03 
  800420f525:	74 0a                	je     800420f531 <_dwarf_attr_init+0x593>
		    form == DW_FORM_block2 || form == DW_FORM_block4) {
  800420f527:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  800420f52e:	04 
  800420f52f:	75 10                	jne    800420f541 <_dwarf_attr_init+0x5a3>
			atref.at_block.bl_len = atref.u[0].u64;
  800420f531:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f535:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			atref.at_block.bl_data = atref.u[1].u8p;
  800420f539:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420f53d:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
  800420f541:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800420f545:	48 83 f8 03          	cmp    $0x3,%rax
  800420f549:	75 39                	jne    800420f584 <_dwarf_attr_init+0x5e6>
			switch (atref.at_form) {
  800420f54b:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800420f54f:	48 83 f8 08          	cmp    $0x8,%rax
  800420f553:	74 1c                	je     800420f571 <_dwarf_attr_init+0x5d3>
  800420f555:	48 83 f8 0e          	cmp    $0xe,%rax
  800420f559:	74 02                	je     800420f55d <_dwarf_attr_init+0x5bf>
				break;
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
				break;
			default:
				break;
  800420f55b:	eb 27                	jmp    800420f584 <_dwarf_attr_init+0x5e6>
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
			switch (atref.at_form) {
			case DW_FORM_strp:
				ret_die->die_name = atref.u[1].s;
  800420f55d:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f561:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420f568:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  800420f56f:	eb 13                	jmp    800420f584 <_dwarf_attr_init+0x5e6>
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
  800420f571:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420f575:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420f57c:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  800420f583:	90                   	nop
			default:
				break;
			}
		}
		ret_die->die_attr[ret_die->die_attr_count++] = atref;
  800420f584:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420f58b:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  800420f592:	8d 48 01             	lea    0x1(%rax),%ecx
  800420f595:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  800420f59c:	88 8a 58 03 00 00    	mov    %cl,0x358(%rdx)
  800420f5a2:	0f b6 c0             	movzbl %al,%eax
  800420f5a5:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  800420f5ac:	48 63 d0             	movslq %eax,%rdx
  800420f5af:	48 89 d0             	mov    %rdx,%rax
  800420f5b2:	48 01 c0             	add    %rax,%rax
  800420f5b5:	48 01 d0             	add    %rdx,%rax
  800420f5b8:	48 c1 e0 05          	shl    $0x5,%rax
  800420f5bc:	48 01 c8             	add    %rcx,%rax
  800420f5bf:	48 05 70 03 00 00    	add    $0x370,%rax
  800420f5c5:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800420f5cc:	48 89 10             	mov    %rdx,(%rax)
  800420f5cf:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  800420f5d6:	48 89 50 08          	mov    %rdx,0x8(%rax)
  800420f5da:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  800420f5de:	48 89 50 10          	mov    %rdx,0x10(%rax)
  800420f5e2:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  800420f5e6:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800420f5ea:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420f5ee:	48 89 50 20          	mov    %rdx,0x20(%rax)
  800420f5f2:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420f5f6:	48 89 50 28          	mov    %rdx,0x28(%rax)
  800420f5fa:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f5fe:	48 89 50 30          	mov    %rdx,0x30(%rax)
  800420f602:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420f606:	48 89 50 38          	mov    %rdx,0x38(%rax)
  800420f60a:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420f60e:	48 89 50 40          	mov    %rdx,0x40(%rax)
  800420f612:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420f616:	48 89 50 48          	mov    %rdx,0x48(%rax)
  800420f61a:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f61e:	48 89 50 50          	mov    %rdx,0x50(%rax)
  800420f622:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f626:	48 89 50 58          	mov    %rdx,0x58(%rax)
	}

	return (ret);
  800420f62a:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420f62d:	c9                   	leaveq 
  800420f62e:	c3                   	retq   

000000800420f62f <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  800420f62f:	55                   	push   %rbp
  800420f630:	48 89 e5             	mov    %rsp,%rbp
  800420f633:	48 81 ec d0 03 00 00 	sub    $0x3d0,%rsp
  800420f63a:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  800420f641:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  800420f648:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  800420f64f:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
	uint64_t abnum;
	uint64_t die_offset;
	int ret, level;
	int i;

	assert(dbg);
  800420f655:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  800420f65c:	00 
  800420f65d:	75 35                	jne    800420f694 <dwarf_search_die_within_cu+0x65>
  800420f65f:	48 b9 78 7c 21 04 80 	movabs $0x8004217c78,%rcx
  800420f666:	00 00 00 
  800420f669:	48 ba ea 7a 21 04 80 	movabs $0x8004217aea,%rdx
  800420f670:	00 00 00 
  800420f673:	be 86 02 00 00       	mov    $0x286,%esi
  800420f678:	48 bf ff 7a 21 04 80 	movabs $0x8004217aff,%rdi
  800420f67f:	00 00 00 
  800420f682:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f687:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420f68e:	00 00 00 
  800420f691:	41 ff d0             	callq  *%r8
	//assert(cu);
	assert(ret_die);
  800420f694:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  800420f69b:	00 
  800420f69c:	75 35                	jne    800420f6d3 <dwarf_search_die_within_cu+0xa4>
  800420f69e:	48 b9 7c 7c 21 04 80 	movabs $0x8004217c7c,%rcx
  800420f6a5:	00 00 00 
  800420f6a8:	48 ba ea 7a 21 04 80 	movabs $0x8004217aea,%rdx
  800420f6af:	00 00 00 
  800420f6b2:	be 88 02 00 00       	mov    $0x288,%esi
  800420f6b7:	48 bf ff 7a 21 04 80 	movabs $0x8004217aff,%rdi
  800420f6be:	00 00 00 
  800420f6c1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f6c6:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420f6cd:	00 00 00 
  800420f6d0:	41 ff d0             	callq  *%r8

	level = 1;
  800420f6d3:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  800420f6da:	e9 17 02 00 00       	jmpq   800420f8f6 <dwarf_search_die_within_cu+0x2c7>

		die_offset = offset;
  800420f6df:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  800420f6e6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  800420f6ea:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800420f6f1:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f6f5:	48 8d 95 80 fc ff ff 	lea    -0x380(%rbp),%rdx
  800420f6fc:	48 89 d6             	mov    %rdx,%rsi
  800420f6ff:	48 89 c7             	mov    %rax,%rdi
  800420f702:	48 b8 08 e6 20 04 80 	movabs $0x800420e608,%rax
  800420f709:	00 00 00 
  800420f70c:	ff d0                	callq  *%rax
  800420f70e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		if (abnum == 0) {
  800420f712:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f717:	75 22                	jne    800420f73b <dwarf_search_die_within_cu+0x10c>
			if (level == 0 || !search_sibling) {
  800420f719:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420f71d:	74 09                	je     800420f728 <dwarf_search_die_within_cu+0xf9>
  800420f71f:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  800420f726:	75 0a                	jne    800420f732 <dwarf_search_die_within_cu+0x103>
				//No more entry
				return (DW_DLE_NO_ENTRY);
  800420f728:	b8 04 00 00 00       	mov    $0x4,%eax
  800420f72d:	e9 f4 01 00 00       	jmpq   800420f926 <dwarf_search_die_within_cu+0x2f7>
			}
			/*
			 * Return to previous DIE level.
			 */
			level--;
  800420f732:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
			continue;
  800420f736:	e9 bb 01 00 00       	jmpq   800420f8f6 <dwarf_search_die_within_cu+0x2c7>
		}

		if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  800420f73b:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  800420f742:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420f746:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800420f74d:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  800420f751:	48 89 34 24          	mov    %rsi,(%rsp)
  800420f755:	48 8b 75 18          	mov    0x18(%rbp),%rsi
  800420f759:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  800420f75e:	48 8b 75 20          	mov    0x20(%rbp),%rsi
  800420f762:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  800420f767:	48 8b 75 28          	mov    0x28(%rbp),%rsi
  800420f76b:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  800420f770:	48 8b 75 30          	mov    0x30(%rbp),%rsi
  800420f774:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
  800420f779:	48 8b 75 38          	mov    0x38(%rbp),%rsi
  800420f77d:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  800420f782:	48 8b 75 40          	mov    0x40(%rbp),%rsi
  800420f786:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
  800420f78b:	48 89 ce             	mov    %rcx,%rsi
  800420f78e:	48 89 c7             	mov    %rax,%rdi
  800420f791:	48 b8 6d ee 20 04 80 	movabs $0x800420ee6d,%rax
  800420f798:	00 00 00 
  800420f79b:	ff d0                	callq  *%rax
  800420f79d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  800420f7a0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420f7a4:	74 08                	je     800420f7ae <dwarf_search_die_within_cu+0x17f>
			return (ret);
  800420f7a6:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f7a9:	e9 78 01 00 00       	jmpq   800420f926 <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_offset = die_offset;
  800420f7ae:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800420f7b5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f7b9:	48 89 10             	mov    %rdx,(%rax)
		ret_die->die_abnum  = abnum;
  800420f7bc:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800420f7c3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f7c7:	48 89 50 10          	mov    %rdx,0x10(%rax)
		ret_die->die_ab  = ab;
  800420f7cb:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800420f7d2:	48 8d 78 20          	lea    0x20(%rax),%rdi
  800420f7d6:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  800420f7dd:	b8 66 00 00 00       	mov    $0x66,%eax
  800420f7e2:	48 89 d6             	mov    %rdx,%rsi
  800420f7e5:	48 89 c1             	mov    %rax,%rcx
  800420f7e8:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		ret_die->die_attr_count = 0;
  800420f7eb:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800420f7f2:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
		ret_die->die_tag = ab.ab_tag;
  800420f7f9:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  800420f800:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800420f807:	48 89 50 18          	mov    %rdx,0x18(%rax)
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  800420f80b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  800420f812:	e9 8e 00 00 00       	jmpq   800420f8a5 <dwarf_search_die_within_cu+0x276>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  800420f817:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420f81a:	48 63 d0             	movslq %eax,%rdx
  800420f81d:	48 89 d0             	mov    %rdx,%rax
  800420f820:	48 01 c0             	add    %rax,%rax
  800420f823:	48 01 d0             	add    %rdx,%rax
  800420f826:	48 c1 e0 03          	shl    $0x3,%rax
  800420f82a:	48 01 e8             	add    %rbp,%rax
  800420f82d:	48 2d 18 03 00 00    	sub    $0x318,%rax
  800420f833:	48 8b 08             	mov    (%rax),%rcx
  800420f836:	48 8d b5 b0 fc ff ff 	lea    -0x350(%rbp),%rsi
  800420f83d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420f840:	48 63 d0             	movslq %eax,%rdx
  800420f843:	48 89 d0             	mov    %rdx,%rax
  800420f846:	48 01 c0             	add    %rax,%rax
  800420f849:	48 01 d0             	add    %rdx,%rax
  800420f84c:	48 c1 e0 03          	shl    $0x3,%rax
  800420f850:	48 83 c0 30          	add    $0x30,%rax
  800420f854:	48 8d 3c 06          	lea    (%rsi,%rax,1),%rdi
  800420f858:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  800420f85f:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  800420f866:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800420f86d:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  800420f874:	49 89 c9             	mov    %rcx,%r9
  800420f877:	49 89 f8             	mov    %rdi,%r8
  800420f87a:	48 89 d1             	mov    %rdx,%rcx
  800420f87d:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  800420f881:	48 89 c7             	mov    %rax,%rdi
  800420f884:	48 b8 9e ef 20 04 80 	movabs $0x800420ef9e,%rax
  800420f88b:	00 00 00 
  800420f88e:	ff d0                	callq  *%rax
  800420f890:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  800420f893:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420f897:	74 08                	je     800420f8a1 <dwarf_search_die_within_cu+0x272>
				return (ret);
  800420f899:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f89c:	e9 85 00 00 00       	jmpq   800420f926 <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_attr_count = 0;
		ret_die->die_tag = ab.ab_tag;
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  800420f8a1:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  800420f8a5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420f8a8:	48 63 d0             	movslq %eax,%rdx
  800420f8ab:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  800420f8b2:	48 39 c2             	cmp    %rax,%rdx
  800420f8b5:	0f 82 5c ff ff ff    	jb     800420f817 <dwarf_search_die_within_cu+0x1e8>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
				return (ret);
		}

		ret_die->die_next_off = offset;
  800420f8bb:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  800420f8c2:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800420f8c9:	48 89 50 08          	mov    %rdx,0x8(%rax)
		if (search_sibling && level > 0) {
  800420f8cd:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  800420f8d4:	74 19                	je     800420f8ef <dwarf_search_die_within_cu+0x2c0>
  800420f8d6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420f8da:	7e 13                	jle    800420f8ef <dwarf_search_die_within_cu+0x2c0>
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  800420f8dc:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  800420f8e3:	3c 01                	cmp    $0x1,%al
  800420f8e5:	75 06                	jne    800420f8ed <dwarf_search_die_within_cu+0x2be>
				/* Advance to next DIE level. */
				level++;
  800420f8e7:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
		}

		ret_die->die_next_off = offset;
		if (search_sibling && level > 0) {
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  800420f8eb:	eb 09                	jmp    800420f8f6 <dwarf_search_die_within_cu+0x2c7>
  800420f8ed:	eb 07                	jmp    800420f8f6 <dwarf_search_die_within_cu+0x2c7>
				/* Advance to next DIE level. */
				level++;
			}
		} else {
			//*ret_die = die;
			return (DW_DLE_NONE);
  800420f8ef:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f8f4:	eb 30                	jmp    800420f926 <dwarf_search_die_within_cu+0x2f7>
	//assert(cu);
	assert(ret_die);

	level = 1;

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  800420f8f6:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  800420f8fa:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  800420f901:	48 39 c2             	cmp    %rax,%rdx
  800420f904:	76 1b                	jbe    800420f921 <dwarf_search_die_within_cu+0x2f2>
  800420f906:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800420f90d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420f911:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  800420f918:	48 39 c2             	cmp    %rax,%rdx
  800420f91b:	0f 87 be fd ff ff    	ja     800420f6df <dwarf_search_die_within_cu+0xb0>
			//*ret_die = die;
			return (DW_DLE_NONE);
		}
	}

	return (DW_DLE_NO_ENTRY);
  800420f921:	b8 04 00 00 00       	mov    $0x4,%eax
}
  800420f926:	c9                   	leaveq 
  800420f927:	c3                   	retq   

000000800420f928 <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  800420f928:	55                   	push   %rbp
  800420f929:	48 89 e5             	mov    %rsp,%rbp
  800420f92c:	48 83 ec 60          	sub    $0x60,%rsp
  800420f930:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f934:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f938:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int ret;

	assert(dbg);
  800420f93c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f941:	75 35                	jne    800420f978 <dwarf_offdie+0x50>
  800420f943:	48 b9 78 7c 21 04 80 	movabs $0x8004217c78,%rcx
  800420f94a:	00 00 00 
  800420f94d:	48 ba ea 7a 21 04 80 	movabs $0x8004217aea,%rdx
  800420f954:	00 00 00 
  800420f957:	be c4 02 00 00       	mov    $0x2c4,%esi
  800420f95c:	48 bf ff 7a 21 04 80 	movabs $0x8004217aff,%rdi
  800420f963:	00 00 00 
  800420f966:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f96b:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420f972:	00 00 00 
  800420f975:	41 ff d0             	callq  *%r8
	assert(ret_die);
  800420f978:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420f97d:	75 35                	jne    800420f9b4 <dwarf_offdie+0x8c>
  800420f97f:	48 b9 7c 7c 21 04 80 	movabs $0x8004217c7c,%rcx
  800420f986:	00 00 00 
  800420f989:	48 ba ea 7a 21 04 80 	movabs $0x8004217aea,%rdx
  800420f990:	00 00 00 
  800420f993:	be c5 02 00 00       	mov    $0x2c5,%esi
  800420f998:	48 bf ff 7a 21 04 80 	movabs $0x8004217aff,%rdi
  800420f99f:	00 00 00 
  800420f9a2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f9a7:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420f9ae:	00 00 00 
  800420f9b1:	41 ff d0             	callq  *%r8

	/* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  800420f9b4:	48 8b 45 30          	mov    0x30(%rbp),%rax
  800420f9b8:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420f9bc:	76 66                	jbe    800420fa24 <dwarf_offdie+0xfc>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  800420f9be:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420f9c2:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420f9c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f9ca:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  800420f9ce:	48 89 0c 24          	mov    %rcx,(%rsp)
  800420f9d2:	48 8b 4d 18          	mov    0x18(%rbp),%rcx
  800420f9d6:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  800420f9db:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
  800420f9df:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  800420f9e4:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800420f9e8:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  800420f9ed:	48 8b 4d 30          	mov    0x30(%rbp),%rcx
  800420f9f1:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  800420f9f6:	48 8b 4d 38          	mov    0x38(%rbp),%rcx
  800420f9fa:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  800420f9ff:	48 8b 4d 40          	mov    0x40(%rbp),%rcx
  800420fa03:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
  800420fa08:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420fa0d:	48 89 c7             	mov    %rax,%rdi
  800420fa10:	48 b8 2f f6 20 04 80 	movabs $0x800420f62f,%rax
  800420fa17:	00 00 00 
  800420fa1a:	ff d0                	callq  *%rax
  800420fa1c:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  800420fa1f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420fa22:	eb 05                	jmp    800420fa29 <dwarf_offdie+0x101>
	}

	/*TODO: Search other CU*/
	return DW_DLV_OK;
  800420fa24:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fa29:	c9                   	leaveq 
  800420fa2a:	c3                   	retq   

000000800420fa2b <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  800420fa2b:	55                   	push   %rbp
  800420fa2c:	48 89 e5             	mov    %rsp,%rbp
  800420fa2f:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420fa33:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fa37:	89 f0                	mov    %esi,%eax
  800420fa39:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Attribute *myat = NULL;
  800420fa3d:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420fa44:	00 
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  800420fa45:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  800420fa4c:	eb 57                	jmp    800420faa5 <_dwarf_attr_find+0x7a>
	{
		if (die->die_attr[i].at_attrib == attr)
  800420fa4e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420fa52:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fa55:	48 63 d0             	movslq %eax,%rdx
  800420fa58:	48 89 d0             	mov    %rdx,%rax
  800420fa5b:	48 01 c0             	add    %rax,%rax
  800420fa5e:	48 01 d0             	add    %rdx,%rax
  800420fa61:	48 c1 e0 05          	shl    $0x5,%rax
  800420fa65:	48 01 c8             	add    %rcx,%rax
  800420fa68:	48 05 80 03 00 00    	add    $0x380,%rax
  800420fa6e:	48 8b 10             	mov    (%rax),%rdx
  800420fa71:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  800420fa75:	48 39 c2             	cmp    %rax,%rdx
  800420fa78:	75 27                	jne    800420faa1 <_dwarf_attr_find+0x76>
		{
			myat = &(die->die_attr[i]);
  800420fa7a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fa7d:	48 63 d0             	movslq %eax,%rdx
  800420fa80:	48 89 d0             	mov    %rdx,%rax
  800420fa83:	48 01 c0             	add    %rax,%rax
  800420fa86:	48 01 d0             	add    %rdx,%rax
  800420fa89:	48 c1 e0 05          	shl    $0x5,%rax
  800420fa8d:	48 8d 90 70 03 00 00 	lea    0x370(%rax),%rdx
  800420fa94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa98:	48 01 d0             	add    %rdx,%rax
  800420fa9b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800420fa9f:	eb 17                	jmp    800420fab8 <_dwarf_attr_find+0x8d>
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
	Dwarf_Attribute *myat = NULL;
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  800420faa1:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800420faa5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420faa9:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  800420fab0:	0f b6 c0             	movzbl %al,%eax
  800420fab3:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  800420fab6:	7f 96                	jg     800420fa4e <_dwarf_attr_find+0x23>
			myat = &(die->die_attr[i]);
			break;
		}
	}

	return myat;
  800420fab8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420fabc:	c9                   	leaveq 
  800420fabd:	c3                   	retq   

000000800420fabe <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
		Dwarf_CU *cu)
{
  800420fabe:	55                   	push   %rbp
  800420fabf:	48 89 e5             	mov    %rsp,%rbp
  800420fac2:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  800420fac6:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420faca:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420face:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800420fad2:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	Dwarf_Attribute *at;
	uint64_t offset;
	int ret, search_sibling;

	assert(dbg);
  800420fad6:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420fadb:	75 35                	jne    800420fb12 <dwarf_siblingof+0x54>
  800420fadd:	48 b9 78 7c 21 04 80 	movabs $0x8004217c78,%rcx
  800420fae4:	00 00 00 
  800420fae7:	48 ba ea 7a 21 04 80 	movabs $0x8004217aea,%rdx
  800420faee:	00 00 00 
  800420faf1:	be ec 02 00 00       	mov    $0x2ec,%esi
  800420faf6:	48 bf ff 7a 21 04 80 	movabs $0x8004217aff,%rdi
  800420fafd:	00 00 00 
  800420fb00:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fb05:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420fb0c:	00 00 00 
  800420fb0f:	41 ff d0             	callq  *%r8
	assert(ret_die);
  800420fb12:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420fb17:	75 35                	jne    800420fb4e <dwarf_siblingof+0x90>
  800420fb19:	48 b9 7c 7c 21 04 80 	movabs $0x8004217c7c,%rcx
  800420fb20:	00 00 00 
  800420fb23:	48 ba ea 7a 21 04 80 	movabs $0x8004217aea,%rdx
  800420fb2a:	00 00 00 
  800420fb2d:	be ed 02 00 00       	mov    $0x2ed,%esi
  800420fb32:	48 bf ff 7a 21 04 80 	movabs $0x8004217aff,%rdi
  800420fb39:	00 00 00 
  800420fb3c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fb41:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420fb48:	00 00 00 
  800420fb4b:	41 ff d0             	callq  *%r8
	assert(cu);
  800420fb4e:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800420fb53:	75 35                	jne    800420fb8a <dwarf_siblingof+0xcc>
  800420fb55:	48 b9 84 7c 21 04 80 	movabs $0x8004217c84,%rcx
  800420fb5c:	00 00 00 
  800420fb5f:	48 ba ea 7a 21 04 80 	movabs $0x8004217aea,%rdx
  800420fb66:	00 00 00 
  800420fb69:	be ee 02 00 00       	mov    $0x2ee,%esi
  800420fb6e:	48 bf ff 7a 21 04 80 	movabs $0x8004217aff,%rdi
  800420fb75:	00 00 00 
  800420fb78:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fb7d:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420fb84:	00 00 00 
  800420fb87:	41 ff d0             	callq  *%r8

	/* Application requests the first DIE in this CU. */
	if (die == NULL)
  800420fb8a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420fb8f:	75 65                	jne    800420fbf6 <dwarf_siblingof+0x138>
		return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  800420fb91:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420fb95:	48 8b 70 28          	mov    0x28(%rax),%rsi
  800420fb99:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420fb9d:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420fba1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420fba5:	48 8b 38             	mov    (%rax),%rdi
  800420fba8:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420fbac:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420fbb0:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420fbb5:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420fbb9:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420fbbe:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420fbc2:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420fbc7:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420fbcb:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420fbd0:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420fbd4:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420fbd9:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420fbdd:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420fbe2:	48 89 cf             	mov    %rcx,%rdi
  800420fbe5:	48 b8 28 f9 20 04 80 	movabs $0x800420f928,%rax
  800420fbec:	00 00 00 
  800420fbef:	ff d0                	callq  *%rax
  800420fbf1:	e9 0a 01 00 00       	jmpq   800420fd00 <dwarf_siblingof+0x242>

	/*
	 * If the DIE doesn't have any children, its sibling sits next
	 * right to it.
	 */
	search_sibling = 0;
  800420fbf6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	if (die->die_ab.ab_children == DW_CHILDREN_no)
  800420fbfd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fc01:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  800420fc05:	84 c0                	test   %al,%al
  800420fc07:	75 0e                	jne    800420fc17 <dwarf_siblingof+0x159>
		offset = die->die_next_off;
  800420fc09:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fc0d:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420fc11:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420fc15:	eb 6b                	jmp    800420fc82 <dwarf_siblingof+0x1c4>
	else {
		/*
		 * Look for DW_AT_sibling attribute for the offset of
		 * its sibling.
		 */
		if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  800420fc17:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fc1b:	be 01 00 00 00       	mov    $0x1,%esi
  800420fc20:	48 89 c7             	mov    %rax,%rdi
  800420fc23:	48 b8 2b fa 20 04 80 	movabs $0x800420fa2b,%rax
  800420fc2a:	00 00 00 
  800420fc2d:	ff d0                	callq  *%rax
  800420fc2f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420fc33:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420fc38:	74 35                	je     800420fc6f <dwarf_siblingof+0x1b1>
			if (at->at_form != DW_FORM_ref_addr)
  800420fc3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc3e:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fc42:	48 83 f8 10          	cmp    $0x10,%rax
  800420fc46:	74 19                	je     800420fc61 <dwarf_siblingof+0x1a3>
				offset = at->u[0].u64 + cu->cu_offset;
  800420fc48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc4c:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420fc50:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420fc54:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420fc58:	48 01 d0             	add    %rdx,%rax
  800420fc5b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420fc5f:	eb 21                	jmp    800420fc82 <dwarf_siblingof+0x1c4>
			else
				offset = at->u[0].u64;
  800420fc61:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc65:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420fc69:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420fc6d:	eb 13                	jmp    800420fc82 <dwarf_siblingof+0x1c4>
		} else {
			offset = die->die_next_off;
  800420fc6f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fc73:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420fc77:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			search_sibling = 1;
  800420fc7b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
		}
	}

	ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  800420fc82:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  800420fc85:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420fc89:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420fc8d:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  800420fc91:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420fc95:	4c 8b 00             	mov    (%rax),%r8
  800420fc98:	4c 89 04 24          	mov    %r8,(%rsp)
  800420fc9c:	4c 8b 40 08          	mov    0x8(%rax),%r8
  800420fca0:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  800420fca5:	4c 8b 40 10          	mov    0x10(%rax),%r8
  800420fca9:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  800420fcae:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420fcb2:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  800420fcb7:	4c 8b 40 20          	mov    0x20(%rax),%r8
  800420fcbb:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
  800420fcc0:	4c 8b 40 28          	mov    0x28(%rax),%r8
  800420fcc4:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
  800420fcc9:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420fccd:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420fcd2:	48 b8 2f f6 20 04 80 	movabs $0x800420f62f,%rax
  800420fcd9:	00 00 00 
  800420fcdc:	ff d0                	callq  *%rax
  800420fcde:	89 45 e4             	mov    %eax,-0x1c(%rbp)


	if (ret == DW_DLE_NO_ENTRY) {
  800420fce1:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  800420fce5:	75 07                	jne    800420fcee <dwarf_siblingof+0x230>
		return (DW_DLV_NO_ENTRY);
  800420fce7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420fcec:	eb 12                	jmp    800420fd00 <dwarf_siblingof+0x242>
	} else if (ret != DW_DLE_NONE)
  800420fcee:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420fcf2:	74 07                	je     800420fcfb <dwarf_siblingof+0x23d>
		return (DW_DLV_ERROR);
  800420fcf4:	b8 01 00 00 00       	mov    $0x1,%eax
  800420fcf9:	eb 05                	jmp    800420fd00 <dwarf_siblingof+0x242>


	return (DW_DLV_OK);
  800420fcfb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fd00:	c9                   	leaveq 
  800420fd01:	c3                   	retq   

000000800420fd02 <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  800420fd02:	55                   	push   %rbp
  800420fd03:	48 89 e5             	mov    %rsp,%rbp
  800420fd06:	48 83 ec 70          	sub    $0x70,%rsp
  800420fd0a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fd0e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420fd12:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420fd16:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int ret;

	assert(die);
  800420fd1a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420fd1f:	75 35                	jne    800420fd56 <dwarf_child+0x54>
  800420fd21:	48 b9 87 7c 21 04 80 	movabs $0x8004217c87,%rcx
  800420fd28:	00 00 00 
  800420fd2b:	48 ba ea 7a 21 04 80 	movabs $0x8004217aea,%rdx
  800420fd32:	00 00 00 
  800420fd35:	be 1c 03 00 00       	mov    $0x31c,%esi
  800420fd3a:	48 bf ff 7a 21 04 80 	movabs $0x8004217aff,%rdi
  800420fd41:	00 00 00 
  800420fd44:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fd49:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420fd50:	00 00 00 
  800420fd53:	41 ff d0             	callq  *%r8
	assert(ret_die);
  800420fd56:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420fd5b:	75 35                	jne    800420fd92 <dwarf_child+0x90>
  800420fd5d:	48 b9 7c 7c 21 04 80 	movabs $0x8004217c7c,%rcx
  800420fd64:	00 00 00 
  800420fd67:	48 ba ea 7a 21 04 80 	movabs $0x8004217aea,%rdx
  800420fd6e:	00 00 00 
  800420fd71:	be 1d 03 00 00       	mov    $0x31d,%esi
  800420fd76:	48 bf ff 7a 21 04 80 	movabs $0x8004217aff,%rdi
  800420fd7d:	00 00 00 
  800420fd80:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fd85:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420fd8c:	00 00 00 
  800420fd8f:	41 ff d0             	callq  *%r8
	assert(dbg);
  800420fd92:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420fd97:	75 35                	jne    800420fdce <dwarf_child+0xcc>
  800420fd99:	48 b9 78 7c 21 04 80 	movabs $0x8004217c78,%rcx
  800420fda0:	00 00 00 
  800420fda3:	48 ba ea 7a 21 04 80 	movabs $0x8004217aea,%rdx
  800420fdaa:	00 00 00 
  800420fdad:	be 1e 03 00 00       	mov    $0x31e,%esi
  800420fdb2:	48 bf ff 7a 21 04 80 	movabs $0x8004217aff,%rdi
  800420fdb9:	00 00 00 
  800420fdbc:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fdc1:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420fdc8:	00 00 00 
  800420fdcb:	41 ff d0             	callq  *%r8
	assert(cu);
  800420fdce:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420fdd3:	75 35                	jne    800420fe0a <dwarf_child+0x108>
  800420fdd5:	48 b9 84 7c 21 04 80 	movabs $0x8004217c84,%rcx
  800420fddc:	00 00 00 
  800420fddf:	48 ba ea 7a 21 04 80 	movabs $0x8004217aea,%rdx
  800420fde6:	00 00 00 
  800420fde9:	be 1f 03 00 00       	mov    $0x31f,%esi
  800420fdee:	48 bf ff 7a 21 04 80 	movabs $0x8004217aff,%rdi
  800420fdf5:	00 00 00 
  800420fdf8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fdfd:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800420fe04:	00 00 00 
  800420fe07:	41 ff d0             	callq  *%r8

	if (die->die_ab.ab_children == DW_CHILDREN_no)
  800420fe0a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe0e:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  800420fe12:	84 c0                	test   %al,%al
  800420fe14:	75 0a                	jne    800420fe20 <dwarf_child+0x11e>
		return (DW_DLE_NO_ENTRY);
  800420fe16:	b8 04 00 00 00       	mov    $0x4,%eax
  800420fe1b:	e9 84 00 00 00       	jmpq   800420fea4 <dwarf_child+0x1a2>

	ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  800420fe20:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe24:	48 8b 70 08          	mov    0x8(%rax),%rsi
  800420fe28:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420fe2c:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  800420fe30:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fe34:	48 8b 08             	mov    (%rax),%rcx
  800420fe37:	48 89 0c 24          	mov    %rcx,(%rsp)
  800420fe3b:	48 8b 48 08          	mov    0x8(%rax),%rcx
  800420fe3f:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  800420fe44:	48 8b 48 10          	mov    0x10(%rax),%rcx
  800420fe48:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  800420fe4d:	48 8b 48 18          	mov    0x18(%rax),%rcx
  800420fe51:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  800420fe56:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800420fe5a:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  800420fe5f:	48 8b 48 28          	mov    0x28(%rax),%rcx
  800420fe63:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  800420fe68:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420fe6c:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420fe71:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420fe76:	48 b8 2f f6 20 04 80 	movabs $0x800420f62f,%rax
  800420fe7d:	00 00 00 
  800420fe80:	ff d0                	callq  *%rax
  800420fe82:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if (ret == DW_DLE_NO_ENTRY) {
  800420fe85:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  800420fe89:	75 07                	jne    800420fe92 <dwarf_child+0x190>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  800420fe8b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420fe90:	eb 12                	jmp    800420fea4 <dwarf_child+0x1a2>
	} else if (ret != DW_DLE_NONE)
  800420fe92:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420fe96:	74 07                	je     800420fe9f <dwarf_child+0x19d>
		return (DW_DLV_ERROR);
  800420fe98:	b8 01 00 00 00       	mov    $0x1,%eax
  800420fe9d:	eb 05                	jmp    800420fea4 <dwarf_child+0x1a2>

	return (DW_DLV_OK);
  800420fe9f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fea4:	c9                   	leaveq 
  800420fea5:	c3                   	retq   

000000800420fea6 <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  800420fea6:	55                   	push   %rbp
  800420fea7:	48 89 e5             	mov    %rsp,%rbp
  800420feaa:	48 83 ec 20          	sub    $0x20,%rsp
  800420feae:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  800420feb2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420feb6:	48 8b 00             	mov    (%rax),%rax
  800420feb9:	48 89 c7             	mov    %rax,%rdi
  800420febc:	48 b8 cd 31 21 04 80 	movabs $0x80042131cd,%rax
  800420fec3:	00 00 00 
  800420fec6:	ff d0                	callq  *%rax
  800420fec8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  800420fecc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fed0:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420fed4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fed8:	48 89 50 08          	mov    %rdx,0x8(%rax)
	ds->ds_addr = secthdr->ds_addr;
  800420fedc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fee0:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420fee4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fee8:	48 89 50 10          	mov    %rdx,0x10(%rax)
	ds->ds_size = secthdr->ds_size;
  800420feec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fef0:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800420fef4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fef8:	48 89 50 18          	mov    %rdx,0x18(%rax)
	return 0;
  800420fefc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420ff01:	c9                   	leaveq 
  800420ff02:	c3                   	retq   

000000800420ff03 <_dwarf_frame_params_init>:

extern int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  800420ff03:	55                   	push   %rbp
  800420ff04:	48 89 e5             	mov    %rsp,%rbp
  800420ff07:	48 83 ec 08          	sub    $0x8,%rsp
  800420ff0b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	/* Initialise call frame related parameters. */
	dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  800420ff0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ff13:	66 c7 40 48 42 00    	movw   $0x42,0x48(%rax)
	dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  800420ff19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ff1d:	66 c7 40 4a 0b 04    	movw   $0x40b,0x4a(%rax)
	dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  800420ff23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ff27:	66 c7 40 4c 9c 05    	movw   $0x59c,0x4c(%rax)
	dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  800420ff2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ff31:	66 c7 40 4e 0b 04    	movw   $0x40b,0x4e(%rax)
	dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  800420ff37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ff3b:	66 c7 40 50 0a 04    	movw   $0x40a,0x50(%rax)
}
  800420ff41:	c9                   	leaveq 
  800420ff42:	c3                   	retq   

000000800420ff43 <dwarf_get_fde_at_pc>:

int
dwarf_get_fde_at_pc(Dwarf_Debug dbg, Dwarf_Addr pc,
		    struct _Dwarf_Fde *ret_fde, Dwarf_Cie cie,
		    Dwarf_Error *error)
{
  800420ff43:	55                   	push   %rbp
  800420ff44:	48 89 e5             	mov    %rsp,%rbp
  800420ff47:	48 83 ec 40          	sub    $0x40,%rsp
  800420ff4b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ff4f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420ff53:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420ff57:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  800420ff5b:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
	Dwarf_Fde fde = ret_fde;
  800420ff5f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ff63:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(fde, 0, sizeof(struct _Dwarf_Fde));
  800420ff67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ff6b:	ba 80 00 00 00       	mov    $0x80,%edx
  800420ff70:	be 00 00 00 00       	mov    $0x0,%esi
  800420ff75:	48 89 c7             	mov    %rax,%rdi
  800420ff78:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  800420ff7f:	00 00 00 
  800420ff82:	ff d0                	callq  *%rax
	fde->fde_cie = cie;
  800420ff84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ff88:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ff8c:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
	if (ret_fde == NULL)
  800420ff90:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420ff95:	75 07                	jne    800420ff9e <dwarf_get_fde_at_pc+0x5b>
		return (DW_DLV_ERROR);
  800420ff97:	b8 01 00 00 00       	mov    $0x1,%eax
  800420ff9c:	eb 75                	jmp    8004210013 <dwarf_get_fde_at_pc+0xd0>

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  800420ff9e:	eb 59                	jmp    800420fff9 <dwarf_get_fde_at_pc+0xb6>
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
  800420ffa0:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420ffa4:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420ffa8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ffac:	be 01 00 00 00       	mov    $0x1,%esi
  800420ffb1:	48 89 c7             	mov    %rax,%rdi
  800420ffb4:	48 b8 58 21 21 04 80 	movabs $0x8004212158,%rax
  800420ffbb:	00 00 00 
  800420ffbe:	ff d0                	callq  *%rax
  800420ffc0:	85 c0                	test   %eax,%eax
  800420ffc2:	79 07                	jns    800420ffcb <dwarf_get_fde_at_pc+0x88>
		{
			return DW_DLV_NO_ENTRY;
  800420ffc4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420ffc9:	eb 48                	jmp    8004210013 <dwarf_get_fde_at_pc+0xd0>
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  800420ffcb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ffcf:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420ffd3:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420ffd7:	77 20                	ja     800420fff9 <dwarf_get_fde_at_pc+0xb6>
  800420ffd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ffdd:	48 8b 50 30          	mov    0x30(%rax),%rdx
		    fde->fde_adrange)
  800420ffe1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ffe5:	48 8b 40 38          	mov    0x38(%rax),%rax
	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
		{
			return DW_DLV_NO_ENTRY;
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  800420ffe9:	48 01 d0             	add    %rdx,%rax
  800420ffec:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420fff0:	76 07                	jbe    800420fff9 <dwarf_get_fde_at_pc+0xb6>
		    fde->fde_adrange)
			return (DW_DLV_OK);
  800420fff2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fff7:	eb 1a                	jmp    8004210013 <dwarf_get_fde_at_pc+0xd0>
	fde->fde_cie = cie;
	
	if (ret_fde == NULL)
		return (DW_DLV_ERROR);

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  800420fff9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fffd:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004210001:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210005:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004210009:	48 39 c2             	cmp    %rax,%rdx
  800421000c:	72 92                	jb     800420ffa0 <dwarf_get_fde_at_pc+0x5d>
		    fde->fde_adrange)
			return (DW_DLV_OK);
	}

	DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
	return (DW_DLV_NO_ENTRY);
  800421000e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8004210013:	c9                   	leaveq 
  8004210014:	c3                   	retq   

0000008004210015 <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
			   Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  8004210015:	55                   	push   %rbp
  8004210016:	48 89 e5             	mov    %rsp,%rbp
  8004210019:	53                   	push   %rbx
  800421001a:	48 83 ec 38          	sub    $0x38,%rsp
  800421001e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210022:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004210026:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800421002a:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	int i;

	assert(dest != NULL);
  800421002e:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004210033:	75 35                	jne    800421006a <_dwarf_frame_regtable_copy+0x55>
  8004210035:	48 b9 9a 7c 21 04 80 	movabs $0x8004217c9a,%rcx
  800421003c:	00 00 00 
  800421003f:	48 ba a7 7c 21 04 80 	movabs $0x8004217ca7,%rdx
  8004210046:	00 00 00 
  8004210049:	be 57 00 00 00       	mov    $0x57,%esi
  800421004e:	48 bf bc 7c 21 04 80 	movabs $0x8004217cbc,%rdi
  8004210055:	00 00 00 
  8004210058:	b8 00 00 00 00       	mov    $0x0,%eax
  800421005d:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004210064:	00 00 00 
  8004210067:	41 ff d0             	callq  *%r8
	assert(src != NULL);
  800421006a:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800421006f:	75 35                	jne    80042100a6 <_dwarf_frame_regtable_copy+0x91>
  8004210071:	48 b9 d2 7c 21 04 80 	movabs $0x8004217cd2,%rcx
  8004210078:	00 00 00 
  800421007b:	48 ba a7 7c 21 04 80 	movabs $0x8004217ca7,%rdx
  8004210082:	00 00 00 
  8004210085:	be 58 00 00 00       	mov    $0x58,%esi
  800421008a:	48 bf bc 7c 21 04 80 	movabs $0x8004217cbc,%rdi
  8004210091:	00 00 00 
  8004210094:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210099:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042100a0:	00 00 00 
  80042100a3:	41 ff d0             	callq  *%r8

	if (*dest == NULL) {
  80042100a6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042100aa:	48 8b 00             	mov    (%rax),%rax
  80042100ad:	48 85 c0             	test   %rax,%rax
  80042100b0:	75 39                	jne    80042100eb <_dwarf_frame_regtable_copy+0xd6>
		*dest = &global_rt_table_shadow;
  80042100b2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042100b6:	48 bb e0 e6 49 04 80 	movabs $0x800449e6e0,%rbx
  80042100bd:	00 00 00 
  80042100c0:	48 89 18             	mov    %rbx,(%rax)
		(*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  80042100c3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042100c7:	48 8b 00             	mov    (%rax),%rax
  80042100ca:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042100ce:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  80042100d2:	66 89 50 18          	mov    %dx,0x18(%rax)
		(*dest)->rt3_rules = global_rules_shadow;
  80042100d6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042100da:	48 8b 00             	mov    (%rax),%rax
  80042100dd:	48 bb 20 e9 49 04 80 	movabs $0x800449e920,%rbx
  80042100e4:	00 00 00 
  80042100e7:	48 89 58 20          	mov    %rbx,0x20(%rax)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  80042100eb:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80042100ef:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042100f3:	48 8b 00             	mov    (%rax),%rax
  80042100f6:	ba 18 00 00 00       	mov    $0x18,%edx
  80042100fb:	48 89 ce             	mov    %rcx,%rsi
  80042100fe:	48 89 c7             	mov    %rax,%rdi
  8004210101:	48 b8 98 dc 20 04 80 	movabs $0x800420dc98,%rax
  8004210108:	00 00 00 
  800421010b:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  800421010d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004210114:	eb 5a                	jmp    8004210170 <_dwarf_frame_regtable_copy+0x15b>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  8004210116:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421011a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421011e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004210121:	48 63 d0             	movslq %eax,%rdx
  8004210124:	48 89 d0             	mov    %rdx,%rax
  8004210127:	48 01 c0             	add    %rax,%rax
  800421012a:	48 01 d0             	add    %rdx,%rax
  800421012d:	48 c1 e0 03          	shl    $0x3,%rax
  8004210131:	48 01 c1             	add    %rax,%rcx
  8004210134:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210138:	48 8b 00             	mov    (%rax),%rax
  800421013b:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421013f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004210142:	48 63 d0             	movslq %eax,%rdx
  8004210145:	48 89 d0             	mov    %rdx,%rax
  8004210148:	48 01 c0             	add    %rax,%rax
  800421014b:	48 01 d0             	add    %rdx,%rax
  800421014e:	48 c1 e0 03          	shl    $0x3,%rax
  8004210152:	48 01 f0             	add    %rsi,%rax
  8004210155:	ba 18 00 00 00       	mov    $0x18,%edx
  800421015a:	48 89 ce             	mov    %rcx,%rsi
  800421015d:	48 89 c7             	mov    %rax,%rdi
  8004210160:	48 b8 98 dc 20 04 80 	movabs $0x800420dc98,%rax
  8004210167:	00 00 00 
  800421016a:	ff d0                	callq  *%rax

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
  800421016c:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004210170:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210174:	48 8b 00             	mov    (%rax),%rax
  8004210177:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421017b:	0f b7 c0             	movzwl %ax,%eax
  800421017e:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004210181:	7e 10                	jle    8004210193 <_dwarf_frame_regtable_copy+0x17e>
		     i < src->rt3_reg_table_size; i++)
  8004210183:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210187:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421018b:	0f b7 c0             	movzwl %ax,%eax
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  800421018e:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004210191:	7f 83                	jg     8004210116 <_dwarf_frame_regtable_copy+0x101>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  8004210193:	eb 32                	jmp    80042101c7 <_dwarf_frame_regtable_copy+0x1b2>
		(*dest)->rt3_rules[i].dw_regnum =
  8004210195:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210199:	48 8b 00             	mov    (%rax),%rax
  800421019c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042101a0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042101a3:	48 63 d0             	movslq %eax,%rdx
  80042101a6:	48 89 d0             	mov    %rdx,%rax
  80042101a9:	48 01 c0             	add    %rax,%rax
  80042101ac:	48 01 d0             	add    %rdx,%rax
  80042101af:	48 c1 e0 03          	shl    $0x3,%rax
  80042101b3:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
			dbg->dbg_frame_undefined_value;
  80042101b7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042101bb:	0f b7 40 50          	movzwl 0x50(%rax),%eax
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
		(*dest)->rt3_rules[i].dw_regnum =
  80042101bf:	66 89 42 02          	mov    %ax,0x2(%rdx)
	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  80042101c3:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042101c7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042101cb:	48 8b 00             	mov    (%rax),%rax
  80042101ce:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042101d2:	0f b7 c0             	movzwl %ax,%eax
  80042101d5:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  80042101d8:	7f bb                	jg     8004210195 <_dwarf_frame_regtable_copy+0x180>
		(*dest)->rt3_rules[i].dw_regnum =
			dbg->dbg_frame_undefined_value;

	return (DW_DLE_NONE);
  80042101da:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042101df:	48 83 c4 38          	add    $0x38,%rsp
  80042101e3:	5b                   	pop    %rbx
  80042101e4:	5d                   	pop    %rbp
  80042101e5:	c3                   	retq   

00000080042101e6 <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
		      Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
		      Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  80042101e6:	55                   	push   %rbp
  80042101e7:	48 89 e5             	mov    %rsp,%rbp
  80042101ea:	53                   	push   %rbx
  80042101eb:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  80042101f2:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  80042101f6:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  80042101fa:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  80042101fe:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  8004210202:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  8004210209:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
			ret = DW_DLE_DF_REG_NUM_TOO_HIGH;               \
			goto program_done;                              \
		}                                                       \
	} while(0)

	ret = DW_DLE_NONE;
  8004210210:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	init_rt = saved_rt = NULL;
  8004210217:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  800421021e:	00 
  800421021f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210223:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	*row_pc = pc;
  8004210227:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421022b:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421022f:	48 89 10             	mov    %rdx,(%rax)

	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  8004210232:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004210236:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800421023a:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  800421023e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004210242:	48 89 c7             	mov    %rax,%rdi
  8004210245:	48 b8 15 00 21 04 80 	movabs $0x8004210015,%rax
  800421024c:	00 00 00 
  800421024f:	ff d0                	callq  *%rax
	p = insts;
  8004210251:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004210255:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	pe = p + len;
  8004210259:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800421025d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004210261:	48 01 d0             	add    %rdx,%rax
  8004210264:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	while (p < pe) {
  8004210268:	e9 3a 0d 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		if (*p == DW_CFA_nop) {
  800421026d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210271:	0f b6 00             	movzbl (%rax),%eax
  8004210274:	84 c0                	test   %al,%al
  8004210276:	75 11                	jne    8004210289 <_dwarf_frame_run_inst+0xa3>
			p++;
  8004210278:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421027c:	48 83 c0 01          	add    $0x1,%rax
  8004210280:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			continue;
  8004210284:	e9 1e 0d 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		}

		high2 = *p & 0xc0;
  8004210289:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421028d:	0f b6 00             	movzbl (%rax),%eax
  8004210290:	83 e0 c0             	and    $0xffffffc0,%eax
  8004210293:	88 45 df             	mov    %al,-0x21(%rbp)
		low6 = *p & 0x3f;
  8004210296:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421029a:	0f b6 00             	movzbl (%rax),%eax
  800421029d:	83 e0 3f             	and    $0x3f,%eax
  80042102a0:	88 45 de             	mov    %al,-0x22(%rbp)
		p++;
  80042102a3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042102a7:	48 83 c0 01          	add    $0x1,%rax
  80042102ab:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

		if (high2 > 0) {
  80042102af:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  80042102b3:	0f 84 a1 01 00 00    	je     800421045a <_dwarf_frame_run_inst+0x274>
			switch (high2) {
  80042102b9:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80042102bd:	3d 80 00 00 00       	cmp    $0x80,%eax
  80042102c2:	74 38                	je     80042102fc <_dwarf_frame_run_inst+0x116>
  80042102c4:	3d c0 00 00 00       	cmp    $0xc0,%eax
  80042102c9:	0f 84 01 01 00 00    	je     80042103d0 <_dwarf_frame_run_inst+0x1ea>
  80042102cf:	83 f8 40             	cmp    $0x40,%eax
  80042102d2:	0f 85 71 01 00 00    	jne    8004210449 <_dwarf_frame_run_inst+0x263>
			case DW_CFA_advance_loc:
			        pc += low6 * caf;
  80042102d8:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  80042102dc:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042102e3:	ff 
  80042102e4:	48 01 45 10          	add    %rax,0x10(%rbp)
			        if (pc_req < pc)
  80042102e8:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042102ec:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042102f0:	73 05                	jae    80042102f7 <_dwarf_frame_run_inst+0x111>
			                goto program_done;
  80042102f2:	e9 be 0c 00 00       	jmpq   8004210fb5 <_dwarf_frame_run_inst+0xdcf>
			        break;
  80042102f7:	e9 59 01 00 00       	jmpq   8004210455 <_dwarf_frame_run_inst+0x26f>
			case DW_CFA_offset:
			        *row_pc = pc;
  80042102fc:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210300:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004210304:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  8004210307:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421030b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421030f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210313:	66 39 c2             	cmp    %ax,%dx
  8004210316:	72 0c                	jb     8004210324 <_dwarf_frame_run_inst+0x13e>
  8004210318:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421031f:	e9 91 0c 00 00       	jmpq   8004210fb5 <_dwarf_frame_run_inst+0xdcf>
			        RL[low6].dw_offset_relevant = 1;
  8004210324:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210328:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421032c:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004210330:	48 89 d0             	mov    %rdx,%rax
  8004210333:	48 01 c0             	add    %rax,%rax
  8004210336:	48 01 d0             	add    %rdx,%rax
  8004210339:	48 c1 e0 03          	shl    $0x3,%rax
  800421033d:	48 01 c8             	add    %rcx,%rax
  8004210340:	c6 00 01             	movb   $0x1,(%rax)
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
  8004210343:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210347:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421034b:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421034f:	48 89 d0             	mov    %rdx,%rax
  8004210352:	48 01 c0             	add    %rax,%rax
  8004210355:	48 01 d0             	add    %rdx,%rax
  8004210358:	48 c1 e0 03          	shl    $0x3,%rax
  800421035c:	48 01 c8             	add    %rcx,%rax
  800421035f:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  8004210363:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210367:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421036b:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421036f:	48 89 d0             	mov    %rdx,%rax
  8004210372:	48 01 c0             	add    %rax,%rax
  8004210375:	48 01 d0             	add    %rdx,%rax
  8004210378:	48 c1 e0 03          	shl    $0x3,%rax
  800421037c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004210380:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004210384:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004210388:	66 89 42 02          	mov    %ax,0x2(%rdx)
			        RL[low6].dw_offset_or_block_len =
  800421038c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210390:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210394:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004210398:	48 89 d0             	mov    %rdx,%rax
  800421039b:	48 01 c0             	add    %rax,%rax
  800421039e:	48 01 d0             	add    %rdx,%rax
  80042103a1:	48 c1 e0 03          	shl    $0x3,%rax
  80042103a5:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
					_dwarf_decode_uleb128(&p) * daf;
  80042103a9:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042103ad:	48 89 c7             	mov    %rax,%rdi
  80042103b0:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  80042103b7:	00 00 00 
  80042103ba:	ff d0                	callq  *%rax
  80042103bc:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  80042103c3:	48 0f af c2          	imul   %rdx,%rax
			        *row_pc = pc;
			        CHECK_TABLE_SIZE(low6);
			        RL[low6].dw_offset_relevant = 1;
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
			        RL[low6].dw_offset_or_block_len =
  80042103c7:	48 89 43 08          	mov    %rax,0x8(%rbx)
					_dwarf_decode_uleb128(&p) * daf;
			        break;
  80042103cb:	e9 85 00 00 00       	jmpq   8004210455 <_dwarf_frame_run_inst+0x26f>
			case DW_CFA_restore:
			        *row_pc = pc;
  80042103d0:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042103d4:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042103d8:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  80042103db:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042103df:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042103e3:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042103e7:	66 39 c2             	cmp    %ax,%dx
  80042103ea:	72 0c                	jb     80042103f8 <_dwarf_frame_run_inst+0x212>
  80042103ec:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042103f3:	e9 bd 0b 00 00       	jmpq   8004210fb5 <_dwarf_frame_run_inst+0xdcf>
			        memcpy(&RL[low6], &INITRL[low6],
  80042103f8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042103fc:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210400:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004210404:	48 89 d0             	mov    %rdx,%rax
  8004210407:	48 01 c0             	add    %rax,%rax
  800421040a:	48 01 d0             	add    %rdx,%rax
  800421040d:	48 c1 e0 03          	shl    $0x3,%rax
  8004210411:	48 01 c1             	add    %rax,%rcx
  8004210414:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210418:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421041c:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004210420:	48 89 d0             	mov    %rdx,%rax
  8004210423:	48 01 c0             	add    %rax,%rax
  8004210426:	48 01 d0             	add    %rdx,%rax
  8004210429:	48 c1 e0 03          	shl    $0x3,%rax
  800421042d:	48 01 f0             	add    %rsi,%rax
  8004210430:	ba 18 00 00 00       	mov    $0x18,%edx
  8004210435:	48 89 ce             	mov    %rcx,%rsi
  8004210438:	48 89 c7             	mov    %rax,%rdi
  800421043b:	48 b8 98 dc 20 04 80 	movabs $0x800420dc98,%rax
  8004210442:	00 00 00 
  8004210445:	ff d0                	callq  *%rax
				       sizeof(Dwarf_Regtable_Entry3));
			        break;
  8004210447:	eb 0c                	jmp    8004210455 <_dwarf_frame_run_inst+0x26f>
			default:
			        DWARF_SET_ERROR(dbg, error,
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
			        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  8004210449:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			        goto program_done;
  8004210450:	e9 60 0b 00 00       	jmpq   8004210fb5 <_dwarf_frame_run_inst+0xdcf>
			}

			continue;
  8004210455:	e9 4d 0b 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		}

		switch (low6) {
  800421045a:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  800421045e:	83 f8 16             	cmp    $0x16,%eax
  8004210461:	0f 87 37 0b 00 00    	ja     8004210f9e <_dwarf_frame_run_inst+0xdb8>
  8004210467:	89 c0                	mov    %eax,%eax
  8004210469:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004210470:	00 
  8004210471:	48 b8 e0 7c 21 04 80 	movabs $0x8004217ce0,%rax
  8004210478:	00 00 00 
  800421047b:	48 01 d0             	add    %rdx,%rax
  800421047e:	48 8b 00             	mov    (%rax),%rax
  8004210481:	ff e0                	jmpq   *%rax
		case DW_CFA_set_loc:
			pc = dbg->decode(&p, dbg->dbg_pointer_size);
  8004210483:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004210487:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421048b:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421048f:	8b 4a 28             	mov    0x28(%rdx),%ecx
  8004210492:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004210496:	89 ce                	mov    %ecx,%esi
  8004210498:	48 89 d7             	mov    %rdx,%rdi
  800421049b:	ff d0                	callq  *%rax
  800421049d:	48 89 45 10          	mov    %rax,0x10(%rbp)
			if (pc_req < pc)
  80042104a1:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042104a5:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042104a9:	73 05                	jae    80042104b0 <_dwarf_frame_run_inst+0x2ca>
			        goto program_done;
  80042104ab:	e9 05 0b 00 00       	jmpq   8004210fb5 <_dwarf_frame_run_inst+0xdcf>
			break;
  80042104b0:	e9 f2 0a 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc1:
			pc += dbg->decode(&p, 1) * caf;
  80042104b5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042104b9:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042104bd:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  80042104c1:	be 01 00 00 00       	mov    $0x1,%esi
  80042104c6:	48 89 d7             	mov    %rdx,%rdi
  80042104c9:	ff d0                	callq  *%rax
  80042104cb:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042104d2:	ff 
  80042104d3:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  80042104d7:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042104db:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042104df:	73 05                	jae    80042104e6 <_dwarf_frame_run_inst+0x300>
			        goto program_done;
  80042104e1:	e9 cf 0a 00 00       	jmpq   8004210fb5 <_dwarf_frame_run_inst+0xdcf>
			break;
  80042104e6:	e9 bc 0a 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc2:
			pc += dbg->decode(&p, 2) * caf;
  80042104eb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042104ef:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042104f3:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  80042104f7:	be 02 00 00 00       	mov    $0x2,%esi
  80042104fc:	48 89 d7             	mov    %rdx,%rdi
  80042104ff:	ff d0                	callq  *%rax
  8004210501:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004210508:	ff 
  8004210509:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  800421050d:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004210511:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004210515:	73 05                	jae    800421051c <_dwarf_frame_run_inst+0x336>
			        goto program_done;
  8004210517:	e9 99 0a 00 00       	jmpq   8004210fb5 <_dwarf_frame_run_inst+0xdcf>
			break;
  800421051c:	e9 86 0a 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc4:
			pc += dbg->decode(&p, 4) * caf;
  8004210521:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004210525:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004210529:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800421052d:	be 04 00 00 00       	mov    $0x4,%esi
  8004210532:	48 89 d7             	mov    %rdx,%rdi
  8004210535:	ff d0                	callq  *%rax
  8004210537:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800421053e:	ff 
  800421053f:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004210543:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004210547:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421054b:	73 05                	jae    8004210552 <_dwarf_frame_run_inst+0x36c>
			        goto program_done;
  800421054d:	e9 63 0a 00 00       	jmpq   8004210fb5 <_dwarf_frame_run_inst+0xdcf>
			break;
  8004210552:	e9 50 0a 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_offset_extended:
			*row_pc = pc;
  8004210557:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421055b:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421055f:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004210562:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210566:	48 89 c7             	mov    %rax,%rdi
  8004210569:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004210570:	00 00 00 
  8004210573:	ff d0                	callq  *%rax
  8004210575:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  8004210579:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421057d:	48 89 c7             	mov    %rax,%rdi
  8004210580:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004210587:	00 00 00 
  800421058a:	ff d0                	callq  *%rax
  800421058c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004210590:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210594:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210598:	0f b7 c0             	movzwl %ax,%eax
  800421059b:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421059f:	77 0c                	ja     80042105ad <_dwarf_frame_run_inst+0x3c7>
  80042105a1:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042105a8:	e9 08 0a 00 00       	jmpq   8004210fb5 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  80042105ad:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042105b1:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042105b5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042105b9:	48 89 d0             	mov    %rdx,%rax
  80042105bc:	48 01 c0             	add    %rax,%rax
  80042105bf:	48 01 d0             	add    %rdx,%rax
  80042105c2:	48 c1 e0 03          	shl    $0x3,%rax
  80042105c6:	48 01 c8             	add    %rcx,%rax
  80042105c9:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  80042105cc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042105d0:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042105d4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042105d8:	48 89 d0             	mov    %rdx,%rax
  80042105db:	48 01 c0             	add    %rax,%rax
  80042105de:	48 01 d0             	add    %rdx,%rax
  80042105e1:	48 c1 e0 03          	shl    $0x3,%rax
  80042105e5:	48 01 c8             	add    %rcx,%rax
  80042105e8:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  80042105ec:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042105f0:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042105f4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042105f8:	48 89 d0             	mov    %rdx,%rax
  80042105fb:	48 01 c0             	add    %rax,%rax
  80042105fe:	48 01 d0             	add    %rdx,%rax
  8004210601:	48 c1 e0 03          	shl    $0x3,%rax
  8004210605:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004210609:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421060d:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004210611:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  8004210615:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210619:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421061d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210621:	48 89 d0             	mov    %rdx,%rax
  8004210624:	48 01 c0             	add    %rax,%rax
  8004210627:	48 01 d0             	add    %rdx,%rax
  800421062a:	48 c1 e0 03          	shl    $0x3,%rax
  800421062e:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004210632:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004210639:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  800421063e:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004210642:	e9 60 09 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_restore_extended:
			*row_pc = pc;
  8004210647:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421064b:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421064f:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004210652:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210656:	48 89 c7             	mov    %rax,%rdi
  8004210659:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004210660:	00 00 00 
  8004210663:	ff d0                	callq  *%rax
  8004210665:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004210669:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421066d:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210671:	0f b7 c0             	movzwl %ax,%eax
  8004210674:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004210678:	77 0c                	ja     8004210686 <_dwarf_frame_run_inst+0x4a0>
  800421067a:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004210681:	e9 2f 09 00 00       	jmpq   8004210fb5 <_dwarf_frame_run_inst+0xdcf>
			memcpy(&RL[reg], &INITRL[reg],
  8004210686:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421068a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421068e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210692:	48 89 d0             	mov    %rdx,%rax
  8004210695:	48 01 c0             	add    %rax,%rax
  8004210698:	48 01 d0             	add    %rdx,%rax
  800421069b:	48 c1 e0 03          	shl    $0x3,%rax
  800421069f:	48 01 c1             	add    %rax,%rcx
  80042106a2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042106a6:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042106aa:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042106ae:	48 89 d0             	mov    %rdx,%rax
  80042106b1:	48 01 c0             	add    %rax,%rax
  80042106b4:	48 01 d0             	add    %rdx,%rax
  80042106b7:	48 c1 e0 03          	shl    $0x3,%rax
  80042106bb:	48 01 f0             	add    %rsi,%rax
  80042106be:	ba 18 00 00 00       	mov    $0x18,%edx
  80042106c3:	48 89 ce             	mov    %rcx,%rsi
  80042106c6:	48 89 c7             	mov    %rax,%rdi
  80042106c9:	48 b8 98 dc 20 04 80 	movabs $0x800420dc98,%rax
  80042106d0:	00 00 00 
  80042106d3:	ff d0                	callq  *%rax
			       sizeof(Dwarf_Regtable_Entry3));
			break;
  80042106d5:	e9 cd 08 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_undefined:
			*row_pc = pc;
  80042106da:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042106de:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042106e2:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042106e5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042106e9:	48 89 c7             	mov    %rax,%rdi
  80042106ec:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  80042106f3:	00 00 00 
  80042106f6:	ff d0                	callq  *%rax
  80042106f8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042106fc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210700:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210704:	0f b7 c0             	movzwl %ax,%eax
  8004210707:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421070b:	77 0c                	ja     8004210719 <_dwarf_frame_run_inst+0x533>
  800421070d:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004210714:	e9 9c 08 00 00       	jmpq   8004210fb5 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  8004210719:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421071d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210721:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210725:	48 89 d0             	mov    %rdx,%rax
  8004210728:	48 01 c0             	add    %rax,%rax
  800421072b:	48 01 d0             	add    %rdx,%rax
  800421072e:	48 c1 e0 03          	shl    $0x3,%rax
  8004210732:	48 01 c8             	add    %rcx,%rax
  8004210735:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  8004210738:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421073c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210740:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210744:	48 89 d0             	mov    %rdx,%rax
  8004210747:	48 01 c0             	add    %rax,%rax
  800421074a:	48 01 d0             	add    %rdx,%rax
  800421074d:	48 c1 e0 03          	shl    $0x3,%rax
  8004210751:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004210755:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004210759:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  800421075d:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  8004210761:	e9 41 08 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_same_value:
			reg = _dwarf_decode_uleb128(&p);
  8004210766:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421076a:	48 89 c7             	mov    %rax,%rdi
  800421076d:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004210774:	00 00 00 
  8004210777:	ff d0                	callq  *%rax
  8004210779:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800421077d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210781:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210785:	0f b7 c0             	movzwl %ax,%eax
  8004210788:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421078c:	77 0c                	ja     800421079a <_dwarf_frame_run_inst+0x5b4>
  800421078e:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004210795:	e9 1b 08 00 00       	jmpq   8004210fb5 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  800421079a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421079e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042107a2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042107a6:	48 89 d0             	mov    %rdx,%rax
  80042107a9:	48 01 c0             	add    %rax,%rax
  80042107ac:	48 01 d0             	add    %rdx,%rax
  80042107af:	48 c1 e0 03          	shl    $0x3,%rax
  80042107b3:	48 01 c8             	add    %rcx,%rax
  80042107b6:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  80042107b9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042107bd:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042107c1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042107c5:	48 89 d0             	mov    %rdx,%rax
  80042107c8:	48 01 c0             	add    %rax,%rax
  80042107cb:	48 01 d0             	add    %rdx,%rax
  80042107ce:	48 c1 e0 03          	shl    $0x3,%rax
  80042107d2:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042107d6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042107da:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  80042107de:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  80042107e2:	e9 c0 07 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_register:
			*row_pc = pc;
  80042107e7:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042107eb:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042107ef:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042107f2:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042107f6:	48 89 c7             	mov    %rax,%rdi
  80042107f9:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004210800:	00 00 00 
  8004210803:	ff d0                	callq  *%rax
  8004210805:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			reg2 = _dwarf_decode_uleb128(&p);
  8004210809:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421080d:	48 89 c7             	mov    %rax,%rdi
  8004210810:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004210817:	00 00 00 
  800421081a:	ff d0                	callq  *%rax
  800421081c:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004210820:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210824:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210828:	0f b7 c0             	movzwl %ax,%eax
  800421082b:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421082f:	77 0c                	ja     800421083d <_dwarf_frame_run_inst+0x657>
  8004210831:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004210838:	e9 78 07 00 00       	jmpq   8004210fb5 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  800421083d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210841:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210845:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210849:	48 89 d0             	mov    %rdx,%rax
  800421084c:	48 01 c0             	add    %rax,%rax
  800421084f:	48 01 d0             	add    %rdx,%rax
  8004210852:	48 c1 e0 03          	shl    $0x3,%rax
  8004210856:	48 01 c8             	add    %rcx,%rax
  8004210859:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = reg2;
  800421085c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210860:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210864:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210868:	48 89 d0             	mov    %rdx,%rax
  800421086b:	48 01 c0             	add    %rax,%rax
  800421086e:	48 01 d0             	add    %rdx,%rax
  8004210871:	48 c1 e0 03          	shl    $0x3,%rax
  8004210875:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004210879:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421087d:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  8004210881:	e9 21 07 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_remember_state:
			_dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  8004210886:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800421088a:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800421088e:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  8004210892:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004210896:	48 89 c7             	mov    %rax,%rdi
  8004210899:	48 b8 15 00 21 04 80 	movabs $0x8004210015,%rax
  80042108a0:	00 00 00 
  80042108a3:	ff d0                	callq  *%rax
			break;
  80042108a5:	e9 fd 06 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_restore_state:
			*row_pc = pc;
  80042108aa:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042108ae:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042108b2:	48 89 10             	mov    %rdx,(%rax)
			_dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  80042108b5:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80042108b9:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  80042108bd:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  80042108c1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042108c5:	48 89 c7             	mov    %rax,%rdi
  80042108c8:	48 b8 15 00 21 04 80 	movabs $0x8004210015,%rax
  80042108cf:	00 00 00 
  80042108d2:	ff d0                	callq  *%rax
			break;
  80042108d4:	e9 ce 06 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa:
			*row_pc = pc;
  80042108d9:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042108dd:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042108e1:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042108e4:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042108e8:	48 89 c7             	mov    %rax,%rdi
  80042108eb:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  80042108f2:	00 00 00 
  80042108f5:	ff d0                	callq  *%rax
  80042108f7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  80042108fb:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042108ff:	48 89 c7             	mov    %rax,%rdi
  8004210902:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004210909:	00 00 00 
  800421090c:	ff d0                	callq  *%rax
  800421090e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  8004210912:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210916:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004210919:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421091d:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  8004210921:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210925:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210929:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = uoff;
  800421092d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210931:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210935:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004210939:	e9 69 06 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_register:
			*row_pc = pc;
  800421093e:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210942:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004210946:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004210949:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421094d:	48 89 c7             	mov    %rax,%rdi
  8004210950:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004210957:	00 00 00 
  800421095a:	ff d0                	callq  *%rax
  800421095c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CFA.dw_regnum = reg;
  8004210960:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210964:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210968:	66 89 50 02          	mov    %dx,0x2(%rax)
			 * Note that DW_CFA_def_cfa_register change the CFA
			 * rule register while keep the old offset. So we
			 * should not touch the CFA.dw_offset_relevant flag
			 * here.
			 */
			break;
  800421096c:	e9 36 06 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_offset:
			*row_pc = pc;
  8004210971:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210975:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004210979:	48 89 10             	mov    %rdx,(%rax)
			uoff = _dwarf_decode_uleb128(&p);
  800421097c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210980:	48 89 c7             	mov    %rax,%rdi
  8004210983:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  800421098a:	00 00 00 
  800421098d:	ff d0                	callq  *%rax
  800421098f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  8004210993:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210997:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  800421099a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421099e:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = uoff;
  80042109a2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042109a6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042109aa:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  80042109ae:	e9 f4 05 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_expression:
			*row_pc = pc;
  80042109b3:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042109b7:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042109bb:	48 89 10             	mov    %rdx,(%rax)
			CFA.dw_offset_relevant = 0;
  80042109be:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042109c2:	c6 00 00             	movb   $0x0,(%rax)
			CFA.dw_value_type = DW_EXPR_EXPRESSION;
  80042109c5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042109c9:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  80042109cd:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  80042109d1:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042109d5:	48 89 c7             	mov    %rax,%rdi
  80042109d8:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  80042109df:	00 00 00 
  80042109e2:	ff d0                	callq  *%rax
  80042109e4:	48 89 43 08          	mov    %rax,0x8(%rbx)
			CFA.dw_block_ptr = p;
  80042109e8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042109ec:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042109f0:	48 89 50 10          	mov    %rdx,0x10(%rax)
			p += CFA.dw_offset_or_block_len;
  80042109f4:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042109f8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042109fc:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210a00:	48 01 d0             	add    %rdx,%rax
  8004210a03:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  8004210a07:	e9 9b 05 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_expression:
			*row_pc = pc;
  8004210a0c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210a10:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004210a14:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004210a17:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210a1b:	48 89 c7             	mov    %rax,%rdi
  8004210a1e:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004210a25:	00 00 00 
  8004210a28:	ff d0                	callq  *%rax
  8004210a2a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004210a2e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210a32:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210a36:	0f b7 c0             	movzwl %ax,%eax
  8004210a39:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004210a3d:	77 0c                	ja     8004210a4b <_dwarf_frame_run_inst+0x865>
  8004210a3f:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004210a46:	e9 6a 05 00 00       	jmpq   8004210fb5 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  8004210a4b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210a4f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210a53:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210a57:	48 89 d0             	mov    %rdx,%rax
  8004210a5a:	48 01 c0             	add    %rax,%rax
  8004210a5d:	48 01 d0             	add    %rdx,%rax
  8004210a60:	48 c1 e0 03          	shl    $0x3,%rax
  8004210a64:	48 01 c8             	add    %rcx,%rax
  8004210a67:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  8004210a6a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210a6e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210a72:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210a76:	48 89 d0             	mov    %rdx,%rax
  8004210a79:	48 01 c0             	add    %rax,%rax
  8004210a7c:	48 01 d0             	add    %rdx,%rax
  8004210a7f:	48 c1 e0 03          	shl    $0x3,%rax
  8004210a83:	48 01 c8             	add    %rcx,%rax
  8004210a86:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  8004210a8a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210a8e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210a92:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210a96:	48 89 d0             	mov    %rdx,%rax
  8004210a99:	48 01 c0             	add    %rax,%rax
  8004210a9c:	48 01 d0             	add    %rdx,%rax
  8004210a9f:	48 c1 e0 03          	shl    $0x3,%rax
  8004210aa3:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004210aa7:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210aab:	48 89 c7             	mov    %rax,%rdi
  8004210aae:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004210ab5:	00 00 00 
  8004210ab8:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  8004210aba:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  8004210abe:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210ac2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210ac6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210aca:	48 89 d0             	mov    %rdx,%rax
  8004210acd:	48 01 c0             	add    %rax,%rax
  8004210ad0:	48 01 d0             	add    %rdx,%rax
  8004210ad3:	48 c1 e0 03          	shl    $0x3,%rax
  8004210ad7:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004210adb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210adf:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  8004210ae3:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004210ae7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210aeb:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004210aef:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210af3:	48 89 d0             	mov    %rdx,%rax
  8004210af6:	48 01 c0             	add    %rax,%rax
  8004210af9:	48 01 d0             	add    %rdx,%rax
  8004210afc:	48 c1 e0 03          	shl    $0x3,%rax
  8004210b00:	48 01 f0             	add    %rsi,%rax
  8004210b03:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210b07:	48 01 c8             	add    %rcx,%rax
  8004210b0a:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  8004210b0e:	e9 94 04 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_offset_extended_sf:
			*row_pc = pc;
  8004210b13:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210b17:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004210b1b:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004210b1e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210b22:	48 89 c7             	mov    %rax,%rdi
  8004210b25:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004210b2c:	00 00 00 
  8004210b2f:	ff d0                	callq  *%rax
  8004210b31:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004210b35:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210b39:	48 89 c7             	mov    %rax,%rdi
  8004210b3c:	48 b8 87 e6 20 04 80 	movabs $0x800420e687,%rax
  8004210b43:	00 00 00 
  8004210b46:	ff d0                	callq  *%rax
  8004210b48:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004210b4c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210b50:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210b54:	0f b7 c0             	movzwl %ax,%eax
  8004210b57:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004210b5b:	77 0c                	ja     8004210b69 <_dwarf_frame_run_inst+0x983>
  8004210b5d:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004210b64:	e9 4c 04 00 00       	jmpq   8004210fb5 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  8004210b69:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210b6d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210b71:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210b75:	48 89 d0             	mov    %rdx,%rax
  8004210b78:	48 01 c0             	add    %rax,%rax
  8004210b7b:	48 01 d0             	add    %rdx,%rax
  8004210b7e:	48 c1 e0 03          	shl    $0x3,%rax
  8004210b82:	48 01 c8             	add    %rcx,%rax
  8004210b85:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004210b88:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210b8c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210b90:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210b94:	48 89 d0             	mov    %rdx,%rax
  8004210b97:	48 01 c0             	add    %rax,%rax
  8004210b9a:	48 01 d0             	add    %rdx,%rax
  8004210b9d:	48 c1 e0 03          	shl    $0x3,%rax
  8004210ba1:	48 01 c8             	add    %rcx,%rax
  8004210ba4:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004210ba8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210bac:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210bb0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210bb4:	48 89 d0             	mov    %rdx,%rax
  8004210bb7:	48 01 c0             	add    %rax,%rax
  8004210bba:	48 01 d0             	add    %rdx,%rax
  8004210bbd:	48 c1 e0 03          	shl    $0x3,%rax
  8004210bc1:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004210bc5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004210bc9:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004210bcd:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  8004210bd1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210bd5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210bd9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210bdd:	48 89 d0             	mov    %rdx,%rax
  8004210be0:	48 01 c0             	add    %rax,%rax
  8004210be3:	48 01 d0             	add    %rdx,%rax
  8004210be6:	48 c1 e0 03          	shl    $0x3,%rax
  8004210bea:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004210bee:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004210bf5:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004210bfa:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004210bfe:	e9 a4 03 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_sf:
			*row_pc = pc;
  8004210c03:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210c07:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004210c0b:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004210c0e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210c12:	48 89 c7             	mov    %rax,%rdi
  8004210c15:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004210c1c:	00 00 00 
  8004210c1f:	ff d0                	callq  *%rax
  8004210c21:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004210c25:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210c29:	48 89 c7             	mov    %rax,%rdi
  8004210c2c:	48 b8 87 e6 20 04 80 	movabs $0x800420e687,%rax
  8004210c33:	00 00 00 
  8004210c36:	ff d0                	callq  *%rax
  8004210c38:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  8004210c3c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210c40:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004210c43:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210c47:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  8004210c4b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210c4f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210c53:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  8004210c57:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210c5b:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004210c62:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004210c67:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004210c6b:	e9 37 03 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_offset_sf:
			*row_pc = pc;
  8004210c70:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210c74:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004210c78:	48 89 10             	mov    %rdx,(%rax)
			soff = _dwarf_decode_sleb128(&p);
  8004210c7b:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210c7f:	48 89 c7             	mov    %rax,%rdi
  8004210c82:	48 b8 87 e6 20 04 80 	movabs $0x800420e687,%rax
  8004210c89:	00 00 00 
  8004210c8c:	ff d0                	callq  *%rax
  8004210c8e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  8004210c92:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210c96:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004210c99:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210c9d:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  8004210ca1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210ca5:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004210cac:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004210cb1:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004210cb5:	e9 ed 02 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_offset:
			*row_pc = pc;
  8004210cba:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210cbe:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004210cc2:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004210cc5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210cc9:	48 89 c7             	mov    %rax,%rdi
  8004210ccc:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004210cd3:	00 00 00 
  8004210cd6:	ff d0                	callq  *%rax
  8004210cd8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  8004210cdc:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210ce0:	48 89 c7             	mov    %rax,%rdi
  8004210ce3:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004210cea:	00 00 00 
  8004210ced:	ff d0                	callq  *%rax
  8004210cef:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004210cf3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210cf7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210cfb:	0f b7 c0             	movzwl %ax,%eax
  8004210cfe:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004210d02:	77 0c                	ja     8004210d10 <_dwarf_frame_run_inst+0xb2a>
  8004210d04:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004210d0b:	e9 a5 02 00 00       	jmpq   8004210fb5 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  8004210d10:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210d14:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210d18:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210d1c:	48 89 d0             	mov    %rdx,%rax
  8004210d1f:	48 01 c0             	add    %rax,%rax
  8004210d22:	48 01 d0             	add    %rdx,%rax
  8004210d25:	48 c1 e0 03          	shl    $0x3,%rax
  8004210d29:	48 01 c8             	add    %rcx,%rax
  8004210d2c:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004210d2f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210d33:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210d37:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210d3b:	48 89 d0             	mov    %rdx,%rax
  8004210d3e:	48 01 c0             	add    %rax,%rax
  8004210d41:	48 01 d0             	add    %rdx,%rax
  8004210d44:	48 c1 e0 03          	shl    $0x3,%rax
  8004210d48:	48 01 c8             	add    %rcx,%rax
  8004210d4b:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004210d4f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210d53:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210d57:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210d5b:	48 89 d0             	mov    %rdx,%rax
  8004210d5e:	48 01 c0             	add    %rax,%rax
  8004210d61:	48 01 d0             	add    %rdx,%rax
  8004210d64:	48 c1 e0 03          	shl    $0x3,%rax
  8004210d68:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004210d6c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004210d70:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004210d74:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  8004210d78:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210d7c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210d80:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210d84:	48 89 d0             	mov    %rdx,%rax
  8004210d87:	48 01 c0             	add    %rax,%rax
  8004210d8a:	48 01 d0             	add    %rdx,%rax
  8004210d8d:	48 c1 e0 03          	shl    $0x3,%rax
  8004210d91:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004210d95:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004210d9c:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004210da1:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004210da5:	e9 fd 01 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_offset_sf:
			*row_pc = pc;
  8004210daa:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210dae:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004210db2:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004210db5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210db9:	48 89 c7             	mov    %rax,%rdi
  8004210dbc:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004210dc3:	00 00 00 
  8004210dc6:	ff d0                	callq  *%rax
  8004210dc8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004210dcc:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210dd0:	48 89 c7             	mov    %rax,%rdi
  8004210dd3:	48 b8 87 e6 20 04 80 	movabs $0x800420e687,%rax
  8004210dda:	00 00 00 
  8004210ddd:	ff d0                	callq  *%rax
  8004210ddf:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004210de3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210de7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210deb:	0f b7 c0             	movzwl %ax,%eax
  8004210dee:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004210df2:	77 0c                	ja     8004210e00 <_dwarf_frame_run_inst+0xc1a>
  8004210df4:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004210dfb:	e9 b5 01 00 00       	jmpq   8004210fb5 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  8004210e00:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210e04:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210e08:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210e0c:	48 89 d0             	mov    %rdx,%rax
  8004210e0f:	48 01 c0             	add    %rax,%rax
  8004210e12:	48 01 d0             	add    %rdx,%rax
  8004210e15:	48 c1 e0 03          	shl    $0x3,%rax
  8004210e19:	48 01 c8             	add    %rcx,%rax
  8004210e1c:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004210e1f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210e23:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210e27:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210e2b:	48 89 d0             	mov    %rdx,%rax
  8004210e2e:	48 01 c0             	add    %rax,%rax
  8004210e31:	48 01 d0             	add    %rdx,%rax
  8004210e34:	48 c1 e0 03          	shl    $0x3,%rax
  8004210e38:	48 01 c8             	add    %rcx,%rax
  8004210e3b:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004210e3f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210e43:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210e47:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210e4b:	48 89 d0             	mov    %rdx,%rax
  8004210e4e:	48 01 c0             	add    %rax,%rax
  8004210e51:	48 01 d0             	add    %rdx,%rax
  8004210e54:	48 c1 e0 03          	shl    $0x3,%rax
  8004210e58:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004210e5c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004210e60:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004210e64:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  8004210e68:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210e6c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210e70:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210e74:	48 89 d0             	mov    %rdx,%rax
  8004210e77:	48 01 c0             	add    %rax,%rax
  8004210e7a:	48 01 d0             	add    %rdx,%rax
  8004210e7d:	48 c1 e0 03          	shl    $0x3,%rax
  8004210e81:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004210e85:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004210e8c:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004210e91:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004210e95:	e9 0d 01 00 00       	jmpq   8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_expression:
			*row_pc = pc;
  8004210e9a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210e9e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004210ea2:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004210ea5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210ea9:	48 89 c7             	mov    %rax,%rdi
  8004210eac:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004210eb3:	00 00 00 
  8004210eb6:	ff d0                	callq  *%rax
  8004210eb8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004210ebc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210ec0:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210ec4:	0f b7 c0             	movzwl %ax,%eax
  8004210ec7:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004210ecb:	77 0c                	ja     8004210ed9 <_dwarf_frame_run_inst+0xcf3>
  8004210ecd:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004210ed4:	e9 dc 00 00 00       	jmpq   8004210fb5 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  8004210ed9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210edd:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210ee1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210ee5:	48 89 d0             	mov    %rdx,%rax
  8004210ee8:	48 01 c0             	add    %rax,%rax
  8004210eeb:	48 01 d0             	add    %rdx,%rax
  8004210eee:	48 c1 e0 03          	shl    $0x3,%rax
  8004210ef2:	48 01 c8             	add    %rcx,%rax
  8004210ef5:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  8004210ef8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210efc:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210f00:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210f04:	48 89 d0             	mov    %rdx,%rax
  8004210f07:	48 01 c0             	add    %rax,%rax
  8004210f0a:	48 01 d0             	add    %rdx,%rax
  8004210f0d:	48 c1 e0 03          	shl    $0x3,%rax
  8004210f11:	48 01 c8             	add    %rcx,%rax
  8004210f14:	c6 40 01 03          	movb   $0x3,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  8004210f18:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210f1c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210f20:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210f24:	48 89 d0             	mov    %rdx,%rax
  8004210f27:	48 01 c0             	add    %rax,%rax
  8004210f2a:	48 01 d0             	add    %rdx,%rax
  8004210f2d:	48 c1 e0 03          	shl    $0x3,%rax
  8004210f31:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004210f35:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210f39:	48 89 c7             	mov    %rax,%rdi
  8004210f3c:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004210f43:	00 00 00 
  8004210f46:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  8004210f48:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  8004210f4c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210f50:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210f54:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210f58:	48 89 d0             	mov    %rdx,%rax
  8004210f5b:	48 01 c0             	add    %rax,%rax
  8004210f5e:	48 01 d0             	add    %rdx,%rax
  8004210f61:	48 c1 e0 03          	shl    $0x3,%rax
  8004210f65:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004210f69:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210f6d:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  8004210f71:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004210f75:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210f79:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004210f7d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210f81:	48 89 d0             	mov    %rdx,%rax
  8004210f84:	48 01 c0             	add    %rax,%rax
  8004210f87:	48 01 d0             	add    %rdx,%rax
  8004210f8a:	48 c1 e0 03          	shl    $0x3,%rax
  8004210f8e:	48 01 f0             	add    %rsi,%rax
  8004210f91:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210f95:	48 01 c8             	add    %rcx,%rax
  8004210f98:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  8004210f9c:	eb 09                	jmp    8004210fa7 <_dwarf_frame_run_inst+0xdc1>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_INSTR_EXEC_ERROR);
			ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  8004210f9e:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			goto program_done;
  8004210fa5:	eb 0e                	jmp    8004210fb5 <_dwarf_frame_run_inst+0xdcf>
	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
	p = insts;
	pe = p + len;

	while (p < pe) {
  8004210fa7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210fab:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004210faf:	0f 82 b8 f2 ff ff    	jb     800421026d <_dwarf_frame_run_inst+0x87>
			goto program_done;
		}
	}

program_done:
	return (ret);
  8004210fb5:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  8004210fb8:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  8004210fbf:	5b                   	pop    %rbx
  8004210fc0:	5d                   	pop    %rbp
  8004210fc1:	c3                   	retq   

0000008004210fc2 <_dwarf_frame_get_internal_table>:
int
_dwarf_frame_get_internal_table(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_req, Dwarf_Regtable3 **ret_rt,
				Dwarf_Addr *ret_row_pc,
				Dwarf_Error *error)
{
  8004210fc2:	55                   	push   %rbp
  8004210fc3:	48 89 e5             	mov    %rsp,%rbp
  8004210fc6:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004210fca:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004210fce:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004210fd2:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004210fd6:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004210fda:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  8004210fde:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Cie cie;
	Dwarf_Regtable3 *rt;
	Dwarf_Addr row_pc;
	int i, ret;

	assert(ret_rt != NULL);
  8004210fe2:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004210fe7:	75 35                	jne    800421101e <_dwarf_frame_get_internal_table+0x5c>
  8004210fe9:	48 b9 98 7d 21 04 80 	movabs $0x8004217d98,%rcx
  8004210ff0:	00 00 00 
  8004210ff3:	48 ba a7 7c 21 04 80 	movabs $0x8004217ca7,%rdx
  8004210ffa:	00 00 00 
  8004210ffd:	be 83 01 00 00       	mov    $0x183,%esi
  8004211002:	48 bf bc 7c 21 04 80 	movabs $0x8004217cbc,%rdi
  8004211009:	00 00 00 
  800421100c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211011:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004211018:	00 00 00 
  800421101b:	41 ff d0             	callq  *%r8

	//dbg = fde->fde_dbg;
	assert(dbg != NULL);
  800421101e:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004211023:	75 35                	jne    800421105a <_dwarf_frame_get_internal_table+0x98>
  8004211025:	48 b9 a7 7d 21 04 80 	movabs $0x8004217da7,%rcx
  800421102c:	00 00 00 
  800421102f:	48 ba a7 7c 21 04 80 	movabs $0x8004217ca7,%rdx
  8004211036:	00 00 00 
  8004211039:	be 86 01 00 00       	mov    $0x186,%esi
  800421103e:	48 bf bc 7c 21 04 80 	movabs $0x8004217cbc,%rdi
  8004211045:	00 00 00 
  8004211048:	b8 00 00 00 00       	mov    $0x0,%eax
  800421104d:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004211054:	00 00 00 
  8004211057:	41 ff d0             	callq  *%r8

	rt = dbg->dbg_internal_reg_table;
  800421105a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421105e:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004211062:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	/* Clear the content of regtable from previous run. */
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  8004211066:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421106a:	ba 18 00 00 00       	mov    $0x18,%edx
  800421106f:	be 00 00 00 00       	mov    $0x0,%esi
  8004211074:	48 89 c7             	mov    %rax,%rdi
  8004211077:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  800421107e:	00 00 00 
  8004211081:	ff d0                	callq  *%rax
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  8004211083:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211087:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421108b:	0f b7 d0             	movzwl %ax,%edx
  800421108e:	48 89 d0             	mov    %rdx,%rax
  8004211091:	48 01 c0             	add    %rax,%rax
  8004211094:	48 01 d0             	add    %rdx,%rax
  8004211097:	48 c1 e0 03          	shl    $0x3,%rax
  800421109b:	48 89 c2             	mov    %rax,%rdx
  800421109e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042110a2:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042110a6:	be 00 00 00 00       	mov    $0x0,%esi
  80042110ab:	48 89 c7             	mov    %rax,%rdi
  80042110ae:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  80042110b5:	00 00 00 
  80042110b8:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  80042110ba:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042110c1:	eb 2f                	jmp    80042110f2 <_dwarf_frame_get_internal_table+0x130>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  80042110c3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042110c7:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042110cb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042110ce:	48 63 d0             	movslq %eax,%rdx
  80042110d1:	48 89 d0             	mov    %rdx,%rax
  80042110d4:	48 01 c0             	add    %rax,%rax
  80042110d7:	48 01 d0             	add    %rdx,%rax
  80042110da:	48 c1 e0 03          	shl    $0x3,%rax
  80042110de:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042110e2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042110e6:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  80042110ea:	66 89 42 02          	mov    %ax,0x2(%rdx)
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  80042110ee:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042110f2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042110f6:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042110fa:	0f b7 c0             	movzwl %ax,%eax
  80042110fd:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004211100:	7f c1                	jg     80042110c3 <_dwarf_frame_get_internal_table+0x101>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

	/* Run initial instructions in CIE. */
	cie = fde->fde_cie;
  8004211102:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211106:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421110a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	assert(cie != NULL);
  800421110e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004211113:	75 35                	jne    800421114a <_dwarf_frame_get_internal_table+0x188>
  8004211115:	48 b9 b3 7d 21 04 80 	movabs $0x8004217db3,%rcx
  800421111c:	00 00 00 
  800421111f:	48 ba a7 7c 21 04 80 	movabs $0x8004217ca7,%rdx
  8004211126:	00 00 00 
  8004211129:	be 95 01 00 00       	mov    $0x195,%esi
  800421112e:	48 bf bc 7c 21 04 80 	movabs $0x8004217cbc,%rdi
  8004211135:	00 00 00 
  8004211138:	b8 00 00 00 00       	mov    $0x0,%eax
  800421113d:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004211144:	00 00 00 
  8004211147:	41 ff d0             	callq  *%r8
	ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  800421114a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421114e:	4c 8b 48 40          	mov    0x40(%rax),%r9
  8004211152:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211156:	4c 8b 40 38          	mov    0x38(%rax),%r8
  800421115a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421115e:	48 8b 48 70          	mov    0x70(%rax),%rcx
  8004211162:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211166:	48 8b 50 68          	mov    0x68(%rax),%rdx
  800421116a:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800421116e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211172:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8004211176:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800421117b:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  800421117f:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004211184:	48 c7 44 24 08 ff ff 	movq   $0xffffffffffffffff,0x8(%rsp)
  800421118b:	ff ff 
  800421118d:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8004211194:	00 
  8004211195:	48 89 c7             	mov    %rax,%rdi
  8004211198:	48 b8 e6 01 21 04 80 	movabs $0x80042101e6,%rax
  800421119f:	00 00 00 
  80042111a2:	ff d0                	callq  *%rax
  80042111a4:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    cie->cie_instlen, cie->cie_caf,
				    cie->cie_daf, 0, ~0ULL,
				    &row_pc, error);
	if (ret != DW_DLE_NONE)
  80042111a7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042111ab:	74 08                	je     80042111b5 <_dwarf_frame_get_internal_table+0x1f3>
		return (ret);
  80042111ad:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042111b0:	e9 98 00 00 00       	jmpq   800421124d <_dwarf_frame_get_internal_table+0x28b>
	/* Run instructions in FDE. */
	if (pc_req >= fde->fde_initloc) {
  80042111b5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042111b9:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042111bd:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042111c1:	77 6f                	ja     8004211232 <_dwarf_frame_get_internal_table+0x270>
		ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  80042111c3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042111c7:	48 8b 78 30          	mov    0x30(%rax),%rdi
  80042111cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042111cf:	4c 8b 48 40          	mov    0x40(%rax),%r9
  80042111d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042111d7:	4c 8b 50 38          	mov    0x38(%rax),%r10
  80042111db:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042111df:	48 8b 48 58          	mov    0x58(%rax),%rcx
  80042111e3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042111e7:	48 8b 50 50          	mov    0x50(%rax),%rdx
  80042111eb:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042111ef:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042111f3:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
  80042111f7:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  80042111fc:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  8004211200:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004211205:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  8004211209:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  800421120e:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004211212:	4d 89 d0             	mov    %r10,%r8
  8004211215:	48 89 c7             	mov    %rax,%rdi
  8004211218:	48 b8 e6 01 21 04 80 	movabs $0x80042101e6,%rax
  800421121f:	00 00 00 
  8004211222:	ff d0                	callq  *%rax
  8004211224:	89 45 e4             	mov    %eax,-0x1c(%rbp)
					    fde->fde_instlen, cie->cie_caf,
					    cie->cie_daf,
					    fde->fde_initloc, pc_req,
					    &row_pc, error);
		if (ret != DW_DLE_NONE)
  8004211227:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421122b:	74 05                	je     8004211232 <_dwarf_frame_get_internal_table+0x270>
			return (ret);
  800421122d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004211230:	eb 1b                	jmp    800421124d <_dwarf_frame_get_internal_table+0x28b>
	}

	*ret_rt = rt;
  8004211232:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004211236:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421123a:	48 89 10             	mov    %rdx,(%rax)
	*ret_row_pc = row_pc;
  800421123d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004211241:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211245:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  8004211248:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421124d:	c9                   	leaveq 
  800421124e:	c3                   	retq   

000000800421124f <dwarf_get_fde_info_for_all_regs>:
int
dwarf_get_fde_info_for_all_regs(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_requested,
				Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc,
				Dwarf_Error *error)
{
  800421124f:	55                   	push   %rbp
  8004211250:	48 89 e5             	mov    %rsp,%rbp
  8004211253:	48 83 ec 50          	sub    $0x50,%rsp
  8004211257:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421125b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421125f:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004211263:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004211267:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  800421126b:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
	Dwarf_Regtable3 *rt;
	Dwarf_Addr pc;
	Dwarf_Half cfa;
	int i, ret;

	if (fde == NULL || reg_table == NULL) {
  800421126f:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211274:	74 07                	je     800421127d <dwarf_get_fde_info_for_all_regs+0x2e>
  8004211276:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800421127b:	75 0a                	jne    8004211287 <dwarf_get_fde_info_for_all_regs+0x38>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  800421127d:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211282:	e9 eb 02 00 00       	jmpq   8004211572 <dwarf_get_fde_info_for_all_regs+0x323>
	}

	assert(dbg != NULL);
  8004211287:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421128c:	75 35                	jne    80042112c3 <dwarf_get_fde_info_for_all_regs+0x74>
  800421128e:	48 b9 a7 7d 21 04 80 	movabs $0x8004217da7,%rcx
  8004211295:	00 00 00 
  8004211298:	48 ba a7 7c 21 04 80 	movabs $0x8004217ca7,%rdx
  800421129f:	00 00 00 
  80042112a2:	be bf 01 00 00       	mov    $0x1bf,%esi
  80042112a7:	48 bf bc 7c 21 04 80 	movabs $0x8004217cbc,%rdi
  80042112ae:	00 00 00 
  80042112b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042112b6:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042112bd:	00 00 00 
  80042112c0:	41 ff d0             	callq  *%r8

	if (pc_requested < fde->fde_initloc ||
  80042112c3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042112c7:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042112cb:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042112cf:	77 19                	ja     80042112ea <dwarf_get_fde_info_for_all_regs+0x9b>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  80042112d1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042112d5:	48 8b 50 30          	mov    0x30(%rax),%rdx
  80042112d9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042112dd:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042112e1:	48 01 d0             	add    %rdx,%rax
		return (DW_DLV_ERROR);
	}

	assert(dbg != NULL);

	if (pc_requested < fde->fde_initloc ||
  80042112e4:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042112e8:	77 0a                	ja     80042112f4 <dwarf_get_fde_info_for_all_regs+0xa5>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
		return (DW_DLV_ERROR);
  80042112ea:	b8 01 00 00 00       	mov    $0x1,%eax
  80042112ef:	e9 7e 02 00 00       	jmpq   8004211572 <dwarf_get_fde_info_for_all_regs+0x323>
	}

	ret = _dwarf_frame_get_internal_table(dbg, fde, pc_requested, &rt, &pc,
  80042112f4:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
  80042112f8:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  80042112fc:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  8004211300:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211304:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004211308:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421130c:	4d 89 c1             	mov    %r8,%r9
  800421130f:	49 89 f8             	mov    %rdi,%r8
  8004211312:	48 89 c7             	mov    %rax,%rdi
  8004211315:	48 b8 c2 0f 21 04 80 	movabs $0x8004210fc2,%rax
  800421131c:	00 00 00 
  800421131f:	ff d0                	callq  *%rax
  8004211321:	89 45 f8             	mov    %eax,-0x8(%rbp)
					      error);
	if (ret != DW_DLE_NONE)
  8004211324:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004211328:	74 0a                	je     8004211334 <dwarf_get_fde_info_for_all_regs+0xe5>
		return (DW_DLV_ERROR);
  800421132a:	b8 01 00 00 00       	mov    $0x1,%eax
  800421132f:	e9 3e 02 00 00       	jmpq   8004211572 <dwarf_get_fde_info_for_all_regs+0x323>
	/*
	 * Copy the CFA rule to the column intended for holding the CFA,
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
  8004211334:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211338:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800421133c:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	if (cfa < DW_REG_TABLE_SIZE) {
  8004211340:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  8004211345:	0f 87 b1 00 00 00    	ja     80042113fc <dwarf_get_fde_info_for_all_regs+0x1ad>
		reg_table->rules[cfa].dw_offset_relevant =
  800421134b:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
			CFA.dw_offset_relevant;
  800421134f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211353:	0f b6 00             	movzbl (%rax),%eax
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
	if (cfa < DW_REG_TABLE_SIZE) {
		reg_table->rules[cfa].dw_offset_relevant =
  8004211356:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421135a:	48 63 c9             	movslq %ecx,%rcx
  800421135d:	48 83 c1 01          	add    $0x1,%rcx
  8004211361:	48 c1 e1 04          	shl    $0x4,%rcx
  8004211365:	48 01 ca             	add    %rcx,%rdx
  8004211368:	88 02                	mov    %al,(%rdx)
			CFA.dw_offset_relevant;
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
  800421136a:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800421136e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211372:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8004211376:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421137a:	48 63 c9             	movslq %ecx,%rcx
  800421137d:	48 83 c1 01          	add    $0x1,%rcx
  8004211381:	48 c1 e1 04          	shl    $0x4,%rcx
  8004211385:	48 01 ca             	add    %rcx,%rdx
  8004211388:	88 42 01             	mov    %al,0x1(%rdx)
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  800421138b:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800421138f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211393:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004211397:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421139b:	48 63 c9             	movslq %ecx,%rcx
  800421139e:	48 83 c1 01          	add    $0x1,%rcx
  80042113a2:	48 c1 e1 04          	shl    $0x4,%rcx
  80042113a6:	48 01 ca             	add    %rcx,%rdx
  80042113a9:	66 89 42 02          	mov    %ax,0x2(%rdx)
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  80042113ad:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  80042113b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042113b5:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042113b9:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042113bd:	48 63 c9             	movslq %ecx,%rcx
  80042113c0:	48 83 c1 01          	add    $0x1,%rcx
  80042113c4:	48 c1 e1 04          	shl    $0x4,%rcx
  80042113c8:	48 01 ca             	add    %rcx,%rdx
  80042113cb:	48 83 c2 08          	add    $0x8,%rdx
  80042113cf:	48 89 02             	mov    %rax,(%rdx)
		reg_table->cfa_rule = reg_table->rules[cfa];
  80042113d2:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80042113d6:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80042113da:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042113de:	48 63 d2             	movslq %edx,%rdx
  80042113e1:	48 83 c2 01          	add    $0x1,%rdx
  80042113e5:	48 c1 e2 04          	shl    $0x4,%rdx
  80042113e9:	48 01 d0             	add    %rdx,%rax
  80042113ec:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042113f0:	48 8b 00             	mov    (%rax),%rax
  80042113f3:	48 89 01             	mov    %rax,(%rcx)
  80042113f6:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  80042113fa:	eb 3c                	jmp    8004211438 <dwarf_get_fde_info_for_all_regs+0x1e9>
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
		    CFA.dw_offset_relevant;
  80042113fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211400:	0f b6 10             	movzbl (%rax),%edx
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
		reg_table->cfa_rule = reg_table->rules[cfa];
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
  8004211403:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211407:	88 10                	mov    %dl,(%rax)
		    CFA.dw_offset_relevant;
		reg_table->cfa_rule.dw_value_type = CFA.dw_value_type;
  8004211409:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421140d:	0f b6 50 01          	movzbl 0x1(%rax),%edx
  8004211411:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211415:	88 50 01             	mov    %dl,0x1(%rax)
		reg_table->cfa_rule.dw_regnum = CFA.dw_regnum;
  8004211418:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421141c:	0f b7 50 02          	movzwl 0x2(%rax),%edx
  8004211420:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211424:	66 89 50 02          	mov    %dx,0x2(%rax)
		reg_table->cfa_rule.dw_offset = CFA.dw_offset_or_block_len;
  8004211428:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421142c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004211430:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211434:	48 89 50 08          	mov    %rdx,0x8(%rax)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  8004211438:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421143f:	e9 fd 00 00 00       	jmpq   8004211541 <dwarf_get_fde_info_for_all_regs+0x2f2>
	     i++) {

		/* Do not overwrite CFA column */
		if (i == cfa)
  8004211444:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8004211448:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800421144b:	75 05                	jne    8004211452 <dwarf_get_fde_info_for_all_regs+0x203>
			continue;
  800421144d:	e9 eb 00 00 00       	jmpq   800421153d <dwarf_get_fde_info_for_all_regs+0x2ee>

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
  8004211452:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211456:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421145a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421145d:	48 63 d0             	movslq %eax,%rdx
  8004211460:	48 89 d0             	mov    %rdx,%rax
  8004211463:	48 01 c0             	add    %rax,%rax
  8004211466:	48 01 d0             	add    %rdx,%rax
  8004211469:	48 c1 e0 03          	shl    $0x3,%rax
  800421146d:	48 01 c8             	add    %rcx,%rax
  8004211470:	0f b6 00             	movzbl (%rax),%eax

		/* Do not overwrite CFA column */
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
  8004211473:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004211477:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421147a:	48 63 c9             	movslq %ecx,%rcx
  800421147d:	48 83 c1 01          	add    $0x1,%rcx
  8004211481:	48 c1 e1 04          	shl    $0x4,%rcx
  8004211485:	48 01 ca             	add    %rcx,%rdx
  8004211488:	88 02                	mov    %al,(%rdx)
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
  800421148a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421148e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211492:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004211495:	48 63 d0             	movslq %eax,%rdx
  8004211498:	48 89 d0             	mov    %rdx,%rax
  800421149b:	48 01 c0             	add    %rax,%rax
  800421149e:	48 01 d0             	add    %rdx,%rax
  80042114a1:	48 c1 e0 03          	shl    $0x3,%rax
  80042114a5:	48 01 c8             	add    %rcx,%rax
  80042114a8:	0f b6 40 01          	movzbl 0x1(%rax),%eax
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
  80042114ac:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042114b0:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042114b3:	48 63 c9             	movslq %ecx,%rcx
  80042114b6:	48 83 c1 01          	add    $0x1,%rcx
  80042114ba:	48 c1 e1 04          	shl    $0x4,%rcx
  80042114be:	48 01 ca             	add    %rcx,%rdx
  80042114c1:	88 42 01             	mov    %al,0x1(%rdx)
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  80042114c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042114c8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042114cc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042114cf:	48 63 d0             	movslq %eax,%rdx
  80042114d2:	48 89 d0             	mov    %rdx,%rax
  80042114d5:	48 01 c0             	add    %rax,%rax
  80042114d8:	48 01 d0             	add    %rdx,%rax
  80042114db:	48 c1 e0 03          	shl    $0x3,%rax
  80042114df:	48 01 c8             	add    %rcx,%rax
  80042114e2:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80042114e6:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042114ea:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042114ed:	48 63 c9             	movslq %ecx,%rcx
  80042114f0:	48 83 c1 01          	add    $0x1,%rcx
  80042114f4:	48 c1 e1 04          	shl    $0x4,%rcx
  80042114f8:	48 01 ca             	add    %rcx,%rdx
  80042114fb:	66 89 42 02          	mov    %ax,0x2(%rdx)
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
  80042114ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211503:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211507:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421150a:	48 63 d0             	movslq %eax,%rdx
  800421150d:	48 89 d0             	mov    %rdx,%rax
  8004211510:	48 01 c0             	add    %rax,%rax
  8004211513:	48 01 d0             	add    %rdx,%rax
  8004211516:	48 c1 e0 03          	shl    $0x3,%rax
  800421151a:	48 01 c8             	add    %rcx,%rax
  800421151d:	48 8b 40 08          	mov    0x8(%rax),%rax
		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
  8004211521:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004211525:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004211528:	48 63 c9             	movslq %ecx,%rcx
  800421152b:	48 83 c1 01          	add    $0x1,%rcx
  800421152f:	48 c1 e1 04          	shl    $0x4,%rcx
  8004211533:	48 01 ca             	add    %rcx,%rdx
  8004211536:	48 83 c2 08          	add    $0x8,%rdx
  800421153a:	48 89 02             	mov    %rax,(%rdx)

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
	     i++) {
  800421153d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  8004211541:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  8004211545:	7f 14                	jg     800421155b <dwarf_get_fde_info_for_all_regs+0x30c>
  8004211547:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421154b:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  800421154f:	0f b7 c0             	movzwl %ax,%eax
  8004211552:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004211555:	0f 8f e9 fe ff ff    	jg     8004211444 <dwarf_get_fde_info_for_all_regs+0x1f5>
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
	}

	if (row_pc) *row_pc = pc;
  800421155b:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004211560:	74 0b                	je     800421156d <dwarf_get_fde_info_for_all_regs+0x31e>
  8004211562:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004211566:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421156a:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLV_OK);
  800421156d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211572:	c9                   	leaveq 
  8004211573:	c3                   	retq   

0000008004211574 <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
			      uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004211574:	55                   	push   %rbp
  8004211575:	48 89 e5             	mov    %rsp,%rbp
  8004211578:	48 83 ec 40          	sub    $0x40,%rsp
  800421157c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211580:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211584:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004211588:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  800421158c:	44 89 c0             	mov    %r8d,%eax
  800421158f:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  8004211593:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  8004211596:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  800421159a:	75 0a                	jne    80042115a6 <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  800421159c:	b8 00 00 00 00       	mov    $0x0,%eax
  80042115a1:	e9 e6 01 00 00       	jmpq   800421178c <_dwarf_frame_read_lsb_encoded+0x218>

	application = encode & 0xf0;
  80042115a6:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  80042115aa:	83 e0 f0             	and    $0xfffffff0,%eax
  80042115ad:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  80042115b0:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  80042115b4:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  80042115b8:	83 f8 0c             	cmp    $0xc,%eax
  80042115bb:	0f 87 72 01 00 00    	ja     8004211733 <_dwarf_frame_read_lsb_encoded+0x1bf>
  80042115c1:	89 c0                	mov    %eax,%eax
  80042115c3:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042115ca:	00 
  80042115cb:	48 b8 c0 7d 21 04 80 	movabs $0x8004217dc0,%rax
  80042115d2:	00 00 00 
  80042115d5:	48 01 d0             	add    %rdx,%rax
  80042115d8:	48 8b 00             	mov    (%rax),%rax
  80042115db:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  80042115dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042115e1:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042115e5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042115e9:	8b 52 28             	mov    0x28(%rdx),%edx
  80042115ec:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042115f0:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042115f4:	48 89 cf             	mov    %rcx,%rdi
  80042115f7:	ff d0                	callq  *%rax
  80042115f9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042115fd:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004211600:	e9 35 01 00 00       	jmpq   800421173a <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  8004211605:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211609:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421160d:	48 89 d6             	mov    %rdx,%rsi
  8004211610:	48 89 c7             	mov    %rax,%rdi
  8004211613:	48 b8 08 e6 20 04 80 	movabs $0x800420e608,%rax
  800421161a:	00 00 00 
  800421161d:	ff d0                	callq  *%rax
  800421161f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004211623:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004211626:	e9 0f 01 00 00       	jmpq   800421173a <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  800421162b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421162f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211633:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004211637:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421163b:	ba 02 00 00 00       	mov    $0x2,%edx
  8004211640:	48 89 cf             	mov    %rcx,%rdi
  8004211643:	ff d0                	callq  *%rax
  8004211645:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004211649:	48 89 02             	mov    %rax,(%rdx)
		break;
  800421164c:	e9 e9 00 00 00       	jmpq   800421173a <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  8004211651:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211655:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211659:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421165d:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004211661:	ba 04 00 00 00       	mov    $0x4,%edx
  8004211666:	48 89 cf             	mov    %rcx,%rdi
  8004211669:	ff d0                	callq  *%rax
  800421166b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421166f:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004211672:	e9 c3 00 00 00       	jmpq   800421173a <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  8004211677:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421167b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421167f:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004211683:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004211687:	ba 08 00 00 00       	mov    $0x8,%edx
  800421168c:	48 89 cf             	mov    %rcx,%rdi
  800421168f:	ff d0                	callq  *%rax
  8004211691:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004211695:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004211698:	e9 9d 00 00 00       	jmpq   800421173a <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  800421169d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042116a1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042116a5:	48 89 d6             	mov    %rdx,%rsi
  80042116a8:	48 89 c7             	mov    %rax,%rdi
  80042116ab:	48 b8 64 e5 20 04 80 	movabs $0x800420e564,%rax
  80042116b2:	00 00 00 
  80042116b5:	ff d0                	callq  *%rax
  80042116b7:	48 89 c2             	mov    %rax,%rdx
  80042116ba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042116be:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042116c1:	eb 77                	jmp    800421173a <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  80042116c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042116c7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042116cb:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042116cf:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042116d3:	ba 02 00 00 00       	mov    $0x2,%edx
  80042116d8:	48 89 cf             	mov    %rcx,%rdi
  80042116db:	ff d0                	callq  *%rax
  80042116dd:	48 0f bf d0          	movswq %ax,%rdx
  80042116e1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042116e5:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042116e8:	eb 50                	jmp    800421173a <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  80042116ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042116ee:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042116f2:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042116f6:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042116fa:	ba 04 00 00 00       	mov    $0x4,%edx
  80042116ff:	48 89 cf             	mov    %rcx,%rdi
  8004211702:	ff d0                	callq  *%rax
  8004211704:	48 63 d0             	movslq %eax,%rdx
  8004211707:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421170b:	48 89 10             	mov    %rdx,(%rax)
		break;
  800421170e:	eb 2a                	jmp    800421173a <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  8004211710:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211714:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211718:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421171c:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004211720:	ba 08 00 00 00       	mov    $0x8,%edx
  8004211725:	48 89 cf             	mov    %rcx,%rdi
  8004211728:	ff d0                	callq  *%rax
  800421172a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421172e:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004211731:	eb 07                	jmp    800421173a <_dwarf_frame_read_lsb_encoded+0x1c6>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004211733:	b8 14 00 00 00       	mov    $0x14,%eax
  8004211738:	eb 52                	jmp    800421178c <_dwarf_frame_read_lsb_encoded+0x218>
	}

	if (application == DW_EH_PE_pcrel) {
  800421173a:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  800421173e:	75 47                	jne    8004211787 <_dwarf_frame_read_lsb_encoded+0x213>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  8004211740:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004211744:	83 f8 01             	cmp    $0x1,%eax
  8004211747:	7c 3d                	jl     8004211786 <_dwarf_frame_read_lsb_encoded+0x212>
  8004211749:	83 f8 04             	cmp    $0x4,%eax
  800421174c:	7e 0a                	jle    8004211758 <_dwarf_frame_read_lsb_encoded+0x1e4>
  800421174e:	83 e8 09             	sub    $0x9,%eax
  8004211751:	83 f8 03             	cmp    $0x3,%eax
  8004211754:	77 30                	ja     8004211786 <_dwarf_frame_read_lsb_encoded+0x212>
  8004211756:	eb 17                	jmp    800421176f <_dwarf_frame_read_lsb_encoded+0x1fb>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  8004211758:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421175c:	48 8b 10             	mov    (%rax),%rdx
  800421175f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211763:	48 01 c2             	add    %rax,%rdx
  8004211766:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421176a:	48 89 10             	mov    %rdx,(%rax)
			break;
  800421176d:	eb 18                	jmp    8004211787 <_dwarf_frame_read_lsb_encoded+0x213>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  800421176f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211773:	48 8b 10             	mov    (%rax),%rdx
  8004211776:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421177a:	48 01 c2             	add    %rax,%rdx
  800421177d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211781:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004211784:	eb 01                	jmp    8004211787 <_dwarf_frame_read_lsb_encoded+0x213>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  8004211786:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  8004211787:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421178c:	c9                   	leaveq 
  800421178d:	c3                   	retq   

000000800421178e <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
				   Dwarf_Error *error)
{
  800421178e:	55                   	push   %rbp
  800421178f:	48 89 e5             	mov    %rsp,%rbp
  8004211792:	48 83 ec 50          	sub    $0x50,%rsp
  8004211796:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421179a:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421179e:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  80042117a2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042117a6:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042117aa:	48 85 c0             	test   %rax,%rax
  80042117ad:	74 0f                	je     80042117be <_dwarf_frame_parse_lsb_cie_augment+0x30>
  80042117af:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042117b3:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042117b7:	0f b6 00             	movzbl (%rax),%eax
  80042117ba:	3c 7a                	cmp    $0x7a,%al
  80042117bc:	74 35                	je     80042117f3 <_dwarf_frame_parse_lsb_cie_augment+0x65>
  80042117be:	48 b9 28 7e 21 04 80 	movabs $0x8004217e28,%rcx
  80042117c5:	00 00 00 
  80042117c8:	48 ba a7 7c 21 04 80 	movabs $0x8004217ca7,%rdx
  80042117cf:	00 00 00 
  80042117d2:	be 4a 02 00 00       	mov    $0x24a,%esi
  80042117d7:	48 bf bc 7c 21 04 80 	movabs $0x8004217cbc,%rdi
  80042117de:	00 00 00 
  80042117e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042117e6:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042117ed:	00 00 00 
  80042117f0:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  80042117f3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042117f7:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042117fb:	48 83 c0 01          	add    $0x1,%rax
  80042117ff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  8004211803:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211807:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421180b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  800421180f:	e9 af 00 00 00       	jmpq   80042118c3 <_dwarf_frame_parse_lsb_cie_augment+0x135>
		switch (*aug_p) {
  8004211814:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211818:	0f b6 00             	movzbl (%rax),%eax
  800421181b:	0f b6 c0             	movzbl %al,%eax
  800421181e:	83 f8 50             	cmp    $0x50,%eax
  8004211821:	74 18                	je     800421183b <_dwarf_frame_parse_lsb_cie_augment+0xad>
  8004211823:	83 f8 52             	cmp    $0x52,%eax
  8004211826:	74 77                	je     800421189f <_dwarf_frame_parse_lsb_cie_augment+0x111>
  8004211828:	83 f8 4c             	cmp    $0x4c,%eax
  800421182b:	0f 85 86 00 00 00    	jne    80042118b7 <_dwarf_frame_parse_lsb_cie_augment+0x129>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  8004211831:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  8004211836:	e9 83 00 00 00       	jmpq   80042118be <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  800421183b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421183f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211843:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004211847:	0f b6 00             	movzbl (%rax),%eax
  800421184a:	88 45 ef             	mov    %al,-0x11(%rbp)
			offset = 0;
  800421184d:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004211854:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004211855:	44 0f b6 45 ef       	movzbl -0x11(%rbp),%r8d
  800421185a:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800421185e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211862:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8004211866:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421186a:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  800421186e:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004211872:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004211878:	48 89 c7             	mov    %rax,%rdi
  800421187b:	48 b8 74 15 21 04 80 	movabs $0x8004211574,%rax
  8004211882:	00 00 00 
  8004211885:	ff d0                	callq  *%rax
  8004211887:	89 45 e8             	mov    %eax,-0x18(%rbp)
							    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  800421188a:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800421188e:	74 05                	je     8004211895 <_dwarf_frame_parse_lsb_cie_augment+0x107>
				return (ret);
  8004211890:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004211893:	eb 42                	jmp    80042118d7 <_dwarf_frame_parse_lsb_cie_augment+0x149>
			augdata_p += offset;
  8004211895:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211899:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  800421189d:	eb 1f                	jmp    80042118be <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  800421189f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042118a3:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042118a7:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  80042118ab:	0f b6 10             	movzbl (%rax),%edx
  80042118ae:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042118b2:	88 50 60             	mov    %dl,0x60(%rax)
			break;
  80042118b5:	eb 07                	jmp    80042118be <_dwarf_frame_parse_lsb_cie_augment+0x130>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  80042118b7:	b8 14 00 00 00       	mov    $0x14,%eax
  80042118bc:	eb 19                	jmp    80042118d7 <_dwarf_frame_parse_lsb_cie_augment+0x149>
		}
		aug_p++;
  80042118be:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
	augdata_p = cie->cie_augdata;
	while (*aug_p != '\0') {
  80042118c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042118c7:	0f b6 00             	movzbl (%rax),%eax
  80042118ca:	84 c0                	test   %al,%al
  80042118cc:	0f 85 42 ff ff ff    	jne    8004211814 <_dwarf_frame_parse_lsb_cie_augment+0x86>
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		}
		aug_p++;
	}

	return (DW_DLE_NONE);
  80042118d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042118d7:	c9                   	leaveq 
  80042118d8:	c3                   	retq   

00000080042118d9 <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, Dwarf_Cie ret_cie, Dwarf_Error *error)
{
  80042118d9:	55                   	push   %rbp
  80042118da:	48 89 e5             	mov    %rsp,%rbp
  80042118dd:	48 83 ec 60          	sub    $0x60,%rsp
  80042118e1:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042118e5:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042118e9:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042118ed:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80042118f1:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  80042118f5:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  80042118fa:	75 35                	jne    8004211931 <_dwarf_frame_set_cie+0x58>
  80042118fc:	48 b9 5d 7e 21 04 80 	movabs $0x8004217e5d,%rcx
  8004211903:	00 00 00 
  8004211906:	48 ba a7 7c 21 04 80 	movabs $0x8004217ca7,%rdx
  800421190d:	00 00 00 
  8004211910:	be 7b 02 00 00       	mov    $0x27b,%esi
  8004211915:	48 bf bc 7c 21 04 80 	movabs $0x8004217cbc,%rdi
  800421191c:	00 00 00 
  800421191f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211924:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800421192b:	00 00 00 
  800421192e:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  8004211931:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004211935:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  8004211939:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421193d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211941:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  8004211944:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004211948:	48 8b 10             	mov    (%rax),%rdx
  800421194b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421194f:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004211953:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211957:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421195b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421195f:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004211963:	48 89 d1             	mov    %rdx,%rcx
  8004211966:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  800421196a:	ba 04 00 00 00       	mov    $0x4,%edx
  800421196f:	48 89 cf             	mov    %rcx,%rdi
  8004211972:	ff d0                	callq  *%rax
  8004211974:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004211978:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421197d:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004211981:	75 2e                	jne    80042119b1 <_dwarf_frame_set_cie+0xd8>
		dwarf_size = 8;
  8004211983:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  800421198a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421198e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211992:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211996:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421199a:	48 89 d1             	mov    %rdx,%rcx
  800421199d:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80042119a1:	ba 08 00 00 00       	mov    $0x8,%edx
  80042119a6:	48 89 cf             	mov    %rcx,%rdi
  80042119a9:	ff d0                	callq  *%rax
  80042119ab:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042119af:	eb 07                	jmp    80042119b8 <_dwarf_frame_set_cie+0xdf>
	} else
		dwarf_size = 4;
  80042119b1:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  80042119b8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042119bc:	48 8b 50 40          	mov    0x40(%rax),%rdx
  80042119c0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042119c4:	48 8b 00             	mov    (%rax),%rax
  80042119c7:	48 29 c2             	sub    %rax,%rdx
  80042119ca:	48 89 d0             	mov    %rdx,%rax
  80042119cd:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042119d1:	73 0a                	jae    80042119dd <_dwarf_frame_set_cie+0x104>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  80042119d3:	b8 12 00 00 00       	mov    $0x12,%eax
  80042119d8:	e9 5d 03 00 00       	jmpq   8004211d3a <_dwarf_frame_set_cie+0x461>
	}

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
  80042119dd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042119e1:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042119e5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042119e9:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042119ed:	48 89 d1             	mov    %rdx,%rcx
  80042119f0:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042119f3:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80042119f7:	48 89 cf             	mov    %rcx,%rdi
  80042119fa:	ff d0                	callq  *%rax
	cie->cie_length = length;
  80042119fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a00:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211a04:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004211a08:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211a0c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211a10:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211a14:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004211a18:	48 89 d1             	mov    %rdx,%rcx
  8004211a1b:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004211a1f:	ba 01 00 00 00       	mov    $0x1,%edx
  8004211a24:	48 89 cf             	mov    %rcx,%rdi
  8004211a27:	ff d0                	callq  *%rax
  8004211a29:	89 c2                	mov    %eax,%edx
  8004211a2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a2f:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004211a33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a37:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004211a3b:	66 83 f8 01          	cmp    $0x1,%ax
  8004211a3f:	74 26                	je     8004211a67 <_dwarf_frame_set_cie+0x18e>
  8004211a41:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a45:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004211a49:	66 83 f8 03          	cmp    $0x3,%ax
  8004211a4d:	74 18                	je     8004211a67 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
  8004211a4f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a53:	0f b7 40 20          	movzwl 0x20(%rax),%eax

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
	cie->cie_length = length;

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004211a57:	66 83 f8 04          	cmp    $0x4,%ax
  8004211a5b:	74 0a                	je     8004211a67 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  8004211a5d:	b8 16 00 00 00       	mov    $0x16,%eax
  8004211a62:	e9 d3 02 00 00       	jmpq   8004211d3a <_dwarf_frame_set_cie+0x461>
	}

	cie->cie_augment = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004211a67:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004211a6b:	48 8b 10             	mov    (%rax),%rdx
  8004211a6e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211a72:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004211a76:	48 01 d0             	add    %rdx,%rax
  8004211a79:	48 89 c2             	mov    %rax,%rdx
  8004211a7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a80:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *)dbg->dbg_eh_offset;
  8004211a84:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211a88:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004211a8c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  8004211a90:	90                   	nop
  8004211a91:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004211a95:	48 8b 00             	mov    (%rax),%rax
  8004211a98:	48 8d 48 01          	lea    0x1(%rax),%rcx
  8004211a9c:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004211aa0:	48 89 0a             	mov    %rcx,(%rdx)
  8004211aa3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004211aa7:	48 01 d0             	add    %rdx,%rax
  8004211aaa:	0f b6 00             	movzbl (%rax),%eax
  8004211aad:	84 c0                	test   %al,%al
  8004211aaf:	75 e0                	jne    8004211a91 <_dwarf_frame_set_cie+0x1b8>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  8004211ab1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ab5:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004211ab9:	0f b6 00             	movzbl (%rax),%eax
  8004211abc:	84 c0                	test   %al,%al
  8004211abe:	74 48                	je     8004211b08 <_dwarf_frame_set_cie+0x22f>
  8004211ac0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ac4:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004211ac8:	0f b6 00             	movzbl (%rax),%eax
  8004211acb:	3c 7a                	cmp    $0x7a,%al
  8004211acd:	74 39                	je     8004211b08 <_dwarf_frame_set_cie+0x22f>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004211acf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ad3:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004211ad7:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004211adb:	75 07                	jne    8004211ae4 <_dwarf_frame_set_cie+0x20b>
  8004211add:	b8 04 00 00 00       	mov    $0x4,%eax
  8004211ae2:	eb 05                	jmp    8004211ae9 <_dwarf_frame_set_cie+0x210>
  8004211ae4:	b8 0c 00 00 00       	mov    $0xc,%eax
  8004211ae9:	48 01 c2             	add    %rax,%rdx
			cie->cie_length;
  8004211aec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211af0:	48 8b 40 18          	mov    0x18(%rax),%rax
	while (p[(*off)++] != '\0')
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004211af4:	48 01 c2             	add    %rax,%rdx
  8004211af7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004211afb:	48 89 10             	mov    %rdx,(%rax)
			cie->cie_length;
		return (DW_DLE_NONE);
  8004211afe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211b03:	e9 32 02 00 00       	jmpq   8004211d3a <_dwarf_frame_set_cie+0x461>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  8004211b08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211b0c:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004211b10:	48 be 65 7e 21 04 80 	movabs $0x8004217e65,%rsi
  8004211b17:	00 00 00 
  8004211b1a:	48 89 c7             	mov    %rax,%rdi
  8004211b1d:	48 b8 1b df 20 04 80 	movabs $0x800420df1b,%rax
  8004211b24:	00 00 00 
  8004211b27:	ff d0                	callq  *%rax
  8004211b29:	48 85 c0             	test   %rax,%rax
  8004211b2c:	74 28                	je     8004211b56 <_dwarf_frame_set_cie+0x27d>
		cie->cie_ehdata = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004211b2e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211b32:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211b36:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211b3a:	8b 52 28             	mov    0x28(%rdx),%edx
  8004211b3d:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004211b41:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004211b45:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004211b49:	48 89 cf             	mov    %rcx,%rdi
  8004211b4c:	ff d0                	callq  *%rax
  8004211b4e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211b52:	48 89 42 30          	mov    %rax,0x30(%rdx)
					    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004211b56:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211b5a:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004211b5e:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004211b62:	48 89 d6             	mov    %rdx,%rsi
  8004211b65:	48 89 c7             	mov    %rax,%rdi
  8004211b68:	48 b8 08 e6 20 04 80 	movabs $0x800420e608,%rax
  8004211b6f:	00 00 00 
  8004211b72:	ff d0                	callq  *%rax
  8004211b74:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211b78:	48 89 42 38          	mov    %rax,0x38(%rdx)
	cie->cie_daf = _dwarf_read_sleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004211b7c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211b80:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004211b84:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004211b88:	48 89 d6             	mov    %rdx,%rsi
  8004211b8b:	48 89 c7             	mov    %rax,%rdi
  8004211b8e:	48 b8 64 e5 20 04 80 	movabs $0x800420e564,%rax
  8004211b95:	00 00 00 
  8004211b98:	ff d0                	callq  *%rax
  8004211b9a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211b9e:	48 89 42 40          	mov    %rax,0x40(%rdx)

	/* Return address register. */
	if (cie->cie_version == 1)
  8004211ba2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ba6:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004211baa:	66 83 f8 01          	cmp    $0x1,%ax
  8004211bae:	75 2b                	jne    8004211bdb <_dwarf_frame_set_cie+0x302>
		cie->cie_ra = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004211bb0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211bb4:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211bb8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211bbc:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004211bc0:	48 89 d1             	mov    %rdx,%rcx
  8004211bc3:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004211bc7:	ba 01 00 00 00       	mov    $0x1,%edx
  8004211bcc:	48 89 cf             	mov    %rcx,%rdi
  8004211bcf:	ff d0                	callq  *%rax
  8004211bd1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211bd5:	48 89 42 48          	mov    %rax,0x48(%rdx)
  8004211bd9:	eb 26                	jmp    8004211c01 <_dwarf_frame_set_cie+0x328>
	else
		cie->cie_ra = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004211bdb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211bdf:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004211be3:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004211be7:	48 89 d6             	mov    %rdx,%rsi
  8004211bea:	48 89 c7             	mov    %rax,%rdi
  8004211bed:	48 b8 08 e6 20 04 80 	movabs $0x800420e608,%rax
  8004211bf4:	00 00 00 
  8004211bf7:	ff d0                	callq  *%rax
  8004211bf9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211bfd:	48 89 42 48          	mov    %rax,0x48(%rdx)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  8004211c01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c05:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004211c09:	0f b6 00             	movzbl (%rax),%eax
  8004211c0c:	3c 7a                	cmp    $0x7a,%al
  8004211c0e:	0f 85 93 00 00 00    	jne    8004211ca7 <_dwarf_frame_set_cie+0x3ce>
		cie->cie_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004211c14:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211c18:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004211c1c:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004211c20:	48 89 d6             	mov    %rdx,%rsi
  8004211c23:	48 89 c7             	mov    %rax,%rdi
  8004211c26:	48 b8 08 e6 20 04 80 	movabs $0x800420e608,%rax
  8004211c2d:	00 00 00 
  8004211c30:	ff d0                	callq  *%rax
  8004211c32:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211c36:	48 89 42 50          	mov    %rax,0x50(%rdx)
		cie->cie_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004211c3a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004211c3e:	48 8b 10             	mov    (%rax),%rdx
  8004211c41:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211c45:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004211c49:	48 01 d0             	add    %rdx,%rax
  8004211c4c:	48 89 c2             	mov    %rax,%rdx
  8004211c4f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c53:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  8004211c57:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004211c5b:	48 8b 10             	mov    (%rax),%rdx
  8004211c5e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c62:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004211c66:	48 01 c2             	add    %rax,%rdx
  8004211c69:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004211c6d:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  8004211c70:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c74:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  8004211c78:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004211c7c:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211c80:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211c84:	48 89 ce             	mov    %rcx,%rsi
  8004211c87:	48 89 c7             	mov    %rax,%rdi
  8004211c8a:	48 b8 8e 17 21 04 80 	movabs $0x800421178e,%rax
  8004211c91:	00 00 00 
  8004211c94:	ff d0                	callq  *%rax
  8004211c96:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  8004211c99:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004211c9d:	74 08                	je     8004211ca7 <_dwarf_frame_set_cie+0x3ce>
			return (ret);
  8004211c9f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004211ca2:	e9 93 00 00 00       	jmpq   8004211d3a <_dwarf_frame_set_cie+0x461>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004211ca7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004211cab:	48 8b 10             	mov    (%rax),%rdx
  8004211cae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211cb2:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004211cb6:	48 01 d0             	add    %rdx,%rax
  8004211cb9:	48 89 c2             	mov    %rax,%rdx
  8004211cbc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211cc0:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  8004211cc4:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004211cc8:	75 2a                	jne    8004211cf4 <_dwarf_frame_set_cie+0x41b>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  8004211cca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211cce:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004211cd2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211cd6:	48 01 c2             	add    %rax,%rdx
  8004211cd9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004211cdd:	48 8b 00             	mov    (%rax),%rax
  8004211ce0:	48 29 c2             	sub    %rax,%rdx
  8004211ce3:	48 89 d0             	mov    %rdx,%rax
  8004211ce6:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004211cea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211cee:	48 89 50 70          	mov    %rdx,0x70(%rax)
  8004211cf2:	eb 28                	jmp    8004211d1c <_dwarf_frame_set_cie+0x443>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  8004211cf4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211cf8:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004211cfc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211d00:	48 01 c2             	add    %rax,%rdx
  8004211d03:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004211d07:	48 8b 00             	mov    (%rax),%rax
  8004211d0a:	48 29 c2             	sub    %rax,%rdx
  8004211d0d:	48 89 d0             	mov    %rdx,%rax
  8004211d10:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004211d14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211d18:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  8004211d1c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004211d20:	48 8b 10             	mov    (%rax),%rdx
  8004211d23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211d27:	48 8b 40 70          	mov    0x70(%rax),%rax
  8004211d2b:	48 01 c2             	add    %rax,%rdx
  8004211d2e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004211d32:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004211d35:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211d3a:	c9                   	leaveq 
  8004211d3b:	c3                   	retq   

0000008004211d3c <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde ret_fde, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  8004211d3c:	55                   	push   %rbp
  8004211d3d:	48 89 e5             	mov    %rsp,%rbp
  8004211d40:	48 83 ec 70          	sub    $0x70,%rsp
  8004211d44:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004211d48:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004211d4c:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004211d50:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004211d54:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
  8004211d58:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = ret_fde;
  8004211d5c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211d60:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	fde->fde_dbg = dbg;
  8004211d64:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211d68:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211d6c:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004211d6f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004211d73:	48 8b 10             	mov    (%rax),%rdx
  8004211d76:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211d7a:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004211d7e:	48 01 d0             	add    %rdx,%rax
  8004211d81:	48 89 c2             	mov    %rax,%rdx
  8004211d84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211d88:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  8004211d8c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004211d90:	48 8b 10             	mov    (%rax),%rdx
  8004211d93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211d97:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004211d9b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211d9f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211da3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211da7:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004211dab:	48 89 d1             	mov    %rdx,%rcx
  8004211dae:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004211db2:	ba 04 00 00 00       	mov    $0x4,%edx
  8004211db7:	48 89 cf             	mov    %rcx,%rdi
  8004211dba:	ff d0                	callq  *%rax
  8004211dbc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004211dc0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211dc5:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004211dc9:	75 2e                	jne    8004211df9 <_dwarf_frame_set_fde+0xbd>
		dwarf_size = 8;
  8004211dcb:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004211dd2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211dd6:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211dda:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211dde:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004211de2:	48 89 d1             	mov    %rdx,%rcx
  8004211de5:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004211de9:	ba 08 00 00 00       	mov    $0x8,%edx
  8004211dee:	48 89 cf             	mov    %rcx,%rdi
  8004211df1:	ff d0                	callq  *%rax
  8004211df3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211df7:	eb 07                	jmp    8004211e00 <_dwarf_frame_set_fde+0xc4>
	} else
		dwarf_size = 4;
  8004211df9:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004211e00:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211e04:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004211e08:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004211e0c:	48 8b 00             	mov    (%rax),%rax
  8004211e0f:	48 29 c2             	sub    %rax,%rdx
  8004211e12:	48 89 d0             	mov    %rdx,%rax
  8004211e15:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004211e19:	73 0a                	jae    8004211e25 <_dwarf_frame_set_fde+0xe9>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004211e1b:	b8 12 00 00 00       	mov    $0x12,%eax
  8004211e20:	e9 ca 02 00 00       	jmpq   80042120ef <_dwarf_frame_set_fde+0x3b3>
	}

	fde->fde_length = length;
  8004211e25:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211e29:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211e2d:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  8004211e31:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004211e35:	74 5e                	je     8004211e95 <_dwarf_frame_set_fde+0x159>
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004211e37:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211e3b:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211e3f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211e43:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004211e47:	48 89 d1             	mov    %rdx,%rcx
  8004211e4a:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004211e4e:	ba 04 00 00 00       	mov    $0x4,%edx
  8004211e53:	48 89 cf             	mov    %rcx,%rdi
  8004211e56:	ff d0                	callq  *%rax
  8004211e58:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211e5c:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = *off - (4 + fde->fde_cieoff);
  8004211e60:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004211e64:	48 8b 10             	mov    (%rax),%rdx
  8004211e67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211e6b:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004211e6f:	48 29 c2             	sub    %rax,%rdx
  8004211e72:	48 89 d0             	mov    %rdx,%rax
  8004211e75:	48 83 e8 04          	sub    $0x4,%rax
  8004211e79:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  8004211e7d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211e81:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211e85:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211e89:	75 3d                	jne    8004211ec8 <_dwarf_frame_set_fde+0x18c>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  8004211e8b:	b8 13 00 00 00       	mov    $0x13,%eax
  8004211e90:	e9 5a 02 00 00       	jmpq   80042120ef <_dwarf_frame_set_fde+0x3b3>
		}
	} else {
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size);
  8004211e95:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211e99:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211e9d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211ea1:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004211ea5:	48 89 d1             	mov    %rdx,%rcx
  8004211ea8:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004211eab:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004211eaf:	48 89 cf             	mov    %rcx,%rdi
  8004211eb2:	ff d0                	callq  *%rax
  8004211eb4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211eb8:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = fde->fde_cieoff;
  8004211ebc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ec0:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004211ec4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  8004211ec8:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004211ecc:	0f 84 c9 00 00 00    	je     8004211f9b <_dwarf_frame_set_fde+0x25f>
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004211ed2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004211ed6:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004211eda:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004211ede:	48 8b 00             	mov    (%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004211ee1:	4c 8d 0c 02          	lea    (%rdx,%rax,1),%r9
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004211ee5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211ee9:	0f b6 40 60          	movzbl 0x60(%rax),%eax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004211eed:	44 0f b6 c0          	movzbl %al,%r8d
						    (uint8_t *)dbg->dbg_eh_offset,
  8004211ef1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211ef5:	48 8b 40 38          	mov    0x38(%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004211ef9:	48 89 c2             	mov    %rax,%rdx
  8004211efc:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004211f00:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004211f04:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211f08:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004211f0c:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004211f10:	48 89 c7             	mov    %rax,%rdi
  8004211f13:	48 b8 74 15 21 04 80 	movabs $0x8004211574,%rax
  8004211f1a:	00 00 00 
  8004211f1d:	ff d0                	callq  *%rax
  8004211f1f:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
		if (ret != DW_DLE_NONE)
  8004211f22:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004211f26:	74 08                	je     8004211f30 <_dwarf_frame_set_fde+0x1f4>
			return (ret);
  8004211f28:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004211f2b:	e9 bf 01 00 00       	jmpq   80042120ef <_dwarf_frame_set_fde+0x3b3>
		fde->fde_initloc = val;
  8004211f30:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211f34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211f38:	48 89 50 30          	mov    %rdx,0x30(%rax)
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
  8004211f3c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211f40:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004211f44:	44 0f b6 c0          	movzbl %al,%r8d
						    (uint8_t *)dbg->dbg_eh_offset,
  8004211f48:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211f4c:	48 8b 40 38          	mov    0x38(%rax),%rax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004211f50:	48 89 c2             	mov    %rax,%rdx
  8004211f53:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004211f57:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004211f5b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211f5f:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004211f63:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004211f67:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004211f6d:	48 89 c7             	mov    %rax,%rdi
  8004211f70:	48 b8 74 15 21 04 80 	movabs $0x8004211574,%rax
  8004211f77:	00 00 00 
  8004211f7a:	ff d0                	callq  *%rax
  8004211f7c:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
  8004211f7f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004211f83:	74 08                	je     8004211f8d <_dwarf_frame_set_fde+0x251>
			return (ret);
  8004211f85:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004211f88:	e9 62 01 00 00       	jmpq   80042120ef <_dwarf_frame_set_fde+0x3b3>
		fde->fde_adrange = val;
  8004211f8d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211f91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211f95:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004211f99:	eb 50                	jmp    8004211feb <_dwarf_frame_set_fde+0x2af>
	} else {
		fde->fde_initloc = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004211f9b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211f9f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211fa3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211fa7:	8b 52 28             	mov    0x28(%rdx),%edx
  8004211faa:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004211fae:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004211fb2:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004211fb6:	48 89 cf             	mov    %rcx,%rdi
  8004211fb9:	ff d0                	callq  *%rax
  8004211fbb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211fbf:	48 89 42 30          	mov    %rax,0x30(%rdx)
					     dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004211fc3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211fc7:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211fcb:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211fcf:	8b 52 28             	mov    0x28(%rdx),%edx
  8004211fd2:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004211fd6:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004211fda:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004211fde:	48 89 cf             	mov    %rcx,%rdi
  8004211fe1:	ff d0                	callq  *%rax
  8004211fe3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211fe7:	48 89 42 38          	mov    %rax,0x38(%rdx)
					     dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  8004211feb:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004211fef:	74 6b                	je     800421205c <_dwarf_frame_set_fde+0x320>
  8004211ff1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211ff5:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004211ff9:	0f b6 00             	movzbl (%rax),%eax
  8004211ffc:	3c 7a                	cmp    $0x7a,%al
  8004211ffe:	75 5c                	jne    800421205c <_dwarf_frame_set_fde+0x320>
		fde->fde_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212000:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212004:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212008:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800421200c:	48 89 d6             	mov    %rdx,%rsi
  800421200f:	48 89 c7             	mov    %rax,%rdi
  8004212012:	48 b8 08 e6 20 04 80 	movabs $0x800420e608,%rax
  8004212019:	00 00 00 
  800421201c:	ff d0                	callq  *%rax
  800421201e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212022:	48 89 42 40          	mov    %rax,0x40(%rdx)
		fde->fde_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212026:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421202a:	48 8b 10             	mov    (%rax),%rdx
  800421202d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212031:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212035:	48 01 d0             	add    %rdx,%rax
  8004212038:	48 89 c2             	mov    %rax,%rdx
  800421203b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421203f:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  8004212043:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212047:	48 8b 10             	mov    (%rax),%rdx
  800421204a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421204e:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004212052:	48 01 c2             	add    %rax,%rdx
  8004212055:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212059:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = (uint8_t *)dbg->dbg_eh_offset + *off;
  800421205c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212060:	48 8b 10             	mov    (%rax),%rdx
  8004212063:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212067:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421206b:	48 01 d0             	add    %rdx,%rax
  800421206e:	48 89 c2             	mov    %rax,%rdx
  8004212071:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212075:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  8004212079:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  800421207d:	75 2a                	jne    80042120a9 <_dwarf_frame_set_fde+0x36d>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  800421207f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212083:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004212087:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421208b:	48 01 c2             	add    %rax,%rdx
  800421208e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212092:	48 8b 00             	mov    (%rax),%rax
  8004212095:	48 29 c2             	sub    %rax,%rdx
  8004212098:	48 89 d0             	mov    %rdx,%rax
  800421209b:	48 8d 50 04          	lea    0x4(%rax),%rdx
  800421209f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042120a3:	48 89 50 58          	mov    %rdx,0x58(%rax)
  80042120a7:	eb 28                	jmp    80042120d1 <_dwarf_frame_set_fde+0x395>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  80042120a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042120ad:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042120b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042120b5:	48 01 c2             	add    %rax,%rdx
  80042120b8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042120bc:	48 8b 00             	mov    (%rax),%rax
  80042120bf:	48 29 c2             	sub    %rax,%rdx
  80042120c2:	48 89 d0             	mov    %rdx,%rax
  80042120c5:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  80042120c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042120cd:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  80042120d1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042120d5:	48 8b 10             	mov    (%rax),%rdx
  80042120d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042120dc:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042120e0:	48 01 c2             	add    %rax,%rdx
  80042120e3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042120e7:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  80042120ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042120ef:	c9                   	leaveq 
  80042120f0:	c3                   	retq   

00000080042120f1 <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  80042120f1:	55                   	push   %rbp
  80042120f2:	48 89 e5             	mov    %rsp,%rbp
  80042120f5:	48 83 ec 20          	sub    $0x20,%rsp
  80042120f9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042120fd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	Dwarf_Regtable3 *rt = &global_rt_table;
  8004212101:	48 b8 a0 e6 49 04 80 	movabs $0x800449e6a0,%rax
  8004212108:	00 00 00 
  800421210b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if (dbg->dbg_internal_reg_table != NULL)
  800421210f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212113:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004212117:	48 85 c0             	test   %rax,%rax
  800421211a:	74 07                	je     8004212123 <_dwarf_frame_interal_table_init+0x32>
		return (DW_DLE_NONE);
  800421211c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212121:	eb 33                	jmp    8004212156 <_dwarf_frame_interal_table_init+0x65>

	rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  8004212123:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212127:	0f b7 50 48          	movzwl 0x48(%rax),%edx
  800421212b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421212f:	66 89 50 18          	mov    %dx,0x18(%rax)
	rt->rt3_rules = global_rules;
  8004212133:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212137:	48 b9 60 ef 49 04 80 	movabs $0x800449ef60,%rcx
  800421213e:	00 00 00 
  8004212141:	48 89 48 20          	mov    %rcx,0x20(%rax)

	dbg->dbg_internal_reg_table = rt;
  8004212145:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212149:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421214d:	48 89 50 58          	mov    %rdx,0x58(%rax)

	return (DW_DLE_NONE);
  8004212151:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212156:	c9                   	leaveq 
  8004212157:	c3                   	retq   

0000008004212158 <_dwarf_get_next_fde>:

static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
		    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  8004212158:	55                   	push   %rbp
  8004212159:	48 89 e5             	mov    %rsp,%rbp
  800421215c:	48 83 ec 60          	sub    $0x60,%rsp
  8004212160:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212164:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  8004212167:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800421216b:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Section *ds = &debug_frame_sec; 
  800421216f:	48 b8 60 a8 22 04 80 	movabs $0x800422a860,%rax
  8004212176:	00 00 00 
  8004212179:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  800421217d:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->curr_off_eh;
  8004212184:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212188:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421218c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	if (offset < dbg->dbg_eh_size) {
  8004212190:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212194:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004212198:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421219c:	48 39 c2             	cmp    %rax,%rdx
  800421219f:	0f 86 fe 01 00 00    	jbe    80042123a3 <_dwarf_get_next_fde+0x24b>
		entry_off = offset;
  80042121a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042121a9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 4);
  80042121ad:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042121b1:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042121b5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042121b9:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042121bd:	48 89 d1             	mov    %rdx,%rcx
  80042121c0:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  80042121c4:	ba 04 00 00 00       	mov    $0x4,%edx
  80042121c9:	48 89 cf             	mov    %rcx,%rdi
  80042121cc:	ff d0                	callq  *%rax
  80042121ce:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  80042121d2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042121d7:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042121db:	75 2e                	jne    800421220b <_dwarf_get_next_fde+0xb3>
			dwarf_size = 8;
  80042121dd:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 8);
  80042121e4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042121e8:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042121ec:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042121f0:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042121f4:	48 89 d1             	mov    %rdx,%rcx
  80042121f7:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  80042121fb:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212200:	48 89 cf             	mov    %rcx,%rdi
  8004212203:	ff d0                	callq  *%rax
  8004212205:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004212209:	eb 07                	jmp    8004212212 <_dwarf_get_next_fde+0xba>
		} else
			dwarf_size = 4;
  800421220b:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > dbg->dbg_eh_size - offset || (length == 0 && !eh_frame)) {
  8004212212:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212216:	48 8b 50 40          	mov    0x40(%rax),%rdx
  800421221a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421221e:	48 29 c2             	sub    %rax,%rdx
  8004212221:	48 89 d0             	mov    %rdx,%rax
  8004212224:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004212228:	72 0d                	jb     8004212237 <_dwarf_get_next_fde+0xdf>
  800421222a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421222f:	75 10                	jne    8004212241 <_dwarf_get_next_fde+0xe9>
  8004212231:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004212235:	75 0a                	jne    8004212241 <_dwarf_get_next_fde+0xe9>
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004212237:	b8 12 00 00 00       	mov    $0x12,%eax
  800421223c:	e9 67 01 00 00       	jmpq   80042123a8 <_dwarf_get_next_fde+0x250>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  8004212241:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004212245:	74 11                	je     8004212258 <_dwarf_get_next_fde+0x100>
  8004212247:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421224c:	75 0a                	jne    8004212258 <_dwarf_get_next_fde+0x100>
			return(-1);
  800421224e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212253:	e9 50 01 00 00       	jmpq   80042123a8 <_dwarf_get_next_fde+0x250>

		cie_id = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, dwarf_size);
  8004212258:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421225c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212260:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212264:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212268:	48 89 d1             	mov    %rdx,%rcx
  800421226b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421226e:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004212272:	48 89 cf             	mov    %rcx,%rdi
  8004212275:	ff d0                	callq  *%rax
  8004212277:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		if (eh_frame) {
  800421227b:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800421227f:	74 79                	je     80042122fa <_dwarf_get_next_fde+0x1a2>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  8004212281:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004212286:	75 32                	jne    80042122ba <_dwarf_get_next_fde+0x162>
				ret = _dwarf_frame_set_cie(dbg, ds,
  8004212288:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421228c:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004212290:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004212294:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004212298:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800421229c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042122a0:	49 89 f8             	mov    %rdi,%r8
  80042122a3:	48 89 c7             	mov    %rax,%rdi
  80042122a6:	48 b8 d9 18 21 04 80 	movabs $0x80042118d9,%rax
  80042122ad:	00 00 00 
  80042122b0:	ff d0                	callq  *%rax
  80042122b2:	89 45 f0             	mov    %eax,-0x10(%rbp)
  80042122b5:	e9 c8 00 00 00       	jmpq   8004212382 <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  80042122ba:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042122be:	4c 8b 40 08          	mov    0x8(%rax),%r8
  80042122c2:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80042122c6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042122ca:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042122ce:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042122d2:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042122d6:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042122da:	4d 89 c1             	mov    %r8,%r9
  80042122dd:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  80042122e3:	48 89 c7             	mov    %rax,%rdi
  80042122e6:	48 b8 3c 1d 21 04 80 	movabs $0x8004211d3c,%rax
  80042122ed:	00 00 00 
  80042122f0:	ff d0                	callq  *%rax
  80042122f2:	89 45 f0             	mov    %eax,-0x10(%rbp)
  80042122f5:	e9 88 00 00 00       	jmpq   8004212382 <_dwarf_get_next_fde+0x22a>
							   &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  80042122fa:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042122fe:	75 0b                	jne    800421230b <_dwarf_get_next_fde+0x1b3>
  8004212300:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212305:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004212309:	74 0d                	je     8004212318 <_dwarf_get_next_fde+0x1c0>
  800421230b:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  800421230f:	75 36                	jne    8004212347 <_dwarf_get_next_fde+0x1ef>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  8004212311:	48 83 7d e0 ff       	cmpq   $0xffffffffffffffff,-0x20(%rbp)
  8004212316:	75 2f                	jne    8004212347 <_dwarf_get_next_fde+0x1ef>
				ret = _dwarf_frame_set_cie(dbg, ds,
  8004212318:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421231c:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004212320:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004212324:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004212328:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800421232c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212330:	49 89 f8             	mov    %rdi,%r8
  8004212333:	48 89 c7             	mov    %rax,%rdi
  8004212336:	48 b8 d9 18 21 04 80 	movabs $0x80042118d9,%rax
  800421233d:	00 00 00 
  8004212340:	ff d0                	callq  *%rax
  8004212342:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004212345:	eb 3b                	jmp    8004212382 <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  8004212347:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421234b:	4c 8b 40 08          	mov    0x8(%rax),%r8
  800421234f:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  8004212353:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212357:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800421235b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421235f:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004212363:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004212367:	4d 89 c1             	mov    %r8,%r9
  800421236a:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8004212370:	48 89 c7             	mov    %rax,%rdi
  8004212373:	48 b8 3c 1d 21 04 80 	movabs $0x8004211d3c,%rax
  800421237a:	00 00 00 
  800421237d:	ff d0                	callq  *%rax
  800421237f:	89 45 f0             	mov    %eax,-0x10(%rbp)
							   &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  8004212382:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8004212386:	74 07                	je     800421238f <_dwarf_get_next_fde+0x237>
			return(-1);
  8004212388:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421238d:	eb 19                	jmp    80042123a8 <_dwarf_get_next_fde+0x250>

		offset = entry_off;
  800421238f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212393:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		dbg->curr_off_eh = offset;
  8004212397:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421239b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421239f:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  80042123a3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042123a8:	c9                   	leaveq 
  80042123a9:	c3                   	retq   

00000080042123aa <dwarf_set_frame_cfa_value>:

Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  80042123aa:	55                   	push   %rbp
  80042123ab:	48 89 e5             	mov    %rsp,%rbp
  80042123ae:	48 83 ec 1c          	sub    $0x1c,%rsp
  80042123b2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042123b6:	89 f0                	mov    %esi,%eax
  80042123b8:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Half old_value;

	old_value = dbg->dbg_frame_cfa_value;
  80042123bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042123c0:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042123c4:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
	dbg->dbg_frame_cfa_value = value;
  80042123c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042123cc:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  80042123d0:	66 89 50 4c          	mov    %dx,0x4c(%rax)

	return (old_value);
  80042123d4:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  80042123d8:	c9                   	leaveq 
  80042123d9:	c3                   	retq   

00000080042123da <dwarf_init_eh_section>:

int dwarf_init_eh_section(Dwarf_Debug dbg, Dwarf_Error *error)
{
  80042123da:	55                   	push   %rbp
  80042123db:	48 89 e5             	mov    %rsp,%rbp
  80042123de:	48 83 ec 10          	sub    $0x10,%rsp
  80042123e2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80042123e6:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	Dwarf_Section *section;

	if (dbg == NULL) {
  80042123ea:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042123ef:	75 0a                	jne    80042123fb <dwarf_init_eh_section+0x21>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  80042123f1:	b8 01 00 00 00       	mov    $0x1,%eax
  80042123f6:	e9 85 00 00 00       	jmpq   8004212480 <dwarf_init_eh_section+0xa6>
	}

	if (dbg->dbg_internal_reg_table == NULL) {
  80042123fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042123ff:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004212403:	48 85 c0             	test   %rax,%rax
  8004212406:	75 25                	jne    800421242d <dwarf_init_eh_section+0x53>
		if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  8004212408:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421240c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212410:	48 89 d6             	mov    %rdx,%rsi
  8004212413:	48 89 c7             	mov    %rax,%rdi
  8004212416:	48 b8 f1 20 21 04 80 	movabs $0x80042120f1,%rax
  800421241d:	00 00 00 
  8004212420:	ff d0                	callq  *%rax
  8004212422:	85 c0                	test   %eax,%eax
  8004212424:	74 07                	je     800421242d <dwarf_init_eh_section+0x53>
			return (DW_DLV_ERROR);
  8004212426:	b8 01 00 00 00       	mov    $0x1,%eax
  800421242b:	eb 53                	jmp    8004212480 <dwarf_init_eh_section+0xa6>
	}

	_dwarf_find_section_enhanced(&debug_frame_sec);
  800421242d:	48 bf 60 a8 22 04 80 	movabs $0x800422a860,%rdi
  8004212434:	00 00 00 
  8004212437:	48 b8 a6 fe 20 04 80 	movabs $0x800420fea6,%rax
  800421243e:	00 00 00 
  8004212441:	ff d0                	callq  *%rax

	dbg->curr_off_eh = 0;
  8004212443:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212447:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  800421244e:	00 
	dbg->dbg_eh_offset = debug_frame_sec.ds_addr;
  800421244f:	48 b8 60 a8 22 04 80 	movabs $0x800422a860,%rax
  8004212456:	00 00 00 
  8004212459:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800421245d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212461:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  8004212465:	48 b8 60 a8 22 04 80 	movabs $0x800422a860,%rax
  800421246c:	00 00 00 
  800421246f:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004212473:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212477:	48 89 50 40          	mov    %rdx,0x40(%rax)

	return (DW_DLV_OK);
  800421247b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212480:	c9                   	leaveq 
  8004212481:	c3                   	retq   

0000008004212482 <_dwarf_lineno_run_program>:
int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
			  uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004212482:	55                   	push   %rbp
  8004212483:	48 89 e5             	mov    %rsp,%rbp
  8004212486:	53                   	push   %rbx
  8004212487:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  800421248e:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  8004212492:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  8004212496:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  800421249d:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  80042124a4:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)
  80042124ab:	4c 89 8d 60 ff ff ff 	mov    %r9,-0xa0(%rbp)
	uint64_t address, file, line, column, isa, opsize;
	int is_stmt, basic_block, end_sequence;
	int prologue_end, epilogue_begin;
	int ret;

	ln = &li->li_line;
  80042124b2:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042124b6:	48 83 c0 48          	add    $0x48,%rax
  80042124ba:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

	/*
	 *   ln->ln_li     = li;             \
	 * Set registers to their default values.
	 */
	RESET_REGISTERS;
  80042124be:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042124c5:	00 
  80042124c6:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  80042124cd:	00 
  80042124ce:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  80042124d5:	00 
  80042124d6:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  80042124dd:	00 
  80042124de:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042124e2:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  80042124e6:	0f b6 c0             	movzbl %al,%eax
  80042124e9:	89 45 cc             	mov    %eax,-0x34(%rbp)
  80042124ec:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  80042124f3:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  80042124fa:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  8004212501:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  8004212508:	e9 0a 05 00 00       	jmpq   8004212a17 <_dwarf_lineno_run_program+0x595>
		if (*p == 0) {
  800421250d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004212514:	0f b6 00             	movzbl (%rax),%eax
  8004212517:	84 c0                	test   %al,%al
  8004212519:	0f 85 78 01 00 00    	jne    8004212697 <_dwarf_lineno_run_program+0x215>

			/*
			 * Extended Opcodes.
			 */

			p++;
  800421251f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004212526:	48 83 c0 01          	add    $0x1,%rax
  800421252a:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
			opsize = _dwarf_decode_uleb128(&p);
  8004212531:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004212538:	48 89 c7             	mov    %rax,%rdi
  800421253b:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004212542:	00 00 00 
  8004212545:	ff d0                	callq  *%rax
  8004212547:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			switch (*p) {
  800421254b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004212552:	0f b6 00             	movzbl (%rax),%eax
  8004212555:	0f b6 c0             	movzbl %al,%eax
  8004212558:	83 f8 02             	cmp    $0x2,%eax
  800421255b:	74 7a                	je     80042125d7 <_dwarf_lineno_run_program+0x155>
  800421255d:	83 f8 03             	cmp    $0x3,%eax
  8004212560:	0f 84 b3 00 00 00    	je     8004212619 <_dwarf_lineno_run_program+0x197>
  8004212566:	83 f8 01             	cmp    $0x1,%eax
  8004212569:	0f 85 09 01 00 00    	jne    8004212678 <_dwarf_lineno_run_program+0x1f6>
			case DW_LNE_end_sequence:
				p++;
  800421256f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004212576:	48 83 c0 01          	add    $0x1,%rax
  800421257a:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				end_sequence = 1;
  8004212581:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
				RESET_REGISTERS;
  8004212588:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800421258f:	00 
  8004212590:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  8004212597:	00 
  8004212598:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  800421259f:	00 
  80042125a0:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  80042125a7:	00 
  80042125a8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042125ac:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  80042125b0:	0f b6 c0             	movzbl %al,%eax
  80042125b3:	89 45 cc             	mov    %eax,-0x34(%rbp)
  80042125b6:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  80042125bd:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  80042125c4:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  80042125cb:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  80042125d2:	e9 bb 00 00 00       	jmpq   8004212692 <_dwarf_lineno_run_program+0x210>
			case DW_LNE_set_address:
				p++;
  80042125d7:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042125de:	48 83 c0 01          	add    $0x1,%rax
  80042125e2:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				address = dbg->decode(&p, cu->addr_size);
  80042125e9:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  80042125f0:	00 00 00 
  80042125f3:	48 8b 00             	mov    (%rax),%rax
  80042125f6:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042125fa:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  80042125fe:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004212602:	0f b6 ca             	movzbl %dl,%ecx
  8004212605:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  800421260c:	89 ce                	mov    %ecx,%esi
  800421260e:	48 89 d7             	mov    %rdx,%rdi
  8004212611:	ff d0                	callq  *%rax
  8004212613:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				break;
  8004212617:	eb 79                	jmp    8004212692 <_dwarf_lineno_run_program+0x210>
			case DW_LNE_define_file:
				p++;
  8004212619:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004212620:	48 83 c0 01          	add    $0x1,%rax
  8004212624:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				ret = _dwarf_lineno_add_file(li, &p, NULL,
  800421262b:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  8004212632:	00 00 00 
  8004212635:	48 8b 08             	mov    (%rax),%rcx
  8004212638:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421263f:	48 8d b5 78 ff ff ff 	lea    -0x88(%rbp),%rsi
  8004212646:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421264a:	49 89 c8             	mov    %rcx,%r8
  800421264d:	48 89 d1             	mov    %rdx,%rcx
  8004212650:	ba 00 00 00 00       	mov    $0x0,%edx
  8004212655:	48 89 c7             	mov    %rax,%rdi
  8004212658:	48 b8 3a 2a 21 04 80 	movabs $0x8004212a3a,%rax
  800421265f:	00 00 00 
  8004212662:	ff d0                	callq  *%rax
  8004212664:	89 45 a4             	mov    %eax,-0x5c(%rbp)
							     error, dbg);
				if (ret != DW_DLE_NONE)
  8004212667:	83 7d a4 00          	cmpl   $0x0,-0x5c(%rbp)
  800421266b:	74 09                	je     8004212676 <_dwarf_lineno_run_program+0x1f4>
					goto prog_fail;
  800421266d:	90                   	nop

	return (DW_DLE_NONE);

prog_fail:

	return (ret);
  800421266e:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004212671:	e9 ba 03 00 00       	jmpq   8004212a30 <_dwarf_lineno_run_program+0x5ae>
				p++;
				ret = _dwarf_lineno_add_file(li, &p, NULL,
							     error, dbg);
				if (ret != DW_DLE_NONE)
					goto prog_fail;
				break;
  8004212676:	eb 1a                	jmp    8004212692 <_dwarf_lineno_run_program+0x210>
			default:
				/* Unrecognized extened opcodes. */
				p += opsize;
  8004212678:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  800421267f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004212683:	48 01 d0             	add    %rdx,%rax
  8004212686:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  800421268d:	e9 85 03 00 00       	jmpq   8004212a17 <_dwarf_lineno_run_program+0x595>
  8004212692:	e9 80 03 00 00       	jmpq   8004212a17 <_dwarf_lineno_run_program+0x595>
			}

		} else if (*p > 0 && *p < li->li_opbase) {
  8004212697:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421269e:	0f b6 00             	movzbl (%rax),%eax
  80042126a1:	84 c0                	test   %al,%al
  80042126a3:	0f 84 3c 02 00 00    	je     80042128e5 <_dwarf_lineno_run_program+0x463>
  80042126a9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042126b0:	0f b6 10             	movzbl (%rax),%edx
  80042126b3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042126b7:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042126bb:	38 c2                	cmp    %al,%dl
  80042126bd:	0f 83 22 02 00 00    	jae    80042128e5 <_dwarf_lineno_run_program+0x463>

			/*
			 * Standard Opcodes.
			 */

			switch (*p++) {
  80042126c3:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042126ca:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042126ce:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  80042126d5:	0f b6 00             	movzbl (%rax),%eax
  80042126d8:	0f b6 c0             	movzbl %al,%eax
  80042126db:	83 f8 0c             	cmp    $0xc,%eax
  80042126de:	0f 87 fb 01 00 00    	ja     80042128df <_dwarf_lineno_run_program+0x45d>
  80042126e4:	89 c0                	mov    %eax,%eax
  80042126e6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042126ed:	00 
  80042126ee:	48 b8 68 7e 21 04 80 	movabs $0x8004217e68,%rax
  80042126f5:	00 00 00 
  80042126f8:	48 01 d0             	add    %rdx,%rax
  80042126fb:	48 8b 00             	mov    (%rax),%rax
  80042126fe:	ff e0                	jmpq   *%rax
			case DW_LNS_copy:
				APPEND_ROW;
  8004212700:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004212707:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800421270b:	73 0a                	jae    8004212717 <_dwarf_lineno_run_program+0x295>
  800421270d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212712:	e9 19 03 00 00       	jmpq   8004212a30 <_dwarf_lineno_run_program+0x5ae>
  8004212717:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421271b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421271f:	48 89 10             	mov    %rdx,(%rax)
  8004212722:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212726:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  800421272d:	00 
  800421272e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212732:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212736:	48 89 50 10          	mov    %rdx,0x10(%rax)
  800421273a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421273e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004212742:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004212746:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421274a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421274e:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004212752:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212756:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004212759:	89 50 28             	mov    %edx,0x28(%rax)
  800421275c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212760:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004212763:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004212766:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421276a:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  800421276d:	89 50 30             	mov    %edx,0x30(%rax)
  8004212770:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004212774:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  800421277b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421277f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004212783:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
				basic_block = 0;
  800421278a:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
				prologue_end = 0;
  8004212791:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
				epilogue_begin = 0;
  8004212798:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  800421279f:	e9 3c 01 00 00       	jmpq   80042128e0 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  80042127a4:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042127ab:	48 89 c7             	mov    %rax,%rdi
  80042127ae:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  80042127b5:	00 00 00 
  80042127b8:	ff d0                	callq  *%rax
					li->li_minlen;
  80042127ba:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  80042127be:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
				basic_block = 0;
				prologue_end = 0;
				epilogue_begin = 0;
				break;
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  80042127c2:	0f b6 d2             	movzbl %dl,%edx
  80042127c5:	48 0f af c2          	imul   %rdx,%rax
  80042127c9:	48 01 45 e8          	add    %rax,-0x18(%rbp)
					li->li_minlen;
				break;
  80042127cd:	e9 0e 01 00 00       	jmpq   80042128e0 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_line:
				line += _dwarf_decode_sleb128(&p);
  80042127d2:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042127d9:	48 89 c7             	mov    %rax,%rdi
  80042127dc:	48 b8 87 e6 20 04 80 	movabs $0x800420e687,%rax
  80042127e3:	00 00 00 
  80042127e6:	ff d0                	callq  *%rax
  80042127e8:	48 01 45 d8          	add    %rax,-0x28(%rbp)
				break;
  80042127ec:	e9 ef 00 00 00       	jmpq   80042128e0 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_file:
				file = _dwarf_decode_uleb128(&p);
  80042127f1:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042127f8:	48 89 c7             	mov    %rax,%rdi
  80042127fb:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004212802:	00 00 00 
  8004212805:	ff d0                	callq  *%rax
  8004212807:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				break;
  800421280b:	e9 d0 00 00 00       	jmpq   80042128e0 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_column:
				column = _dwarf_decode_uleb128(&p);
  8004212810:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004212817:	48 89 c7             	mov    %rax,%rdi
  800421281a:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004212821:	00 00 00 
  8004212824:	ff d0                	callq  *%rax
  8004212826:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
				break;
  800421282a:	e9 b1 00 00 00       	jmpq   80042128e0 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_negate_stmt:
				is_stmt = !is_stmt;
  800421282f:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004212833:	0f 94 c0             	sete   %al
  8004212836:	0f b6 c0             	movzbl %al,%eax
  8004212839:	89 45 cc             	mov    %eax,-0x34(%rbp)
				break;
  800421283c:	e9 9f 00 00 00       	jmpq   80042128e0 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_basic_block:
				basic_block = 1;
  8004212841:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%rbp)
				break;
  8004212848:	e9 93 00 00 00       	jmpq   80042128e0 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_const_add_pc:
				address += ADDRESS(255);
  800421284d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004212851:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004212855:	0f b6 c0             	movzbl %al,%eax
  8004212858:	ba ff 00 00 00       	mov    $0xff,%edx
  800421285d:	89 d1                	mov    %edx,%ecx
  800421285f:	29 c1                	sub    %eax,%ecx
  8004212861:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004212865:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004212869:	0f b6 d8             	movzbl %al,%ebx
  800421286c:	89 c8                	mov    %ecx,%eax
  800421286e:	99                   	cltd   
  800421286f:	f7 fb                	idiv   %ebx
  8004212871:	89 c2                	mov    %eax,%edx
  8004212873:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004212877:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  800421287b:	0f b6 c0             	movzbl %al,%eax
  800421287e:	0f af c2             	imul   %edx,%eax
  8004212881:	48 98                	cltq   
  8004212883:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  8004212887:	eb 57                	jmp    80042128e0 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_fixed_advance_pc:
				address += dbg->decode(&p, 2);
  8004212889:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  8004212890:	00 00 00 
  8004212893:	48 8b 00             	mov    (%rax),%rax
  8004212896:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421289a:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  80042128a1:	be 02 00 00 00       	mov    $0x2,%esi
  80042128a6:	48 89 d7             	mov    %rdx,%rdi
  80042128a9:	ff d0                	callq  *%rax
  80042128ab:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  80042128af:	eb 2f                	jmp    80042128e0 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_prologue_end:
				prologue_end = 1;
  80042128b1:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%rbp)
				break;
  80042128b8:	eb 26                	jmp    80042128e0 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_epilogue_begin:
				epilogue_begin = 1;
  80042128ba:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
				break;
  80042128c1:	eb 1d                	jmp    80042128e0 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_isa:
				isa = _dwarf_decode_uleb128(&p);
  80042128c3:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042128ca:	48 89 c7             	mov    %rax,%rdi
  80042128cd:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  80042128d4:	00 00 00 
  80042128d7:	ff d0                	callq  *%rax
  80042128d9:	48 89 45 98          	mov    %rax,-0x68(%rbp)
				break;
  80042128dd:	eb 01                	jmp    80042128e0 <_dwarf_lineno_run_program+0x45e>
			default:
				/* Unrecognized extened opcodes. What to do? */
				break;
  80042128df:	90                   	nop
			}

		} else {
  80042128e0:	e9 32 01 00 00       	jmpq   8004212a17 <_dwarf_lineno_run_program+0x595>

			/*
			 * Special Opcodes.
			 */

			line += LINE(*p);
  80042128e5:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042128e9:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  80042128ed:	0f be c8             	movsbl %al,%ecx
  80042128f0:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042128f7:	0f b6 00             	movzbl (%rax),%eax
  80042128fa:	0f b6 d0             	movzbl %al,%edx
  80042128fd:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004212901:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004212905:	0f b6 c0             	movzbl %al,%eax
  8004212908:	29 c2                	sub    %eax,%edx
  800421290a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421290e:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004212912:	0f b6 f0             	movzbl %al,%esi
  8004212915:	89 d0                	mov    %edx,%eax
  8004212917:	99                   	cltd   
  8004212918:	f7 fe                	idiv   %esi
  800421291a:	89 d0                	mov    %edx,%eax
  800421291c:	01 c8                	add    %ecx,%eax
  800421291e:	48 98                	cltq   
  8004212920:	48 01 45 d8          	add    %rax,-0x28(%rbp)
			address += ADDRESS(*p);
  8004212924:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421292b:	0f b6 00             	movzbl (%rax),%eax
  800421292e:	0f b6 d0             	movzbl %al,%edx
  8004212931:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004212935:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004212939:	0f b6 c0             	movzbl %al,%eax
  800421293c:	89 d1                	mov    %edx,%ecx
  800421293e:	29 c1                	sub    %eax,%ecx
  8004212940:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004212944:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004212948:	0f b6 d8             	movzbl %al,%ebx
  800421294b:	89 c8                	mov    %ecx,%eax
  800421294d:	99                   	cltd   
  800421294e:	f7 fb                	idiv   %ebx
  8004212950:	89 c2                	mov    %eax,%edx
  8004212952:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004212956:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  800421295a:	0f b6 c0             	movzbl %al,%eax
  800421295d:	0f af c2             	imul   %edx,%eax
  8004212960:	48 98                	cltq   
  8004212962:	48 01 45 e8          	add    %rax,-0x18(%rbp)
			APPEND_ROW;
  8004212966:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421296d:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004212971:	73 0a                	jae    800421297d <_dwarf_lineno_run_program+0x4fb>
  8004212973:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212978:	e9 b3 00 00 00       	jmpq   8004212a30 <_dwarf_lineno_run_program+0x5ae>
  800421297d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212981:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212985:	48 89 10             	mov    %rdx,(%rax)
  8004212988:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421298c:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004212993:	00 
  8004212994:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212998:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421299c:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80042129a0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042129a4:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042129a8:	48 89 50 18          	mov    %rdx,0x18(%rax)
  80042129ac:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042129b0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042129b4:	48 89 50 20          	mov    %rdx,0x20(%rax)
  80042129b8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042129bc:	8b 55 c8             	mov    -0x38(%rbp),%edx
  80042129bf:	89 50 28             	mov    %edx,0x28(%rax)
  80042129c2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042129c6:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042129c9:	89 50 2c             	mov    %edx,0x2c(%rax)
  80042129cc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042129d0:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042129d3:	89 50 30             	mov    %edx,0x30(%rax)
  80042129d6:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042129da:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80042129e1:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042129e5:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042129e9:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
			basic_block = 0;
  80042129f0:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
			prologue_end = 0;
  80042129f7:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
			epilogue_begin = 0;
  80042129fe:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
			p++;
  8004212a05:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004212a0c:	48 83 c0 01          	add    $0x1,%rax
  8004212a10:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	RESET_REGISTERS;

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  8004212a17:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004212a1e:	48 3b 85 70 ff ff ff 	cmp    -0x90(%rbp),%rax
  8004212a25:	0f 82 e2 fa ff ff    	jb     800421250d <_dwarf_lineno_run_program+0x8b>
			epilogue_begin = 0;
			p++;
		}
	}

	return (DW_DLE_NONE);
  8004212a2b:	b8 00 00 00 00       	mov    $0x0,%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  8004212a30:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  8004212a37:	5b                   	pop    %rbx
  8004212a38:	5d                   	pop    %rbp
  8004212a39:	c3                   	retq   

0000008004212a3a <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
		       Dwarf_Error *error, Dwarf_Debug dbg)
{
  8004212a3a:	55                   	push   %rbp
  8004212a3b:	48 89 e5             	mov    %rsp,%rbp
  8004212a3e:	53                   	push   %rbx
  8004212a3f:	48 83 ec 48          	sub    $0x48,%rsp
  8004212a43:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004212a47:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004212a4b:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004212a4f:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004212a53:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
	char *fname;
	//const char *dirname;
	uint8_t *src;
	int slen;

	src = *p;
  8004212a57:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212a5b:	48 8b 00             	mov    (%rax),%rax
  8004212a5e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
  return (DW_DLE_MEMORY);
  }
*/  
	//lf->lf_fullpath = NULL;
	fname = (char *) src;
  8004212a62:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212a66:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	src += strlen(fname) + 1;
  8004212a6a:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  8004212a6e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212a72:	48 89 c7             	mov    %rax,%rdi
  8004212a75:	48 b8 f1 d7 20 04 80 	movabs $0x800420d7f1,%rax
  8004212a7c:	00 00 00 
  8004212a7f:	ff d0                	callq  *%rax
  8004212a81:	48 98                	cltq   
  8004212a83:	48 83 c0 01          	add    $0x1,%rax
  8004212a87:	48 01 d8             	add    %rbx,%rax
  8004212a8a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	_dwarf_decode_uleb128(&src);
  8004212a8e:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004212a92:	48 89 c7             	mov    %rax,%rdi
  8004212a95:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004212a9c:	00 00 00 
  8004212a9f:	ff d0                	callq  *%rax
	   snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
	   lf->lf_fname);
	   }
	   }
	*/
	_dwarf_decode_uleb128(&src);
  8004212aa1:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004212aa5:	48 89 c7             	mov    %rax,%rdi
  8004212aa8:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004212aaf:	00 00 00 
  8004212ab2:	ff d0                	callq  *%rax
	_dwarf_decode_uleb128(&src);
  8004212ab4:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004212ab8:	48 89 c7             	mov    %rax,%rdi
  8004212abb:	48 b8 19 e7 20 04 80 	movabs $0x800420e719,%rax
  8004212ac2:	00 00 00 
  8004212ac5:	ff d0                	callq  *%rax
	//STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
	//li->li_lflen++;

	*p = src;
  8004212ac7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212acb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212acf:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  8004212ad2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212ad7:	48 83 c4 48          	add    $0x48,%rsp
  8004212adb:	5b                   	pop    %rbx
  8004212adc:	5d                   	pop    %rbp
  8004212add:	c3                   	retq   

0000008004212ade <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  8004212ade:	55                   	push   %rbp
  8004212adf:	48 89 e5             	mov    %rsp,%rbp
  8004212ae2:	53                   	push   %rbx
  8004212ae3:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  8004212aea:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  8004212af1:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  8004212af8:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  8004212aff:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  8004212b06:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
	Dwarf_Section myds = {.ds_name = ".debug_line"};
  8004212b0d:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8004212b14:	00 
  8004212b15:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  8004212b1c:	00 
  8004212b1d:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  8004212b24:	00 
  8004212b25:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004212b2c:	00 
  8004212b2d:	48 b8 d0 7e 21 04 80 	movabs $0x8004217ed0,%rax
  8004212b34:	00 00 00 
  8004212b37:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  8004212b3b:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8004212b3f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//Dwarf_LineFile lf, tlf;
	uint64_t length, hdroff, endoff;
	uint8_t *p;
	int dwarf_size, i, ret;
            
	cu = die->cu_header;
  8004212b43:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004212b4a:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  8004212b51:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	assert(cu != NULL); 
  8004212b55:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004212b5a:	75 35                	jne    8004212b91 <_dwarf_lineno_init+0xb3>
  8004212b5c:	48 b9 dc 7e 21 04 80 	movabs $0x8004217edc,%rcx
  8004212b63:	00 00 00 
  8004212b66:	48 ba e7 7e 21 04 80 	movabs $0x8004217ee7,%rdx
  8004212b6d:	00 00 00 
  8004212b70:	be 13 01 00 00       	mov    $0x113,%esi
  8004212b75:	48 bf fc 7e 21 04 80 	movabs $0x8004217efc,%rdi
  8004212b7c:	00 00 00 
  8004212b7f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212b84:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004212b8b:	00 00 00 
  8004212b8e:	41 ff d0             	callq  *%r8
	assert(dbg != NULL);
  8004212b91:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  8004212b98:	00 00 00 
  8004212b9b:	48 8b 00             	mov    (%rax),%rax
  8004212b9e:	48 85 c0             	test   %rax,%rax
  8004212ba1:	75 35                	jne    8004212bd8 <_dwarf_lineno_init+0xfa>
  8004212ba3:	48 b9 13 7f 21 04 80 	movabs $0x8004217f13,%rcx
  8004212baa:	00 00 00 
  8004212bad:	48 ba e7 7e 21 04 80 	movabs $0x8004217ee7,%rdx
  8004212bb4:	00 00 00 
  8004212bb7:	be 14 01 00 00       	mov    $0x114,%esi
  8004212bbc:	48 bf fc 7e 21 04 80 	movabs $0x8004217efc,%rdi
  8004212bc3:	00 00 00 
  8004212bc6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212bcb:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004212bd2:	00 00 00 
  8004212bd5:	41 ff d0             	callq  *%r8

	if ((_dwarf_find_section_enhanced(ds)) != 0)
  8004212bd8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212bdc:	48 89 c7             	mov    %rax,%rdi
  8004212bdf:	48 b8 a6 fe 20 04 80 	movabs $0x800420fea6,%rax
  8004212be6:	00 00 00 
  8004212be9:	ff d0                	callq  *%rax
  8004212beb:	85 c0                	test   %eax,%eax
  8004212bed:	74 0a                	je     8004212bf9 <_dwarf_lineno_init+0x11b>
		return (DW_DLE_NONE);
  8004212bef:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212bf4:	e9 4f 04 00 00       	jmpq   8004213048 <_dwarf_lineno_init+0x56a>

	li = linfo;
  8004212bf9:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004212c00:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	 break;
	 }
	 }
	*/

	length = dbg->read(ds->ds_data, &offset, 4);
  8004212c04:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  8004212c0b:	00 00 00 
  8004212c0e:	48 8b 00             	mov    (%rax),%rax
  8004212c11:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212c15:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212c19:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004212c1d:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004212c24:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212c29:	48 89 cf             	mov    %rcx,%rdi
  8004212c2c:	ff d0                	callq  *%rax
  8004212c2e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (length == 0xffffffff) {
  8004212c32:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212c37:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004212c3b:	75 37                	jne    8004212c74 <_dwarf_lineno_init+0x196>
		dwarf_size = 8;
  8004212c3d:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
		length = dbg->read(ds->ds_data, &offset, 8);
  8004212c44:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  8004212c4b:	00 00 00 
  8004212c4e:	48 8b 00             	mov    (%rax),%rax
  8004212c51:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212c55:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212c59:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004212c5d:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004212c64:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212c69:	48 89 cf             	mov    %rcx,%rdi
  8004212c6c:	ff d0                	callq  *%rax
  8004212c6e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004212c72:	eb 07                	jmp    8004212c7b <_dwarf_lineno_init+0x19d>
	} else
		dwarf_size = 4;
  8004212c74:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

	if (length > ds->ds_size - offset) {
  8004212c7b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212c7f:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004212c83:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004212c8a:	48 29 c2             	sub    %rax,%rdx
  8004212c8d:	48 89 d0             	mov    %rdx,%rax
  8004212c90:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004212c94:	73 0a                	jae    8004212ca0 <_dwarf_lineno_init+0x1c2>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
		return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004212c96:	b8 0f 00 00 00       	mov    $0xf,%eax
  8004212c9b:	e9 a8 03 00 00       	jmpq   8004213048 <_dwarf_lineno_init+0x56a>
	}
	/*
	 * Read in line number program header.
	 */
	li->li_length = length;
  8004212ca0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212ca4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212ca8:	48 89 10             	mov    %rdx,(%rax)
	endoff = offset + length;
  8004212cab:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  8004212cb2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212cb6:	48 01 d0             	add    %rdx,%rax
  8004212cb9:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  8004212cbd:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  8004212cc4:	00 00 00 
  8004212cc7:	48 8b 00             	mov    (%rax),%rax
  8004212cca:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212cce:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212cd2:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004212cd6:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004212cdd:	ba 02 00 00 00       	mov    $0x2,%edx
  8004212ce2:	48 89 cf             	mov    %rcx,%rdi
  8004212ce5:	ff d0                	callq  *%rax
  8004212ce7:	89 c2                	mov    %eax,%edx
  8004212ce9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212ced:	66 89 50 08          	mov    %dx,0x8(%rax)
	li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  8004212cf1:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  8004212cf8:	00 00 00 
  8004212cfb:	48 8b 00             	mov    (%rax),%rax
  8004212cfe:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212d02:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212d06:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004212d0a:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004212d0d:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004212d14:	48 89 cf             	mov    %rcx,%rdi
  8004212d17:	ff d0                	callq  *%rax
  8004212d19:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212d1d:	48 89 42 10          	mov    %rax,0x10(%rdx)
	hdroff = offset;
  8004212d21:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004212d28:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  8004212d2c:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  8004212d33:	00 00 00 
  8004212d36:	48 8b 00             	mov    (%rax),%rax
  8004212d39:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212d3d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212d41:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004212d45:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004212d4c:	ba 01 00 00 00       	mov    $0x1,%edx
  8004212d51:	48 89 cf             	mov    %rcx,%rdi
  8004212d54:	ff d0                	callq  *%rax
  8004212d56:	89 c2                	mov    %eax,%edx
  8004212d58:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212d5c:	88 50 18             	mov    %dl,0x18(%rax)
	li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  8004212d5f:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  8004212d66:	00 00 00 
  8004212d69:	48 8b 00             	mov    (%rax),%rax
  8004212d6c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212d70:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212d74:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004212d78:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004212d7f:	ba 01 00 00 00       	mov    $0x1,%edx
  8004212d84:	48 89 cf             	mov    %rcx,%rdi
  8004212d87:	ff d0                	callq  *%rax
  8004212d89:	89 c2                	mov    %eax,%edx
  8004212d8b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212d8f:	88 50 19             	mov    %dl,0x19(%rax)
	li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  8004212d92:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  8004212d99:	00 00 00 
  8004212d9c:	48 8b 00             	mov    (%rax),%rax
  8004212d9f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212da3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212da7:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004212dab:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004212db2:	ba 01 00 00 00       	mov    $0x1,%edx
  8004212db7:	48 89 cf             	mov    %rcx,%rdi
  8004212dba:	ff d0                	callq  *%rax
  8004212dbc:	89 c2                	mov    %eax,%edx
  8004212dbe:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212dc2:	88 50 1a             	mov    %dl,0x1a(%rax)
	li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  8004212dc5:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  8004212dcc:	00 00 00 
  8004212dcf:	48 8b 00             	mov    (%rax),%rax
  8004212dd2:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212dd6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212dda:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004212dde:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004212de5:	ba 01 00 00 00       	mov    $0x1,%edx
  8004212dea:	48 89 cf             	mov    %rcx,%rdi
  8004212ded:	ff d0                	callq  *%rax
  8004212def:	89 c2                	mov    %eax,%edx
  8004212df1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212df5:	88 50 1b             	mov    %dl,0x1b(%rax)
	li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  8004212df8:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  8004212dff:	00 00 00 
  8004212e02:	48 8b 00             	mov    (%rax),%rax
  8004212e05:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212e09:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212e0d:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004212e11:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004212e18:	ba 01 00 00 00       	mov    $0x1,%edx
  8004212e1d:	48 89 cf             	mov    %rcx,%rdi
  8004212e20:	ff d0                	callq  *%rax
  8004212e22:	89 c2                	mov    %eax,%edx
  8004212e24:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212e28:	88 50 1c             	mov    %dl,0x1c(%rax)
	//STAILQ_INIT(&li->li_lflist);
	//STAILQ_INIT(&li->li_lnlist);

	if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  8004212e2b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212e2f:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004212e33:	8d 50 fb             	lea    -0x5(%rax),%edx
  8004212e36:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212e3a:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004212e3e:	0f b6 c0             	movzbl %al,%eax
  8004212e41:	83 e8 01             	sub    $0x1,%eax
  8004212e44:	39 c2                	cmp    %eax,%edx
  8004212e46:	7d 0c                	jge    8004212e54 <_dwarf_lineno_init+0x376>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004212e48:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004212e4f:	e9 f1 01 00 00       	jmpq   8004213045 <_dwarf_lineno_init+0x567>
	}

	li->li_oplen = global_std_op;
  8004212e54:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212e58:	48 bb a0 f5 49 04 80 	movabs $0x800449f5a0,%rbx
  8004212e5f:	00 00 00 
  8004212e62:	48 89 58 20          	mov    %rbx,0x20(%rax)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004212e66:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  8004212e6d:	eb 41                	jmp    8004212eb0 <_dwarf_lineno_init+0x3d2>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  8004212e6f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212e73:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004212e77:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004212e7a:	48 98                	cltq   
  8004212e7c:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004212e80:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  8004212e87:	00 00 00 
  8004212e8a:	48 8b 00             	mov    (%rax),%rax
  8004212e8d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212e91:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212e95:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004212e99:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004212ea0:	ba 01 00 00 00       	mov    $0x1,%edx
  8004212ea5:	48 89 cf             	mov    %rcx,%rdi
  8004212ea8:	ff d0                	callq  *%rax
  8004212eaa:	88 03                	mov    %al,(%rbx)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004212eac:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  8004212eb0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212eb4:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004212eb8:	0f b6 c0             	movzbl %al,%eax
  8004212ebb:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  8004212ebe:	7f af                	jg     8004212e6f <_dwarf_lineno_init+0x391>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);

	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
  8004212ec0:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004212ec7:	00 
	p = ds->ds_data + offset;
  8004212ec8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212ecc:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004212ed0:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004212ed7:	48 01 d0             	add    %rdx,%rax
  8004212eda:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	while (*p != '\0') {
  8004212ee1:	eb 1f                	jmp    8004212f02 <_dwarf_lineno_init+0x424>
		while (*p++ != '\0')
  8004212ee3:	90                   	nop
  8004212ee4:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004212eeb:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004212eef:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
  8004212ef6:	0f b6 00             	movzbl (%rax),%eax
  8004212ef9:	84 c0                	test   %al,%al
  8004212efb:	75 e7                	jne    8004212ee4 <_dwarf_lineno_init+0x406>
			;
		length++;
  8004212efd:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
	p = ds->ds_data + offset;
	while (*p != '\0') {
  8004212f02:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004212f09:	0f b6 00             	movzbl (%rax),%eax
  8004212f0c:	84 c0                	test   %al,%al
  8004212f0e:	75 d3                	jne    8004212ee3 <_dwarf_lineno_init+0x405>
		while (*p++ != '\0')
			;
		length++;
	}
	li->li_inclen = length;
  8004212f10:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212f14:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212f18:	48 89 50 30          	mov    %rdx,0x30(%rax)

	/* Sanity check. */
	if (p - ds->ds_data > (int) ds->ds_size) {
  8004212f1c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004212f23:	48 89 c2             	mov    %rax,%rdx
  8004212f26:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212f2a:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212f2e:	48 29 c2             	sub    %rax,%rdx
  8004212f31:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212f35:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212f39:	48 98                	cltq   
  8004212f3b:	48 39 c2             	cmp    %rax,%rdx
  8004212f3e:	7e 0c                	jle    8004212f4c <_dwarf_lineno_init+0x46e>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004212f40:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004212f47:	e9 f9 00 00 00       	jmpq   8004213045 <_dwarf_lineno_init+0x567>
	}
	p++;
  8004212f4c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004212f53:	48 83 c0 01          	add    $0x1,%rax
  8004212f57:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  8004212f5e:	eb 3c                	jmp    8004212f9c <_dwarf_lineno_init+0x4be>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  8004212f60:	48 b8 58 a8 22 04 80 	movabs $0x800422a858,%rax
  8004212f67:	00 00 00 
  8004212f6a:	48 8b 08             	mov    (%rax),%rcx
  8004212f6d:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004212f74:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  8004212f7b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212f7f:	49 89 c8             	mov    %rcx,%r8
  8004212f82:	48 89 d1             	mov    %rdx,%rcx
  8004212f85:	ba 00 00 00 00       	mov    $0x0,%edx
  8004212f8a:	48 89 c7             	mov    %rax,%rdi
  8004212f8d:	48 b8 3a 2a 21 04 80 	movabs $0x8004212a3a,%rax
  8004212f94:	00 00 00 
  8004212f97:	ff d0                	callq  *%rax
  8004212f99:	89 45 dc             	mov    %eax,-0x24(%rbp)
	p++;

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  8004212f9c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004212fa3:	0f b6 00             	movzbl (%rax),%eax
  8004212fa6:	84 c0                	test   %al,%al
  8004212fa8:	75 b6                	jne    8004212f60 <_dwarf_lineno_init+0x482>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
		//p++;
	}

	p++;
  8004212faa:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004212fb1:	48 83 c0 01          	add    $0x1,%rax
  8004212fb5:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	/* Sanity check. */
	if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  8004212fbc:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004212fc3:	48 89 c2             	mov    %rax,%rdx
  8004212fc6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212fca:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212fce:	48 29 c2             	sub    %rax,%rdx
  8004212fd1:	48 89 d0             	mov    %rdx,%rax
  8004212fd4:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
  8004212fd8:	48 89 c2             	mov    %rax,%rdx
  8004212fdb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212fdf:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004212fe3:	48 39 c2             	cmp    %rax,%rdx
  8004212fe6:	74 09                	je     8004212ff1 <_dwarf_lineno_init+0x513>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004212fe8:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004212fef:	eb 54                	jmp    8004213045 <_dwarf_lineno_init+0x567>
	}

	/*
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  8004212ff1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212ff5:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004212ff9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212ffd:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004213001:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  8004213008:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  800421300f:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  8004213016:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800421301a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421301e:	4d 89 c1             	mov    %r8,%r9
  8004213021:	49 89 f8             	mov    %rdi,%r8
  8004213024:	48 89 c7             	mov    %rax,%rdi
  8004213027:	48 b8 82 24 21 04 80 	movabs $0x8004212482,%rax
  800421302e:	00 00 00 
  8004213031:	ff d0                	callq  *%rax
  8004213033:	89 45 dc             	mov    %eax,-0x24(%rbp)
					error);
	if (ret != DW_DLE_NONE)
  8004213036:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800421303a:	74 02                	je     800421303e <_dwarf_lineno_init+0x560>
		goto fail_cleanup;
  800421303c:	eb 07                	jmp    8004213045 <_dwarf_lineno_init+0x567>

	//cu->cu_lineinfo = li;

	return (DW_DLE_NONE);
  800421303e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213043:	eb 03                	jmp    8004213048 <_dwarf_lineno_init+0x56a>
fail_cleanup:

	/*if (li->li_oplen)
	  free(li->li_oplen);*/

	return (ret);
  8004213045:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  8004213048:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  800421304f:	5b                   	pop    %rbx
  8004213050:	5d                   	pop    %rbp
  8004213051:	c3                   	retq   

0000008004213052 <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004213052:	55                   	push   %rbp
  8004213053:	48 89 e5             	mov    %rsp,%rbp
  8004213056:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  800421305d:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004213064:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  800421306b:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004213072:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
	_Dwarf_LineInfo li;
	Dwarf_Attribute *at;

	assert(die);
  8004213079:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  8004213080:	00 
  8004213081:	75 35                	jne    80042130b8 <dwarf_srclines+0x66>
  8004213083:	48 b9 1f 7f 21 04 80 	movabs $0x8004217f1f,%rcx
  800421308a:	00 00 00 
  800421308d:	48 ba e7 7e 21 04 80 	movabs $0x8004217ee7,%rdx
  8004213094:	00 00 00 
  8004213097:	be 9a 01 00 00       	mov    $0x19a,%esi
  800421309c:	48 bf fc 7e 21 04 80 	movabs $0x8004217efc,%rdi
  80042130a3:	00 00 00 
  80042130a6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042130ab:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042130b2:	00 00 00 
  80042130b5:	41 ff d0             	callq  *%r8
	assert(linebuf);
  80042130b8:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  80042130bf:	00 
  80042130c0:	75 35                	jne    80042130f7 <dwarf_srclines+0xa5>
  80042130c2:	48 b9 23 7f 21 04 80 	movabs $0x8004217f23,%rcx
  80042130c9:	00 00 00 
  80042130cc:	48 ba e7 7e 21 04 80 	movabs $0x8004217ee7,%rdx
  80042130d3:	00 00 00 
  80042130d6:	be 9b 01 00 00       	mov    $0x19b,%esi
  80042130db:	48 bf fc 7e 21 04 80 	movabs $0x8004217efc,%rdi
  80042130e2:	00 00 00 
  80042130e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042130ea:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042130f1:	00 00 00 
  80042130f4:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  80042130f7:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  80042130fe:	ba 88 00 00 00       	mov    $0x88,%edx
  8004213103:	be 00 00 00 00       	mov    $0x0,%esi
  8004213108:	48 89 c7             	mov    %rax,%rdi
  800421310b:	48 b8 f6 da 20 04 80 	movabs $0x800420daf6,%rax
  8004213112:	00 00 00 
  8004213115:	ff d0                	callq  *%rax

	if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  8004213117:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421311e:	be 10 00 00 00       	mov    $0x10,%esi
  8004213123:	48 89 c7             	mov    %rax,%rdi
  8004213126:	48 b8 2b fa 20 04 80 	movabs $0x800420fa2b,%rax
  800421312d:	00 00 00 
  8004213130:	ff d0                	callq  *%rax
  8004213132:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004213136:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421313b:	75 0a                	jne    8004213147 <dwarf_srclines+0xf5>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  800421313d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213142:	e9 84 00 00 00       	jmpq   80042131cb <dwarf_srclines+0x179>
	}

	if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  8004213147:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421314b:	48 8b 70 28          	mov    0x28(%rax),%rsi
  800421314f:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  8004213156:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  800421315d:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  8004213164:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421316b:	49 89 f8             	mov    %rdi,%r8
  800421316e:	48 89 c7             	mov    %rax,%rdi
  8004213171:	48 b8 de 2a 21 04 80 	movabs $0x8004212ade,%rax
  8004213178:	00 00 00 
  800421317b:	ff d0                	callq  *%rax
  800421317d:	85 c0                	test   %eax,%eax
  800421317f:	74 07                	je     8004213188 <dwarf_srclines+0x136>
	    DW_DLE_NONE)
	{
		return (DW_DLV_ERROR);
  8004213181:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213186:	eb 43                	jmp    80042131cb <dwarf_srclines+0x179>
	}
	*linebuf = li.li_line;
  8004213188:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800421318f:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213193:	48 89 10             	mov    %rdx,(%rax)
  8004213196:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421319a:	48 89 50 08          	mov    %rdx,0x8(%rax)
  800421319e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042131a2:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80042131a6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042131aa:	48 89 50 18          	mov    %rdx,0x18(%rax)
  80042131ae:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042131b2:	48 89 50 20          	mov    %rdx,0x20(%rax)
  80042131b6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042131ba:	48 89 50 28          	mov    %rdx,0x28(%rax)
  80042131be:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042131c2:	48 89 50 30          	mov    %rdx,0x30(%rax)

	return (DW_DLV_OK);
  80042131c6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042131cb:	c9                   	leaveq 
  80042131cc:	c3                   	retq   

00000080042131cd <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  80042131cd:	55                   	push   %rbp
  80042131ce:	48 89 e5             	mov    %rsp,%rbp
  80042131d1:	48 83 ec 20          	sub    $0x20,%rsp
  80042131d5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *ret=NULL;
  80042131d9:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042131e0:	00 
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  80042131e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042131e8:	eb 57                	jmp    8004213241 <_dwarf_find_section+0x74>
		if(!strcmp(section_info[i].ds_name, name)) {
  80042131ea:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  80042131f1:	00 00 00 
  80042131f4:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042131f7:	48 63 d2             	movslq %edx,%rdx
  80042131fa:	48 c1 e2 05          	shl    $0x5,%rdx
  80042131fe:	48 01 d0             	add    %rdx,%rax
  8004213201:	48 8b 00             	mov    (%rax),%rax
  8004213204:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213208:	48 89 d6             	mov    %rdx,%rsi
  800421320b:	48 89 c7             	mov    %rax,%rdi
  800421320e:	48 b8 bf d9 20 04 80 	movabs $0x800420d9bf,%rax
  8004213215:	00 00 00 
  8004213218:	ff d0                	callq  *%rax
  800421321a:	85 c0                	test   %eax,%eax
  800421321c:	75 1f                	jne    800421323d <_dwarf_find_section+0x70>
			ret = (section_info + i);
  800421321e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213221:	48 98                	cltq   
  8004213223:	48 c1 e0 05          	shl    $0x5,%rax
  8004213227:	48 89 c2             	mov    %rax,%rdx
  800421322a:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213231:	00 00 00 
  8004213234:	48 01 d0             	add    %rdx,%rax
  8004213237:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800421323b:	eb 0a                	jmp    8004213247 <_dwarf_find_section+0x7a>
_dwarf_find_section(const char *name)
{
	Dwarf_Section *ret=NULL;
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  800421323d:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004213241:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213245:	7e a3                	jle    80042131ea <_dwarf_find_section+0x1d>
			ret = (section_info + i);
			break;
		}
	}

	return ret;
  8004213247:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421324b:	c9                   	leaveq 
  800421324c:	c3                   	retq   

000000800421324d <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  800421324d:	55                   	push   %rbp
  800421324e:	48 89 e5             	mov    %rsp,%rbp
  8004213251:	48 83 ec 40          	sub    $0x40,%rsp
  8004213255:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	Elf *ehdr = (Elf *)elf;
  8004213259:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421325d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uintptr_t debug_address = USTABDATA;
  8004213261:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  8004213268:	00 
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  8004213269:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421326d:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004213271:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213275:	48 01 d0             	add    %rdx,%rax
  8004213278:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  800421327c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213280:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004213284:	0f b7 c0             	movzwl %ax,%eax
  8004213287:	48 c1 e0 06          	shl    $0x6,%rax
  800421328b:	48 89 c2             	mov    %rax,%rdx
  800421328e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213292:	48 01 d0             	add    %rdx,%rax
  8004213295:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Secthdr* esh = sh + ehdr->e_shnum;
  8004213299:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421329d:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  80042132a1:	0f b7 c0             	movzwl %ax,%eax
  80042132a4:	48 c1 e0 06          	shl    $0x6,%rax
  80042132a8:	48 89 c2             	mov    %rax,%rdx
  80042132ab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042132af:	48 01 d0             	add    %rdx,%rax
  80042132b2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;sh < esh; sh++) {
  80042132b6:	e9 4b 02 00 00       	jmpq   8004213506 <find_debug_sections+0x2b9>
		char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  80042132bb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042132bf:	8b 00                	mov    (%rax),%eax
  80042132c1:	89 c2                	mov    %eax,%edx
  80042132c3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042132c7:	48 8b 48 18          	mov    0x18(%rax),%rcx
  80042132cb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042132cf:	48 01 c8             	add    %rcx,%rax
  80042132d2:	48 01 d0             	add    %rdx,%rax
  80042132d5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!strcmp(name, ".debug_info")) {
  80042132d9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042132dd:	48 be 2b 7f 21 04 80 	movabs $0x8004217f2b,%rsi
  80042132e4:	00 00 00 
  80042132e7:	48 89 c7             	mov    %rax,%rdi
  80042132ea:	48 b8 bf d9 20 04 80 	movabs $0x800420d9bf,%rax
  80042132f1:	00 00 00 
  80042132f4:	ff d0                	callq  *%rax
  80042132f6:	85 c0                	test   %eax,%eax
  80042132f8:	75 4b                	jne    8004213345 <find_debug_sections+0xf8>
			section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  80042132fa:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042132fe:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213305:	00 00 00 
  8004213308:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  800421330c:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213313:	00 00 00 
  8004213316:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421331a:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  800421331e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213322:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004213326:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  800421332d:	00 00 00 
  8004213330:	48 89 50 18          	mov    %rdx,0x18(%rax)
			debug_address += sh->sh_size;
  8004213334:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213338:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421333c:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004213340:	e9 bc 01 00 00       	jmpq   8004213501 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_abbrev")) {
  8004213345:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213349:	48 be 37 7f 21 04 80 	movabs $0x8004217f37,%rsi
  8004213350:	00 00 00 
  8004213353:	48 89 c7             	mov    %rax,%rdi
  8004213356:	48 b8 bf d9 20 04 80 	movabs $0x800420d9bf,%rax
  800421335d:	00 00 00 
  8004213360:	ff d0                	callq  *%rax
  8004213362:	85 c0                	test   %eax,%eax
  8004213364:	75 4b                	jne    80042133b1 <find_debug_sections+0x164>
			section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  8004213366:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421336a:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213371:	00 00 00 
  8004213374:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  8004213378:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  800421337f:	00 00 00 
  8004213382:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213386:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  800421338a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421338e:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004213392:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213399:	00 00 00 
  800421339c:	48 89 50 38          	mov    %rdx,0x38(%rax)
			debug_address += sh->sh_size;
  80042133a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042133a4:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042133a8:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042133ac:	e9 50 01 00 00       	jmpq   8004213501 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_line")){
  80042133b1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042133b5:	48 be 4f 7f 21 04 80 	movabs $0x8004217f4f,%rsi
  80042133bc:	00 00 00 
  80042133bf:	48 89 c7             	mov    %rax,%rdi
  80042133c2:	48 b8 bf d9 20 04 80 	movabs $0x800420d9bf,%rax
  80042133c9:	00 00 00 
  80042133cc:	ff d0                	callq  *%rax
  80042133ce:	85 c0                	test   %eax,%eax
  80042133d0:	75 4b                	jne    800421341d <find_debug_sections+0x1d0>
			section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  80042133d2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042133d6:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  80042133dd:	00 00 00 
  80042133e0:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  80042133e4:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  80042133eb:	00 00 00 
  80042133ee:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042133f2:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  80042133f6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042133fa:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042133fe:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213405:	00 00 00 
  8004213408:	48 89 50 78          	mov    %rdx,0x78(%rax)
			debug_address += sh->sh_size;
  800421340c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213410:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213414:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004213418:	e9 e4 00 00 00       	jmpq   8004213501 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".eh_frame")){
  800421341d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213421:	48 be 45 7f 21 04 80 	movabs $0x8004217f45,%rsi
  8004213428:	00 00 00 
  800421342b:	48 89 c7             	mov    %rax,%rdi
  800421342e:	48 b8 bf d9 20 04 80 	movabs $0x800420d9bf,%rax
  8004213435:	00 00 00 
  8004213438:	ff d0                	callq  *%rax
  800421343a:	85 c0                	test   %eax,%eax
  800421343c:	75 53                	jne    8004213491 <find_debug_sections+0x244>
			section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  800421343e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213442:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004213446:	48 89 c2             	mov    %rax,%rdx
  8004213449:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213450:	00 00 00 
  8004213453:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  8004213457:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421345b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800421345f:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213466:	00 00 00 
  8004213469:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  800421346d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213471:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004213475:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  800421347c:	00 00 00 
  800421347f:	48 89 50 58          	mov    %rdx,0x58(%rax)
			debug_address += sh->sh_size;
  8004213483:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213487:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421348b:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  800421348f:	eb 70                	jmp    8004213501 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_str")) {
  8004213491:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213495:	48 be 5b 7f 21 04 80 	movabs $0x8004217f5b,%rsi
  800421349c:	00 00 00 
  800421349f:	48 89 c7             	mov    %rax,%rdi
  80042134a2:	48 b8 bf d9 20 04 80 	movabs $0x800420d9bf,%rax
  80042134a9:	00 00 00 
  80042134ac:	ff d0                	callq  *%rax
  80042134ae:	85 c0                	test   %eax,%eax
  80042134b0:	75 4f                	jne    8004213501 <find_debug_sections+0x2b4>
			section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  80042134b2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042134b6:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  80042134bd:	00 00 00 
  80042134c0:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  80042134c7:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  80042134ce:	00 00 00 
  80042134d1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042134d5:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  80042134dc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042134e0:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042134e4:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  80042134eb:	00 00 00 
  80042134ee:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
			debug_address += sh->sh_size;
  80042134f5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042134f9:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042134fd:	48 01 45 f8          	add    %rax,-0x8(%rbp)
	Elf *ehdr = (Elf *)elf;
	uintptr_t debug_address = USTABDATA;
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
	Secthdr* esh = sh + ehdr->e_shnum;
	for(;sh < esh; sh++) {
  8004213501:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  8004213506:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421350a:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800421350e:	0f 82 a7 fd ff ff    	jb     80042132bb <find_debug_sections+0x6e>
			section_info[DEBUG_STR].ds_size = sh->sh_size;
			debug_address += sh->sh_size;
		}
	}

}
  8004213514:	c9                   	leaveq 
  8004213515:	c3                   	retq   

0000008004213516 <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  8004213516:	55                   	push   %rbp
  8004213517:	48 89 e5             	mov    %rsp,%rbp
  800421351a:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  8004213521:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  8004213528:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
	Secthdr* secthdr_ptr[20] = {0};
  800421352f:	48 8d b5 c0 fe ff ff 	lea    -0x140(%rbp),%rsi
  8004213536:	b8 00 00 00 00       	mov    $0x0,%eax
  800421353b:	ba 14 00 00 00       	mov    $0x14,%edx
  8004213540:	48 89 f7             	mov    %rsi,%rdi
  8004213543:	48 89 d1             	mov    %rdx,%rcx
  8004213546:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  8004213549:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  8004213550:	00 
  8004213551:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213555:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  800421355c:	48 01 d0             	add    %rdx,%rax
  800421355f:	48 83 e8 01          	sub    $0x1,%rax
  8004213563:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004213567:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421356b:	ba 00 00 00 00       	mov    $0x0,%edx
  8004213570:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004213574:	48 89 d0             	mov    %rdx,%rax
  8004213577:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421357b:	48 29 c2             	sub    %rax,%rdx
  800421357e:	48 89 d0             	mov    %rdx,%rax
  8004213581:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	uint64_t kvoffset = 0;
  8004213585:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  800421358c:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  8004213590:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213594:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	char * secthdr = NULL;
  8004213598:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  800421359f:	00 
	uint64_t offset;
	if(elfhdr == KELFHDR)
  80042135a0:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  80042135a7:	00 00 00 
  80042135aa:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  80042135b1:	75 11                	jne    80042135c4 <read_section_headers+0xae>
		offset = ((Elf*)elfhdr)->e_shoff;
  80042135b3:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042135ba:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042135be:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042135c2:	eb 26                	jmp    80042135ea <read_section_headers+0xd4>
	else
		offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  80042135c4:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042135cb:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042135cf:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042135d6:	48 01 c2             	add    %rax,%rdx
  80042135d9:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  80042135e0:	ff ff ff 
  80042135e3:	48 01 d0             	add    %rdx,%rax
  80042135e6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  80042135ea:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042135f1:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  80042135f5:	0f b7 c0             	movzwl %ax,%eax
  80042135f8:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  80042135fb:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004213602:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  8004213606:	0f b7 c0             	movzwl %ax,%eax
  8004213609:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  800421360c:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004213613:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  8004213617:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421361a:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  800421361e:	48 63 f0             	movslq %eax,%rsi
  8004213621:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213625:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421362c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213630:	48 89 c7             	mov    %rax,%rdi
  8004213633:	48 b8 55 3c 21 04 80 	movabs $0x8004213c55,%rax
  800421363a:	00 00 00 
  800421363d:	ff d0                	callq  *%rax
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  800421363f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213643:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004213647:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421364b:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004213651:	48 89 c2             	mov    %rax,%rdx
  8004213654:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213658:	48 29 d0             	sub    %rdx,%rax
  800421365b:	48 89 c2             	mov    %rax,%rdx
  800421365e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213662:	48 01 d0             	add    %rdx,%rax
  8004213665:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  8004213669:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004213670:	eb 24                	jmp    8004213696 <read_section_headers+0x180>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  8004213672:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213675:	48 98                	cltq   
  8004213677:	48 c1 e0 06          	shl    $0x6,%rax
  800421367b:	48 89 c2             	mov    %rax,%rdx
  800421367e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213682:	48 01 c2             	add    %rax,%rdx
  8004213685:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213688:	48 98                	cltq   
  800421368a:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  8004213691:	ff 
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
	for (i = 0; i < numSectionHeaders; i++)
  8004213692:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004213696:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213699:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  800421369c:	7c d4                	jl     8004213672 <read_section_headers+0x15c>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  800421369e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042136a2:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80042136a6:	0f b7 c0             	movzwl %ax,%eax
  80042136a9:	48 98                	cltq   
  80042136ab:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042136b2:	ff 
  80042136b3:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  80042136b7:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042136be:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  80042136c2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042136c6:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042136ca:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042136ce:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042136d2:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  80042136d9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042136dd:	48 01 c8             	add    %rcx,%rax
  80042136e0:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042136e7:	48 89 c7             	mov    %rax,%rdi
  80042136ea:	48 b8 55 3c 21 04 80 	movabs $0x8004213c55,%rax
  80042136f1:	00 00 00 
  80042136f4:	ff d0                	callq  *%rax
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  80042136f6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042136fa:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042136fe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004213702:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213706:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  800421370a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421370e:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004213714:	48 29 c2             	sub    %rax,%rdx
  8004213717:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421371b:	48 01 c2             	add    %rax,%rdx
  800421371e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213722:	48 01 d0             	add    %rdx,%rax
  8004213725:	48 89 45 90          	mov    %rax,-0x70(%rbp)

	for (i = 0; i < numSectionHeaders; i++)
  8004213729:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004213730:	e9 04 05 00 00       	jmpq   8004213c39 <read_section_headers+0x723>
	{
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  8004213735:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213738:	48 98                	cltq   
  800421373a:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004213741:	ff 
  8004213742:	8b 00                	mov    (%rax),%eax
  8004213744:	89 c2                	mov    %eax,%edx
  8004213746:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421374a:	48 01 d0             	add    %rdx,%rax
  800421374d:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		assert(kvoffset % SECTSIZE == 0);
  8004213751:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004213758:	25 ff 01 00 00       	and    $0x1ff,%eax
  800421375d:	48 85 c0             	test   %rax,%rax
  8004213760:	74 35                	je     8004213797 <read_section_headers+0x281>
  8004213762:	48 b9 66 7f 21 04 80 	movabs $0x8004217f66,%rcx
  8004213769:	00 00 00 
  800421376c:	48 ba 7f 7f 21 04 80 	movabs $0x8004217f7f,%rdx
  8004213773:	00 00 00 
  8004213776:	be 86 00 00 00       	mov    $0x86,%esi
  800421377b:	48 bf 94 7f 21 04 80 	movabs $0x8004217f94,%rdi
  8004213782:	00 00 00 
  8004213785:	b8 00 00 00 00       	mov    $0x0,%eax
  800421378a:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004213791:	00 00 00 
  8004213794:	41 ff d0             	callq  *%r8
		temp = kvoffset;
  8004213797:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  800421379e:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
  80042137a2:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042137a6:	48 be 2b 7f 21 04 80 	movabs $0x8004217f2b,%rsi
  80042137ad:	00 00 00 
  80042137b0:	48 89 c7             	mov    %rax,%rdi
  80042137b3:	48 b8 bf d9 20 04 80 	movabs $0x800420d9bf,%rax
  80042137ba:	00 00 00 
  80042137bd:	ff d0                	callq  *%rax
  80042137bf:	85 c0                	test   %eax,%eax
  80042137c1:	0f 85 d8 00 00 00    	jne    800421389f <read_section_headers+0x389>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042137c7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042137ca:	48 98                	cltq   
  80042137cc:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042137d3:	ff 
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042137d4:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042137d8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042137db:	48 98                	cltq   
  80042137dd:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042137e4:	ff 
  80042137e5:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042137e9:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  80042137f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042137f4:	48 01 c8             	add    %rcx,%rax
  80042137f7:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042137fe:	48 89 c7             	mov    %rax,%rdi
  8004213801:	48 b8 55 3c 21 04 80 	movabs $0x8004213c55,%rax
  8004213808:	00 00 00 
  800421380b:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  800421380d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213810:	48 98                	cltq   
  8004213812:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004213819:	ff 
  800421381a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421381e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213821:	48 98                	cltq   
  8004213823:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421382a:	ff 
  800421382b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421382f:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  8004213833:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213837:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  800421383d:	48 29 c2             	sub    %rax,%rdx
  8004213840:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213844:	48 01 c2             	add    %rax,%rdx
  8004213847:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421384b:	48 01 c2             	add    %rax,%rdx
  800421384e:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213855:	00 00 00 
  8004213858:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  800421385c:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213863:	00 00 00 
  8004213866:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421386a:	48 89 c2             	mov    %rax,%rdx
  800421386d:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213874:	00 00 00 
  8004213877:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  800421387b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421387e:	48 98                	cltq   
  8004213880:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004213887:	ff 
  8004213888:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421388c:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213893:	00 00 00 
  8004213896:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421389a:	e9 96 03 00 00       	jmpq   8004213c35 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_abbrev"))
  800421389f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042138a3:	48 be 37 7f 21 04 80 	movabs $0x8004217f37,%rsi
  80042138aa:	00 00 00 
  80042138ad:	48 89 c7             	mov    %rax,%rdi
  80042138b0:	48 b8 bf d9 20 04 80 	movabs $0x800420d9bf,%rax
  80042138b7:	00 00 00 
  80042138ba:	ff d0                	callq  *%rax
  80042138bc:	85 c0                	test   %eax,%eax
  80042138be:	0f 85 de 00 00 00    	jne    80042139a2 <read_section_headers+0x48c>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042138c4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042138c7:	48 98                	cltq   
  80042138c9:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042138d0:	ff 
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_abbrev"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042138d1:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042138d5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042138d8:	48 98                	cltq   
  80042138da:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042138e1:	ff 
  80042138e2:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042138e6:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  80042138ed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042138f1:	48 01 c8             	add    %rcx,%rax
  80042138f4:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042138fb:	48 89 c7             	mov    %rax,%rdi
  80042138fe:	48 b8 55 3c 21 04 80 	movabs $0x8004213c55,%rax
  8004213905:	00 00 00 
  8004213908:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  800421390a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421390d:	48 98                	cltq   
  800421390f:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004213916:	ff 
  8004213917:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421391b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421391e:	48 98                	cltq   
  8004213920:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004213927:	ff 
  8004213928:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421392c:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004213933:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421393a:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004213940:	48 29 c2             	sub    %rax,%rdx
  8004213943:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213947:	48 01 c2             	add    %rax,%rdx
  800421394a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421394e:	48 01 c2             	add    %rax,%rdx
  8004213951:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213958:	00 00 00 
  800421395b:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  800421395f:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213966:	00 00 00 
  8004213969:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421396d:	48 89 c2             	mov    %rax,%rdx
  8004213970:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213977:	00 00 00 
  800421397a:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  800421397e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213981:	48 98                	cltq   
  8004213983:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421398a:	ff 
  800421398b:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421398f:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213996:	00 00 00 
  8004213999:	48 89 50 38          	mov    %rdx,0x38(%rax)
  800421399d:	e9 93 02 00 00       	jmpq   8004213c35 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_line"))
  80042139a2:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042139a6:	48 be 4f 7f 21 04 80 	movabs $0x8004217f4f,%rsi
  80042139ad:	00 00 00 
  80042139b0:	48 89 c7             	mov    %rax,%rdi
  80042139b3:	48 b8 bf d9 20 04 80 	movabs $0x800420d9bf,%rax
  80042139ba:	00 00 00 
  80042139bd:	ff d0                	callq  *%rax
  80042139bf:	85 c0                	test   %eax,%eax
  80042139c1:	0f 85 de 00 00 00    	jne    8004213aa5 <read_section_headers+0x58f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042139c7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042139ca:	48 98                	cltq   
  80042139cc:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042139d3:	ff 
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_line"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042139d4:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042139d8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042139db:	48 98                	cltq   
  80042139dd:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042139e4:	ff 
  80042139e5:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042139e9:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  80042139f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042139f4:	48 01 c8             	add    %rcx,%rax
  80042139f7:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042139fe:	48 89 c7             	mov    %rax,%rdi
  8004213a01:	48 b8 55 3c 21 04 80 	movabs $0x8004213c55,%rax
  8004213a08:	00 00 00 
  8004213a0b:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004213a0d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213a10:	48 98                	cltq   
  8004213a12:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004213a19:	ff 
  8004213a1a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213a1e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213a21:	48 98                	cltq   
  8004213a23:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004213a2a:	ff 
  8004213a2b:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213a2f:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004213a36:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004213a3d:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004213a43:	48 29 c2             	sub    %rax,%rdx
  8004213a46:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213a4a:	48 01 c2             	add    %rax,%rdx
  8004213a4d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213a51:	48 01 c2             	add    %rax,%rdx
  8004213a54:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213a5b:	00 00 00 
  8004213a5e:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  8004213a62:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213a69:	00 00 00 
  8004213a6c:	48 8b 40 68          	mov    0x68(%rax),%rax
  8004213a70:	48 89 c2             	mov    %rax,%rdx
  8004213a73:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213a7a:	00 00 00 
  8004213a7d:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  8004213a81:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213a84:	48 98                	cltq   
  8004213a86:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004213a8d:	ff 
  8004213a8e:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004213a92:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213a99:	00 00 00 
  8004213a9c:	48 89 50 78          	mov    %rdx,0x78(%rax)
  8004213aa0:	e9 90 01 00 00       	jmpq   8004213c35 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".eh_frame"))
  8004213aa5:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004213aa9:	48 be 45 7f 21 04 80 	movabs $0x8004217f45,%rsi
  8004213ab0:	00 00 00 
  8004213ab3:	48 89 c7             	mov    %rax,%rdi
  8004213ab6:	48 b8 bf d9 20 04 80 	movabs $0x800420d9bf,%rax
  8004213abd:	00 00 00 
  8004213ac0:	ff d0                	callq  *%rax
  8004213ac2:	85 c0                	test   %eax,%eax
  8004213ac4:	75 65                	jne    8004213b2b <read_section_headers+0x615>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  8004213ac6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213ac9:	48 98                	cltq   
  8004213acb:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004213ad2:	ff 
  8004213ad3:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004213ad7:	48 89 c2             	mov    %rax,%rdx
  8004213ada:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213ae1:	00 00 00 
  8004213ae4:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  8004213ae8:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213aef:	00 00 00 
  8004213af2:	48 8b 40 48          	mov    0x48(%rax),%rax
  8004213af6:	48 89 c2             	mov    %rax,%rdx
  8004213af9:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213b00:	00 00 00 
  8004213b03:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  8004213b07:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213b0a:	48 98                	cltq   
  8004213b0c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004213b13:	ff 
  8004213b14:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004213b18:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213b1f:	00 00 00 
  8004213b22:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004213b26:	e9 0a 01 00 00       	jmpq   8004213c35 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_str"))
  8004213b2b:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004213b2f:	48 be 5b 7f 21 04 80 	movabs $0x8004217f5b,%rsi
  8004213b36:	00 00 00 
  8004213b39:	48 89 c7             	mov    %rax,%rdi
  8004213b3c:	48 b8 bf d9 20 04 80 	movabs $0x800420d9bf,%rax
  8004213b43:	00 00 00 
  8004213b46:	ff d0                	callq  *%rax
  8004213b48:	85 c0                	test   %eax,%eax
  8004213b4a:	0f 85 e5 00 00 00    	jne    8004213c35 <read_section_headers+0x71f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004213b50:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213b53:	48 98                	cltq   
  8004213b55:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004213b5c:	ff 
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_str"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004213b5d:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213b61:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213b64:	48 98                	cltq   
  8004213b66:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004213b6d:	ff 
  8004213b6e:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004213b72:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004213b79:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213b7d:	48 01 c8             	add    %rcx,%rax
  8004213b80:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004213b87:	48 89 c7             	mov    %rax,%rdi
  8004213b8a:	48 b8 55 3c 21 04 80 	movabs $0x8004213c55,%rax
  8004213b91:	00 00 00 
  8004213b94:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004213b96:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213b99:	48 98                	cltq   
  8004213b9b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004213ba2:	ff 
  8004213ba3:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213ba7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213baa:	48 98                	cltq   
  8004213bac:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004213bb3:	ff 
  8004213bb4:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213bb8:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  8004213bbf:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004213bc6:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004213bcc:	48 29 c2             	sub    %rax,%rdx
  8004213bcf:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213bd3:	48 01 c2             	add    %rax,%rdx
  8004213bd6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213bda:	48 01 c2             	add    %rax,%rdx
  8004213bdd:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213be4:	00 00 00 
  8004213be7:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  8004213bee:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213bf5:	00 00 00 
  8004213bf8:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004213bff:	48 89 c2             	mov    %rax,%rdx
  8004213c02:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213c09:	00 00 00 
  8004213c0c:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  8004213c13:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213c16:	48 98                	cltq   
  8004213c18:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004213c1f:	ff 
  8004213c20:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004213c24:	48 b8 80 a8 22 04 80 	movabs $0x800422a880,%rax
  8004213c2b:	00 00 00 
  8004213c2e:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	temp = kvoffset;
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	

	for (i = 0; i < numSectionHeaders; i++)
  8004213c35:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004213c39:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213c3c:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004213c3f:	0f 8c f0 fa ff ff    	jl     8004213735 <read_section_headers+0x21f>
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
		}
	}
	
	return ((uintptr_t)kvbase + kvoffset);
  8004213c45:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004213c49:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004213c50:	48 01 d0             	add    %rdx,%rax
}
  8004213c53:	c9                   	leaveq 
  8004213c54:	c3                   	retq   

0000008004213c55 <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  8004213c55:	55                   	push   %rbp
  8004213c56:	48 89 e5             	mov    %rsp,%rbp
  8004213c59:	48 83 ec 30          	sub    $0x30,%rsp
  8004213c5d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004213c61:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004213c65:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004213c69:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  8004213c6d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213c71:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  8004213c75:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213c79:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213c7d:	48 01 d0             	add    %rdx,%rax
  8004213c80:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  8004213c84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c88:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004213c8d:	48 85 c0             	test   %rax,%rax
  8004213c90:	74 35                	je     8004213cc7 <readseg+0x72>
  8004213c92:	48 b9 a2 7f 21 04 80 	movabs $0x8004217fa2,%rcx
  8004213c99:	00 00 00 
  8004213c9c:	48 ba 7f 7f 21 04 80 	movabs $0x8004217f7f,%rdx
  8004213ca3:	00 00 00 
  8004213ca6:	be c0 00 00 00       	mov    $0xc0,%esi
  8004213cab:	48 bf 94 7f 21 04 80 	movabs $0x8004217f94,%rdi
  8004213cb2:	00 00 00 
  8004213cb5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213cba:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004213cc1:	00 00 00 
  8004213cc4:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  8004213cc7:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  8004213cce:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  8004213ccf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213cd3:	48 c1 e8 09          	shr    $0x9,%rax
  8004213cd7:	48 83 c0 01          	add    $0x1,%rax
  8004213cdb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004213cdf:	eb 3c                	jmp    8004213d1d <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  8004213ce1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ce5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004213ce9:	48 89 d6             	mov    %rdx,%rsi
  8004213cec:	48 89 c7             	mov    %rax,%rdi
  8004213cef:	48 b8 e5 3d 21 04 80 	movabs $0x8004213de5,%rax
  8004213cf6:	00 00 00 
  8004213cf9:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  8004213cfb:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  8004213d02:	00 
		*kvoffset += SECTSIZE;
  8004213d03:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213d07:	48 8b 00             	mov    (%rax),%rax
  8004213d0a:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004213d11:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213d15:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  8004213d18:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004213d1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d21:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004213d25:	72 ba                	jb     8004213ce1 <readseg+0x8c>
		pa += SECTSIZE;
		*kvoffset += SECTSIZE;
		offset++;
	}

	if(((orgoff % SECTSIZE) + count) > SECTSIZE)
  8004213d27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213d2b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004213d30:	48 89 c2             	mov    %rax,%rdx
  8004213d33:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213d37:	48 01 d0             	add    %rdx,%rax
  8004213d3a:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  8004213d40:	76 2f                	jbe    8004213d71 <readseg+0x11c>
	{
		readsect((uint8_t*) pa, offset);
  8004213d42:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d46:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004213d4a:	48 89 d6             	mov    %rdx,%rsi
  8004213d4d:	48 89 c7             	mov    %rax,%rdi
  8004213d50:	48 b8 e5 3d 21 04 80 	movabs $0x8004213de5,%rax
  8004213d57:	00 00 00 
  8004213d5a:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  8004213d5c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213d60:	48 8b 00             	mov    (%rax),%rax
  8004213d63:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004213d6a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213d6e:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  8004213d71:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213d75:	48 8b 00             	mov    (%rax),%rax
  8004213d78:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004213d7d:	48 85 c0             	test   %rax,%rax
  8004213d80:	74 35                	je     8004213db7 <readseg+0x162>
  8004213d82:	48 b9 b5 7f 21 04 80 	movabs $0x8004217fb5,%rcx
  8004213d89:	00 00 00 
  8004213d8c:	48 ba 7f 7f 21 04 80 	movabs $0x8004217f7f,%rdx
  8004213d93:	00 00 00 
  8004213d96:	be d6 00 00 00       	mov    $0xd6,%esi
  8004213d9b:	48 bf 94 7f 21 04 80 	movabs $0x8004217f94,%rdi
  8004213da2:	00 00 00 
  8004213da5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213daa:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004213db1:	00 00 00 
  8004213db4:	41 ff d0             	callq  *%r8
}
  8004213db7:	c9                   	leaveq 
  8004213db8:	c3                   	retq   

0000008004213db9 <waitdisk>:

void
waitdisk(void)
{
  8004213db9:	55                   	push   %rbp
  8004213dba:	48 89 e5             	mov    %rsp,%rbp
  8004213dbd:	48 83 ec 10          	sub    $0x10,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  8004213dc1:	90                   	nop
  8004213dc2:	c7 45 fc f7 01 00 00 	movl   $0x1f7,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004213dc9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213dcc:	89 c2                	mov    %eax,%edx
  8004213dce:	ec                   	in     (%dx),%al
  8004213dcf:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  8004213dd2:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004213dd6:	0f b6 c0             	movzbl %al,%eax
  8004213dd9:	25 c0 00 00 00       	and    $0xc0,%eax
  8004213dde:	83 f8 40             	cmp    $0x40,%eax
  8004213de1:	75 df                	jne    8004213dc2 <waitdisk+0x9>
		/* do nothing */;
}
  8004213de3:	c9                   	leaveq 
  8004213de4:	c3                   	retq   

0000008004213de5 <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  8004213de5:	55                   	push   %rbp
  8004213de6:	48 89 e5             	mov    %rsp,%rbp
  8004213de9:	48 83 ec 60          	sub    $0x60,%rsp
  8004213ded:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004213df1:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	// wait for disk to be ready
	waitdisk();
  8004213df5:	48 b8 b9 3d 21 04 80 	movabs $0x8004213db9,%rax
  8004213dfc:	00 00 00 
  8004213dff:	ff d0                	callq  *%rax
  8004213e01:	c7 45 fc f2 01 00 00 	movl   $0x1f2,-0x4(%rbp)
  8004213e08:	c6 45 fb 01          	movb   $0x1,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004213e0c:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004213e10:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004213e13:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  8004213e14:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213e18:	0f b6 c0             	movzbl %al,%eax
  8004213e1b:	c7 45 f4 f3 01 00 00 	movl   $0x1f3,-0xc(%rbp)
  8004213e22:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004213e25:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004213e29:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004213e2c:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  8004213e2d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213e31:	48 c1 e8 08          	shr    $0x8,%rax
  8004213e35:	0f b6 c0             	movzbl %al,%eax
  8004213e38:	c7 45 ec f4 01 00 00 	movl   $0x1f4,-0x14(%rbp)
  8004213e3f:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004213e42:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004213e46:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004213e49:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  8004213e4a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213e4e:	48 c1 e8 10          	shr    $0x10,%rax
  8004213e52:	0f b6 c0             	movzbl %al,%eax
  8004213e55:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%rbp)
  8004213e5c:	88 45 e3             	mov    %al,-0x1d(%rbp)
  8004213e5f:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004213e63:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004213e66:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  8004213e67:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213e6b:	48 c1 e8 18          	shr    $0x18,%rax
  8004213e6f:	83 c8 e0             	or     $0xffffffe0,%eax
  8004213e72:	0f b6 c0             	movzbl %al,%eax
  8004213e75:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%rbp)
  8004213e7c:	88 45 db             	mov    %al,-0x25(%rbp)
  8004213e7f:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004213e83:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004213e86:	ee                   	out    %al,(%dx)
  8004213e87:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%rbp)
  8004213e8e:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
  8004213e92:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004213e96:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004213e99:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  8004213e9a:	48 b8 b9 3d 21 04 80 	movabs $0x8004213db9,%rax
  8004213ea1:	00 00 00 
  8004213ea4:	ff d0                	callq  *%rax
  8004213ea6:	c7 45 cc f0 01 00 00 	movl   $0x1f0,-0x34(%rbp)
  8004213ead:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004213eb1:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004213eb5:	c7 45 bc 80 00 00 00 	movl   $0x80,-0x44(%rbp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
  8004213ebc:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004213ebf:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004213ec3:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004213ec6:	48 89 ce             	mov    %rcx,%rsi
  8004213ec9:	48 89 f7             	mov    %rsi,%rdi
  8004213ecc:	89 c1                	mov    %eax,%ecx
  8004213ece:	fc                   	cld    
  8004213ecf:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  8004213ed1:	89 c8                	mov    %ecx,%eax
  8004213ed3:	48 89 fe             	mov    %rdi,%rsi
  8004213ed6:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004213eda:	89 45 bc             	mov    %eax,-0x44(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  8004213edd:	c9                   	leaveq 
  8004213ede:	c3                   	retq   
  8004213edf:	90                   	nop

0000008004213ee0 <mpentry_start>:
.set pml4, pml4phys

.code16           
.globl mpentry_start
mpentry_start:
	cli
  8004213ee0:	fa                   	cli    
	xorw    %ax, %ax
  8004213ee1:	31 c0                	xor    %eax,%eax
	movw    %ax, %ds
  8004213ee3:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004213ee5:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004213ee7:	8e d0                	mov    %eax,%ss
	
	
	lgdt    MPBOOTPHYS(gdt32desc)   // load 32 bit global descritor table
  8004213ee9:	0f 01 16             	lgdt   (%rsi)
  8004213eec:	e0 70                	loopne 8004213f5e <start64+0x10>
	movl    %cr0, %eax
  8004213eee:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004213ef1:	66 83 c8 01          	or     $0x1,%ax
	movl    %eax, %cr0
  8004213ef5:	0f 22 c0             	mov    %rax,%cr0
	ljmp	$(PROT_MODE_CSEG),$(MPBOOTPHYS(start32))
  8004213ef8:	ea                   	(bad)  
  8004213ef9:	1d 70 08 00 66       	sbb    $0x66000870,%eax

0000008004213efd <start32>:

.code32
start32:
	
	movw    $(PROT_MODE_DSEG), %ax
  8004213efd:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004213f01:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004213f03:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004213f05:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004213f07:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004213f0b:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004213f0d:	8e e8                	mov    %eax,%gs

	movl $CR4_PAE,%eax
  8004213f0f:	b8 20 00 00 00       	mov    $0x20,%eax

	movl %eax,%cr4
  8004213f14:	0f 22 e0             	mov    %rax,%cr4
	
	lgdt    MPBOOTPHYS(gdtdesc)
  8004213f17:	0f 01 15 c0 70 00 00 	lgdt   0x70c0(%rip)        # 421afde <_start+0x401afd2>
	movl    %cr0, %eax
  8004213f1e:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004213f21:	83 c8 01             	or     $0x1,%eax
	movl    %eax, %cr0
  8004213f24:	0f 22 c0             	mov    %rax,%cr0
	
	# Set up initial page table. We cannot use kern_pgdir yet because
	# we are still running at a low EIP.
	movl    $pml4, %eax
  8004213f27:	b8 00 20 10 00       	mov    $0x102000,%eax
	movl    %eax, %cr3
  8004213f2c:	0f 22 d8             	mov    %rax,%cr3
	
	# enable the long mode in MSR
	movl $EFER_MSR,%ecx
  8004213f2f:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  8004213f34:	0f 32                	rdmsr  
	btsl $EFER_LME,%eax
  8004213f36:	0f ba e8 08          	bts    $0x8,%eax
	wrmsr
  8004213f3a:	0f 30                	wrmsr  
	
	# Turn on paging.
	movl    %cr0, %eax
  8004213f3c:	0f 20 c0             	mov    %cr0,%rax
	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  8004213f3f:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl    %eax, %cr0
  8004213f44:	0f 22 c0             	mov    %rax,%cr0
	

	ljmpl   $(LONG_MODE_CSEG), $(MPBOOTPHYS(start64))
  8004213f47:	ea                   	(bad)  
  8004213f48:	6e                   	outsb  %ds:(%rsi),(%dx)
  8004213f49:	70 00                	jo     8004213f4b <start32+0x4e>
  8004213f4b:	00 08                	add    %cl,(%rax)
	...

0000008004213f4e <start64>:

.code64
start64:
	movw    $(LONG_MODE_DSEG), %ax
  8004213f4e:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004213f52:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004213f54:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004213f56:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004213f58:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004213f5c:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004213f5e:	8e e8                	mov    %eax,%gs

	# Switch to the per-cpu stack allocated in boot_aps()
	movabs    mpentry_kstack, %rax
  8004213f60:	48 a1 18 e7 49 04 80 	movabs 0x800449e718,%rax
  8004213f67:	00 00 00 
	movq    %rax,%rsp
  8004213f6a:	48 89 c4             	mov    %rax,%rsp
	movq    $0x0, %rbp       # nuke frame pointer
  8004213f6d:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movabs    $mp_main, %rax
  8004213f74:	48 b8 e8 03 20 04 80 	movabs $0x80042003e8,%rax
  8004213f7b:	00 00 00 
	call    *%rax
  8004213f7e:	ff d0                	callq  *%rax

0000008004213f80 <spin>:

	# If mp_main returns (it shouldn't), loop.
spin:
	jmp     spin
  8004213f80:	eb fe                	jmp    8004213f80 <spin>
  8004213f82:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000008004213f88 <gdt>:
	...
  8004213f90:	ff                   	(bad)  
  8004213f91:	ff 00                	incl   (%rax)
  8004213f93:	00 00                	add    %al,(%rax)
  8004213f95:	9a                   	(bad)  
  8004213f96:	af                   	scas   %es:(%rdi),%eax
  8004213f97:	00 ff                	add    %bh,%bh
  8004213f99:	ff 00                	incl   (%rax)
  8004213f9b:	00 00                	add    %al,(%rax)
  8004213f9d:	92                   	xchg   %eax,%edx
  8004213f9e:	af                   	scas   %es:(%rdi),%eax
	...

0000008004213fa0 <gdtdesc>:
  8004213fa0:	17                   	(bad)  
  8004213fa1:	00 a8 70 00 00 66    	add    %ch,0x66000070(%rax)
  8004213fa7:	90                   	nop

0000008004213fa8 <gdt32>:
	...
  8004213fb0:	ff                   	(bad)  
  8004213fb1:	ff 00                	incl   (%rax)
  8004213fb3:	00 00                	add    %al,(%rax)
  8004213fb5:	9a                   	(bad)  
  8004213fb6:	cf                   	iret   
  8004213fb7:	00 ff                	add    %bh,%bh
  8004213fb9:	ff 00                	incl   (%rax)
  8004213fbb:	00 00                	add    %al,(%rax)
  8004213fbd:	92                   	xchg   %eax,%edx
  8004213fbe:	cf                   	iret   
	...

0000008004213fc0 <gdt32desc>:
  8004213fc0:	17                   	(bad)  
  8004213fc1:	00 c8                	add    %cl,%al
  8004213fc3:	70 00                	jo     8004213fc5 <gdt32desc+0x5>
	...

0000008004213fc6 <mpentry_end>:
	.long   MPBOOTPHYS(gdt32)			# address gdt


.globl mpentry_end
mpentry_end:
	nop
  8004213fc6:	90                   	nop

0000008004213fc7 <sum>:
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source

static uint8_t
sum(void *addr, int len)
{
  8004213fc7:	55                   	push   %rbp
  8004213fc8:	48 89 e5             	mov    %rsp,%rbp
  8004213fcb:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004213fcf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004213fd3:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int i, sum;

	sum = 0;
  8004213fd6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < len; i++)
  8004213fdd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004213fe4:	eb 1a                	jmp    8004214000 <sum+0x39>
		sum += ((uint8_t *)addr)[i];
  8004213fe6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213fe9:	48 63 d0             	movslq %eax,%rdx
  8004213fec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ff0:	48 01 d0             	add    %rdx,%rax
  8004213ff3:	0f b6 00             	movzbl (%rax),%eax
  8004213ff6:	0f b6 c0             	movzbl %al,%eax
  8004213ff9:	01 45 f8             	add    %eax,-0x8(%rbp)
sum(void *addr, int len)
{
	int i, sum;

	sum = 0;
	for (i = 0; i < len; i++)
  8004213ffc:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004214000:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004214003:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8004214006:	7c de                	jl     8004213fe6 <sum+0x1f>
		sum += ((uint8_t *)addr)[i];
	return sum;
  8004214008:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  800421400b:	c9                   	leaveq 
  800421400c:	c3                   	retq   

000000800421400d <mpsearch1>:

// Look for an MP structure in the len bytes at physical address addr.
static struct mp *
mpsearch1(physaddr_t a, int len)
{
  800421400d:	55                   	push   %rbp
  800421400e:	48 89 e5             	mov    %rsp,%rbp
  8004214011:	48 83 ec 40          	sub    $0x40,%rsp
  8004214015:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004214019:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	struct mp *mp = KADDR(a), *end = KADDR(a + len);
  800421401c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214020:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004214024:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214028:	48 c1 e8 0c          	shr    $0xc,%rax
  800421402c:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800421402f:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004214032:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004214039:	00 00 00 
  800421403c:	48 8b 00             	mov    (%rax),%rax
  800421403f:	48 39 c2             	cmp    %rax,%rdx
  8004214042:	72 32                	jb     8004214076 <mpsearch1+0x69>
  8004214044:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214048:	48 89 c1             	mov    %rax,%rcx
  800421404b:	48 ba d0 7f 21 04 80 	movabs $0x8004217fd0,%rdx
  8004214052:	00 00 00 
  8004214055:	be 58 00 00 00       	mov    $0x58,%esi
  800421405a:	48 bf f3 7f 21 04 80 	movabs $0x8004217ff3,%rdi
  8004214061:	00 00 00 
  8004214064:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214069:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004214070:	00 00 00 
  8004214073:	41 ff d0             	callq  *%r8
  8004214076:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421407d:	00 00 00 
  8004214080:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214084:	48 01 d0             	add    %rdx,%rax
  8004214087:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421408b:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421408e:	48 63 d0             	movslq %eax,%rdx
  8004214091:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214095:	48 01 d0             	add    %rdx,%rax
  8004214098:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800421409c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042140a0:	48 c1 e8 0c          	shr    $0xc,%rax
  80042140a4:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042140a7:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042140aa:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  80042140b1:	00 00 00 
  80042140b4:	48 8b 00             	mov    (%rax),%rax
  80042140b7:	48 39 c2             	cmp    %rax,%rdx
  80042140ba:	72 32                	jb     80042140ee <mpsearch1+0xe1>
  80042140bc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042140c0:	48 89 c1             	mov    %rax,%rcx
  80042140c3:	48 ba d0 7f 21 04 80 	movabs $0x8004217fd0,%rdx
  80042140ca:	00 00 00 
  80042140cd:	be 58 00 00 00       	mov    $0x58,%esi
  80042140d2:	48 bf f3 7f 21 04 80 	movabs $0x8004217ff3,%rdi
  80042140d9:	00 00 00 
  80042140dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042140e1:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042140e8:	00 00 00 
  80042140eb:	41 ff d0             	callq  *%r8
  80042140ee:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042140f5:	00 00 00 
  80042140f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042140fc:	48 01 d0             	add    %rdx,%rax
  80042140ff:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	for (; mp < end; mp++)
  8004214103:	eb 4d                	jmp    8004214152 <mpsearch1+0x145>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  8004214105:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214109:	ba 04 00 00 00       	mov    $0x4,%edx
  800421410e:	48 be 03 80 21 04 80 	movabs $0x8004218003,%rsi
  8004214115:	00 00 00 
  8004214118:	48 89 c7             	mov    %rax,%rdi
  800421411b:	48 b8 cc dc 20 04 80 	movabs $0x800420dccc,%rax
  8004214122:	00 00 00 
  8004214125:	ff d0                	callq  *%rax
  8004214127:	85 c0                	test   %eax,%eax
  8004214129:	75 22                	jne    800421414d <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
  800421412b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421412f:	be 10 00 00 00       	mov    $0x10,%esi
  8004214134:	48 89 c7             	mov    %rax,%rdi
  8004214137:	48 b8 c7 3f 21 04 80 	movabs $0x8004213fc7,%rax
  800421413e:	00 00 00 
  8004214141:	ff d0                	callq  *%rax
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  8004214143:	84 c0                	test   %al,%al
  8004214145:	75 06                	jne    800421414d <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
  8004214147:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421414b:	eb 14                	jmp    8004214161 <mpsearch1+0x154>
static struct mp *
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
  800421414d:	48 83 45 f8 10       	addq   $0x10,-0x8(%rbp)
  8004214152:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214156:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421415a:	72 a9                	jb     8004214105 <mpsearch1+0xf8>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
	return NULL;
  800421415c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214161:	c9                   	leaveq 
  8004214162:	c3                   	retq   

0000008004214163 <mpsearch>:
// 1) in the first KB of the EBDA;
// 2) if there is no EBDA, in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp *
mpsearch(void)
{
  8004214163:	55                   	push   %rbp
  8004214164:	48 89 e5             	mov    %rsp,%rbp
  8004214167:	48 83 ec 30          	sub    $0x30,%rsp
	struct mp *mp;

	//static_assert(sizeof(*mp) == 32);

	// The BIOS data area lives in 16-bit segment 0x40.
	bda = (uint8_t *) KADDR(0x40 << 4);
  800421416b:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  8004214172:	00 
  8004214173:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214177:	48 c1 e8 0c          	shr    $0xc,%rax
  800421417b:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800421417e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004214181:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004214188:	00 00 00 
  800421418b:	48 8b 00             	mov    (%rax),%rax
  800421418e:	48 39 c2             	cmp    %rax,%rdx
  8004214191:	72 32                	jb     80042141c5 <mpsearch+0x62>
  8004214193:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214197:	48 89 c1             	mov    %rax,%rcx
  800421419a:	48 ba d0 7f 21 04 80 	movabs $0x8004217fd0,%rdx
  80042141a1:	00 00 00 
  80042141a4:	be 70 00 00 00       	mov    $0x70,%esi
  80042141a9:	48 bf f3 7f 21 04 80 	movabs $0x8004217ff3,%rdi
  80042141b0:	00 00 00 
  80042141b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042141b8:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  80042141bf:	00 00 00 
  80042141c2:	41 ff d0             	callq  *%r8
  80042141c5:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042141cc:	00 00 00 
  80042141cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042141d3:	48 01 d0             	add    %rdx,%rax
  80042141d6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// [MP 4] The 16-bit segment of the EBDA is in the two bytes
	// starting at byte 0x0E of the BDA.  0 if not present.
	if ((p = *(uint16_t *) (bda + 0x0E))) {
  80042141da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042141de:	48 83 c0 0e          	add    $0xe,%rax
  80042141e2:	0f b7 00             	movzwl (%rax),%eax
  80042141e5:	0f b7 c0             	movzwl %ax,%eax
  80042141e8:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  80042141eb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042141ef:	74 2c                	je     800421421d <mpsearch+0xba>
		p <<= 4;	// Translate from segment to PA
  80042141f1:	c1 65 e4 04          	shll   $0x4,-0x1c(%rbp)
		if ((mp = mpsearch1(p, 1024)))
  80042141f5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042141f8:	be 00 04 00 00       	mov    $0x400,%esi
  80042141fd:	48 89 c7             	mov    %rax,%rdi
  8004214200:	48 b8 0d 40 21 04 80 	movabs $0x800421400d,%rax
  8004214207:	00 00 00 
  800421420a:	ff d0                	callq  *%rax
  800421420c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004214210:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004214215:	74 49                	je     8004214260 <mpsearch+0xfd>
			return mp;
  8004214217:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421421b:	eb 59                	jmp    8004214276 <mpsearch+0x113>
	} else {
		// The size of base memory, in KB is in the two bytes
		// starting at 0x13 of the BDA.
		p = *(uint16_t *) (bda + 0x13) * 1024;
  800421421d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214221:	48 83 c0 13          	add    $0x13,%rax
  8004214225:	0f b7 00             	movzwl (%rax),%eax
  8004214228:	0f b7 c0             	movzwl %ax,%eax
  800421422b:	c1 e0 0a             	shl    $0xa,%eax
  800421422e:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if ((mp = mpsearch1(p - 1024, 1024)))
  8004214231:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004214234:	2d 00 04 00 00       	sub    $0x400,%eax
  8004214239:	89 c0                	mov    %eax,%eax
  800421423b:	be 00 04 00 00       	mov    $0x400,%esi
  8004214240:	48 89 c7             	mov    %rax,%rdi
  8004214243:	48 b8 0d 40 21 04 80 	movabs $0x800421400d,%rax
  800421424a:	00 00 00 
  800421424d:	ff d0                	callq  *%rax
  800421424f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004214253:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004214258:	74 06                	je     8004214260 <mpsearch+0xfd>
			return mp;
  800421425a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421425e:	eb 16                	jmp    8004214276 <mpsearch+0x113>
	}
	return mpsearch1(0xF0000, 0x10000);
  8004214260:	be 00 00 01 00       	mov    $0x10000,%esi
  8004214265:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  800421426a:	48 b8 0d 40 21 04 80 	movabs $0x800421400d,%rax
  8004214271:	00 00 00 
  8004214274:	ff d0                	callq  *%rax
}
  8004214276:	c9                   	leaveq 
  8004214277:	c3                   	retq   

0000008004214278 <mpconfig>:
// Search for an MP configuration table.  For now, don't accept the
// default configurations (physaddr == 0).
// Check for the correct signature, checksum, and version.
static struct mpconf *
mpconfig(struct mp **pmp)
{
  8004214278:	55                   	push   %rbp
  8004214279:	48 89 e5             	mov    %rsp,%rbp
  800421427c:	48 83 ec 30          	sub    $0x30,%rsp
  8004214280:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	struct mpconf *conf;
	struct mp *mp;

	if ((mp = mpsearch()) == 0)
  8004214284:	48 b8 63 41 21 04 80 	movabs $0x8004214163,%rax
  800421428b:	00 00 00 
  800421428e:	ff d0                	callq  *%rax
  8004214290:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004214294:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004214299:	75 0a                	jne    80042142a5 <mpconfig+0x2d>
		return NULL;
  800421429b:	b8 00 00 00 00       	mov    $0x0,%eax
  80042142a0:	e9 f6 01 00 00       	jmpq   800421449b <mpconfig+0x223>
	if (mp->physaddr == 0 || mp->type != 0) {
  80042142a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042142a9:	8b 40 04             	mov    0x4(%rax),%eax
  80042142ac:	85 c0                	test   %eax,%eax
  80042142ae:	74 0c                	je     80042142bc <mpconfig+0x44>
  80042142b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042142b4:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  80042142b8:	84 c0                	test   %al,%al
  80042142ba:	74 25                	je     80042142e1 <mpconfig+0x69>
		cprintf("SMP: Default configurations not implemented\n");
  80042142bc:	48 bf 08 80 21 04 80 	movabs $0x8004218008,%rdi
  80042142c3:	00 00 00 
  80042142c6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042142cb:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042142d2:	00 00 00 
  80042142d5:	ff d2                	callq  *%rdx
		return NULL;
  80042142d7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042142dc:	e9 ba 01 00 00       	jmpq   800421449b <mpconfig+0x223>
	}
	conf = (struct mpconf *) KADDR(mp->physaddr);
  80042142e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042142e5:	8b 40 04             	mov    0x4(%rax),%eax
  80042142e8:	89 c0                	mov    %eax,%eax
  80042142ea:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042142ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042142f2:	48 c1 e8 0c          	shr    $0xc,%rax
  80042142f6:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042142f9:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042142fc:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004214303:	00 00 00 
  8004214306:	48 8b 00             	mov    (%rax),%rax
  8004214309:	48 39 c2             	cmp    %rax,%rdx
  800421430c:	72 32                	jb     8004214340 <mpconfig+0xc8>
  800421430e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214312:	48 89 c1             	mov    %rax,%rcx
  8004214315:	48 ba d0 7f 21 04 80 	movabs $0x8004217fd0,%rdx
  800421431c:	00 00 00 
  800421431f:	be 91 00 00 00       	mov    $0x91,%esi
  8004214324:	48 bf f3 7f 21 04 80 	movabs $0x8004217ff3,%rdi
  800421432b:	00 00 00 
  800421432e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214333:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  800421433a:	00 00 00 
  800421433d:	41 ff d0             	callq  *%r8
  8004214340:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004214347:	00 00 00 
  800421434a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421434e:	48 01 d0             	add    %rdx,%rax
  8004214351:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (memcmp(conf, "PCMP", 4) != 0) {
  8004214355:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214359:	ba 04 00 00 00       	mov    $0x4,%edx
  800421435e:	48 be 35 80 21 04 80 	movabs $0x8004218035,%rsi
  8004214365:	00 00 00 
  8004214368:	48 89 c7             	mov    %rax,%rdi
  800421436b:	48 b8 cc dc 20 04 80 	movabs $0x800420dccc,%rax
  8004214372:	00 00 00 
  8004214375:	ff d0                	callq  *%rax
  8004214377:	85 c0                	test   %eax,%eax
  8004214379:	74 25                	je     80042143a0 <mpconfig+0x128>
		cprintf("SMP: Incorrect MP configuration table signature\n");
  800421437b:	48 bf 40 80 21 04 80 	movabs $0x8004218040,%rdi
  8004214382:	00 00 00 
  8004214385:	b8 00 00 00 00       	mov    $0x0,%eax
  800421438a:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004214391:	00 00 00 
  8004214394:	ff d2                	callq  *%rdx
		return NULL;
  8004214396:	b8 00 00 00 00       	mov    $0x0,%eax
  800421439b:	e9 fb 00 00 00       	jmpq   800421449b <mpconfig+0x223>
	}
	if (sum(conf, conf->length) != 0) {
  80042143a0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042143a4:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  80042143a8:	0f b7 d0             	movzwl %ax,%edx
  80042143ab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042143af:	89 d6                	mov    %edx,%esi
  80042143b1:	48 89 c7             	mov    %rax,%rdi
  80042143b4:	48 b8 c7 3f 21 04 80 	movabs $0x8004213fc7,%rax
  80042143bb:	00 00 00 
  80042143be:	ff d0                	callq  *%rax
  80042143c0:	84 c0                	test   %al,%al
  80042143c2:	74 25                	je     80042143e9 <mpconfig+0x171>
		cprintf("SMP: Bad MP configuration checksum\n");
  80042143c4:	48 bf 78 80 21 04 80 	movabs $0x8004218078,%rdi
  80042143cb:	00 00 00 
  80042143ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80042143d3:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042143da:	00 00 00 
  80042143dd:	ff d2                	callq  *%rdx
		return NULL;
  80042143df:	b8 00 00 00 00       	mov    $0x0,%eax
  80042143e4:	e9 b2 00 00 00       	jmpq   800421449b <mpconfig+0x223>
	}
	if (conf->version != 1 && conf->version != 4) {
  80042143e9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042143ed:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042143f1:	3c 01                	cmp    $0x1,%al
  80042143f3:	74 3b                	je     8004214430 <mpconfig+0x1b8>
  80042143f5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042143f9:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042143fd:	3c 04                	cmp    $0x4,%al
  80042143ff:	74 2f                	je     8004214430 <mpconfig+0x1b8>
		cprintf("SMP: Unsupported MP version %d\n", conf->version);
  8004214401:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214405:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004214409:	0f b6 c0             	movzbl %al,%eax
  800421440c:	89 c6                	mov    %eax,%esi
  800421440e:	48 bf a0 80 21 04 80 	movabs $0x80042180a0,%rdi
  8004214415:	00 00 00 
  8004214418:	b8 00 00 00 00       	mov    $0x0,%eax
  800421441d:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004214424:	00 00 00 
  8004214427:	ff d2                	callq  *%rdx
		return NULL;
  8004214429:	b8 00 00 00 00       	mov    $0x0,%eax
  800421442e:	eb 6b                	jmp    800421449b <mpconfig+0x223>
	}
	if (sum((uint8_t *)conf + conf->length, conf->xlength) != conf->xchecksum) {
  8004214430:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214434:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  8004214438:	0f b7 c0             	movzwl %ax,%eax
  800421443b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421443f:	0f b7 52 04          	movzwl 0x4(%rdx),%edx
  8004214443:	0f b7 ca             	movzwl %dx,%ecx
  8004214446:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421444a:	48 01 ca             	add    %rcx,%rdx
  800421444d:	89 c6                	mov    %eax,%esi
  800421444f:	48 89 d7             	mov    %rdx,%rdi
  8004214452:	48 b8 c7 3f 21 04 80 	movabs $0x8004213fc7,%rax
  8004214459:	00 00 00 
  800421445c:	ff d0                	callq  *%rax
  800421445e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214462:	0f b6 52 2a          	movzbl 0x2a(%rdx),%edx
  8004214466:	38 d0                	cmp    %dl,%al
  8004214468:	74 22                	je     800421448c <mpconfig+0x214>
		cprintf("SMP: Bad MP configuration extended checksum\n");
  800421446a:	48 bf c0 80 21 04 80 	movabs $0x80042180c0,%rdi
  8004214471:	00 00 00 
  8004214474:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214479:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  8004214480:	00 00 00 
  8004214483:	ff d2                	callq  *%rdx
		return NULL;
  8004214485:	b8 00 00 00 00       	mov    $0x0,%eax
  800421448a:	eb 0f                	jmp    800421449b <mpconfig+0x223>
	}
	*pmp = mp;
  800421448c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214490:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214494:	48 89 10             	mov    %rdx,(%rax)
	return conf;
  8004214497:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  800421449b:	c9                   	leaveq 
  800421449c:	c3                   	retq   

000000800421449d <mp_init>:

void
mp_init(void)
{
  800421449d:	55                   	push   %rbp
  800421449e:	48 89 e5             	mov    %rsp,%rbp
  80042144a1:	53                   	push   %rbx
  80042144a2:	48 83 ec 58          	sub    $0x58,%rsp
	struct mpconf *conf;
	struct mpproc *proc;
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
  80042144a6:	48 b8 e0 03 4a 04 80 	movabs $0x80044a03e0,%rax
  80042144ad:	00 00 00 
  80042144b0:	48 bb 20 00 4a 04 80 	movabs $0x80044a0020,%rbx
  80042144b7:	00 00 00 
  80042144ba:	48 89 18             	mov    %rbx,(%rax)
	if ((conf = mpconfig(&mp)) == 0)
  80042144bd:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  80042144c1:	48 89 c7             	mov    %rax,%rdi
  80042144c4:	48 b8 78 42 21 04 80 	movabs $0x8004214278,%rax
  80042144cb:	00 00 00 
  80042144ce:	ff d0                	callq  *%rax
  80042144d0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042144d4:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042144d9:	75 05                	jne    80042144e0 <mp_init+0x43>
		return;
  80042144db:	e9 71 03 00 00       	jmpq   8004214851 <mp_init+0x3b4>
	ismp = 1;
  80042144e0:	48 b8 00 00 4a 04 80 	movabs $0x80044a0000,%rax
  80042144e7:	00 00 00 
  80042144ea:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	lapicaddr = conf->lapicaddr;
  80042144f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042144f4:	8b 40 24             	mov    0x24(%rax),%eax
  80042144f7:	89 c2                	mov    %eax,%edx
  80042144f9:	48 b8 00 10 52 04 80 	movabs $0x8004521000,%rax
  8004214500:	00 00 00 
  8004214503:	48 89 10             	mov    %rdx,(%rax)

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  8004214506:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421450a:	48 83 c0 2c          	add    $0x2c,%rax
  800421450e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004214512:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  8004214519:	e9 18 02 00 00       	jmpq   8004214736 <mp_init+0x299>
		switch (*p) {
  800421451e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214522:	0f b6 00             	movzbl (%rax),%eax
  8004214525:	0f b6 c0             	movzbl %al,%eax
  8004214528:	85 c0                	test   %eax,%eax
  800421452a:	74 16                	je     8004214542 <mp_init+0xa5>
  800421452c:	85 c0                	test   %eax,%eax
  800421452e:	0f 88 b9 01 00 00    	js     80042146ed <mp_init+0x250>
  8004214534:	83 f8 04             	cmp    $0x4,%eax
  8004214537:	0f 8f b0 01 00 00    	jg     80042146ed <mp_init+0x250>
  800421453d:	e9 a4 01 00 00       	jmpq   80042146e6 <mp_init+0x249>
		case MPPROC:
			proc = (struct mpproc *)p;
  8004214542:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214546:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			if (proc->flags & MPPROC_BOOT) {
  800421454a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421454e:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004214552:	0f b6 c0             	movzbl %al,%eax
  8004214555:	83 e0 02             	and    $0x2,%eax
  8004214558:	85 c0                	test   %eax,%eax
  800421455a:	74 51                	je     80042145ad <mp_init+0x110>
				bootcpu = &cpus[ncpu];
  800421455c:	48 b8 e8 03 4a 04 80 	movabs $0x80044a03e8,%rax
  8004214563:	00 00 00 
  8004214566:	8b 00                	mov    (%rax),%eax
  8004214568:	48 98                	cltq   
  800421456a:	48 c1 e0 03          	shl    $0x3,%rax
  800421456e:	48 89 c2             	mov    %rax,%rdx
  8004214571:	48 c1 e2 04          	shl    $0x4,%rdx
  8004214575:	48 29 c2             	sub    %rax,%rdx
  8004214578:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  800421457f:	00 00 00 
  8004214582:	48 01 c2             	add    %rax,%rdx
  8004214585:	48 b8 e0 03 4a 04 80 	movabs $0x80044a03e0,%rax
  800421458c:	00 00 00 
  800421458f:	48 89 10             	mov    %rdx,(%rax)
				cprintf("Found boot cpu..\n");
  8004214592:	48 bf ed 80 21 04 80 	movabs $0x80042180ed,%rdi
  8004214599:	00 00 00 
  800421459c:	b8 00 00 00 00       	mov    $0x0,%eax
  80042145a1:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042145a8:	00 00 00 
  80042145ab:	ff d2                	callq  *%rdx
			}
			if (ncpu < NCPU) {
  80042145ad:	48 b8 e8 03 4a 04 80 	movabs $0x80044a03e8,%rax
  80042145b4:	00 00 00 
  80042145b7:	8b 00                	mov    (%rax),%eax
  80042145b9:	83 f8 07             	cmp    $0x7,%eax
  80042145bc:	0f 8f f5 00 00 00    	jg     80042146b7 <mp_init+0x21a>
				cprintf("type: %d apicid:%d version:%d signature:%x feature:%x flags:%x reserved:%x\n", proc->type, proc->apicid, proc->version, proc->signature, proc->feature, proc->flags, proc->reserved);
  80042145c2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042145c6:	4c 8d 40 0c          	lea    0xc(%rax),%r8
  80042145ca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042145ce:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  80042145d2:	0f b6 f0             	movzbl %al,%esi
  80042145d5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042145d9:	8b 78 08             	mov    0x8(%rax),%edi
  80042145dc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042145e0:	4c 8d 50 04          	lea    0x4(%rax),%r10
  80042145e4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042145e8:	0f b6 40 02          	movzbl 0x2(%rax),%eax
  80042145ec:	0f b6 c8             	movzbl %al,%ecx
  80042145ef:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042145f3:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80042145f7:	0f b6 d0             	movzbl %al,%edx
  80042145fa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042145fe:	0f b6 00             	movzbl (%rax),%eax
  8004214601:	0f b6 c0             	movzbl %al,%eax
  8004214604:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004214609:	89 34 24             	mov    %esi,(%rsp)
  800421460c:	41 89 f9             	mov    %edi,%r9d
  800421460f:	4d 89 d0             	mov    %r10,%r8
  8004214612:	89 c6                	mov    %eax,%esi
  8004214614:	48 bf 00 81 21 04 80 	movabs $0x8004218100,%rdi
  800421461b:	00 00 00 
  800421461e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214623:	49 ba 0e 92 20 04 80 	movabs $0x800420920e,%r10
  800421462a:	00 00 00 
  800421462d:	41 ff d2             	callq  *%r10
				if (proc->flags & MPROC_EN) {
  8004214630:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214634:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004214638:	0f b6 c0             	movzbl %al,%eax
  800421463b:	83 e0 01             	and    $0x1,%eax
  800421463e:	85 c0                	test   %eax,%eax
  8004214640:	74 58                	je     800421469a <mp_init+0x1fd>
					cpus[ncpu].cpu_id = ncpu;
  8004214642:	48 b8 e8 03 4a 04 80 	movabs $0x80044a03e8,%rax
  8004214649:	00 00 00 
  800421464c:	8b 10                	mov    (%rax),%edx
  800421464e:	48 b8 e8 03 4a 04 80 	movabs $0x80044a03e8,%rax
  8004214655:	00 00 00 
  8004214658:	8b 00                	mov    (%rax),%eax
  800421465a:	89 c1                	mov    %eax,%ecx
  800421465c:	48 be 20 00 4a 04 80 	movabs $0x80044a0020,%rsi
  8004214663:	00 00 00 
  8004214666:	48 63 c2             	movslq %edx,%rax
  8004214669:	48 c1 e0 03          	shl    $0x3,%rax
  800421466d:	48 89 c2             	mov    %rax,%rdx
  8004214670:	48 c1 e2 04          	shl    $0x4,%rdx
  8004214674:	48 29 c2             	sub    %rax,%rdx
  8004214677:	48 8d 04 16          	lea    (%rsi,%rdx,1),%rax
  800421467b:	88 08                	mov    %cl,(%rax)
					ncpu++;
  800421467d:	48 b8 e8 03 4a 04 80 	movabs $0x80044a03e8,%rax
  8004214684:	00 00 00 
  8004214687:	8b 00                	mov    (%rax),%eax
  8004214689:	8d 50 01             	lea    0x1(%rax),%edx
  800421468c:	48 b8 e8 03 4a 04 80 	movabs $0x80044a03e8,%rax
  8004214693:	00 00 00 
  8004214696:	89 10                	mov    %edx,(%rax)
  8004214698:	eb 45                	jmp    80042146df <mp_init+0x242>
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
  800421469a:	48 bf 50 81 21 04 80 	movabs $0x8004218150,%rdi
  80042146a1:	00 00 00 
  80042146a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042146a9:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042146b0:	00 00 00 
  80042146b3:	ff d2                	callq  *%rdx
  80042146b5:	eb 28                	jmp    80042146df <mp_init+0x242>
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
					proc->apicid);
  80042146b7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042146bb:	0f b6 40 01          	movzbl 0x1(%rax),%eax
					ncpu++;
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
  80042146bf:	0f b6 c0             	movzbl %al,%eax
  80042146c2:	89 c6                	mov    %eax,%esi
  80042146c4:	48 bf 80 81 21 04 80 	movabs $0x8004218180,%rdi
  80042146cb:	00 00 00 
  80042146ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80042146d3:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042146da:	00 00 00 
  80042146dd:	ff d2                	callq  *%rdx
					proc->apicid);
			}
			p += sizeof(struct mpproc);
  80042146df:	48 83 45 e8 14       	addq   $0x14,-0x18(%rbp)
			continue;
  80042146e4:	eb 4c                	jmp    8004214732 <mp_init+0x295>
		case MPBUS:
		case MPIOAPIC:
		case MPIOINTR:
		case MPLINTR:
		p += 8;
  80042146e6:	48 83 45 e8 08       	addq   $0x8,-0x18(%rbp)
		continue;
  80042146eb:	eb 45                	jmp    8004214732 <mp_init+0x295>
		default:
			cprintf("mpinit: unknown config type %x\n", *p);
  80042146ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042146f1:	0f b6 00             	movzbl (%rax),%eax
  80042146f4:	0f b6 c0             	movzbl %al,%eax
  80042146f7:	89 c6                	mov    %eax,%esi
  80042146f9:	48 bf a8 81 21 04 80 	movabs $0x80042181a8,%rdi
  8004214700:	00 00 00 
  8004214703:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214708:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800421470f:	00 00 00 
  8004214712:	ff d2                	callq  *%rdx
			ismp = 0;
  8004214714:	48 b8 00 00 4a 04 80 	movabs $0x80044a0000,%rax
  800421471b:	00 00 00 
  800421471e:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			i = conf->entry;
  8004214724:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214728:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  800421472c:	0f b7 c0             	movzwl %ax,%eax
  800421472f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if ((conf = mpconfig(&mp)) == 0)
		return;
	ismp = 1;
	lapicaddr = conf->lapicaddr;

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  8004214732:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  8004214736:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421473a:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  800421473e:	0f b7 c0             	movzwl %ax,%eax
  8004214741:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8004214744:	0f 87 d4 fd ff ff    	ja     800421451e <mp_init+0x81>
			i = conf->entry;
		}
	}


	bootcpu->cpu_status = CPU_STARTED;
  800421474a:	48 b8 e0 03 4a 04 80 	movabs $0x80044a03e0,%rax
  8004214751:	00 00 00 
  8004214754:	48 8b 00             	mov    (%rax),%rax
  8004214757:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
	if (!ismp) {
  800421475e:	48 b8 00 00 4a 04 80 	movabs $0x80044a0000,%rax
  8004214765:	00 00 00 
  8004214768:	8b 00                	mov    (%rax),%eax
  800421476a:	85 c0                	test   %eax,%eax
  800421476c:	75 41                	jne    80042147af <mp_init+0x312>
		// Didn't like what we found; fall back to no MP.
		ncpu = 1;
  800421476e:	48 b8 e8 03 4a 04 80 	movabs $0x80044a03e8,%rax
  8004214775:	00 00 00 
  8004214778:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
		lapicaddr = 0;
  800421477e:	48 b8 00 10 52 04 80 	movabs $0x8004521000,%rax
  8004214785:	00 00 00 
  8004214788:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		cprintf("SMP: configuration not found, SMP disabled\n");
  800421478f:	48 bf c8 81 21 04 80 	movabs $0x80042181c8,%rdi
  8004214796:	00 00 00 
  8004214799:	b8 00 00 00 00       	mov    $0x0,%eax
  800421479e:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042147a5:	00 00 00 
  80042147a8:	ff d2                	callq  *%rdx
		return;
  80042147aa:	e9 a2 00 00 00       	jmpq   8004214851 <mp_init+0x3b4>
	}
	cprintf("SMP: CPU %d found %d CPU(s)\n", bootcpu->cpu_id,  ncpu);
  80042147af:	48 b8 e8 03 4a 04 80 	movabs $0x80044a03e8,%rax
  80042147b6:	00 00 00 
  80042147b9:	8b 10                	mov    (%rax),%edx
  80042147bb:	48 b8 e0 03 4a 04 80 	movabs $0x80044a03e0,%rax
  80042147c2:	00 00 00 
  80042147c5:	48 8b 00             	mov    (%rax),%rax
  80042147c8:	0f b6 00             	movzbl (%rax),%eax
  80042147cb:	0f b6 c0             	movzbl %al,%eax
  80042147ce:	89 c6                	mov    %eax,%esi
  80042147d0:	48 bf f4 81 21 04 80 	movabs $0x80042181f4,%rdi
  80042147d7:	00 00 00 
  80042147da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042147df:	48 b9 0e 92 20 04 80 	movabs $0x800420920e,%rcx
  80042147e6:	00 00 00 
  80042147e9:	ff d1                	callq  *%rcx

	if (mp->imcrp) {
  80042147eb:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042147ef:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  80042147f3:	84 c0                	test   %al,%al
  80042147f5:	74 5a                	je     8004214851 <mp_init+0x3b4>
		// [MP 3.2.6.1] If the hardware implements PIC mode,
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
  80042147f7:	48 bf 18 82 21 04 80 	movabs $0x8004218218,%rdi
  80042147fe:	00 00 00 
  8004214801:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214806:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  800421480d:	00 00 00 
  8004214810:	ff d2                	callq  *%rdx
  8004214812:	c7 45 cc 22 00 00 00 	movl   $0x22,-0x34(%rbp)
  8004214819:	c6 45 cb 70          	movb   $0x70,-0x35(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800421481d:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004214821:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004214824:	ee                   	out    %al,(%dx)
  8004214825:	c7 45 c4 23 00 00 00 	movl   $0x23,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800421482c:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421482f:	89 c2                	mov    %eax,%edx
  8004214831:	ec                   	in     (%dx),%al
  8004214832:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  8004214835:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  8004214839:	83 c8 01             	or     $0x1,%eax
  800421483c:	0f b6 c0             	movzbl %al,%eax
  800421483f:	c7 45 bc 23 00 00 00 	movl   $0x23,-0x44(%rbp)
  8004214846:	88 45 bb             	mov    %al,-0x45(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004214849:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  800421484d:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004214850:	ee                   	out    %al,(%dx)
	}
}
  8004214851:	48 83 c4 58          	add    $0x58,%rsp
  8004214855:	5b                   	pop    %rbx
  8004214856:	5d                   	pop    %rbp
  8004214857:	c3                   	retq   

0000008004214858 <lapicw>:
physaddr_t lapicaddr;        // Initialized in mpconfig.c
volatile uint32_t *lapic;

static void
lapicw(int index, int value)
{
  8004214858:	55                   	push   %rbp
  8004214859:	48 89 e5             	mov    %rsp,%rbp
  800421485c:	48 83 ec 08          	sub    $0x8,%rsp
  8004214860:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004214863:	89 75 f8             	mov    %esi,-0x8(%rbp)
	lapic[index] = value;
  8004214866:	48 b8 08 10 52 04 80 	movabs $0x8004521008,%rax
  800421486d:	00 00 00 
  8004214870:	48 8b 00             	mov    (%rax),%rax
  8004214873:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004214876:	48 63 d2             	movslq %edx,%rdx
  8004214879:	48 c1 e2 02          	shl    $0x2,%rdx
  800421487d:	48 01 c2             	add    %rax,%rdx
  8004214880:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004214883:	89 02                	mov    %eax,(%rdx)
	lapic[ID];  // wait for write to finish, by reading
  8004214885:	48 b8 08 10 52 04 80 	movabs $0x8004521008,%rax
  800421488c:	00 00 00 
  800421488f:	48 8b 00             	mov    (%rax),%rax
  8004214892:	48 83 c0 20          	add    $0x20,%rax
  8004214896:	8b 00                	mov    (%rax),%eax
}
  8004214898:	c9                   	leaveq 
  8004214899:	c3                   	retq   

000000800421489a <lapic_init>:

void
lapic_init(void)
{
  800421489a:	55                   	push   %rbp
  800421489b:	48 89 e5             	mov    %rsp,%rbp
	if (!lapicaddr)
  800421489e:	48 b8 00 10 52 04 80 	movabs $0x8004521000,%rax
  80042148a5:	00 00 00 
  80042148a8:	48 8b 00             	mov    (%rax),%rax
  80042148ab:	48 85 c0             	test   %rax,%rax
  80042148ae:	75 05                	jne    80042148b5 <lapic_init+0x1b>
		return;
  80042148b0:	e9 da 01 00 00       	jmpq   8004214a8f <lapic_init+0x1f5>

	// lapicaddr is the physical address of the LAPIC's 4K MMIO
	// region.  Map it in to virtual memory so we can access it.
	lapic = mmio_map_region(lapicaddr, 4096);
  80042148b5:	48 b8 00 10 52 04 80 	movabs $0x8004521000,%rax
  80042148bc:	00 00 00 
  80042148bf:	48 8b 00             	mov    (%rax),%rax
  80042148c2:	be 00 10 00 00       	mov    $0x1000,%esi
  80042148c7:	48 89 c7             	mov    %rax,%rdi
  80042148ca:	48 b8 b5 3e 20 04 80 	movabs $0x8004203eb5,%rax
  80042148d1:	00 00 00 
  80042148d4:	ff d0                	callq  *%rax
  80042148d6:	48 ba 08 10 52 04 80 	movabs $0x8004521008,%rdx
  80042148dd:	00 00 00 
  80042148e0:	48 89 02             	mov    %rax,(%rdx)

	// Enable local APIC; set spurious interrupt vector.
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));
  80042148e3:	be 27 01 00 00       	mov    $0x127,%esi
  80042148e8:	bf 3c 00 00 00       	mov    $0x3c,%edi
  80042148ed:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  80042148f4:	00 00 00 
  80042148f7:	ff d0                	callq  *%rax

	// The timer repeatedly counts down at bus frequency
	// from lapic[TICR] and then issues an interrupt.  
	// If we cared more about precise timekeeping,
	// TICR would be calibrated using an external time source.
	lapicw(TDCR, X1);
  80042148f9:	be 0b 00 00 00       	mov    $0xb,%esi
  80042148fe:	bf f8 00 00 00       	mov    $0xf8,%edi
  8004214903:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  800421490a:	00 00 00 
  800421490d:	ff d0                	callq  *%rax
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
  800421490f:	be 20 00 02 00       	mov    $0x20020,%esi
  8004214914:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004214919:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  8004214920:	00 00 00 
  8004214923:	ff d0                	callq  *%rax
	lapicw(TICR, 10000000); 
  8004214925:	be 80 96 98 00       	mov    $0x989680,%esi
  800421492a:	bf e0 00 00 00       	mov    $0xe0,%edi
  800421492f:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  8004214936:	00 00 00 
  8004214939:	ff d0                	callq  *%rax
	//
	// According to Intel MP Specification, the BIOS should initialize
	// BSP's local APIC in Virtual Wire Mode, in which 8259A's
	// INTR is virtually connected to BSP's LINTIN0. In this mode,
	// we do not need to program the IOAPIC.
	if (thiscpu != bootcpu)
  800421493b:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004214942:	00 00 00 
  8004214945:	ff d0                	callq  *%rax
  8004214947:	48 98                	cltq   
  8004214949:	48 c1 e0 03          	shl    $0x3,%rax
  800421494d:	48 89 c2             	mov    %rax,%rdx
  8004214950:	48 c1 e2 04          	shl    $0x4,%rdx
  8004214954:	48 29 c2             	sub    %rax,%rdx
  8004214957:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  800421495e:	00 00 00 
  8004214961:	48 01 c2             	add    %rax,%rdx
  8004214964:	48 b8 e0 03 4a 04 80 	movabs $0x80044a03e0,%rax
  800421496b:	00 00 00 
  800421496e:	48 8b 00             	mov    (%rax),%rax
  8004214971:	48 39 c2             	cmp    %rax,%rdx
  8004214974:	74 16                	je     800421498c <lapic_init+0xf2>
		lapicw(LINT0, MASKED);
  8004214976:	be 00 00 01 00       	mov    $0x10000,%esi
  800421497b:	bf d4 00 00 00       	mov    $0xd4,%edi
  8004214980:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  8004214987:	00 00 00 
  800421498a:	ff d0                	callq  *%rax

	// Disable NMI (LINT1) on all CPUs
	lapicw(LINT1, MASKED);
  800421498c:	be 00 00 01 00       	mov    $0x10000,%esi
  8004214991:	bf d8 00 00 00       	mov    $0xd8,%edi
  8004214996:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  800421499d:	00 00 00 
  80042149a0:	ff d0                	callq  *%rax

	// Disable performance counter overflow interrupts
	// on machines that provide that interrupt entry.
	if (((lapic[VER]>>16) & 0xFF) >= 4)
  80042149a2:	48 b8 08 10 52 04 80 	movabs $0x8004521008,%rax
  80042149a9:	00 00 00 
  80042149ac:	48 8b 00             	mov    (%rax),%rax
  80042149af:	48 83 c0 30          	add    $0x30,%rax
  80042149b3:	8b 00                	mov    (%rax),%eax
  80042149b5:	c1 e8 10             	shr    $0x10,%eax
  80042149b8:	0f b6 c0             	movzbl %al,%eax
  80042149bb:	83 f8 03             	cmp    $0x3,%eax
  80042149be:	76 16                	jbe    80042149d6 <lapic_init+0x13c>
		lapicw(PCINT, MASKED);
  80042149c0:	be 00 00 01 00       	mov    $0x10000,%esi
  80042149c5:	bf d0 00 00 00       	mov    $0xd0,%edi
  80042149ca:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  80042149d1:	00 00 00 
  80042149d4:	ff d0                	callq  *%rax

	// Map error interrupt to IRQ_ERROR.
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);
  80042149d6:	be 33 00 00 00       	mov    $0x33,%esi
  80042149db:	bf dc 00 00 00       	mov    $0xdc,%edi
  80042149e0:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  80042149e7:	00 00 00 
  80042149ea:	ff d0                	callq  *%rax

	// Clear error status register (requires back-to-back writes).
	lapicw(ESR, 0);
  80042149ec:	be 00 00 00 00       	mov    $0x0,%esi
  80042149f1:	bf a0 00 00 00       	mov    $0xa0,%edi
  80042149f6:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  80042149fd:	00 00 00 
  8004214a00:	ff d0                	callq  *%rax
	lapicw(ESR, 0);
  8004214a02:	be 00 00 00 00       	mov    $0x0,%esi
  8004214a07:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004214a0c:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  8004214a13:	00 00 00 
  8004214a16:	ff d0                	callq  *%rax

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);
  8004214a18:	be 00 00 00 00       	mov    $0x0,%esi
  8004214a1d:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004214a22:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  8004214a29:	00 00 00 
  8004214a2c:	ff d0                	callq  *%rax

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
  8004214a2e:	be 00 00 00 00       	mov    $0x0,%esi
  8004214a33:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004214a38:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  8004214a3f:	00 00 00 
  8004214a42:	ff d0                	callq  *%rax
	lapicw(ICRLO, BCAST | INIT | LEVEL);
  8004214a44:	be 00 85 08 00       	mov    $0x88500,%esi
  8004214a49:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004214a4e:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  8004214a55:	00 00 00 
  8004214a58:	ff d0                	callq  *%rax
	while(lapic[ICRLO] & DELIVS)
  8004214a5a:	90                   	nop
  8004214a5b:	48 b8 08 10 52 04 80 	movabs $0x8004521008,%rax
  8004214a62:	00 00 00 
  8004214a65:	48 8b 00             	mov    (%rax),%rax
  8004214a68:	48 05 00 03 00 00    	add    $0x300,%rax
  8004214a6e:	8b 00                	mov    (%rax),%eax
  8004214a70:	25 00 10 00 00       	and    $0x1000,%eax
  8004214a75:	85 c0                	test   %eax,%eax
  8004214a77:	75 e2                	jne    8004214a5b <lapic_init+0x1c1>
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
  8004214a79:	be 00 00 00 00       	mov    $0x0,%esi
  8004214a7e:	bf 20 00 00 00       	mov    $0x20,%edi
  8004214a83:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  8004214a8a:	00 00 00 
  8004214a8d:	ff d0                	callq  *%rax
}
  8004214a8f:	5d                   	pop    %rbp
  8004214a90:	c3                   	retq   

0000008004214a91 <cpunum>:

int
cpunum(void)
{
  8004214a91:	55                   	push   %rbp
  8004214a92:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004214a95:	48 b8 08 10 52 04 80 	movabs $0x8004521008,%rax
  8004214a9c:	00 00 00 
  8004214a9f:	48 8b 00             	mov    (%rax),%rax
  8004214aa2:	48 85 c0             	test   %rax,%rax
  8004214aa5:	74 18                	je     8004214abf <cpunum+0x2e>
		return lapic[ID] >> 24;
  8004214aa7:	48 b8 08 10 52 04 80 	movabs $0x8004521008,%rax
  8004214aae:	00 00 00 
  8004214ab1:	48 8b 00             	mov    (%rax),%rax
  8004214ab4:	48 83 c0 20          	add    $0x20,%rax
  8004214ab8:	8b 00                	mov    (%rax),%eax
  8004214aba:	c1 e8 18             	shr    $0x18,%eax
  8004214abd:	eb 05                	jmp    8004214ac4 <cpunum+0x33>
	return 0;
  8004214abf:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214ac4:	5d                   	pop    %rbp
  8004214ac5:	c3                   	retq   

0000008004214ac6 <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  8004214ac6:	55                   	push   %rbp
  8004214ac7:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004214aca:	48 b8 08 10 52 04 80 	movabs $0x8004521008,%rax
  8004214ad1:	00 00 00 
  8004214ad4:	48 8b 00             	mov    (%rax),%rax
  8004214ad7:	48 85 c0             	test   %rax,%rax
  8004214ada:	74 16                	je     8004214af2 <lapic_eoi+0x2c>
		lapicw(EOI, 0);
  8004214adc:	be 00 00 00 00       	mov    $0x0,%esi
  8004214ae1:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004214ae6:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  8004214aed:	00 00 00 
  8004214af0:	ff d0                	callq  *%rax
}
  8004214af2:	5d                   	pop    %rbp
  8004214af3:	c3                   	retq   

0000008004214af4 <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  8004214af4:	55                   	push   %rbp
  8004214af5:	48 89 e5             	mov    %rsp,%rbp
  8004214af8:	48 83 ec 04          	sub    $0x4,%rsp
  8004214afc:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
  8004214aff:	c9                   	leaveq 
  8004214b00:	c3                   	retq   

0000008004214b01 <lapic_startap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uint8_t apicid, uint32_t addr)
{
  8004214b01:	55                   	push   %rbp
  8004214b02:	48 89 e5             	mov    %rsp,%rbp
  8004214b05:	48 83 ec 40          	sub    $0x40,%rsp
  8004214b09:	89 f8                	mov    %edi,%eax
  8004214b0b:	89 75 c8             	mov    %esi,-0x38(%rbp)
  8004214b0e:	88 45 cc             	mov    %al,-0x34(%rbp)
  8004214b11:	c7 45 dc 70 00 00 00 	movl   $0x70,-0x24(%rbp)
  8004214b18:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
  8004214b1c:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004214b20:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004214b23:	ee                   	out    %al,(%dx)
  8004214b24:	c7 45 d4 71 00 00 00 	movl   $0x71,-0x2c(%rbp)
  8004214b2b:	c6 45 d3 0a          	movb   $0xa,-0x2d(%rbp)
  8004214b2f:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004214b33:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004214b36:	ee                   	out    %al,(%dx)
	// "The BSP must initialize CMOS shutdown code to 0AH
	// and the warm reset vector (DWORD based at 40:67) to point at
	// the AP startup code prior to the [universal startup algorithm]."
	outb(IO_RTC, 0xF);  // offset 0xF is shutdown code
	outb(IO_RTC+1, 0x0A);
	wrv = (uint16_t *)KADDR((0x40 << 4 | 0x67));  // Warm reset vector
  8004214b37:	48 c7 45 f0 67 04 00 	movq   $0x467,-0x10(%rbp)
  8004214b3e:	00 
  8004214b3f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214b43:	48 c1 e8 0c          	shr    $0xc,%rax
  8004214b47:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004214b4a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004214b4d:	48 b8 30 e7 49 04 80 	movabs $0x800449e730,%rax
  8004214b54:	00 00 00 
  8004214b57:	48 8b 00             	mov    (%rax),%rax
  8004214b5a:	48 39 c2             	cmp    %rax,%rdx
  8004214b5d:	72 32                	jb     8004214b91 <lapic_startap+0x90>
  8004214b5f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214b63:	48 89 c1             	mov    %rax,%rcx
  8004214b66:	48 ba 60 82 21 04 80 	movabs $0x8004218260,%rdx
  8004214b6d:	00 00 00 
  8004214b70:	be 98 00 00 00       	mov    $0x98,%esi
  8004214b75:	48 bf 83 82 21 04 80 	movabs $0x8004218283,%rdi
  8004214b7c:	00 00 00 
  8004214b7f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214b84:	49 b8 ae 04 20 04 80 	movabs $0x80042004ae,%r8
  8004214b8b:	00 00 00 
  8004214b8e:	41 ff d0             	callq  *%r8
  8004214b91:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004214b98:	00 00 00 
  8004214b9b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214b9f:	48 01 d0             	add    %rdx,%rax
  8004214ba2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	wrv[0] = 0;
  8004214ba6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214baa:	66 c7 00 00 00       	movw   $0x0,(%rax)
	wrv[1] = addr >> 4;
  8004214baf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214bb3:	48 8d 50 02          	lea    0x2(%rax),%rdx
  8004214bb7:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004214bba:	c1 e8 04             	shr    $0x4,%eax
  8004214bbd:	66 89 02             	mov    %ax,(%rdx)

	// "Universal startup algorithm."
	// Send INIT (level-triggered) interrupt to reset other CPU.
	lapicw(ICRHI, apicid << 24);
  8004214bc0:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004214bc4:	c1 e0 18             	shl    $0x18,%eax
  8004214bc7:	89 c6                	mov    %eax,%esi
  8004214bc9:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004214bce:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  8004214bd5:	00 00 00 
  8004214bd8:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL | ASSERT);
  8004214bda:	be 00 c5 00 00       	mov    $0xc500,%esi
  8004214bdf:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004214be4:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  8004214beb:	00 00 00 
  8004214bee:	ff d0                	callq  *%rax
	microdelay(200);
  8004214bf0:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004214bf5:	48 b8 f4 4a 21 04 80 	movabs $0x8004214af4,%rax
  8004214bfc:	00 00 00 
  8004214bff:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL);
  8004214c01:	be 00 85 00 00       	mov    $0x8500,%esi
  8004214c06:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004214c0b:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  8004214c12:	00 00 00 
  8004214c15:	ff d0                	callq  *%rax
	microdelay(100);    // should be 10ms, but too slow in Bochs!
  8004214c17:	bf 64 00 00 00       	mov    $0x64,%edi
  8004214c1c:	48 b8 f4 4a 21 04 80 	movabs $0x8004214af4,%rax
  8004214c23:	00 00 00 
  8004214c26:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004214c28:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004214c2f:	eb 4b                	jmp    8004214c7c <lapic_startap+0x17b>
		lapicw(ICRHI, apicid << 24);
  8004214c31:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004214c35:	c1 e0 18             	shl    $0x18,%eax
  8004214c38:	89 c6                	mov    %eax,%esi
  8004214c3a:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004214c3f:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  8004214c46:	00 00 00 
  8004214c49:	ff d0                	callq  *%rax
		lapicw(ICRLO, STARTUP | (addr >> 12));
  8004214c4b:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004214c4e:	c1 e8 0c             	shr    $0xc,%eax
  8004214c51:	80 cc 06             	or     $0x6,%ah
  8004214c54:	89 c6                	mov    %eax,%esi
  8004214c56:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004214c5b:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  8004214c62:	00 00 00 
  8004214c65:	ff d0                	callq  *%rax
		microdelay(200);
  8004214c67:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004214c6c:	48 b8 f4 4a 21 04 80 	movabs $0x8004214af4,%rax
  8004214c73:	00 00 00 
  8004214c76:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004214c78:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004214c7c:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  8004214c80:	7e af                	jle    8004214c31 <lapic_startap+0x130>
		lapicw(ICRHI, apicid << 24);
		lapicw(ICRLO, STARTUP | (addr >> 12));
		microdelay(200);
	}
}
  8004214c82:	c9                   	leaveq 
  8004214c83:	c3                   	retq   

0000008004214c84 <lapic_ipi>:

void
lapic_ipi(int vector)
{
  8004214c84:	55                   	push   %rbp
  8004214c85:	48 89 e5             	mov    %rsp,%rbp
  8004214c88:	48 83 ec 08          	sub    $0x8,%rsp
  8004214c8c:	89 7d fc             	mov    %edi,-0x4(%rbp)
	lapicw(ICRLO, OTHERS | FIXED | vector);
  8004214c8f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004214c92:	0d 00 00 0c 00       	or     $0xc0000,%eax
  8004214c97:	89 c6                	mov    %eax,%esi
  8004214c99:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004214c9e:	48 b8 58 48 21 04 80 	movabs $0x8004214858,%rax
  8004214ca5:	00 00 00 
  8004214ca8:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  8004214caa:	90                   	nop
  8004214cab:	48 b8 08 10 52 04 80 	movabs $0x8004521008,%rax
  8004214cb2:	00 00 00 
  8004214cb5:	48 8b 00             	mov    (%rax),%rax
  8004214cb8:	48 05 00 03 00 00    	add    $0x300,%rax
  8004214cbe:	8b 00                	mov    (%rax),%eax
  8004214cc0:	25 00 10 00 00       	and    $0x1000,%eax
  8004214cc5:	85 c0                	test   %eax,%eax
  8004214cc7:	75 e2                	jne    8004214cab <lapic_ipi+0x27>
		;
}
  8004214cc9:	c9                   	leaveq 
  8004214cca:	c3                   	retq   

0000008004214ccb <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004214ccb:	55                   	push   %rbp
  8004214ccc:	48 89 e5             	mov    %rsp,%rbp
  8004214ccf:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004214cd3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214cd7:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004214cda:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214cde:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004214ce1:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004214ce5:	f0 87 02             	lock xchg %eax,(%rdx)
  8004214ce8:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004214ceb:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004214cee:	c9                   	leaveq 
  8004214cef:	c3                   	retq   

0000008004214cf0 <get_caller_pcs>:

#ifdef DEBUG_SPINLOCK
// Record the current call stack in pcs[] by following the %ebp chain.
static void
get_caller_pcs(uint64_t pcs[])
{
  8004214cf0:	55                   	push   %rbp
  8004214cf1:	48 89 e5             	mov    %rsp,%rbp
  8004214cf4:	48 83 ec 28          	sub    $0x28,%rsp
  8004214cf8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

static __inline uint64_t
read_rbp(void)
{
	uint64_t rbp;
	__asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  8004214cfc:	48 89 e8             	mov    %rbp,%rax
  8004214cff:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	return rbp;
  8004214d03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
  8004214d07:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (i = 0; i < 10; i++){
  8004214d0b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004214d12:	eb 45                	jmp    8004214d59 <get_caller_pcs+0x69>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
  8004214d14:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004214d19:	74 44                	je     8004214d5f <get_caller_pcs+0x6f>
  8004214d1b:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004214d22:	00 00 00 
  8004214d25:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004214d29:	76 34                	jbe    8004214d5f <get_caller_pcs+0x6f>
			break;
		pcs[i] = rbp[1];          // saved %rip
  8004214d2b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214d2e:	48 98                	cltq   
  8004214d30:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004214d37:	00 
  8004214d38:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214d3c:	48 01 c2             	add    %rax,%rdx
  8004214d3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214d43:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214d47:	48 89 02             	mov    %rax,(%rdx)
		rbp = (uint64_t *)rbp[0]; // saved %rbp
  8004214d4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214d4e:	48 8b 00             	mov    (%rax),%rax
  8004214d51:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
{
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
	for (i = 0; i < 10; i++){
  8004214d55:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004214d59:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004214d5d:	7e b5                	jle    8004214d14 <get_caller_pcs+0x24>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004214d5f:	eb 1f                	jmp    8004214d80 <get_caller_pcs+0x90>
		pcs[i] = 0;
  8004214d61:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214d64:	48 98                	cltq   
  8004214d66:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004214d6d:	00 
  8004214d6e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214d72:	48 01 d0             	add    %rdx,%rax
  8004214d75:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004214d7c:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004214d80:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004214d84:	7e db                	jle    8004214d61 <get_caller_pcs+0x71>
		pcs[i] = 0;
}
  8004214d86:	c9                   	leaveq 
  8004214d87:	c3                   	retq   

0000008004214d88 <holding>:

// Check whether this CPU is holding the lock.
static int
holding(struct spinlock *lock)
{
  8004214d88:	55                   	push   %rbp
  8004214d89:	48 89 e5             	mov    %rsp,%rbp
  8004214d8c:	53                   	push   %rbx
  8004214d8d:	48 83 ec 18          	sub    $0x18,%rsp
  8004214d91:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return lock->locked && lock->cpu == thiscpu;
  8004214d95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214d99:	8b 00                	mov    (%rax),%eax
  8004214d9b:	85 c0                	test   %eax,%eax
  8004214d9d:	74 3d                	je     8004214ddc <holding+0x54>
  8004214d9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214da3:	48 8b 58 10          	mov    0x10(%rax),%rbx
  8004214da7:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004214dae:	00 00 00 
  8004214db1:	ff d0                	callq  *%rax
  8004214db3:	48 98                	cltq   
  8004214db5:	48 c1 e0 03          	shl    $0x3,%rax
  8004214db9:	48 89 c2             	mov    %rax,%rdx
  8004214dbc:	48 c1 e2 04          	shl    $0x4,%rdx
  8004214dc0:	48 29 c2             	sub    %rax,%rdx
  8004214dc3:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  8004214dca:	00 00 00 
  8004214dcd:	48 01 d0             	add    %rdx,%rax
  8004214dd0:	48 39 c3             	cmp    %rax,%rbx
  8004214dd3:	75 07                	jne    8004214ddc <holding+0x54>
  8004214dd5:	b8 01 00 00 00       	mov    $0x1,%eax
  8004214dda:	eb 05                	jmp    8004214de1 <holding+0x59>
  8004214ddc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214de1:	48 83 c4 18          	add    $0x18,%rsp
  8004214de5:	5b                   	pop    %rbx
  8004214de6:	5d                   	pop    %rbp
  8004214de7:	c3                   	retq   

0000008004214de8 <__spin_initlock>:
#endif

void
__spin_initlock(struct spinlock *lk, char *name)
{
  8004214de8:	55                   	push   %rbp
  8004214de9:	48 89 e5             	mov    %rsp,%rbp
  8004214dec:	48 83 ec 10          	sub    $0x10,%rsp
  8004214df0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004214df4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	lk->locked = 0;
  8004214df8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214dfc:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
#ifdef DEBUG_SPINLOCK
	lk->name = name;
  8004214e02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214e06:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004214e0a:	48 89 50 08          	mov    %rdx,0x8(%rax)
	lk->cpu = 0;
  8004214e0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214e12:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004214e19:	00 
#endif
}
  8004214e1a:	c9                   	leaveq 
  8004214e1b:	c3                   	retq   

0000008004214e1c <spin_lock>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
spin_lock(struct spinlock *lk)
{
  8004214e1c:	55                   	push   %rbp
  8004214e1d:	48 89 e5             	mov    %rsp,%rbp
  8004214e20:	53                   	push   %rbx
  8004214e21:	48 83 ec 18          	sub    $0x18,%rsp
  8004214e25:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
  8004214e29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214e2d:	48 89 c7             	mov    %rax,%rdi
  8004214e30:	48 b8 88 4d 21 04 80 	movabs $0x8004214d88,%rax
  8004214e37:	00 00 00 
  8004214e3a:	ff d0                	callq  *%rax
  8004214e3c:	85 c0                	test   %eax,%eax
  8004214e3e:	74 44                	je     8004214e84 <spin_lock+0x68>
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
  8004214e40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214e44:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004214e48:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004214e4f:	00 00 00 
  8004214e52:	ff d0                	callq  *%rax
  8004214e54:	49 89 d8             	mov    %rbx,%r8
  8004214e57:	89 c1                	mov    %eax,%ecx
  8004214e59:	48 ba a0 82 21 04 80 	movabs $0x80042182a0,%rdx
  8004214e60:	00 00 00 
  8004214e63:	be 41 00 00 00       	mov    $0x41,%esi
  8004214e68:	48 bf ca 82 21 04 80 	movabs $0x80042182ca,%rdi
  8004214e6f:	00 00 00 
  8004214e72:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214e77:	49 b9 ae 04 20 04 80 	movabs $0x80042004ae,%r9
  8004214e7e:	00 00 00 
  8004214e81:	41 ff d1             	callq  *%r9
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004214e84:	eb 02                	jmp    8004214e88 <spin_lock+0x6c>
		asm volatile ("pause");
  8004214e86:	f3 90                	pause  
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004214e88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214e8c:	be 01 00 00 00       	mov    $0x1,%esi
  8004214e91:	48 89 c7             	mov    %rax,%rdi
  8004214e94:	48 b8 cb 4c 21 04 80 	movabs $0x8004214ccb,%rax
  8004214e9b:	00 00 00 
  8004214e9e:	ff d0                	callq  *%rax
  8004214ea0:	85 c0                	test   %eax,%eax
  8004214ea2:	75 e2                	jne    8004214e86 <spin_lock+0x6a>
		asm volatile ("pause");

	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
  8004214ea4:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004214eab:	00 00 00 
  8004214eae:	ff d0                	callq  *%rax
  8004214eb0:	48 98                	cltq   
  8004214eb2:	48 c1 e0 03          	shl    $0x3,%rax
  8004214eb6:	48 89 c2             	mov    %rax,%rdx
  8004214eb9:	48 c1 e2 04          	shl    $0x4,%rdx
  8004214ebd:	48 29 c2             	sub    %rax,%rdx
  8004214ec0:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  8004214ec7:	00 00 00 
  8004214eca:	48 01 c2             	add    %rax,%rdx
  8004214ecd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214ed1:	48 89 50 10          	mov    %rdx,0x10(%rax)
	get_caller_pcs(lk->pcs);
  8004214ed5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214ed9:	48 83 c0 18          	add    $0x18,%rax
  8004214edd:	48 89 c7             	mov    %rax,%rdi
  8004214ee0:	48 b8 f0 4c 21 04 80 	movabs $0x8004214cf0,%rax
  8004214ee7:	00 00 00 
  8004214eea:	ff d0                	callq  *%rax
#endif
}
  8004214eec:	48 83 c4 18          	add    $0x18,%rsp
  8004214ef0:	5b                   	pop    %rbx
  8004214ef1:	5d                   	pop    %rbp
  8004214ef2:	c3                   	retq   

0000008004214ef3 <spin_unlock>:

// Release the lock.
void
spin_unlock(struct spinlock *lk)
{
  8004214ef3:	55                   	push   %rbp
  8004214ef4:	48 89 e5             	mov    %rsp,%rbp
  8004214ef7:	41 54                	push   %r12
  8004214ef9:	53                   	push   %rbx
  8004214efa:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  8004214f01:	48 89 bd d8 fa ff ff 	mov    %rdi,-0x528(%rbp)
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
  8004214f08:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004214f0f:	48 89 c7             	mov    %rax,%rdi
  8004214f12:	48 b8 88 4d 21 04 80 	movabs $0x8004214d88,%rax
  8004214f19:	00 00 00 
  8004214f1c:	ff d0                	callq  *%rax
  8004214f1e:	85 c0                	test   %eax,%eax
  8004214f20:	0f 85 d2 01 00 00    	jne    80042150f8 <spin_unlock+0x205>
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
  8004214f26:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004214f2d:	48 8d 48 18          	lea    0x18(%rax),%rcx
  8004214f31:	48 8d 85 e0 fa ff ff 	lea    -0x520(%rbp),%rax
  8004214f38:	ba 28 00 00 00       	mov    $0x28,%edx
  8004214f3d:	48 89 ce             	mov    %rcx,%rsi
  8004214f40:	48 89 c7             	mov    %rax,%rdi
  8004214f43:	48 b8 81 db 20 04 80 	movabs $0x800420db81,%rax
  8004214f4a:	00 00 00 
  8004214f4d:	ff d0                	callq  *%rax
		if (!lk->cpu) 
  8004214f4f:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004214f56:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214f5a:	48 85 c0             	test   %rax,%rax
  8004214f5d:	75 39                	jne    8004214f98 <spin_unlock+0xa5>
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
  8004214f5f:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004214f66:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004214f6a:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004214f71:	00 00 00 
  8004214f74:	ff d0                	callq  *%rax
  8004214f76:	48 89 da             	mov    %rbx,%rdx
  8004214f79:	89 c6                	mov    %eax,%esi
  8004214f7b:	48 bf e0 82 21 04 80 	movabs $0x80042182e0,%rdi
  8004214f82:	00 00 00 
  8004214f85:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214f8a:	48 b9 0e 92 20 04 80 	movabs $0x800420920e,%rcx
  8004214f91:	00 00 00 
  8004214f94:	ff d1                	callq  *%rcx
  8004214f96:	eb 4d                	jmp    8004214fe5 <spin_unlock+0xf2>
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
  8004214f98:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004214f9f:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214fa3:	0f b6 00             	movzbl (%rax),%eax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  8004214fa6:	44 0f b6 e0          	movzbl %al,%r12d
  8004214faa:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004214fb1:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004214fb5:	48 b8 91 4a 21 04 80 	movabs $0x8004214a91,%rax
  8004214fbc:	00 00 00 
  8004214fbf:	ff d0                	callq  *%rax
  8004214fc1:	44 89 e1             	mov    %r12d,%ecx
  8004214fc4:	48 89 da             	mov    %rbx,%rdx
  8004214fc7:	89 c6                	mov    %eax,%esi
  8004214fc9:	48 bf 20 83 21 04 80 	movabs $0x8004218320,%rdi
  8004214fd0:	00 00 00 
  8004214fd3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214fd8:	49 b8 0e 92 20 04 80 	movabs $0x800420920e,%r8
  8004214fdf:	00 00 00 
  8004214fe2:	41 ff d0             	callq  *%r8
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004214fe5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004214fec:	e9 c3 00 00 00       	jmpq   80042150b4 <spin_unlock+0x1c1>
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
  8004214ff1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004214ff4:	48 98                	cltq   
  8004214ff6:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004214ffd:	89 c0                	mov    %eax,%eax
  8004214fff:	48 8d 95 10 fb ff ff 	lea    -0x4f0(%rbp),%rdx
  8004215006:	48 89 d6             	mov    %rdx,%rsi
  8004215009:	48 89 c7             	mov    %rax,%rdi
  800421500c:	48 b8 5e c7 20 04 80 	movabs $0x800420c75e,%rax
  8004215013:	00 00 00 
  8004215016:	ff d0                	callq  *%rax
  8004215018:	85 c0                	test   %eax,%eax
  800421501a:	78 6b                	js     8004215087 <spin_unlock+0x194>
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  800421501c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421501f:	48 98                	cltq   
  8004215021:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004215028:	89 c2                	mov    %eax,%edx
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  800421502a:	48 8b 85 30 fb ff ff 	mov    -0x4d0(%rbp),%rax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004215031:	48 29 c2             	sub    %rax,%rdx
  8004215034:	49 89 d0             	mov    %rdx,%r8
  8004215037:	48 8b bd 20 fb ff ff 	mov    -0x4e0(%rbp),%rdi
  800421503e:	8b b5 28 fb ff ff    	mov    -0x4d8(%rbp),%esi
  8004215044:	8b 8d 18 fb ff ff    	mov    -0x4e8(%rbp),%ecx
  800421504a:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  8004215051:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004215054:	48 98                	cltq   
  8004215056:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  800421505d:	4c 89 04 24          	mov    %r8,(%rsp)
  8004215061:	49 89 f9             	mov    %rdi,%r9
  8004215064:	41 89 f0             	mov    %esi,%r8d
  8004215067:	89 c6                	mov    %eax,%esi
  8004215069:	48 bf 56 83 21 04 80 	movabs $0x8004218356,%rdi
  8004215070:	00 00 00 
  8004215073:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215078:	49 ba 0e 92 20 04 80 	movabs $0x800420920e,%r10
  800421507f:	00 00 00 
  8004215082:	41 ff d2             	callq  *%r10
  8004215085:	eb 29                	jmp    80042150b0 <spin_unlock+0x1bd>
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
  8004215087:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421508a:	48 98                	cltq   
  800421508c:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004215093:	89 c6                	mov    %eax,%esi
  8004215095:	48 bf 6d 83 21 04 80 	movabs $0x800421836d,%rdi
  800421509c:	00 00 00 
  800421509f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042150a4:	48 ba 0e 92 20 04 80 	movabs $0x800420920e,%rdx
  80042150ab:	00 00 00 
  80042150ae:	ff d2                	callq  *%rdx
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  80042150b0:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042150b4:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  80042150b8:	7f 14                	jg     80042150ce <spin_unlock+0x1db>
  80042150ba:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042150bd:	48 98                	cltq   
  80042150bf:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  80042150c6:	85 c0                	test   %eax,%eax
  80042150c8:	0f 85 23 ff ff ff    	jne    8004214ff1 <spin_unlock+0xfe>
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
		}
		panic("spin_unlock");
  80042150ce:	48 ba 75 83 21 04 80 	movabs $0x8004218375,%rdx
  80042150d5:	00 00 00 
  80042150d8:	be 6b 00 00 00       	mov    $0x6b,%esi
  80042150dd:	48 bf ca 82 21 04 80 	movabs $0x80042182ca,%rdi
  80042150e4:	00 00 00 
  80042150e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042150ec:	48 b9 ae 04 20 04 80 	movabs $0x80042004ae,%rcx
  80042150f3:	00 00 00 
  80042150f6:	ff d1                	callq  *%rcx
	}

	lk->pcs[0] = 0;
  80042150f8:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042150ff:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  8004215106:	00 
	lk->cpu = 0;
  8004215107:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421510e:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004215115:	00 
	// But the 2007 Intel 64 Architecture Memory Ordering White
	// Paper says that Intel 64 and IA-32 will not move a load
	// after a store. So lock->locked = 0 would work here.
	// The xchg being asm volatile ensures gcc emits it after
	// the above assignments (and after the critical section).
	xchg(&lk->locked, 0);
  8004215116:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421511d:	be 00 00 00 00       	mov    $0x0,%esi
  8004215122:	48 89 c7             	mov    %rax,%rdi
  8004215125:	48 b8 cb 4c 21 04 80 	movabs $0x8004214ccb,%rax
  800421512c:	00 00 00 
  800421512f:	ff d0                	callq  *%rax
}
  8004215131:	48 81 c4 20 05 00 00 	add    $0x520,%rsp
  8004215138:	5b                   	pop    %rbx
  8004215139:	41 5c                	pop    %r12
  800421513b:	5d                   	pop    %rbp
  800421513c:	c3                   	retq   
